#include "StdAfx.h"
#include ".\x2guuser.h"


#ifdef REDUCED_PRECOMPILED_HEADER_TEST
#include "./X2GUElsword_SwordMan.h"
#include "./X2GUArme_VioletMage.h"
#include "./X2GULire_ElvenRanger.h"
#include "./X2GURaven.h"
#include "./X2GuEve.h"

//{{ kimhc // 2010.11.25 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
#include "./X2GUChung.h"
#endif	NEW_CHARACTER_CHUNG
//}} kimhc // 2010.11.25 //  2010-12-23 New Character CHUNG

#ifdef ARA_CHARACTER_BASE
#include "./X2GUAra.h"
#endif

#ifdef NEW_CHARACTER_EL
#include "./X2GUEl.h"
#endif // NEW_CHARACTER_EL

#ifdef SERV_9TH_NEW_CHARACTER // 김태환 ( 캐릭터 추가용 )
#include "./X2GUAdd.h"
#endif //SERV_9TH_NEW_CHARACTER

#endif REDUCED_PRECOMPILED_HEADER_TEST


// dmlee 2009.3.12 백그라운드 로딩관련해서 eqip의 unit_xskinanim을 shared_ptr로 해야해서 guuser의 m_pxskinanim, m_porgxskinanim을 shared_ptr로 사용함

// dmlee 2009.11.10 - skip point에는 아래의 3가지 종류가 있습니다.
// 필살기 캔슬	: 	else if( SpecialAttackEventProcess() == true )
// 대시 캔슬	:	else if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 0.5f && (m_InputData.pureDoubleRight == true || m_InputData.pureDoubleLeft == true) ) { StateChangeDashIfPossible(); }
// 걷기 캔슬	:	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC { if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 0.267f ) }



#ifdef KHELP_SYSTEM_TEST
IMPLEMENT_HELP_SYSTEM( CX2GUUser )
{
	WCHAR   wbuffer[1024];
	int     ix = 16;
	int     iy = 16;
	StringCchPrintfW( wbuffer, ARRAY_SIZE(wbuffer), L"%S", __FUNCTION__ );

	if ( g_pMain && g_pX2Game && g_pX2Game->GetMyUnit() )
	{
		g_pMain->GetFontForDebuf()->OutTextXY( ix, iy, wbuffer, D3DXCOLOR( 1, 1, 0, 1), 
			CKTDGFontManager::FS_SHELL, D3DXCOLOR( 0, 0, 0, 1 ) );

		g_pX2Game->GetMyUnit()->Debug_RenderHelp( ix, iy );
	}//if
}
#endif KHELP_SYSTEM_TEST

#ifdef _CLASS_CUTIN_

namespace _CONST_CUTIN_
{
	static const wstring s_SkillCutInElsword[] = 
	{
		L"0",
		L"Bringit",
		L"1"
	};

	static const wstring s_SkillCutInElswordKnight[] = 
	{
		L"taste some steel",
		L"thiswillhurtalot",
		L"timetocallyourmomma"
	};

	static const wstring s_SkillCutInElswordMagicKnight[] = 
	{
		L"feeltheburn",
		L"fired",
		L"readysomeheat"
	};

	static const wstring s_SkillCutInAisha[] = 
	{
		L"heyugly",
		L"ididitagain",
		L"idontthink"
	};

	static const wstring s_SkillCutInAishaHigh[] = 
	{
		L"mighttikle",
		L"playtimesover",
		L"youshallnotpass"
	};

	static const wstring s_SkillCutInAishaDark[] = 
	{
		L"despair",
		L"fearthedarkness",
		L"youcan'thandlethis"
	};

	static const wstring s_SkillCutInLena[] = 
	{
		L"forgiveme",
		L"maydeath",
		L"surrenderyourself"
	};

	static const wstring s_SkillCutInLenaCombat[] = 
	{
		L"Elders",
		L"isthiswhat",
		L"staydown"
	};

	static const wstring s_SkillCutInLenaSniper[] = 
	{
		L"Letmethrough",
		L"Thismarksyourend",
		L"Youhaveveenwarned"
	};

	static const wstring s_SkillCutInRaven[] = 
	{
		L"raven_01",
		L"raven_02",
		L"raven_03"
	};

	static const wstring s_SkillCutInRavenSoul[] = 
	{
		L"Sword_Taker_01",
		L"Sword_Taker_02",
		L"Sword_Taker_03"
	};

	static const wstring s_SkillCutInRavenOver[] = 
	{
		L"Over_taker_01",
		L"Over_taker_02",
		L"Over_taker_03"
	};

	static const wstring s_SkillCutInEve[] = 
	{
		L"eve1_0",
		L"eve1_1",
		L"eve1_2",
	};

	static const wstring s_SkillCutInEveExotic[] = 
	{
		L"eve1_3",
		L"eve1_4",
		L"eve1_5",
	};

	static const wstring s_SkillCutInEveArchitecture[] = 
	{
		L"eve1_6",
		L"eve1_7",
		L"eve1_8",
	};

	static const wstring s_SkillCutInEveNemesis[] = 
	{
		L"eve1_3",
		L"eve1_4",
		L"eve1_5",
	};

	static const wstring s_SkillCutInEveEmpress[] = 
	{
		L"eve1_6",
		L"eve1_7",
		L"eve1_8",
	};

	static const wstring s_SkillCutInChung[] = 
	{
		L"Chung_01",
		L"Chung_02",
		L"Chung_03",
	};

	static const wstring s_SkillCutInChungShooting[] = 
	{
		L"Shooting_Guardian_01",
		L"Shooting_Guardian_02",
		L"Shooting_Guardian_03",
	};

	static const wstring s_SkillCutInChungFury[] = 
	{
		L"Fury_Guadian_01",
		L"Fury_Guadian_02",
		L"Fury_Guadian_03",
	};

	static const wstring s_SkillCutInChungChaser[] = 
	{
		L"Shooting_Guardian_01",
		L"Shooting_Guardian_02",
		L"Shooting_Guardian_03",
	};

	static const wstring s_SkillCutInChungPaladin[] = 
	{
		L"Fury_Guadian_01",
		L"Fury_Guadian_02",
		L"Fury_Guadian_03",
	};
#ifdef ELSWORD_SHEATH_KNIGHT
	static const wstring s_SkillCutInElswordShethKnight[] =
	{
		L"Sheth_Knight_01",
		L"Sheth_Knight_02",
		L"Sheth_Knight_03",
	};
#endif ELSWORD_SHEATH_KNIGHT

#ifdef SERV_ADD_ARME_BATTLE_MAGICIAN
	static const wstring s_SkillCutInAishaBattleMagician[] =
	{
		L"Battle_Magician_01",
		L"Battle_Magician_02",
		L"Battle_Magician_03",
	};
#endif SERV_ADD_ARME_BATTLE_MAGICIAN

#ifdef SERV_TRAPPING_RANGER_TEST
	static const wstring s_SkillCutInLenaTrappingRanger[] =
	{
		L"Trapping_Ranger_01",
		L"Trapping_Ranger_02",
		L"Trapping_Ranger_03",
	};
#endif SERV_TRAPPING_RANGER_TEST

#ifdef SERV_RAVEN_WEAPON_TAKER
	static const wstring s_SkillCutInRavenWeaponTaker[] =
	{
		L"Weapon_Taker_01",
		L"Weapon_Taker_02",
		L"Weapon_Taker_03",
	};
#endif SERV_RAVEN_WEAPON_TAKER

#ifdef SERV_EVE_ELECTRA
	static const wstring s_SkillCutInEveElectra[] =
	{
		L"Code_Electra_01",
		L"Code_Electra_02",
		L"Code_Electra_03",
	};
#endif SERV_EVE_ELECTRA

#ifdef SERV_ADD_CHUNG_SHELLING_GUARDIAN
	static const wstring s_SkillCutInChungShellingGuardian[] =
	{
		L"Shelling_Guardian_01",
		L"Shelling_Guardian_02",
		L"Shelling_Guardian_03",
	};
#endif SERV_ADD_CHUNG_SHELLING_GUARDIAN
	
	static const wstring s_SkillCutInAra[] =
	{
		L"Ara_01",
		L"Ara_02",
		L"Ara_03",
	};

	static const wstring s_SkillCutInSosun[] =
	{
		L"Sosun_01",
		L"Sosun_02",
		L"Sosun_03",
	};

	static const wstring s_SkillCutInSoma[] =
	{
		L"Soma_01",
		L"Soma_02",
		L"Soma_03",
	};
}
#endif _CLASS_CUTIN_


#ifdef _CLASS_CUTIN_
wstring CX2GUUser::GetCutInFileName(bool IsRight)
{
	wstring wstrCutIn = L"HQ_CutIn_Talk_";
	if(IsRight)
	{
		wstrCutIn += L"R_";
	}
	else
	{
		wstrCutIn += L"L_";
	}

	int texID = rand() % 3;
	switch( m_pUnit->GetClass() )
	{
	case CX2Unit::UC_ELSWORD_SWORDMAN:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInElsword[texID];
		break;
	case CX2Unit::UC_ELSWORD_KNIGHT:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInElswordKnight[texID];
		break;
	case CX2Unit::UC_ELSWORD_MAGIC_KNIGHT:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInElswordMagicKnight[texID];
		break;	
	case CX2Unit::UC_ELSWORD_RUNE_SLAYER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInElswordMagicKnight[texID];
		break;	
	case CX2Unit::UC_ELSWORD_LORD_KNIGHT:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInElswordKnight[texID];
		break;
#ifdef ELSWORD_SHEATH_KNIGHT
	case CX2Unit::UC_ELSWORD_SHEATH_KNIGHT:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInElswordShethKnight[texID];
		break;
#endif ELSWORD_SHEATH_KNIGHT
	case CX2Unit::UC_ELSWORD_INFINITY_SWORD:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInElswordShethKnight[texID];
		break;
	case CX2Unit::UC_ARME_VIOLET_MAGE:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInAisha[texID];
		break;
	case CX2Unit::UC_ARME_HIGH_MAGICIAN:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInAishaHigh[texID];
		break;
	case CX2Unit::UC_ARME_DARK_MAGICIAN:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInAishaDark[texID];
		break;
	case CX2Unit::UC_ARME_ELEMENTAL_MASTER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInAishaHigh[texID];
		break;
	case CX2Unit::UC_ARME_VOID_PRINCESS:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInAishaDark[texID];
		break;
#ifdef SERV_ADD_ARME_BATTLE_MAGICIAN
	case CX2Unit::UC_ARME_BATTLE_MAGICIAN:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInAishaBattleMagician[texID];
		break;
#endif SERV_ADD_ARME_BATTLE_MAGICIAN
	case CX2Unit::UC_ARME_DIMENSION_WITCH:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInAishaBattleMagician[texID];
		break;
	case CX2Unit::UC_LIRE_ELVEN_RANGER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInLena[texID];
		break;
	case CX2Unit::UC_LIRE_COMBAT_RANGER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInLenaCombat[texID];
		break;
	case CX2Unit::UC_LIRE_SNIPING_RANGER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInLenaSniper[texID];
		break;
	case CX2Unit::UC_LIRE_WIND_SNEAKER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInLenaCombat[texID];
		break;
	case CX2Unit::UC_LIRE_GRAND_ARCHER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInLenaSniper[texID];
		break;
#ifdef SERV_TRAPPING_RANGER_TEST
	case CX2Unit::UC_LIRE_TRAPPING_RANGER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInLenaTrappingRanger[texID];
		break;
#endif SERV_TRAPPING_RANGER_TEST
	case CX2Unit::UC_LIRE_NIGHT_WATCHER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInLenaTrappingRanger[texID];
		break;
	case CX2Unit::UC_RAVEN_FIGHTER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInRaven[texID];
		break;
	case CX2Unit::UC_RAVEN_SOUL_TAKER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInRavenSoul[texID];
		break;
	case CX2Unit::UC_RAVEN_OVER_TAKER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInRavenOver[texID];
		break;
	case CX2Unit::UC_RAVEN_BLADE_MASTER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInRavenSoul[texID];
		break;
	case CX2Unit::UC_RAVEN_RECKLESS_FIST:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInRavenOver[texID];
		break;
#ifdef SERV_RAVEN_WEAPON_TAKER
	case CX2Unit::UC_RAVEN_WEAPON_TAKER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInRavenWeaponTaker[texID];
		break;
#endif SERV_RAVEN_WEAPON_TAKER		
	case CX2Unit::UC_RAVEN_VETERAN_COMMANDER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInRavenWeaponTaker[texID];
		break;
	case CX2Unit::UC_EVE_NASOD:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInEve[texID];
		break;
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInEveExotic[texID];
		break;
	case CX2Unit::UC_EVE_ARCHITECTURE:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInEveArchitecture[texID];
		break;
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInEveNemesis[texID];
		break;
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInEveEmpress[texID];
		break;
#ifdef SERV_EVE_ELECTRA
	case CX2Unit::UC_EVE_ELECTRA:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInEveElectra[texID];
		break;
#endif SERV_EVE_ELECTRA
	case CX2Unit::UC_EVE_BATTLE_SERAPH:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInEveElectra[texID];
		break;
	case CX2Unit::UC_CHUNG_IRON_CANNON:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInChung[texID];
		break;
	case CX2Unit::UC_CHUNG_FURY_GUARDIAN:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInChungFury[texID];
		break;
	case CX2Unit::UC_CHUNG_SHOOTING_GUARDIAN:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInChungShooting[texID];
		break;
	case CX2Unit::UC_CHUNG_IRON_PALADIN:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInChungPaladin[texID];
		break;
	case CX2Unit::UC_CHUNG_DEADLY_CHASER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInChungChaser[texID];
		break;
#ifdef SERV_ADD_CHUNG_SHELLING_GUARDIAN
	case CX2Unit::UC_CHUNG_SHELLING_GUARDIAN:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInChungShellingGuardian[texID];
		break;
#endif SERV_ADD_CHUNG_SHELLING_GUARDIAN
	case CX2Unit::UC_CHUNG_TACTICAL_TROOPER:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInChungShellingGuardian[texID];
		break;
	case CX2Unit::UC_ARA_MARTIAL_ARTIST:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInAra[texID];
		break;
	case CX2Unit::UC_ARA_LITTLE_HSIEN:
	case CX2Unit::UC_ARA_SAKRA_DEVANAM:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInSosun[texID];
		break;
	case CX2Unit::UC_ARA_LITTLE_DEVIL:
	case CX2Unit::UC_ARA_YAMA_RAJA:
		wstrCutIn += _CONST_CUTIN_::s_SkillCutInSoma[texID];
		break;
	}
	return wstrCutIn;
}
#endif _CLASS_CUTIN_


#ifdef HYPER_MODE_EFFECT_ADD_BY_ITEM
void CX2GUUser::ShowSpecialEffectHyperMode()
{
	// 하드 코딩 보다 소켓 옵션으로 하는게 좋을가? 으음....일단 하드 코딩으로
	//switch(m_pUnit->GetTitleId())// 이 함수로 타이틀이 안오네 다른 방법 찾아보자. 
	CX2Item* pItem = m_pUnit->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_AC_BODY, false );
	if( NULL == g_pX2Game || NULL == pItem )
		return;

	switch( pItem->GetItemTemplet()->GetItemID() )
	{
	case HYPER_EFFECT_ITEM_DARK_DRAGON:
		{
			if( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON || g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD )	//던전 및 필드용 이펙트
			{
				g_pX2Game->GetEffectSet()->PlayEffectSet(L"EffectSet_DarkDragon_HyperMode_Dungeon", this);
			}
			
			if( g_pX2Game->GetGameType() == CX2Game::GT_PVP )	// 대전용 이펙트
			{
				g_pX2Game->GetEffectSet()->PlayEffectSet(L"EffectSet_DarkDragon_HyperMode_Pvp", this);
			}
		}
		break;
	}
}
#endif

void CX2GUUser::Debug_RenderHelp( int ix_, int iy_ )
{
	int     ix = ix_ + 16;
	int     iy = iy_ + 16;

	wstringstream wstrm;
	wstrm << L"UID: " << GetUnitUID() << ", " << std::endl;
	wstrm << L"Name: " << GetUnit()->GetNickName() << ", " << std::endl;
	wstrm << L"SPEED:         ( " << m_PhysicParam.nowSpeed.x << ", " << m_PhysicParam.nowSpeed.y << " ), " << std::endl;
	wstrm << L"PASSIVE_SPEED: ( " << m_PhysicParam.passiveSpeed.x << ", " << m_PhysicParam.passiveSpeed.y << " ), " << std::endl;



	wstrm << std::endl;
	wstrm << L"---- FUTURE ---- " << std::endl;
	wstrm << L"nowState: " << (int) m_FrameDataFuture.syncData.nowState << ", " << std::endl;
	wstrm << L"lastTouchLineIndex: " << (int) m_FrameDataFuture.syncData.lastTouchLineIndex << ", " << std::endl;
	wstrm << L"position: ( " << m_FrameDataFuture.syncData.position.x << ", " 
		<< m_FrameDataFuture.syncData.position.y << "," 
		<< m_FrameDataFuture.syncData.position.z << " ), " << std::endl;


	wstrm << L"m_usRandomTableIndex: " << GetRandomFloat() << ", " << std::endl;


	//wstrm << L"bInvincible: " << (int) m_FrameDataFuture.stateParam.bInvincible << ", " << std::endl;
	//wstrm << L"bSuperArmor: " << (int) m_FrameDataFuture.stateParam.bSuperArmor << ", " << std::endl;

	//wstrm << L"fStateTime: " << (int)m_FrameDataFuture.unitCondition.fStateTime << ", " << std::endl;
	wstrm << L"dirDegree: ( " << m_FrameDataFuture.unitCondition.dirDegree.x << ", " 
		<< m_FrameDataFuture.unitCondition.dirDegree.y << "," 
		<< m_FrameDataFuture.unitCondition.dirDegree.z << " ), " << std::endl;
	//wstrm << L"dirVector: ( " << m_FrameDataFuture.unitCondition.dirVector.x << ", " 
	//	<< m_FrameDataFuture.unitCondition.dirVector.y << "," 
	//	<< m_FrameDataFuture.unitCondition.dirVector.z << " ), " << std::endl;

	wstrm << L"bFootOnLine: " << (int)m_FrameDataFuture.unitCondition.bFootOnLine << ", " << std::endl;
//#ifdef STEP_ON_MONSTER_TEST
//	wstrm << L"bFootOnUnit: " << (int)m_FrameDataFuture.unitCondition.bFootOnUnit << ", " << std::endl;
//#endif STEP_ON_MONSTER_TEST



	wstrm << std::endl;
	wstrm << L"---- CURRENT ---- " << std::endl;
	wstrm << L"nowState: " << (int) m_FrameDataNow.syncData.nowState << ", " << std::endl;
	wstrm << L"lastTouchLineIndex: " << (int) m_FrameDataNow.syncData.lastTouchLineIndex << ", " << std::endl;
	wstrm << L"position: ( " << m_FrameDataNow.syncData.position.x << ", " 
		<< m_FrameDataNow.syncData.position.y << "," 
		<< m_FrameDataNow.syncData.position.z << " ), " << std::endl;

	wstrm << L"m_usRandomTableIndex: " << GetRandomFloat() << ", " << std::endl;

	//wstrm << L"bInvincible: " << (int) m_FrameDataNow.stateParam.bInvincible << ", " << std::endl;
	//wstrm << L"bSuperArmor: " << (int) m_FrameDataNow.stateParam.bSuperArmor << ", " << std::endl;
	//wstrm << L"fStateTime: " << (int)m_FrameDataNow.unitCondition.fStateTime << ", " << std::endl;
	wstrm << L"dirDegree: ( " << m_FrameDataNow.unitCondition.dirDegree.x << ", " 
		<< m_FrameDataNow.unitCondition.dirDegree.y << "," 
		<< m_FrameDataNow.unitCondition.dirDegree.z << " ), " << std::endl;
	//wstrm << L"dirVector: ( " << m_FrameDataNow.unitCondition.dirVector.x << ", " 
	//	<< m_FrameDataNow.unitCondition.dirVector.y << "," 
	//	<< m_FrameDataNow.unitCondition.dirVector.z << " ), " << std::endl;

	wstrm << L"bFootOnLine: " << (int)m_FrameDataNow.unitCondition.bFootOnLine << ", " << std::endl;
//#ifdef STEP_ON_MONSTER_TEST
//	wstrm << L"bFootOnUnit: " << (int)m_FrameDataNow.unitCondition.bFootOnUnit << ", " << std::endl;
//#endif STEP_ON_MONSTER_TEST



	g_pMain->GetFontForDebuf()->OutTextMultiline( ix, iy, wstrm.str().c_str(), D3DXCOLOR( 1, 1, 0, 1), 
		CKTDGFontManager::FS_SHELL, D3DXCOLOR( 0, 0, 0, 1 ) );
	iy += 16 * 3;

}





CX2GUUser::CX2GUUser( int unitIndex, int teamNum, 
#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	lua_State*   pScriptLuaState,
#else	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	const WCHAR* pScriptFileName, 
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	int frameBufferNum, CX2Unit* pUnit )
: CX2GameUnit( unitIndex, teamNum, 
#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	NULL
#else	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	pScriptFileName 
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	)
, m_hSeqWeaponCommon1( INVALID_PARTICLE_SEQUENCE_HANDLE )
, m_hSeqWeaponCommon2( INVALID_PARTICLE_SEQUENCE_HANDLE )
, m_hSeqWeaponCommon3( INVALID_PARTICLE_SEQUENCE_HANDLE )
, m_hSeqEnchantedWeaponCommon4( INVALID_PARTICLE_SEQUENCE_HANDLE )
, m_DeadStageIndex( 0 )
, m_DeadSubStageIndex( 0 )
#ifdef RENA_SIEGE_MODE_ANGLE_TEST
, m_bEnableLookAtIK_Spine( false )
, m_fLookAtIKAngle_Spine( 0.f )
#endif RENA_SIEGE_MODE_ANGLE_TEST
, m_bRotateBone( false )
, m_fRotateBoneDegree( 0.f )
, m_eSpecialAttackKeyPressed( SAKP_NONE )
, m_bSpecialAttackEventProcessedAtThisFrame( false )
, m_iSkillCutInSetIndex( 0 )
#ifdef	GUILD_SKILL_PART_2
, m_bHaveSacrificeOfHero( false )
#endif	GUILD_SKILL_PART_2
#ifdef RAVEN_SECOND_CLASS_CHANGE
, m_fPassiveCriticalRate( 0.f )
#endif
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
, m_fShadowOfDisasterRate( 0.f )
#endif //UPGRADE_SKILL_SYSTEM_2013
//#ifdef TRANSFORMER_TEST
//, m_pTransformer( NULL )
//#endif TRANSFORMER_TEST
	//{{ 임규수 임규수 던전 스타트 표시 나오기 전 , 던전 보스 죽인 후에 퀵슬롯 사용 못하도록 수정
#ifdef FIX_QUICK_SLOT_USE_DUNGEON_PLAY
, m_bStarted( false )
#endif 
	//}}
//{{ kimhc // 2010.4.5 // 비밀던전 작업(셋트아이템효과)
#ifdef SERV_SECRET_HELL
, m_fManaRecoveryDurationTime( 0.0f )
, m_fManaRecoveryVal( 0.0f )
, m_fIntervalTimeForCureDebuff( 0.0f )
, m_pBoneShieldData( NULL )
#endif SERV_SECRET_HELL
//}} kimhc // 2010.4.5 // 비밀던전 작업(셋트아이템효과)

//{{ kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함
, m_iHoldStateID( 0 )
//}} kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함

//{{ kimhc // 2010.11.3 // 레피 - 승화된 분노
#ifdef	NEW_SKILL_2010_11
, m_bCanChangeHyperModeInHyperModeState( false )
#endif	NEW_SKILL_2010_11
//}} kimhc // 2010.11.3 // 레피 - 승화된 분노
, m_bDownForce( false )
#ifdef	CHUNG_FIRST_CLASS_CHANGE
, m_fAddAnimSpeedFactor( 0.0f )
#endif
#ifdef	TEST_GROUP_GRAP
, m_iGrapStateID( USI_DAMAGE_AIR_FLY_FRONT )
#endif	TEST_GROUP_GRAP
//{{ kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트
#ifdef	SERV_TOONILAND_CHANNELING_EVENT
, m_hEffectTooniLandEvent( INVALID_EFFECTSET_HANDLE )
#endif	SERV_TOONILAND_CHANNELING_EVENT
//}} kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트
#ifdef SERV_ADD_CHUNG_SHELLING_GUARDIAN
, m_fCannonBallDamageUp( 0.f )
, m_fForceDownRelDamageRateBase ( 0.f )
#endif
#ifdef DUNGEON_DASH_LOG
, m_iDashCount ( 0 )
#endif DUNGEON_DASH_LOG

, m_ElapsedTimeNotBusyState( 2.0f )

#ifdef SERV_ELSWORD_INFINITY_SWORD
, m_bLearnLightningStep( false )
, m_OldStateId( USI_BASE )
#endif
#ifdef SERV_ARME_DIMENSION_WITCH
, m_iAdvancedTeleportationLv( 0 )
#endif
, m_delegatePhysicProcessPortalByGameType( DelegatePhysicProcessPortalByGameType() )
, m_fCurrentFinalDamage( 0 )
#ifdef FIX_ENCHANT_FROZEN_TRACE_BUG_BY_MAGICAL_MAKEUP
, m_bUseChangeWeapon( false )				/// 아이샤의 매지컬 메이크 업이나 청의 3각성을 통한 무기 변경 여부
#endif FIX_ENCHANT_FROZEN_TRACE_BUG_BY_MAGICAL_MAKEUP
, m_hEnterCashShop(INVALID_PARTICLE_SEQUENCE_HANDLE)
, m_bHasHyperModeItem(false)
, m_pTextureRank (NULL)
, m_bEnterCashShop( false )
#ifdef ARA_CHANGE_CLASS_FIRST
, m_bCanAvoidance( false) 
#endif //ARA_CHANGE_CLASS_FIRST
#ifdef NOT_CANCEL_BBT_STUN_BY_HIT
, m_bChangeGroggyState( false )		/// 버프를 통한 스턴 그로기 스테이트 전환 여부
#endif NOT_CANCEL_BBT_STUN_BY_HIT
, m_ComboAndSkillChainSystem()
#ifdef EFFECT_TOOL
, m_pXSkinAnim_EffectTool( NULL )
#endif // EFFECT_TOOL
#ifdef RIDING_SYSTEM
, m_bRidingOn( false )
, m_wstrRidingMotionName( L"" )
, m_ElapsedTimeRidingWaitHabit( 5.f )
, m_iRidingBoost( 0 )
, m_fAirDashTime( 0.f )
, m_iAirDashCount( 0 )
, m_iDoubleJumpCount( 0 )
#endif //RIDING_SYSTEM
#ifdef CHECK_CAMERA_INFO
, m_bIsLineMapCamera(false)
#endif //CHECK_CAMERA_INFO
#ifdef CHECK_SOUND_LOADING_TIME
, dwStartTime( 0 )
, dwTickCount( 0 )
#endif // CHECK_SOUND_LOADING_TIME
#ifdef ADDED_RELATIONSHIP_SYSTEM
, m_RelationshipTargetUID( 0 )
#endif //ADDED_RELATIONSHIP_SYSTEM
#ifdef NEW_CHARACTER_EL
, m_fAddAccuaracyPercent(0.f)
, m_fAddMagicAttackCriticalRate(0.f)
, m_fAddMagicAttackCriticalDamageRate(0.f)
#endif //NEW_CHARACTER_EL
#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE //김창한
, m_bSetCustomRenderParam( false )
#endif //SERV_ELESIS_SECOND_CLASS_CHANGE
#ifdef INSERT_BUFF_FACTOR_BY_SCPRIPT_STATE
, m_uiNowStateSkillLevel( 0 )
#endif // INSERT_BUFF_FACTOR_BY_SCPRIPT_STATE
, m_fShowSkillCutInTime(-1.f)
, m_bChangeWorldColor(false)
, m_iSkillCutInSetSubIndex( 0 )
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환
, m_bIsLimitCrusherCharge( false )
#endif // UPGRADE_SKILL_SYSTEM_2013
#ifdef SERV_ARA_CHANGE_CLASS_SECOND // 김태환
, m_bRightAtThisState( false )
#endif // SERV_ARA_CHANGE_CLASS_SECOND
#ifdef MODIFY_AFTER_IMAGE
, m_pHairXSkinMesh(NULL)
#endif //MODIFY_AFTER_IMAGE
#ifdef FIX_BATTLE_FIELD_DYNAMIC_CAMERA
, fPreWorldNear(-1.f)
#endif // FIX_BATTLE_FIELD_DYNAMIC_CAMERA
#ifdef ACTIVE_KOG_GAME_PERFORMANCE_CHECK
, m_dwLastRecvFrameMoveCount( 0 )
#endif//ACTIVE_KOG_GAME_PERFORMANCE_CHECK
#ifdef FIX_SKILL_SLOT_CHANGE_BUG
, m_fSlotChangeLeftCoolTime ( -1.f ) 
#endif // FIX_SKILL_SLOT_CHANGE_BUG
#ifdef CHEAT_SELF_DAMAGE // 김태환
, m_iFrontDamage( -1 )
#endif //CHEAT_SELF_DAMAGE
#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
, m_fSocketOptionCoolTime( 0.0f )
, m_fSocketOptionHyperCoolTime( 0.0f )
#endif //ADJUST_SECRET_ITEM_OPTION

#ifdef  X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
, m_bDoubleAttack( false )
#endif  X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION

#ifdef CRAYONPOP_EMOTION_WITH_MUSIC		// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨
, m_bIsPlayAvatarEmotionSoundWithoutEmotion ( false )
#endif // CRAYONPOP_EMOTION_WITH_MUSIC	// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨

#ifdef SERV_ADD_LUNATIC_PSYKER // 김태환
, m_fGetFinalDamageValue( 0.f )
#endif //SERV_ADD_LUNATIC_PSYKER
#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
, m_bParryingState ( false )
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
{	
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

#ifdef SKILL_BALANCE_PATCH
    m_bFutureCanPassUnit = false;
#endif
    m_bFutureApplyAnimMove = true;
    m_bNowFallDown = true;
    m_bDisableGravity = false;
    m_bDisableGravityInScript = false;
    m_vDisableGravityInScriptTime = D3DXVECTOR2( 0, 0 );
#ifdef  AISHA_SECOND_CLASS_CHANGE
    m_vFutureIgnoreLineTime = D3DXVECTOR2( 0, 0 );
#endif  AISHA_SECOND_CLASS_CHANGE
    m_fNowSlashTraceTipWide = 4.0f;
    m_fCommonDamageChangeTime =  -1.f;
//{{ kimhc // 2011.1.21 // 청 1차 전직
#ifdef	CHUNG_FIRST_CLASS_CHANGE
    m_eHittedTypeAtState = CX2DamageManager::HTD_NO_SOUND;	// 스테이트 별 HittedType 지정
#endif	CHUNG_FIRST_CLASS_CHANGE
//}} kimhc // 2011.1.21 // 청 1차 전직
    m_v2NowAfterImageTime = D3DXVECTOR2( -1.f, -1.f );
	m_bDeleteEffectSetOnStateEnd = false;
	m_bDeleteEffectSetOnDamageReact = false;
	m_bDeleteEffectSetOnDie = false;
#ifdef DELETE_EFFECTSET_ON_CUSTOM_STATE
	m_bDeleteEffectSetOnCustomState = false;
#endif DELETE_EFFECTSET_ON_CUSTOM_STATE
	m_bHyperEffectSet = false;
	m_fEffectSetLifeTime = 0.f;
#ifdef ADDITIONAL_MEMO
    m_iMemoId = 0;
#endif
#ifdef CUSTOM_DELETE_EFFECT_ON_DAMAGE_REACT
    m_bIsCustomStateDeleteEffectOnDamageReact = false;
#endif // CUSTOM_DELETE_EFFECT_ON_DAMAGE_REACT
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE


#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	if ( pScriptLuaState != NULL )
		m_LuaManager.AssignNewLuaState( pScriptLuaState, 0, false );
	else
		m_LuaManager.AssignNewLuaState( g_pKTDXApp->GetLuaBinder()->GetLuaState(), 0, true );
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD

	m_eObjectType = OT_CX2GUUser;
	

	m_GameUnitType				= GUT_USER;
	m_OwnerUserUID				= pUnit->GetOwnerUserUID();
	m_UnitUID					= pUnit->GetUID();
	m_FrameBufferNum			= frameBufferNum;
	m_pUnit						= pUnit;
	m_MachineGunWaitState		= 0;
	m_ChargeMpState				= 0;
	//{{ robobeg : 2008-10-27
	//	m_DownDamageLandFront		= 0;
	//}} robobeg : 2008-10-27


//#ifdef PVP_BOSS_COMBAT_TEST
//	m_FrozenState = 0;
//#endif PVP_BOSS_COMBAT_TEST

	m_bFirstDataReceive			= false;
	m_bPopAgain					= false;
	m_OrgInputData.Init();

	m_SendSyncDataList.reserve( m_FrameBufferNum * 2 );
	m_ReceiveSyncDataList.reserve( m_FrameBufferNum * 2 );
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
    m_LastSendSyncDataList.reserve( m_FrameBufferNum * 2 );
    m_adwInitFrameMoveCount[0] = 0;
	m_adwInitFrameMoveCount[1] = 0;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

	//유닛 컴포넌트
	m_pMotionFuture				= NULL;
	m_pMotion					= NULL;
	m_pXSkinAnimFuture			= NULL;
	m_pAniXET					= NULL;

	m_pOrgMotionFuture			= NULL;
	m_pOrgMotion				= NULL;
	m_pOrgXSkinAnimFuture		= NULL;

#ifdef FIX_MEMLEAK01
	m_pAfterImageMotion			= NULL;
#endif
	//m_pAfterImage				= NULL;

	m_hSeqHeadMarker			= INVALID_PARTICLE_SEQUENCE_HANDLE;
    m_hSeqEmblem				= INVALID_PARTICLE_SEQUENCE_HANDLE;
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hHeadMarkerParticle		= INVALID_PARTICLE_HANDLE;
	m_hPart_Emblem_200			= INVALID_PARTICLE_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_pHeadMarkerParticle		= NULL;
	m_pPart_Emblem_200			= NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

	m_hHoldEffCenter			= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hHoldEffCircle			= INVALID_PARTICLE_SEQUENCE_HANDLE;

	m_AddFrameBuffer			= 1;
	m_fFrameWaitTime			= 0.0f;
	m_FrameWaitNum				= 0;
	m_fFrameSkipTime			= 0.0f;
	m_FrameSkipNum				= 0;

	m_fRebirthTime				= 0.0f;
	m_nDamageCount				= 0;

	m_StopAdvanceTimeFuture		= false;
#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_AdvanceTimeCount			= 1;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_pFrame_Bip01_Spine		= NULL;


	m_bHyperModeUsed					= false;
	m_fElaspedTimeLastGuideMessage		= 0.f;

	m_bConnect						= false;
	m_fConnectTimeOut				= 0.0f;
	m_bConnectSend					= false;

#ifdef ATTACK_DELAY_GAGE
	m_bAddAttackDelayThisState		= false;
	m_fLastAttackPassTime			= 0.0f;
#endif ATTACK_DELAY_GAGE
	m_bAddForceDownGageThisState	= false;
	m_fLastDamagePassTime			= 0.0f;
#ifdef BALANCE_PATCH_20110303
	m_fMaxDownForce = -9999.f;
#endif


	m_bResurrectionTimeOut			= false;
	m_fDevAddDamage					= 0.f;

	m_iNowSpecialAttack				= 0;
	m_bHoldSpecialAttack			= false;	
	m_bHoldingSpecialAttack			= false;
//
//#ifndef NOT_USE_DICE_ROLL
//	m_pDiceRoll		= NULL;
//	//m_pDiceRoll		= new DiceRoll( this );
//#endif //NOT_USE_DICE_ROLL

	m_vAddJumpSpeed = D3DXVECTOR3(0, 0, 0 );
	m_bSteppedJumpLinemap = false;

	m_fAnimSpeedRate = 1.f;
	m_fAnimSpeed = 1.f;
#ifdef ADD_ANIM_SPEED_FUTURE
	m_fAnimSpeedFuture = 1.f;
#endif // ADD_ANIM_SPEED_FUTURE
	m_bColdSlowApplied = false;
	m_bFrozenSlowApplied = false;


	m_fTimeToDashCameraChange			= 0.0f;
	m_fAngleDegree						= 0.0f;
	m_fTimeToReturnCameraAngle			= 0.0f;

	//{{ kimhc // 2010.06.14 // 드래고닉셋트효과 아이템 버그 수정
#ifdef	SERV_SECRET_HELL
	SetOriginalMPChangeRate( 1.f );
#else	SERV_SECRET_HELL
	m_fOriginalMPChangeRate				= 1.f;
#endif	SERV_SECRET_HELL
	//}} kimhc // 2010.6.14 // 드래고닉셋트효과 아이템 버그 수정

	//{{ mauntain : 김태환 [2012.07.26] 클로킹 메모 쓸쓸한 기다림 버그 수정 ( 작업자 : 엘소드 대만 이지헌 )
#ifdef EVE_MEMO5_BUG_FIX
	m_fAdditionalMPChangeRateByPassive = 0.f;
#endif EVE_MEMO5_BUG_FIX
	//}}

#ifdef PORTAL_LINEMAP_TEST
	m_bEnterPortal = false;
	m_bLeavePortal = true;
#endif PORTAL_LINEMAP_TEST


	m_fPepperRunTime = 0.f;

	m_bRidingMachine = false;
	m_bLeaping = false;


	m_bReserveForceDownForShock	= false;

#ifdef UNIT_EMOTION
	m_ePlayedEmotion = CX2Unit::ET_NONE;
	m_bReserveSitReadyEmotion = false;
#endif

	m_fSocketSuperArmor = 0.f;
	m_bSocketSuperArmor = false;

	m_bStateSuperArmor	= false;

#ifdef DUNGEON_ITEM
	m_fSuperArmorByItem = 0.f;
	m_bSuperArmorByItem = false;
#endif

#ifdef BUFF_TEMPLET_SYSTEM
	m_hEffectCrystalOfElBuff = INVALID_EFFECTSET_HANDLE;	
	//10초당 전체 체력의 % 회복 소켓 - 회복 카운트 시간
	m_fSocketHPIncreasePerSecondTime = 0.f;
#endif BUFF_TEMPLET_SYSTEM

	m_ViewEqipList.reserve( 64 );



#ifdef EQUIP_STRIP_TEST
	m_fTimeLeftToClearOutSuccessiveHit = 0.f;
	m_iSuccessiveHitCount = 0;
#endif EQUIP_STRIP_TEST




//#ifdef PVP_BOSS_COMBAT_TEST
//	m_hEffectSetBossMark = INVALID_EFFECTSET_HANDLE;
//	m_iFriendlyHittedCountAtFrozenState = 0;
//#endif PVP_BOSS_COMBAT_TEST

#ifdef USER_HOLD
	m_bHold = false;
	m_vHold = D3DXVECTOR3(0.f, 0.f, 0.f);
#endif

#ifdef SKILL_CASH_10_TEST
	m_hSeqDrainParticle = INVALID_PARTICLE_SEQUENCE_HANDLE;
#endif

#ifdef NO_DETONATION
	m_bNoDetonation = false;
	m_bNowStateDamageReact = false;
#endif

	m_pComboGuide = new CX2ComboGuide();

	//{{ kimhc // 2010.2.10 //	이브 2차 전직 네메시스
#ifdef	EVE_SECOND_CLASS_CHANGE
	SetHitNasodWeapon( false );	// 나소드 무기 강화에 맞았는가?
#endif	EVE_SECOND_CLASS_CHANGE
	//}} kimhc // 2010.2.10 //	이브 2차 전직 네메시스

#ifdef SERV_INTEGRATION
	//{{ oasis907 : 김상윤 [2010.5.17] // 
	m_pTextureServer = g_pKTDXApp->GetDeviceManager()->OpenTexture( L"DLG_UI_Common_Texture11.tga" );
	//}}
#endif SERV_INTEGRATION

#ifdef SERV_PET_SYSTEM
	m_iDieCount = 0;
#endif

#ifdef PET_AURA_SKILL
	m_bApplyAura = false;
#endif

	m_fOxygenGage = MAGIC_OXYGEN_GAGE;	

	//{{ JHKang / 강정훈 / 2010/12/16 / 현재 피격 상태인가?
#ifdef SEASON3_MONSTER_2010_12
	m_bNowHit = false;	
#endif SEASON3_MONSTER_2010_12
	//}} JHKang / 강정훈 / 2010/12/16 / 현재 피격 상태인가?
	
	//{{ JHKang / 강정훈 / 2011/01/17 / 최종 데미지 값을 저장할 멤버 변수
#ifdef SEASON3_MONSTER_2010_12
	m_fRealDamage = 0.f;
	m_fAnimSpeedRateByNpc = 1.f;
#endif SEASON3_MONSTER_2010_12
	//}} JHKang / 강정훈 / 2011/01/17 / 최종 데미지 값을 저장할 멤버 변수

	//{{ JHKang / 강정훈 / 2011/02/14 / 던전 랭크 개선 관련
#ifdef DUNGEON_RANK_NEW
	m_iTotalAttackedDamage	= 0;
	m_iTotalRecoveryHP		= 0;
	m_iUsingSkillCount		= 0;
	m_iTotalGivenDamamge	= 0;
	ZeroMemory( &m_iSkillSlotACount, sizeof( m_iSkillSlotACount ) );
	ZeroMemory( &m_iSkillSlotBCount, sizeof( m_iSkillSlotBCount ) );
#endif DUNGEON_RANK_NEW
	//}} JHKang / 강정훈 / 2011/02/14 / 던전 랭크 개선 관련

#ifdef TEST_GROUP_GRAP
	m_bGrap = false;
	m_iGrapShakeCount = 0;
	m_vGrap				= D3DXVECTOR3(0.f, 0.f, 0.f);
	m_vBeforeGrapPos	= D3DXVECTOR3(0.f, 0.f, 0.f);


	m_bGrapEscapeKeyLeftCheck = false;
	m_bGrapEscapeKeyRightCheck = false;

#endif TEST_GROUP_GRAP
	
#ifdef WORLD_TRIGGER
	m_fTriggerTime = 0.f;
#endif

	for(int i=0; i < AVATAR_EMOTION_NUM; ++i)
		m_bMixedEmotion[i] = false;
	m_pAvatarEmotionSound = NULL;

#ifdef NEW_HENIR_TEST
	m_hHenirBuff_Nature = INVALID_EFFECTSET_HANDLE;
	m_hHenirBuff_Wind	= INVALID_EFFECTSET_HANDLE;
#endif NEW_HENIR_TEST

#ifdef SPECIAL_USE_ITEM
	m_hSpecialItemBuff_Wind	= INVALID_EFFECTSET_HANDLE;
	m_iThrowItemValue		= 0;
	m_bThrowSuccess			= false;
	m_fThrowStartTime		= 0.f;		// 이후 파생클래스에서 재 초기화 함
#endif

#ifdef FACE_OFF_MONSTER_HEAD_TEST
	m_bHideNoRenderable = false;
#endif FACE_OFF_MONSTER_HEAD_TEST

#ifdef SERV_ADD_TITLE_CONDITION
	m_ucDieReason = KEGS_USER_UNIT_DIE_REQ::UUDR_UNKNOWN;
#endif

#ifdef UPGRADE_RAVEN
	m_bParryingState = false;
#endif

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	m_bManeuverParryingState = false;
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

#ifdef ARA_CHANGE_CLASS_FIRST
	m_bQuickenGuardBlocking = false;
	m_bQuickenGuardTurning = false;
#endif

#ifdef SERV_ADD_ARME_BATTLE_MAGICIAN
	m_bIsTransformed = false;
#endif

#ifdef ELSWORD_WAY_OF_SWORD
	m_iHoldStateID = USI_DAMAGE_AIR_FALL;
#endif ELSWORD_WAY_OF_SWORD

#ifdef ELSWORD_SHEATH_KNIGHT
	m_fAttackCancelAfterEx	= 9999.f;
	m_fAttackCancelAfter	= 9999.f;
	m_fSkillCancelAfter		= 9999.f;
	m_fWalkCancelAfter		= 9999.f;
	m_fBWalkCancelAfter		= 9999.f;
	m_fDashCancelAfter		= 9999.f;
#endif ELSWORD_SHEATH_KNIGHT

#ifdef SERV_RAVEN_VETERAN_COMMANDER
	m_fSkillCancelAfterFly	= 9999.f;		/// 공중용 스킬 캔슬
#endif SERV_RAVEN_VETERAN_COMMANDER

#ifdef HYPER_MODE_FIX
	m_iLastStateHyperModeCount	= 0;
	m_bReserveHyperModeZero		= false;
#endif HYPER_MODE_FIX

#ifdef SERV_CHUNG_TACTICAL_TROOPER
	m_iHyperModeCountUsed		= 0;
#endif SERV_CHUNG_TACTICAL_TROOPER

#ifdef EVE_ELECTRA
	m_hSeqWhiteOut  = INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_bWhiteOut		= false;
#endif EVE_ELECTRA

	m_pSlashTrace = NULL;
	m_pSlashTraceTip = NULL;

#ifndef FIX_LIMITED_MANA_MANAGEMENT
	m_bLimitManaManagement = false;
#endif //FIX_LIMITED_MANA_MANAGEMENT

	InitByGameType();

	for ( int index = 0; index < COMMON_MAJOR_PII_END; ++index )
		m_ahCommonMajorParticleInstance[index] = INVALID_PARTICLE_SEQUENCE_HANDLE;
	for ( int index = 0; index < COMMON_MINOR_PII_END; ++index )
		m_ahCommonMinorParticleInstance[index] = INVALID_PARTICLE_SEQUENCE_HANDLE;

	m_fSummonNpcCoolTime = 0.f;

#ifdef SERV_TRAPPING_RANGER_TEST
	m_delegateVitalPointPiercing = DelegateVitalPointPiercing();
#endif SERV_TRAPPING_RANGER_TEST

#ifdef SERV_CHUNG_TACTICAL_TROOPER
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hCEffectTacticalField = INVALID_DAMAGE_EFFECT_HANDLE;					/// 택티컬 필드 데미지 이펙트
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_pCEffectTacticalField = NULL;					/// 택티컬 필드 데미지 이펙트
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#endif SERV_CHUNG_TACTICAL_TROOPER

#ifdef RIDING_SYSTEM
	INIT_VECTOR3( m_vSaddlePos, 0, 0, 0 )
	INIT_VECTOR3( m_vDirDegree, 0, 0, 0 )
#endif //RIDING_SYSTEM

	if ( NULL != g_pMain->GetPVPEmblem() )
	{
#ifdef PVP_SEASON2
		CX2PVPEmblem::PVPEmblemData *pPvpEmblemData = g_pMain->GetPVPEmblem()->GetPVPEmblemData( GetUnit()->GetPvpRank() );
#else
		CX2PVPEmblem::PVPEmblemData *pPvpEmblemData = g_pMain->GetPVPEmblem()->GetPVPEmblemData( GetUnit()->GetPVPEmblem() );
#endif

		if( pPvpEmblemData != NULL )
			m_pTextureRank = g_pKTDXApp->GetDeviceManager()->OpenTexture( pPvpEmblemData->m_TextureName );
	}	


#ifdef NEXON_QA_CHEAT_REQ
	m_bIsInvincibleAndNoMpConsume = false;
#endif //NEXON_QA_CHEAT_REQ


#ifdef SERV_APRIL_FOOLS_DAY	
	CTime ctCurrentTime( g_pData->GetServerCurrentTime() );

	if( 4 == ctCurrentTime.GetMonth() && 1 == ctCurrentTime.GetDay() )
		m_bIsFoolsDay = true;
	else
		m_bIsFoolsDay = false;
#endif //APRIL_FOOLS_DAY

//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
    ResetLocalAndRelativePosAndTimers();
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC

#ifdef SERV_GATE_OF_DARKNESS_SUPPORT_EVENT
	m_iAllyEventMonsterUID = -1;
#endif SERV_GATE_OF_DARKNESS_SUPPORT_EVENT
}

CX2GUUser::~CX2GUUser(void)
{
#ifdef SERV_GATE_OF_DARKNESS_SUPPORT_EVENT
	if( -1 != m_iAllyEventMonsterUID )
	{
		CX2GUNPC* pNPCUnit = g_pX2Game->GetNPCUnitByUID( m_iAllyEventMonsterUID );

		if( NULL != pNPCUnit )
			pNPCUnit->SetNowHp( 0.f );

		m_iAllyEventMonsterUID = -1;

		g_pX2Game->SetEventMonsterOut( GetUnitUID() );
	}
#endif SERV_GATE_OF_DARKNESS_SUPPORT_EVENT

//#ifdef TRANSFORMER_TEST
//	TransformIntoUser();
//	//m_pTransformer = NULL;
//	//SAFE_DELETE_KTDGOBJECT( m_pTrasformer );
//#endif TRANSFORMER_TEST

#ifdef SERV_PET_SYSTEM
	if( g_pData != NULL && g_pData->GetPetManager() != NULL )
	{
		g_pData->GetPetManager()->RemovePet( GetUnitUID() );
	}
#endif

#ifdef RIDING_SYSTEM
	if( CX2RidingPetManager::GetInstance() != NULL )
	{
		CX2RidingPetManager::GetInstance()->RemoveRidingPet( GetUnitUID() );
	}
#endif //RIDING_SYSTEM RemoveRidingPet()

	m_pUnit = NULL;

	m_SendSyncDataList.clear();
	m_ReceiveSyncDataList.clear();
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
    m_LastSendSyncDataList.clear();
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_EventTimeStampFuture.clear();
	m_EventTimeStampNow.clear();
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

	for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
	{
		CX2EqipPtr pEqip = m_ViewEqipList[i];
		if( pEqip != NULL )
		{
			pEqip->SetManagerObject( NULL );
		}
	}
	m_ViewEqipList.clear();


#ifdef EQUIP_STRIP_TEST
	BOOST_TEST_FOREACH( CX2ItemManager::EquipPositionMap::value_type&, value, m_mapBasicEquip )
	{
		CX2EqipPtr pEquip = value.second;
		if( pEquip != NULL )
		{
			pEquip->SetManagerObject( NULL );
		}
	}
	m_mapBasicEquip.clear();
#endif EQUIP_STRIP_TEST


#ifdef SERV_ADD_ARME_BATTLE_MAGICIAN
	bool bDeleteOrgMotion = false;
	if( m_pMotion != m_pOrgMotion )
		bDeleteOrgMotion = true;
#endif

	SAFE_CLOSE( m_pMotionFuture );
	SAFE_CLOSE( m_pMotion );
	SAFE_CLOSE( m_pAniXET );
	SAFE_CLOSE( m_pTextureRank );

	//SAFE_DELETE( m_pXSkinAnimFuture );
	//SAFE_DELETE( m_pXSkinAnim );
	//{{ seojt // 2009-1-12, 16:44
	bool bTryDelete_m_pOrgXSkinAnimFuture = false;
	if( m_pXSkinAnimFuture != m_pOrgXSkinAnimFuture )
	{
		bTryDelete_m_pOrgXSkinAnimFuture = true;
	}//if


#ifdef EFFECT_TOOL
	SAFE_DELETE_KTDGOBJECT( m_pXSkinAnim_EffectTool );
#endif // EFFECT_TOOL
	SAFE_DELETE_KTDGOBJECT( m_pXSkinAnimFuture );
#ifdef FIX_MEMLEAK01
	SAFE_CLOSE( m_pAfterImageMotion );
#endif

	bool bTryDelete_m_pOrgXSkinAnim = false;
	if( m_pXSkinAnim != m_pOrgXSkinAnim )
	{
		bTryDelete_m_pOrgXSkinAnim = true;
	}//if

	m_pXSkinAnim.reset();

	SAFE_CLOSE( m_pOrgMotionFuture );
#ifdef SERV_ADD_ARME_BATTLE_MAGICIAN
	if( bDeleteOrgMotion == true )
		SAFE_CLOSE( m_pOrgMotion );
#else
	SAFE_CLOSE( m_pOrgMotion );
#endif


	/** 같은 포인터를 두번 delete하여 crash될 가능성을 막는다.
	- jintaeks on 2009-01-12, 16:45 */
	if( bTryDelete_m_pOrgXSkinAnimFuture == true )
	{
		SAFE_DELETE_KTDGOBJECT( m_pOrgXSkinAnimFuture)
	}//if
	if( bTryDelete_m_pOrgXSkinAnim == true )
	{
		m_pOrgXSkinAnim.reset();
	}//if
	//}} seojt // 2009-1-12, 16:44


	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqHeadMarker );



//#ifdef TITLE_SYSTEM
	g_pData->GetUIMajorParticle()->DestroyInstanceHandle( m_hSeqEmblem );
//#else
//	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqEmblem );
//#endif

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hHeadMarkerParticle = INVALID_PARTICLE_HANDLE;
    m_hPart_Emblem_200 = INVALID_PARTICLE_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_pPart_Emblem_200 = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE


	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hHoldEffCenter );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hHoldEffCircle );

	if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_hEnterCashShop )
	{
		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle(m_hEnterCashShop);
	}

	DeleteEnchantedWeaponEffectAtHand();


#ifdef SKILL_CASH_10_TEST
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqDrainParticle );
#endif

	//SAFE_DELETE_KTDGOBJECT( m_pAfterImage );
//#ifndef NOT_USE_DICE_ROLL
//	SAFE_DELETE( m_pDiceRoll );
//#endif //NOT_USE_DICE_ROLL

//#ifdef PVP_BOSS_COMBAT_TEST
//	g_pX2Game->GetEffectSet()->StopEffectSet( m_hEffectSetBossMark );
//#endif PVP_BOSS_COMBAT_TEST

	//{{ kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트
#ifdef	SERV_TOONILAND_CHANNELING_EVENT
	SetShowTooniLandEventEffectSet( false );
#endif	SERV_TOONILAND_CHANNELING_EVENT
	//}} kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트

	SAFE_DELETE( m_pComboGuide );

//{{ kimhc // 2010.4.9 // 비밀던전 작업(셋트아이템효과)
#ifdef SERV_SECRET_HELL
	SAFE_DELETE( m_pBoneShieldData );
#endif SERV_SECRET_HELL
//}} kimhc // 2010.4.9 // 비밀던전 작업(셋트아이템효과)

#ifdef SERV_INTEGRATION
	SAFE_CLOSE( m_pTextureServer );
#endif SERV_INTEGRATION

	if( m_pAvatarEmotionSound != NULL )
	{
		m_pAvatarEmotionSound->Stop();
		SAFE_CLOSE(m_pAvatarEmotionSound);
	}

	m_StateList.clear();

	//{{ mauntain : 김태환 [2012.06.14] 몬스터 카드 소환 기능 - 해당 User 이탈 시 몬스터 처리
#ifdef SUMMON_MONSTER_CARD_SYSTEM
	int SummonMonsterUID = GetSummonMonsterCardData().GetSummonMonsterUID();

	if( -1 != SummonMonsterUID )
	{
		CX2GUNPC* pNPCUnit = g_pX2Game->GetNPCUnitByUID( SummonMonsterUID );

		if( NULL != pNPCUnit )
		{
			pNPCUnit->SetNowHp( 0.f );
#ifdef NO_COPY_CARD_MONSTER_DATA_SHASHA // 카드 몬스터로 제작된 하멜 비던 샤샤에 대한 예외 처리, 13-09-06 kimjh, 나중에 NPC Type 을 추가하거나 인자를 추가하여 변경할 것!	
			if ( false == pNPCUnit->IsUnitID( CX2UnitManager::NUI_SHASHA_STAGE0 ) &&
				false == pNPCUnit->IsUnitID( CX2UnitManager::NUI_SHASHA_STAGE1 ) &&
				false == pNPCUnit->IsUnitID( CX2UnitManager::NUI_SHASHA_STAGE2 ) )
#endif // NO_COPY_CARD_MONSTER_DATA_SHASHA // 카드 몬스터로 제작된 하멜 비던 샤샤에 대한 예외 처리, 13-09-06 kimjh, 나중에 NPC Type 을 추가하거나 인자를 추가하여 변경할 것!		
				AccessSummonMonsterCardData().init();
		}
	}
#endif SUMMON_MONSTER_CARD_SYSTEM
	//}}

#ifdef ADD_RENA_SYSTEM //김창한
	// 스킬 관련 저장 초기화
	m_AllDamageRelateSkillData.Init();
#endif //ADD_RENA_SYSTEM

}



//#ifdef TRANSFORMER_TEST
//
//
//	void CX2GUUser::TransformIntoUser()
//	{
//		if( NULL != GetTransformer() )
//		{
//			GetTransformer()->SetNowHp( 0.f );
//		}
//
//		SetTransformed( false );
//		SetTransformer( NULL );
//
//		//SAFE_DELETE_KTDGOBJECT( m_pTrasformer );
//		StateChange( m_CommonState.m_Wait );
//		SetShowObject( true );
//
//	}
//
//	void CX2GUUser::TransformIntoMonster( CX2UnitManager::NPC_UNIT_ID eNPCID )
//	{
//		TransformIntoUser();
//
//		const CX2Unit::UnitData* pUnitData = &GetUnit()->GetUnitData();
//
//		int iHyperMode = 0;
//		g_pX2Game->CreateNPCReq( eNPCID, iHyperMode, true, GetPos(), 
//			GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_NO_BRAIN, GetUnitUID() );
//
//
//		//StateChange( m_CommonState.m_Transformed );
//	}
//
//
//#endif TRANSFORMER_TEST

/*static*/
void     CX2GUUser::InitInit( InitData& OutInit_, KLuaManager& luaManager_ )
{
	CX2GameUnit::InitDevice( OutInit_.m_device, luaManager_ );
	InitMotion( OutInit_, luaManager_ );
}//CX2GUUser::InitInit()


void CX2GUUser::Init( bool bUseTeamPos, int startPosIndex )
{
//#ifndef NOT_USE_DICE_ROLL
//	if( m_pDiceRoll == NULL )
//		m_pDiceRoll		= new DiceRoll( this );
//#endif //NOT_USE_DICE_ROLL

	InitSystem();
	InitDevice();
	InitMotion();


	InitStat();

#ifdef TEMP_HERO_MATCH_NO_ITEM_ABILITY
	// 대회채널에는 속성, 소켓, 세트, 강화 아무것도 적용안되고, 1레벨 기본 unit stat만 적용된다.
	if( CX2Main::XS_PVP_GAME != g_pMain->GetNowStateID() || 
		KPVPChannelInfo::PCC_TOURNAMENT != g_pMain->GetPVPChannelClass( g_pMain->GetConnectedChannelID() ) )
#endif TEMP_HERO_MATCH_NO_ITEM_ABILITY
	{
		InitSocketData();
		InitEnchantData();
	}

	InitPhysic();
	InitEqip();
	InitComponent();

	ParseCommonRandomState();
	InitEffect();
	InitAdditionalBasicStatValue();	/// InitPassiveSikllState() 의 제일 마지막에 있어야 함
	InitState();

	// FieldFix: 임시로 이렇게 처리...
	if ( NULL != g_pX2Game )
	{
		switch ( g_pX2Game->GetGameType() )
		{
		case CX2Game::GT_BATTLE_FIELD:
			{
				if ( IsMyUnit() && false == g_pData->GetBattleFieldManager().GetNowBattleFieldPositionInfoStartPosition() )
					InitPosByBattleFieldPosition();
				else
					InitPosition( bUseTeamPos, startPosIndex );
			}
			break;

		default:
			InitPosition( bUseTeamPos, startPosIndex );
			break;
		}
	}
	InitEtc();

// 	CX2PET *pPet = g_pData->GetPetManager()->GetPet( GetUnitUID() );
// 	if( pPet != NULL )
// 		pPet->InitPos();

	SetEnableAttackBox( L"Rfoot", false );
	SetEnableAttackBox( L"Lfoot", false );
	SetEnableAttackBox( L"Lhand2", false );

	if ( NULL != GetGageData() )
		m_FrameDataFuture.syncData.m_HyperModeCount = GetGageData()->GetHyperModeCount();

#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
	m_bPositionBackup = false;
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION
	m_FrameDataNow		= m_FrameDataFuture;

	SetCenter( m_pMotion->GetCenter() );
	SetBoundingRadius( m_pMotion->GetBoundingRadius() );

#ifdef WORLD_TOOL
	StateChange( USI_WAIT );
#else
	// FieldFix: 임시로 이렇게 처리...
	if ( NULL != g_pX2Game )
	{
		switch ( g_pX2Game->GetGameType() )
		{
		case CX2Game::GT_BATTLE_FIELD:
			StateChange( USI_WAIT );
			break;

#ifdef RIDING_SYSTEM
		case CX2Game::GT_PVP:
			StateChange( USI_START );
			break;
#endif //RIDING_SYSTEM

		default:
			{
#ifdef RIDING_SYSTEM
				if ( NULL != GetUnit() && NULL != GetUnit()->GetRidingPetInfo() )
					StateChange( GetRidingStartStateID() );
				else
					StateChange( USI_START );
#else
				StateChange( USI_START );
#endif //RIDING_SYSTEM Change Start
			} break;
		}

#ifdef RIDING_SYSTEM
		if ( CX2Game::GT_PVP != g_pX2Game->GetGameType() )
		{
			if ( NULL != GetUnit() )
			{
				const KRidingPetInfo* pRidingPetInfo
					= GetUnit()->GetRidingPetInfo();
				if ( NULL != pRidingPetInfo )
					ProcessRidingOn( true, *pRidingPetInfo );
			}
		}
#endif //RIDING_SYSTEM Pet 정보 받아오기
	}
#endif //WORLD_TOOL
	
	m_bWaitingForRebirthAfterBungee = false;

#ifdef PORTAL_LINEMAP_TEST
	m_bEnterPortal = false;
	m_bLeavePortal = true;
#endif PORTAL_LINEMAP_TEST

	m_bDisableGravity = false;

	ClearEffectiveBlackHoleDamageEffect();

	//{{ kimhc // 2009-12-29 // 길드스킬 영웅의희생 관련 부분 초기화
#ifdef	GUILD_SKILL_PART_2
	m_bHaveSacrificeOfHero		= false;
	m_RenderParam.renderType	= CKTDGXRenderer::RT_CARTOON_BLACK_EDGE;
	//m_GuildSkillData.Init();
#endif	GUILD_SKILL_PART_2
	//}} kimhc // 2009-12-29 // 길드스킬 영웅의희생 관련 부분 초기화

#ifdef SERV_PET_SYSTEM
	if( g_pData != NULL && g_pData->GetPetManager() != NULL )
	{
		if( GetUnit()->GetPetInfo() != NULL )
		{
			KPetInfo *pPetInfo = GetUnit()->GetPetInfo();
			CX2PET::PetInfo petInfo;

			petInfo.m_PetUid = pPetInfo->m_iPetUID;
#ifdef SERV_PETID_DATA_TYPE_CHANGE //2013.07.02
			petInfo.m_PetId = pPetInfo->m_iPetID;
#else //SERV_PETID_DATA_TYPE_CHANGE
			petInfo.m_PetId = pPetInfo->m_cPetID;
#endif //SERV_PETID_DATA_TYPE_CHANGE
			petInfo.m_Evolution_Step = pPetInfo->m_cEvolutionStep;
			petInfo.m_wstrPetName = pPetInfo->m_wstrPetName;		
			petInfo.m_Intimacy = (float)pPetInfo->m_iIntimacy;
			petInfo.m_Satiety = pPetInfo->m_sSatiety;
			petInfo.m_Extroversion = pPetInfo->m_sExtroversion;
			petInfo.m_Emotion = pPetInfo->m_sEmotion;
#ifdef PET_DROP_ITEM_PICKUP
			petInfo.m_bIsDropItemPickup = pPetInfo->m_bAutoLooting;
#endif //PET_DROP_ITEM_PICKUP
			petInfo.m_bSummon = true;
#ifdef SERV_PET_SYSTEM_EX1
			petInfo.m_bAlwaysMaxSatiety = pPetInfo->m_bAlwaysMaxSatiety;
#endif //SERV_PET_SYSTEM_EX1
#ifdef SERV_EVENT_PET_INVENTORY
			petInfo.m_bEventFoodEat		= pPetInfo->m_bEventFoodEat;
			petInfo.m_bIsEventPetID		= pPetInfo->m_bIsEventPetID;
#endif SERV_EVENT_PET_INVENTORY
			g_pData->GetPetManager()->CreateGamePet( GetUnitUID(), petInfo );
		}
		else
		{
			g_pData->GetPetManager()->RemovePet( GetUnitUID() );
		}		
	}
#endif
	
	//{{ kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트
#if defined(SERV_TOONILAND_CHANNELING_EVENT) && !defined(X2TOOL)

	SetShowTooniLandEventEffectSet( true );
#endif	SERV_TOONILAND_CHANNELING_EVENT
	//}} kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트

#ifdef ADD_RENA_SYSTEM //김창한
	// 스킬 관련 저장 초기화
	m_AllDamageRelateSkillData.Init();
#endif //ADD_RENA_SYSTEM

}

void CX2GUUser::ReInit( bool bUseTeamPos, int startPosIndex )
{
	int hyperModeCount = GetHyperModeCount();
	m_bDownForce = false;

	CX2GameUnit::ReInit( bUseTeamPos, startPosIndex );
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    m_vecAttackTime.resize( 0 );
	m_StopAllList.resize(0);
	m_StopOtherList.resize(0);
	m_StopMyList.resize(0);
	m_Stop2AllList.resize(0);
	m_Stop2OtherList.resize(0);
	m_Stop2MyList.resize(0);
    m_vecSoundPlayData.resize( 0 );
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

	//{{ kimhc // 2009-12-29 // 길드스킬 영웅의희생 관련 부분 초기화
#ifdef	GUILD_SKILL_PART_2
	m_bHaveSacrificeOfHero		= false;
	m_RenderParam.renderType	= CKTDGXRenderer::RT_CARTOON_BLACK_EDGE;
	m_GuildSkillData.Init();
#endif	GUILD_SKILL_PART_2
	//}} kimhc // 2009-12-29 // 길드스킬 영웅의희생 관련 부분 초기화

	m_bFirstDataReceive			= false;
	m_bPopAgain					= false;
	m_fRebirthTime				= 0.0f;

	m_fExtraBigHead				= 0.f;

	ClearRecieveSyncData();
	m_SendSyncDataList.reserve( m_FrameBufferNum * 2 );
	m_ReceiveSyncDataList.reserve( m_FrameBufferNum * 2 );
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
    m_LastSendSyncDataList.reserve( m_FrameBufferNum * 2 );
    m_adwInitFrameMoveCount[0] = 0;
	m_adwInitFrameMoveCount[1] = 0;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

	m_FutureStateData.Init();
	m_NowStateData.Init();


	//m_FrameDataFutureBefore.Init();
	m_FrameDataNowBefore.Init();
	
	m_BeforeInputData.Init();
	m_InputData.Init();

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    ClearAnimEventTimerOneshotFuture();
    ClearAnimEventTimerOneshotNow();
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    m_EventTimeStampFuture.clear();
	m_EventTimeStampNow.clear();
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

	m_DamagedMap.clear();

#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
	m_bPositionBackup = false;
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#ifdef  SUPER_ARMOR_TIME
    m_vecNowSuperArmorTime.resize(0);
#endif  SUPER_ARMOR_TIME
#ifdef SKILL_BALANCE_PATCH
	m_bFutureCanPassUnit = false;
#endif
    m_bFutureApplyAnimMove = true;
    m_bNowFallDown = true;
    m_fNowSlashTraceTipWide = 4.0f;
    m_mapNowAddSlashTrace.clear();
    m_v2NowAfterImageTime = D3DXVECTOR2( -1.f, -1.f );
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE



	//아군이 있으면 아군 위치에서 부활
	switch ( g_pX2Game->GetGameType() )
	{
	case CX2Game::GT_DUNGEON:
		{
            m_FrameDataFuture.Init();
            m_FrameDataNow.Init();

			bool bInitPos = false;
			bool bIsExistMyTeam = false;
			for( int i= 0; i < g_pX2Game->GetUserUnitNum(); i++ )
			{
				CX2GUUser* pCX2GUUser = g_pX2Game->GetUserUnit( i );
				if( pCX2GUUser != NULL && pCX2GUUser->GetTeam() == GetTeam() && NULL != g_pX2Game->GetMyUnit() )
				{
					if ( pCX2GUUser != g_pX2Game->GetMyUnit() )
						bIsExistMyTeam = true;

					if ( pCX2GUUser != g_pX2Game->GetMyUnit() &&
						pCX2GUUser->GetGameUnitState() != CX2GUUser::GUSI_DIE && 
						pCX2GUUser->GetNowHp() > 0.0f )
					{
						// 우리팀이 있고 한명이라도 살아있다면 팀원 위치에서 부활
						bInitPos = true;
						InitPosition( pCX2GUUser );
					}
				}
			}

			if ( bInitPos == false )
			{

				//{{ kimhc // 2010.8.10 // 특정 몬스터의 위치 값을 부활 위치로 사용
				if( NULL != g_pX2Game && CX2Game::GT_DUNGEON == g_pX2Game->GetGameType() )
				{
					CX2DungeonGame*		pDungeonGame	= static_cast<CX2DungeonGame*>(g_pX2Game);
					if( NULL != pDungeonGame )
					{
						CX2DungeonSubStage*	pSubStage		= pDungeonGame->GetDungeon()->GetNowStage()->GetNowSubStage();

						// 솔로 플레이인 경우에는 죽은 위치에서 부활
						if ( bIsExistMyTeam == false 
							&& m_DeadStageIndex == pDungeonGame->GetDungeon()->GetNowStageIndex() 
							&& m_DeadSubStageIndex == pDungeonGame->GetDungeon()->GetNowStage()->GetNowSubStageIndex() )
						{
							InitPosByDeadPos( g_pX2Game->GetMyUnit() );
						}
						// 솔로 플레이에서 죽을 때의 stage와 다르거나, 우리팀이 있기는 있는데 다 죽은 상황이라면 해당 서브스테이지의 랜덤 위치에서 부활
						else
						{
							//{{ kimhc // 2011-04-29 // 디펜스 던전 부활 위치 수정
#ifdef	SERV_INSERT_GLOBAL_SERVER
							if ( true == g_pData->GetDungeonManager()->IsDefenceDungeon( pDungeonGame->GetDungeon()->GetDungeonData()->m_DungeonID ) )
							{
								InitPosByDeadPos( g_pX2Game->GetMyUnit() );	// 죽은 자리에서 부활
							}
							else
#endif	SERV_INSERT_GLOBAL_SERVER
								//}} kimhc // 2011-04-29 // 디펜스 던전 부활 위치 수정
							{
								// 헤니르 시공의 경우 pSubStage가 NULL 임
								bool bSuccessRebirth = true;

								if ( pSubStage != NULL && pSubStage->GetSubStageData()->GetUsePosOfMonsterForRebirth() == true )
									bSuccessRebirth = InitPosByMonsterPos();

								if ( bSuccessRebirth == false || pSubStage == NULL || pSubStage->GetSubStageData()->GetUsePosOfMonsterForRebirth() == false )
									InitPosition( bUseTeamPos, startPosIndex );
							}
						}
				//}} kimhc // 2010.8.10 // 특정 몬스터의 위치 값을 부활 위치로 사용
					}
				}
			}
			//{{ kimhc // 2011-04-29 // 디펜스 던전 부활 위치 수정
#ifdef	SERV_INSERT_GLOBAL_SERVER
			else
			{
				if( NULL != g_pX2Game && CX2Game::GT_DUNGEON == g_pX2Game->GetGameType() )
				{
					CX2DungeonGame*		pDungeonGame	= static_cast<CX2DungeonGame*>(g_pX2Game);
					if ( NULL != pDungeonGame &&
						NULL != pDungeonGame->GetDungeon() &&
						NULL != pDungeonGame->GetDungeon()->GetDungeonData() &&
						true == g_pData->GetDungeonManager()->IsDefenceDungeon( pDungeonGame->GetDungeon()->GetDungeonData()->m_DungeonID ) )
					{
						InitPosByDeadPos( g_pX2Game->GetMyUnit() );	// 죽은 자리에서 부활
					}
				}
			}
#endif	SERV_INSERT_GLOBAL_SERVER
			//}} kimhc // 2011-04-29 // 디펜스 던전 부활 위치 수정
		} break;

	case CX2Game::GT_BATTLE_FIELD:
		{
			m_FrameDataFuture.Init();
			m_FrameDataFuture.syncData.position				= m_FrameDataNow.syncData.position;
			m_FrameDataFuture.unitCondition.dirDegree		= m_FrameDataNow.unitCondition.dirDegree;
			m_FrameDataFuture.unitCondition.landPosition	= m_FrameDataNow.unitCondition.landPosition;
			m_FrameDataFuture.syncData.lastTouchLineIndex	= m_FrameDataNow.syncData.lastTouchLineIndex;
			m_FrameDataFuture.syncData.bIsRight				= m_FrameDataNow.syncData.bIsRight;

			m_FrameDataNow.Init();
			m_FrameDataNow.syncData.position				= m_FrameDataFuture.syncData.position;
			m_FrameDataNow.unitCondition.dirDegree			= m_FrameDataFuture.unitCondition.dirDegree;
			m_FrameDataNow.unitCondition.landPosition		= m_FrameDataFuture.unitCondition.landPosition;
			m_FrameDataNow.syncData.lastTouchLineIndex		= m_FrameDataFuture.syncData.lastTouchLineIndex;
			m_FrameDataNow.syncData.bIsRight				= m_FrameDataFuture.syncData.bIsRight;

		} break;

	default:
		{
			m_FrameDataFuture.Init();
			m_FrameDataNow.Init();

			InitPosition( bUseTeamPos, startPosIndex );

		} break;
		
	}
	
	m_FrameDataDead.Init();


	if( m_LuaManager.BeginTable( "INIT_SYSTEM" ) == true )
	{
		LUA_GET_VALUE( m_LuaManager, "UNIT_WIDTH", m_FrameDataFuture.unitCondition.fUnitWidth, 35.f );
		LUA_GET_VALUE( m_LuaManager, "UNIT_HEIGHT", m_FrameDataFuture.unitCondition.fUnitHeight, 150.f );
		m_FrameDataNow.unitCondition.fUnitWidth = m_FrameDataFuture.unitCondition.fUnitWidth;
		m_FrameDataNow.unitCondition.fUnitHeight = m_FrameDataFuture.unitCondition.fUnitHeight;


		m_LuaManager.EndTable();
	}

	if( m_LuaManager.BeginTable( "INIT_COMPONENT" ) == true )
	{
		ResetMaxHP();
		m_LuaManager.GetValue( "MP_CHANGE_RATE",		m_fOriginalMPChangeRate );
		
		//{{ kimhc // 2010.06.04 // 드래고닉셋트효과 아이템 버그 수정
#ifdef SERV_SECRET_HELL
		SetManaRecoveryTime( 0.0f );
		SetManaRecoveryVal( 0.0f );
		ResetMPChangeRate( GetOriginalMPChangeRate() );

#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
		SetSocketOptionCoolTime( 0.0f );
		SetSocketOptionHyperCoolTime( 0.0f );
#endif //ADJUST_SECRET_ITEM_OPTION

#else	SERV_SECRET_HELL
		ResetMPChangeRate( m_fOriginalMPChangeRate );
#endif SERV_SECRET_HELL
		//}} kimhc // 2010.06.04 // 드래고닉셋트효과 아이템 버그 수정

		float fData = 0.f;
		m_LuaManager.GetValue( "MP_CHARGE_RATE",		fData );
		SetChangeRateChargeMpForDetonation( fData );
		

		SetNowHp( GetMaxHp() );
		ResetMaxMP();
		SetMaxSoul( 100.f );
		

#ifdef PVP_SEASON2
		if ( CX2Room::TN_RED == GetTeam() || CX2Room::TN_BLUE == GetTeam() )
		{
			int iDiffKillNum = 0;

			if ( CX2Room::TN_RED == GetTeam() )
				iDiffKillNum = g_pX2Game->GetRedTeamKill() - g_pX2Game->GetBlueTeamKill();
			else if ( CX2Room::TN_BLUE == GetTeam() )
				iDiffKillNum = g_pX2Game->GetBlueTeamKill() - g_pX2Game->GetRedTeamKill();
				
			if ( 1 < iDiffKillNum )
				SetNowMp( 0.f );
			else if ( iDiffKillNum == 1 )
				SetNowMp( GetNowMp() * 0.5f );
		}
#else
		if( GetTeam() == CX2Room::TN_RED && g_pX2Game->GetRedTeamKill() > g_pX2Game->GetBlueTeamKill() )
		{
			SetNowMp( 0.f );
			SetNowSoul( 0.f );
		}
		else if( GetTeam() == CX2Room::TN_BLUE && g_pX2Game->GetRedTeamKill() < g_pX2Game->GetBlueTeamKill() )
		{
			SetNowMp( 0.f );
			SetNowSoul( 0.f ); 
		}
#endif

#ifdef RESURRECT_MAX_MP
		//던전에서 부활석 사용 시 MP 최대치로 회복 시켜 주도록 수정  
		if( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON || g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD )
		{
			SetNowMp( GetMaxMp() );
		}
#endif //RESURRECT_MAX_MP
		GetGageData()->SetEnable( true );

		m_FrameDataFuture.syncData.fNowHP				= GetNowHp();
		m_FrameDataFuture.syncData.fNowMP				= GetNowMp();

		if ( m_pAfterImage != NULL )
		{
			m_pAfterImage->SetAfterImageColor( 0xffcccccc );
		}

		//{{ kimhc // 2010.6.16 // 같은 기능을 하는 함수가 존재하여 함수를 사용함
#ifdef	ENCHANT_BUG_TEST
		for( UINT i=0; i<m_vecpWeapon.size(); i++ )
		{ 
			Weapon* pWeapon = m_vecpWeapon[i];
			if( pWeapon != NULL )
			{
				pWeapon->LoadDataForUser( m_LuaManager );
			}
		}

		InitEnchantedWeaponEffectAtHand();
		InitEnchantWeaponEffectUnitSpecific();

		//SetShowEnchantWeaponParticle( true );
#else	ENCHANT_BUG_TEST
		// 2008.10.28 죽었을 때 무기 인챈트 효과  : 살아나면 켬 - 김태완
		for( UINT i=0; i<m_vecpWeapon.size(); i++ )
		{ 
			Weapon* pWeapon = m_vecpWeapon[i];
			if( pWeapon != NULL )
			{
				pWeapon->SetEnchantParticleShow(true);
			}
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeqWeapon = NULL;
		pSeqWeapon = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon1 );
		if( pSeqWeapon != NULL )
			pSeqWeapon->SetShowObject(true);
		pSeqWeapon = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon2 );
		if( pSeqWeapon != NULL )
			pSeqWeapon->SetShowObject(true);
		pSeqWeapon = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon3 );
		if( pSeqWeapon != NULL )
			pSeqWeapon->SetShowObject(true);		

		pSeqWeapon = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchantedWeaponCommon4 );
		if( pSeqWeapon != NULL )
			pSeqWeapon->SetShowObject(true);	
#endif	ENCHANT_BUG_TEST
		//}} kimhc // 2010.6.16 // 같은 기능을 하는 함수가 존재하여 함수를 사용함

#ifdef ADD_UPGRADE_WEAPON_PARTICLE
		BOOST_FOREACH( Weapon* pWeapon, m_vecpWeapon )		/// 강화 무기 이펙트 설정
		{
			if( NULL != pWeapon )
			{
				pWeapon->DeleteUpgradeWeaponParticle();		/// 설정되어 있을지도 모르니, 삭제
				pWeapon->InitUpgradeWeaponParticle();		/// 강화 무기 이펙트 초기화
			}
		}
#endif ADD_UPGRADE_WEAPON_PARTICLE

		m_LuaManager.EndTable();
	}

// 
// 	CKTDGParticleSystem::CParticleEventSequence* pSeq_RFoot = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostRFoot );
// 	CKTDGParticleSystem::CParticleEventSequence* pSeq_LFoot = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostLFoot );
// 	CKTDGParticleSystem::CParticleEventSequence* pSeq_RArm = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostRArm );
// 	CKTDGParticleSystem::CParticleEventSequence* pSeq_LArm = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostLArm );
// 
// 	if( pSeq_RFoot != NULL )
// 	{
// 		pSeq_RFoot->SetPosition( GetBonePos( L"Bip01_R_Foot" ) );
// 		pSeq_RFoot->SetEmitRate( 0.f, 0.f );
// 	}
// 	if( pSeq_LFoot != NULL )
// 	{
// 		pSeq_LFoot->SetPosition( GetBonePos( L"Bip01_L_Foot" ) );
// 		pSeq_LFoot->SetEmitRate( 0.f, 0.f );
// 	}
// 	if( pSeq_RArm != NULL )
// 	{
// 		pSeq_RArm->SetPosition( GetBonePos( L"Bip01_R_UpperArm" ) );
// 		pSeq_RArm->SetEmitRate( 0.f, 0.f );
// 	}
// 	if( pSeq_LArm != NULL )
// 	{
// 		pSeq_LArm->SetPosition( GetBonePos( L"Bip01_L_UpperArm" ) );
// 		pSeq_LArm->SetEmitRate( 0.f, 0.f );
// 	}
// 
// 
// 	SetRemainHyperModeTime( 0.0f );


	m_pXSkinAnimFuture->SetPlaySpeed( 1.0f );
	m_pXSkinAnim->SetPlaySpeed( 1.0f );


#ifdef ATTACK_DELAY_GAGE
	//{{AFX
	m_bAddAttackDelayThisState		= false;
	m_fLastAttackPassTime			= 0.0f;
	//}}AFX
#endif ATTACK_DELAY_GAGE

	m_bAddForceDownGageThisState	= false;
	m_fLastDamagePassTime			= 0.0f;
#ifdef BALANCE_PATCH_20110303
	m_fMaxDownForce = -9999.f;
#endif

	for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
	{
		CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];
		pCX2Eqip->ChangeNormalMode();
	}

#ifdef EQUIP_STRIP_TEST
	BOOST_TEST_FOREACH( CX2ItemManager::EquipPositionMap::value_type&, value, m_mapBasicEquip )
	{
		CX2EqipPtr pEquip = value.second;
		if( pEquip != NULL )
		{
			pEquip->ChangeNormalMode();
		}
	}
#endif EQUIP_STRIP_TEST


	SetEnableAttackBox( L"Rfoot", false );
	SetEnableAttackBox( L"Lfoot", false );
	SetEnableAttackBox( L"Lhand2", false );

	SetHyperModeCount( hyperModeCount );
	
	m_bWaitingForRebirthAfterBungee = false;

#ifdef PORTAL_LINEMAP_TEST
	m_bEnterPortal = false;
	m_bLeavePortal = true;
#endif PORTAL_LINEMAP_TEST


	m_bDisableGravity = false;
	ClearEffectiveBlackHoleDamageEffect();

	SetEnableDash( true );
	SetEntangled( false );

	if( m_ExtraDamagePack.m_EnchantShock.m_fTime <= 0.f &&
		m_ExtraDamagePack.m_Frozen.m_fTime <= 0.f )
	{
		g_pX2Game->SetEnableAllKeyProcess( true );
	}

#ifdef SERV_PET_SYSTEM
	if( g_pData != NULL && g_pData->GetPetManager() != NULL )
	{
		if( GetUnit()->GetPetInfo() != NULL )
		{
			KPetInfo *pPetInfo = GetUnit()->GetPetInfo();
			CX2PET::PetInfo petInfo;

			petInfo.m_PetUid = pPetInfo->m_iPetUID;
#ifdef SERV_PETID_DATA_TYPE_CHANGE //2013.07.02
			petInfo.m_PetId = pPetInfo->m_iPetID;
#else //SERV_PETID_DATA_TYPE_CHANGE
			petInfo.m_PetId = pPetInfo->m_cPetID;
#endif //SERV_PETID_DATA_TYPE_CHANGE
			petInfo.m_Evolution_Step = pPetInfo->m_cEvolutionStep;
			petInfo.m_wstrPetName = pPetInfo->m_wstrPetName;		
			petInfo.m_Intimacy = (float)pPetInfo->m_iIntimacy;
			petInfo.m_Satiety = pPetInfo->m_sSatiety;
			petInfo.m_Extroversion = pPetInfo->m_sExtroversion;
			petInfo.m_Emotion = pPetInfo->m_sEmotion;
#ifdef PET_DROP_ITEM_PICKUP
			petInfo.m_bIsDropItemPickup = pPetInfo->m_bAutoLooting;
#endif //PET_DROP_ITEM_PICKUP
			petInfo.m_bSummon = true;
#ifdef SERV_PET_SYSTEM_EX1
			petInfo.m_bAlwaysMaxSatiety = pPetInfo->m_bAlwaysMaxSatiety;
#endif //SERV_PET_SYSTEM_EX1
#ifdef SERV_EVENT_PET_INVENTORY
			petInfo.m_bEventFoodEat		= pPetInfo->m_bEventFoodEat;
			petInfo.m_bIsEventPetID		= pPetInfo->m_bIsEventPetID;
#endif SERV_EVENT_PET_INVENTORY
			g_pData->GetPetManager()->CreateGamePet( GetUnitUID(), petInfo );
		}
		else
		{
			g_pData->GetPetManager()->RemovePet( GetUnitUID() );
		}	

		ClearMPFactor();
	}
#endif

	m_fOxygenGage = MAGIC_OXYGEN_GAGE;	
	
	//{{ kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트
#ifdef	SERV_TOONILAND_CHANNELING_EVENT
	SetShowTooniLandEventEffectSet( true );
#endif	SERV_TOONILAND_CHANNELING_EVENT
	//}} kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트

#ifdef NEW_HENIR_TEST

	EndHenirBuff();

#endif NEW_HENIR_TEST

#ifdef SPECIAL_USE_ITEM
	EndSpecialItemBuff();
#endif

	m_fSummonNpcCoolTime = 0.f;

#ifdef FIX_ENCHANT_FROZEN_TRACE_BUG_BY_MAGICAL_MAKEUP
	 m_bUseChangeWeapon	= false; /// 아이샤의 매지컬 메이크 업이나 청의 3각성을 통한 무기 변경 여부 초기화
#endif FIX_ENCHANT_FROZEN_TRACE_BUG_BY_MAGICAL_MAKEUP

#ifdef SET_WORLD_BUFF_AT_RESURRECTION // 김태환
	 /// 부활시, 서버에서 준 버프를 적용해 준다.
	 if ( NULL != GetUnit() )
	 {
		 const vector<BUFF_FACTOR_ID>& vecWorldBuffFactorID = GetUnit()->GetWorldBuffFactorID();

		 BOOST_FOREACH( BUFF_FACTOR_ID eWorldBuffFactorID, vecWorldBuffFactorID )
		 {
			 SetBuffFactorToGameUnitByBuffFactorID( eWorldBuffFactorID );
		 }
	 }
#endif // SET_WORLD_BUFF_AT_RESURRECTION

#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE //김창한
	 m_bSetCustomRenderParam = false;
#endif //SERV_ELESIS_SECOND_CLASS_CHANGE

#ifdef ADD_PLAY_SOUND //김창한
	 PlaySoundRevive();
#endif //ADD_PLAY_SOUND

#ifdef ADD_RENA_SYSTEM //김창한
	 // 스킬 관련 저장 초기화
	 m_AllDamageRelateSkillData.Init();
#endif //ADD_RENA_SYSTEM
}

#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
/*static*/
void	CX2GUUser::AppendDeviceToDeviceList( CKTDXDeviceDataList& listInOut_, CX2Unit* pX2Unit_ )
{
	if ( pX2Unit_ == NULL )
		return;

	switch( pX2Unit_->GetType() )
	{
	case CX2Unit::UT_NONE:
		break;
	case CX2Unit::UT_ELSWORD:
		CX2GUElsword_SwordMan::AppendDeviceToDeviceList( listInOut_ );
		break;
	case CX2Unit::UT_ARME:
		CX2GUArme_VioletMage::AppendDeviceToDeviceList( listInOut_ );
		break;
	case CX2Unit::UT_LIRE:
		CX2GULire_ElvenRanger::AppendDeviceToDeviceList( listInOut_ );
		break;
	case CX2Unit::UT_RAVEN:
		CX2GURaven::AppendDeviceToDeviceList( listInOut_ );
		break;
	case CX2Unit::UT_EVE:
		CX2GUEve::AppendDeviceToDeviceList( listInOut_ );
		break;
	case CX2Unit::UT_CHUNG:
		CX2GUChung::AppendDeviceToDeviceList( listInOut_ );
		break;
#ifdef ARA_CHARACTER_BASE
	case CX2Unit::UT_ARA:
		CX2GUAra::AppendDeviceToDeviceList( listInOut_ );
		break;
#endif
#ifdef NEW_CHARACTER_EL
	case CX2Unit::UT_ELESIS:
		CX2GUEL::AppendDeviceToDeviceList( listInOut_ );
		break;
#endif // NEW_CHARACTER_EL
#ifdef SERV_9TH_NEW_CHARACTER // 김태환 ( 캐릭터 추가용 )
	case CX2Unit::UT_ADD:
		CX2GUAdd::AppendDeviceToDeviceList( listInOut_ );
		break;
#endif //SERV_9TH_NEW_CHARACTER
	}	
}

#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD


void CX2GUUser::InitDevice()
{
	CX2GameUnit::InitDevice();
}

void CX2GUUser::InitSystem()
{
#ifdef REALTIME_SCRIPT_PATCH
	SetScriptFileName();
#endif //REALTIME_SCRIPT_PATCH
	CX2GameUnit::InitSystem();

	if( m_LuaManager.BeginTable( "INIT_SYSTEM" ) == true )
	{
		LUA_GET_VALUE( m_LuaManager, "UNIT_WIDTH", m_FrameDataFuture.unitCondition.fUnitWidth, 75.f );
		LUA_GET_VALUE( m_LuaManager, "UNIT_HEIGHT", m_FrameDataFuture.unitCondition.fUnitHeight, 150.f );

		m_vOrgUnitSize.x = m_FrameDataFuture.unitCondition.fUnitWidth;
		m_vOrgUnitSize.y = m_FrameDataFuture.unitCondition.fUnitHeight;

		m_FrameDataNow.unitCondition.fUnitWidth = m_FrameDataFuture.unitCondition.fUnitWidth;
		m_FrameDataNow.unitCondition.fUnitHeight = m_FrameDataFuture.unitCondition.fUnitHeight;



		// fix!! 일단 여기에 두고 나중에 테이블을 따로 만들던지 하자
		if( true == m_LuaManager.BeginTable( "DUNGEON_SPEECH" ) )
		{
			int iStringIndex = -1;
			int iValueIndex = 1;
			while( true )
			{
				LUA_GET_VALUE_RETURN( m_LuaManager,	iValueIndex, iStringIndex, STR_ID_EMPTY, break; );
				m_vecDungeonWinSpeech.push_back( GET_STRING( iStringIndex ) );
				iValueIndex++;
			}

			m_LuaManager.EndTable(); // DUNGEON_SPEECH
			iValueIndex++;
		}


		m_FrameDataFuture.syncData.nowState = GUSI_LOADING;

		if ( /*IsMyUnit() && */m_LuaManager.BeginTable( "CHAIN_SYSTEM" ) )
		{
			if ( !m_ComboAndSkillChainSystem.CreateComboAndSkillChain( m_LuaManager ) )
			{
				DISPLAY_ERROR( L"ComboAndSkillChainSystem Parsing Error" );
			}
			m_LuaManager.EndTable();	/// CHAIN_SYSTEM
		}

		m_LuaManager.EndTable();
	}
}

void    CX2GUUser::InitData::AppendToDeviceList( CKTDXDeviceDataList& listInOut_, CX2Unit* pX2Unit_ ) const
{
	m_device.AppendToDeviceList( listInOut_ );
	
#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	CX2GUUser::AppendDeviceToDeviceList( listInOut_, pX2Unit_ );
	CX2GUUser::AppendMotionToDeviceList( listInOut_, pX2Unit_ );
	CX2GUUser::AppendComponentToDeviceList( listInOut_, pX2Unit_ );
	CX2GUUser::AppendEffectToDeviceList( listInOut_, pX2Unit_ );
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD

}//CX2GUUser::InitData::AppendToDeviceList()

void CX2GUUser::InitPosition( bool bUseTeamPos, int startPosIndex )
{

#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
    m_bPositionBackup = false;
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION

//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
    ResetLocalAndRelativePosAndTimers();
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC

	KTDXPROFILE();
	if( g_pX2Game->GetWorld() == NULL )
	{
		//최초 프레임 데이타에 업데이트 한다.
		m_FrameDataFuture.syncData.position				= D3DXVECTOR3(0,0,0);
		m_FrameDataFuture.unitCondition.dirDegree		= D3DXVECTOR3(0,0,0);
		m_FrameDataFuture.unitCondition.landPosition	= D3DXVECTOR3(0,0,0);
		m_FrameDataFuture.syncData.lastTouchLineIndex	= 0;
		m_FrameDataFuture.syncData.bIsRight				= true;
		m_FrameDataFuture.unitCondition.dirDegree		= D3DXVECTOR3(0,0,0);

		m_FrameDataNow.syncData.position				= m_FrameDataFuture.syncData.position;
		m_FrameDataNow.unitCondition.dirDegree			= m_FrameDataFuture.unitCondition.dirDegree;
		m_FrameDataNow.unitCondition.landPosition		= m_FrameDataFuture.unitCondition.landPosition;
		m_FrameDataNow.syncData.lastTouchLineIndex		= m_FrameDataFuture.syncData.lastTouchLineIndex;
		m_FrameDataNow.syncData.bIsRight				= m_FrameDataFuture.syncData.bIsRight;
		m_FrameDataNow.unitCondition.dirDegree			= m_FrameDataFuture.unitCondition.dirDegree;
		return;
	}
	CKTDGLineMap*	pLineMap = g_pX2Game->GetWorld()->GetLineMap();
	
	if( NULL == pLineMap )
		return;

	D3DXVECTOR3		startPos;
	int lineIndex = -1;

	if ( bUseTeamPos == true )
	{
		if ( startPosIndex == -1 )	//직접 어디에서 태어날지 정해주지 않은경우
		{
			if( m_TeamNum == CX2Room::TN_RED )
			{
				startPos								= pLineMap->GetRedTeamStartPosition( m_UnitIndex );
				m_FrameDataFuture.syncData.bIsRight		= pLineMap->GetRedTeamStartRight( m_UnitIndex );
				lineIndex								= pLineMap->GetRedTeamStartLineIndex( m_UnitIndex );
			}
			else if( m_TeamNum == CX2Room::TN_BLUE )
			{
				int index = m_UnitIndex - 4;
				if( index < 0 )
					index = 0;

				startPos								= pLineMap->GetBlueTeamStartPosition( index );
				m_FrameDataFuture.syncData.bIsRight		= pLineMap->GetBlueTeamStartRight( index );
				lineIndex								= pLineMap->GetBlueTeamStartLineIndex( index );
			}
			else
			{
				startPos								= pLineMap->GetStartPosition( m_UnitIndex );
				m_FrameDataFuture.syncData.bIsRight		= pLineMap->GetStartRight( m_UnitIndex );
				lineIndex								= pLineMap->GetStartLineIndex( m_UnitIndex );
			}
		}
		else
		{
			if( m_TeamNum == CX2Room::TN_RED )
			{
				startPos								= pLineMap->GetRedTeamStartPosition( startPosIndex );
				m_FrameDataFuture.syncData.bIsRight		= pLineMap->GetRedTeamStartRight( startPosIndex );
				lineIndex								= pLineMap->GetRedTeamStartLineIndex( startPosIndex );
			}
			else if( m_TeamNum == CX2Room::TN_BLUE )
			{	
				startPos								= pLineMap->GetBlueTeamStartPosition( startPosIndex );
				m_FrameDataFuture.syncData.bIsRight		= pLineMap->GetBlueTeamStartRight( startPosIndex );
				lineIndex								= pLineMap->GetBlueTeamStartLineIndex( startPosIndex );
			}
			else
			{
				startPos								= pLineMap->GetStartPosition( startPosIndex );
				m_FrameDataFuture.syncData.bIsRight		= pLineMap->GetStartRight( startPosIndex );
				lineIndex								= pLineMap->GetStartLineIndex( startPosIndex );
			}
		}
	}
	else
	{
		if ( startPosIndex != -1 )
		{            
			startPos								= pLineMap->GetStartPosition( startPosIndex );
			m_FrameDataFuture.syncData.bIsRight		= pLineMap->GetStartRight( startPosIndex );
			lineIndex								= pLineMap->GetStartLineIndex( startPosIndex );

			const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData(lineIndex);
			if( NULL != pLineData )
			{
				if( pLineData->lineType != CKTDGLineMap::LT_NORMAL || pLineData->bEnable == false )
				{
					// 부활위치 재 설정
					for(int lineInx = 0; lineInx < pLineMap->GetNumLineData(); ++lineInx)
					{
						if(pLineMap->GetLineData(lineInx) == NULL)
							continue;

						if(pLineMap->GetLineData(lineInx)->lineType == CKTDGLineMap::LT_NORMAL && pLineMap->GetLineData(lineInx)->bEnable == true)
						{
							startPos = (pLineMap->GetLineData(lineInx)->startPos + pLineMap->GetLineData(lineInx)->endPos) * 0.5f;
							lineIndex = lineInx;
							break;
						}
					}                
				}
			}
		}
		else
		{
#ifdef  X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
            int index = pLineMap->GetRandomStartPosIndex();
#else   X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
			ASSERT( pLineMap->GetStartPosNum() > 0 );
			int index = 0;
			if( pLineMap->GetStartPosNum() > 0 )
			{
				index = rand() % pLineMap->GetStartPosNum();
			}
#endif  X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX

			startPos								= pLineMap->GetStartPosition( index );
			m_FrameDataFuture.syncData.bIsRight		= pLineMap->GetStartRight( index );
			lineIndex								= pLineMap->GetStartLineIndex( index );


			const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData(lineIndex);
			if( NULL != pLineData )
			{
				if( pLineData->lineType != CKTDGLineMap::LT_NORMAL || pLineData->bEnable == false )
				{
					// 부활위치 재 설정
					for(int lineInx = 0; lineInx < pLineMap->GetNumLineData(); ++lineInx)
					{
						if(pLineMap->GetLineData(lineInx) == NULL)
							continue;

						if(pLineMap->GetLineData(lineInx)->lineType == CKTDGLineMap::LT_NORMAL && pLineMap->GetLineData(lineInx)->bEnable == true)
						{
							startPos = (pLineMap->GetLineData(lineInx)->startPos + pLineMap->GetLineData(lineInx)->endPos) * 0.5f;
							lineIndex = lineInx;
							break;
						}
					}                
				}
			}
		}
	}



	//정확한 라인 보정위치와 라인 인덱스를 구한다	
	D3DXVECTOR3	landPos = startPos;
	if( lineIndex < 0 || lineIndex >= pLineMap->GetNumLineData() )
	{
		pLineMap->GetLandPosition( startPos, LINE_RADIUS, &lineIndex );
		pLineMap->IsOnLineConnect( startPos, &lineIndex, LINE_RADIUS, &landPos );
	}

	const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData( lineIndex );
	startPos = landPos;
	D3DXVECTOR3 dirDegree(1,0,0);
	if( NULL != pLineData )
	{
		dirDegree = pLineData->dirDegree;
	}


	//최초 프레임 데이타에 업데이트 한다.
	m_FrameDataFuture.syncData.position					= startPos;
	m_FrameDataFuture.unitCondition.dirDegree			= dirDegree;
	m_FrameDataFuture.unitCondition.landPosition		= startPos;
	m_FrameDataFuture.syncData.lastTouchLineIndex		= lineIndex;
	if( m_FrameDataFuture.syncData.bIsRight == false )
		m_FrameDataFuture.unitCondition.dirDegree.y		+= 180.0f;

	m_FrameDataNow.syncData.position					= m_FrameDataFuture.syncData.position;
	m_FrameDataNow.unitCondition.dirDegree				= m_FrameDataFuture.unitCondition.dirDegree;
	m_FrameDataNow.unitCondition.landPosition			= m_FrameDataFuture.unitCondition.landPosition;
	m_FrameDataNow.syncData.lastTouchLineIndex			= m_FrameDataFuture.syncData.lastTouchLineIndex;
	m_FrameDataNow.syncData.bIsRight					= m_FrameDataFuture.syncData.bIsRight;

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
    DWORD   dwFrameMoveCount = 0;
    if ( m_ReceiveSyncDataList.empty() == false )
        dwFrameMoveCount = m_ReceiveSyncDataList.back().dwFrameMoveCount;
    else
        dwFrameMoveCount = m_FrameDataNow.syncData.dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	while( m_FrameBufferNum > (int)m_ReceiveSyncDataList.size() )
	{
		m_ReceiveSyncDataList.push_back( m_FrameDataFuture.syncData );
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
        dwFrameMoveCount++;
        m_ReceiveSyncDataList.back().dwFrameMoveCount = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	}

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	m_adwInitFrameMoveCount[0] = dwFrameMoveCount - m_FrameBufferNum + 1;
	m_adwInitFrameMoveCount[1] = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

#ifndef WORLD_TOOL
	CX2PET *pPet = g_pData->GetPetManager()->GetPet( GetUnitUID() );
	if( pPet != NULL )
		pPet->InitPos();
#endif

	m_vecNeverMovePtr.clear();
}


void CX2GUUser::InitPosition( CX2GUUser* pCX2GUUser )
{
#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
    m_bPositionBackup = false;
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION

//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
    ResetLocalAndRelativePosAndTimers();
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC

	if( pCX2GUUser != NULL )
	{
		//최초 프레임 데이타에 업데이트 한다.
		m_FrameDataFuture.syncData.position					= pCX2GUUser->GetFrameData().unitCondition.landPosition;
		m_FrameDataFuture.unitCondition.dirDegree			= pCX2GUUser->GetFrameData().unitCondition.dirDegree;
		m_FrameDataFuture.unitCondition.landPosition		= pCX2GUUser->GetFrameData().unitCondition.landPosition;
		m_FrameDataFuture.syncData.lastTouchLineIndex		= pCX2GUUser->GetFrameData().syncData.lastTouchLineIndex;
		if( m_FrameDataFuture.syncData.bIsRight == false )
			m_FrameDataFuture.unitCondition.dirDegree.y		+= 180.0f;

		m_FrameDataNow.syncData.position					= m_FrameDataFuture.syncData.position;
		m_FrameDataNow.unitCondition.dirDegree				= m_FrameDataFuture.unitCondition.dirDegree;
		m_FrameDataNow.unitCondition.landPosition			= m_FrameDataFuture.unitCondition.landPosition;
		m_FrameDataNow.syncData.lastTouchLineIndex			= m_FrameDataFuture.syncData.lastTouchLineIndex;
		m_FrameDataNow.syncData.bIsRight					= m_FrameDataFuture.syncData.bIsRight;

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
    DWORD   dwFrameMoveCount = 0;
    if ( m_ReceiveSyncDataList.empty() == false )
        dwFrameMoveCount = m_ReceiveSyncDataList.back().dwFrameMoveCount;
    else
        dwFrameMoveCount = m_FrameDataNow.syncData.dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	    while( m_FrameBufferNum > (int)m_ReceiveSyncDataList.size() )
	    {
		    m_ReceiveSyncDataList.push_back( m_FrameDataFuture.syncData );
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
            dwFrameMoveCount++;
            m_ReceiveSyncDataList.back().dwFrameMoveCount = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	    }

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
		m_adwInitFrameMoveCount[0] = dwFrameMoveCount - m_FrameBufferNum + 1;
		m_adwInitFrameMoveCount[1] = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

		m_vecNeverMovePtr.clear();
	}
}

void CX2GUUser::InitPosByDeadPos( CX2GUUser* pCX2GUUser )
{
	if( pCX2GUUser != NULL )
	{
		//최초 프레임 데이타에 업데이트 한다.
		m_FrameDataFuture.syncData.position					= pCX2GUUser->GetFrameDataDead().unitCondition.landPosition;
		m_FrameDataFuture.unitCondition.dirDegree			= pCX2GUUser->GetFrameDataDead().unitCondition.dirDegree;
		m_FrameDataFuture.unitCondition.landPosition		= pCX2GUUser->GetFrameDataDead().unitCondition.landPosition;
		m_FrameDataFuture.syncData.lastTouchLineIndex		= pCX2GUUser->GetFrameDataDead().syncData.lastTouchLineIndex;
		if( m_FrameDataFuture.syncData.bIsRight == false )
			m_FrameDataFuture.unitCondition.dirDegree.y		+= 180.0f;

		m_FrameDataNow.syncData.position					= m_FrameDataFuture.syncData.position;
		m_FrameDataNow.unitCondition.dirDegree				= m_FrameDataFuture.unitCondition.dirDegree;
		m_FrameDataNow.unitCondition.landPosition			= m_FrameDataFuture.unitCondition.landPosition;
		m_FrameDataNow.syncData.lastTouchLineIndex			= m_FrameDataFuture.syncData.lastTouchLineIndex;
		m_FrameDataNow.syncData.bIsRight					= m_FrameDataFuture.syncData.bIsRight;

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
    DWORD   dwFrameMoveCount = 0;
    if ( m_ReceiveSyncDataList.empty() == false )
        dwFrameMoveCount = m_ReceiveSyncDataList.back().dwFrameMoveCount;
    else
        dwFrameMoveCount = m_FrameDataNow.syncData.dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	    while( m_FrameBufferNum > (int)m_ReceiveSyncDataList.size() )
	    {
		    m_ReceiveSyncDataList.push_back( m_FrameDataFuture.syncData );
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
            dwFrameMoveCount++;
            m_ReceiveSyncDataList.back().dwFrameMoveCount = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	    }

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
		m_adwInitFrameMoveCount[0] = dwFrameMoveCount - m_FrameBufferNum + 1;
		m_adwInitFrameMoveCount[1] = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	}
}


void CX2GUUser::InitPosByLineData( int iLineIndex )
{
	if( NULL != g_pX2Game &&
		NULL != g_pX2Game->GetLineMap() )
	{
		const CKTDGLineMap::LineData* pLineData = g_pX2Game->GetLineMap()->GetLineData( iLineIndex );
		if( NULL == pLineData )
			return; // fix!! 에러다~ plinedata should not be null

		D3DXVECTOR3 vLandPos = ( pLineData->startPos + pLineData->endPos ) * 0.5f;
		D3DXVECTOR3 vPos = vLandPos + D3DXVECTOR3( 0, 200, 0 );

		vPos = pLineData->startPos + ( (pLineData->endPos - pLineData->startPos) * 0.5f ); // fix InitPos



		//최초 프레임 데이타에 업데이트 한다.
		m_FrameDataFuture.syncData.position					= vPos;
		m_FrameDataFuture.unitCondition.dirDegree			= pLineData->dirDegree;
		m_FrameDataFuture.unitCondition.landPosition		= vLandPos;
		m_FrameDataFuture.syncData.lastTouchLineIndex		= iLineIndex;

		m_FrameDataNow.syncData.position					= m_FrameDataFuture.syncData.position;
		m_FrameDataNow.unitCondition.dirDegree				= m_FrameDataFuture.unitCondition.dirDegree;
		m_FrameDataNow.unitCondition.landPosition			= m_FrameDataFuture.unitCondition.landPosition;
		m_FrameDataNow.syncData.lastTouchLineIndex			= m_FrameDataFuture.syncData.lastTouchLineIndex;

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
    DWORD   dwFrameMoveCount = 0;
    if ( m_ReceiveSyncDataList.empty() == false )
        dwFrameMoveCount = m_ReceiveSyncDataList.back().dwFrameMoveCount;
    else
        dwFrameMoveCount = m_FrameDataNow.syncData.dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	    while( m_FrameBufferNum > (int)m_ReceiveSyncDataList.size() )
	    {
		    m_ReceiveSyncDataList.push_back( m_FrameDataFuture.syncData );
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
            dwFrameMoveCount++;
            m_ReceiveSyncDataList.back().dwFrameMoveCount = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	    }

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
		m_adwInitFrameMoveCount[0] = dwFrameMoveCount - m_FrameBufferNum + 1;
		m_adwInitFrameMoveCount[1] = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	}
}

void CX2GUUser::InitPosByBattleFieldPosition()
{
	if( NULL != g_pX2Game && NULL != g_pX2Game->GetLineMap() )
	{
		CX2BattleFieldManager& battleFieldManager = g_pData->GetBattleFieldManager();

		// StartPosition 이면 수행 안함
		if ( true == battleFieldManager.GetNowBattleFieldPositionInfoStartPosition() )
		{
			ASSERT( !"GetNowBattleFieldPositionInfo is wrong" );
			StateLog( "GetNowBattleFieldPositionInfo is wrong" );
			return;
		}
		else
		{
			const CKTDGLineMap::LineData* pLineData 
				= g_pX2Game->GetLineMap()->GetLineData( battleFieldManager.GetBattleFieldPositionIndexWhereIShouldBe() );

			if ( NULL != pLineData )
			{
				const float fPositionValue = battleFieldManager.GetBattleFieldPositionValue() * 0.01f;
				const D3DXVECTOR3 vDistanceVector3( pLineData->endPos - pLineData->startPos );

				m_FrameDataFuture.syncData.position					= pLineData->startPos + ( vDistanceVector3 * fPositionValue );
				m_FrameDataFuture.unitCondition.dirDegree			= pLineData->dirDegree;
				m_FrameDataFuture.unitCondition.landPosition		= m_FrameDataFuture.syncData.position;
				m_FrameDataFuture.syncData.lastTouchLineIndex		=  static_cast<UCHAR>( battleFieldManager.GetBattleFieldPositionIndexWhereIShouldBe() );
				m_FrameDataFuture.syncData.bIsRight					= true;

				m_FrameDataNow.syncData.position					= m_FrameDataFuture.syncData.position;
				m_FrameDataNow.unitCondition.dirDegree				= m_FrameDataFuture.unitCondition.dirDegree;
				m_FrameDataNow.unitCondition.landPosition			= m_FrameDataFuture.unitCondition.landPosition;
				m_FrameDataNow.syncData.lastTouchLineIndex			= m_FrameDataFuture.syncData.lastTouchLineIndex;
				m_FrameDataNow.syncData.bIsRight					= m_FrameDataFuture.syncData.bIsRight;

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
                DWORD   dwFrameMoveCount = 0;
                if ( m_ReceiveSyncDataList.empty() == false )
                    dwFrameMoveCount = m_ReceiveSyncDataList.back().dwFrameMoveCount;
                else
                    dwFrameMoveCount = m_FrameDataNow.syncData.dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	            while( m_FrameBufferNum > (int)m_ReceiveSyncDataList.size() )
	            {
		            m_ReceiveSyncDataList.push_back( m_FrameDataFuture.syncData );
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
                    dwFrameMoveCount++;
                    m_ReceiveSyncDataList.back().dwFrameMoveCount = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	            }

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
				m_adwInitFrameMoveCount[0] = dwFrameMoveCount - m_FrameBufferNum + 1;
				m_adwInitFrameMoveCount[1] = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

				CX2PET *pPet = g_pData->GetPetManager()->GetPet( GetUnitUID() );
				if( pPet != NULL )
					pPet->InitPos();
			}
			else
			{
				ASSERT( !"GetNowBattleFieldPostionIndex is wrong" );
				StateLog( "GetNowBattleFieldPostionIndex is wrong" );
				return;
			}
		}
	}
}

//{{ kimhc // 2010.8.10 // 특정 몬스터의 위치 값을 부활 위치로 사용
bool CX2GUUser::InitPosByMonsterPos()
{
	if( NULL != g_pX2Game && CX2Game::GT_DUNGEON == g_pX2Game->GetGameType() )
	{
		CX2DungeonGame*		pDungeonGame	= static_cast<CX2DungeonGame*>(g_pX2Game);
		if( NULL != pDungeonGame &&
			NULL != pDungeonGame->GetDungeon() &&
			NULL != pDungeonGame->GetDungeon()->GetNowStage() &&
			NULL != pDungeonGame->GetDungeon()->GetNowStage()->GetNowSubStage() )
		{
			CX2DungeonSubStage* pSubStage		= pDungeonGame->GetDungeon()->GetNowStage()->GetNowSubStage();

			// 부활 위치를 정하는데 참고할 몬스터의 키코드를 가져온 후 해당 몬스터를 얻어옴
			int iKeyCode = pSubStage->GetSubStageData()->GetKeyCodeOfMonsterForRebirth();
			CX2GUNPC* pKeyCodeNpc = pDungeonGame->GetNPCUnitByKeyCode( iKeyCode );

			if ( pKeyCodeNpc == NULL )
				return false;


			D3DXVECTOR3 vPosForRebirth	= pKeyCodeNpc->GetPos();
			D3DXVECTOR3	vSpacing		= pKeyCodeNpc->GetDirVector() * ( pKeyCodeNpc->GetUnitWidth( false ) / 2 );

			vPosForRebirth -= vSpacing;

			CKTDGLineMap* pLineMap = g_pX2Game->GetLineMap();
			int iLineIndex = pLineMap->GetNearestLine( vPosForRebirth );

			const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData( iLineIndex );

			if ( pLineData == NULL )
				return false;

			D3DXVECTOR3 vLandPos = ( pLineData->startPos + pLineData->endPos ) * 0.5f;

			if ( vLandPos.x > vPosForRebirth.x )
				vLandPos = pLineData->startPos;

			D3DXVECTOR3 vPos = vLandPos + D3DXVECTOR3( 0, LINE_RADIUS, 0 );

			//최초 프레임 데이타에 업데이트 한다.

			if ( IsMyUnit() )
			{
				m_FrameDataFuture.syncData.position					= vPos;
				m_FrameDataFuture.unitCondition.dirDegree			= pLineData->dirDegree;
				m_FrameDataFuture.unitCondition.landPosition		= vLandPos;
				m_FrameDataFuture.syncData.lastTouchLineIndex		= iLineIndex;
			}

			m_FrameDataNow.syncData.position					= m_FrameDataFuture.syncData.position;
			m_FrameDataNow.unitCondition.dirDegree				= m_FrameDataFuture.unitCondition.dirDegree;
			m_FrameDataNow.unitCondition.landPosition			= m_FrameDataFuture.unitCondition.landPosition;
			m_FrameDataNow.syncData.lastTouchLineIndex			= m_FrameDataFuture.syncData.lastTouchLineIndex;

			BOOST_FOREACH( SyncData& syncData, m_ReceiveSyncDataList )
			{
				syncData.position = vPos;
				syncData.lastTouchLineIndex = iLineIndex;
			}
			return true;
		}
		else
			return false;
	}
	
	return false;
}
//}} kimhc // 2010.8.10 // 특정 몬스터의 위치 값을 부활 위치로 사용

void CX2GUUser::InitStat()
{	
	CX2GameUnit::InitStat();

	AccessStat().InitStat();

	if( GetUnit()->GetUnitData().m_GameStat.m_fBaseHP > 0 )
	{
		//AccessStat().AddStat( GetUnit()->GetUnitData().m_GameStat );
		SetGameStat( GetUnit()->GetUnitData().m_GameStat );
	}
	else
	{
		SetGameStat( GetUnit()->GetUnitData().m_Stat );
	}

}


void CX2GUUser::InitSocketData()
{
	if( NULL == GetUnit() )
	{
		return; 
	}

	{
		m_SocketData.m_SocketExtraDamage.m_DamagePerSec = GetStat().GetStat().m_fAtkMagic;	// 혹시 아래의 코드에서 초기화가 안되는 경우를 대비해서
	}

	for( int i = 0; i < (int)GetUnit()->GetUnitData().m_NowEqipItemUIDList.size(); i++ )
	{
		UidType eqipUID = GetUnit()->GetUnitData().m_NowEqipItemUIDList[i];
		CX2Item* pItem = GetUnit()->GetInventory().GetItem( eqipUID );

		if( NULL == pItem ||  
			NULL == pItem->GetItemTemplet() 
            )
		{
			continue;
		}

		//{{ kimhc // 실시간 엘소드 중 실시간 내구도 감소
#ifdef REAL_TIME_ELSWORD
		if ( pItem->GetItemData().m_PeriodType == CX2Item::PT_ENDURANCE && pItem->GetItemData().m_Endurance <= 0 )
			continue;
#endif REAL_TIME_ELSWORD
		//}} kimhc // 실시간 엘소드 중 실시간 내구도 감소

		const float fAtkMagic = pItem->GetStat().m_fAtkMagic;

		//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업

#ifdef  X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
	#ifdef SERV_NEW_ITEM_SYSTEM_2013_05 // 오현빈
			std::vector<int> vecSocketOptions;// 일반 소켓과 랜덤 옵션을 같이 닮을 컨테이너
			// 랜덤 소켓 옵션 담기
			if( NULL != pItem )
			{
				vecSocketOptions.assign( pItem->GetItemData().m_vecRandomSocket.begin(), 
					pItem->GetItemData().m_vecRandomSocket.end() );
			}
			// 일반 소켓 옵션 담기
			std::vector<int> vecNormalSocketOption;
			pItem->GetItemTemplet()->GetSocketOptions( vecNormalSocketOption );
#ifdef SERV_EVENT_VALENTINE_RING_IS_DUNGEON
			//여기서 수치가 계산 되는지 확인해 보장 
			std::vector<int>::iterator ivecIter;
			for(ivecIter = vecNormalSocketOption.begin(); ivecIter != vecNormalSocketOption.end();)
			{
				if( (g_pMain!= NULL && g_pMain->GetNowStateID() == CX2Main::XS_VILLAGE_MAP) || ( g_pX2Game != NULL && CX2Game::GT_DUNGEON != g_pX2Game->GetGameType() ) 
					|| ( g_pData != NULL && g_pData->GetDungeonRoom() != NULL && g_pData->GetDungeonRoom()->GetDungeonID() != SEnum::DI_EVENT_VALENTINE_DUNGEON_INT ))
				{
					if( *ivecIter == 1090005 || *ivecIter == 1090006 || *ivecIter == 1090007 || *ivecIter == 1090008
						|| *ivecIter == 1090009 || *ivecIter == 1090010 || *ivecIter == 1090011 || *ivecIter == 1090012 )
					{
						ivecIter = vecNormalSocketOption.erase(ivecIter++);
					}
					else
					{
						++ivecIter;
					}
				}
				else
				{
					++ivecIter;
				}
			}		
#endif SERV_EVENT_VALENTINE_RING_IS_DUNGEON
			vecSocketOptions.insert( vecSocketOptions.end(), vecNormalSocketOption.begin(), vecNormalSocketOption.end() );
	#else
			std::vector<int>    vecSocketOptions;
			pItem->GetItemTemplet()->GetSocketOptions( vecSocketOptions );
	#endif // SERV_NEW_ITEM_SYSTEM_2013_05
#else   //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
        const std::vector<int>&    vecSocketOptions = pItem->GetItemTemplet()->m_vecSocketOption;
#endif  //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING


		// 아이템에 요구 레벨이 있으면 요구 레벨을 소켓의 레벨로 사용
		int iSocketLevel = 0;
		if ( 0 < pItem->GetItemTemplet()->GetUseLevel() )
			iSocketLevel = GetUnitLevel();			
		// 없으면 유저의 레벨을 소켓의 레벨로 사용
		else
			iSocketLevel = GetUnit()->GetUnitData().m_Level;

		// 아이템 고유의 소켓 옵션 설정

		SumSocketOption( vecSocketOptions, fAtkMagic, iSocketLevel );

		// 아이템에 유저가 박은 소켓에 의한 옵션 설정
		SumSocketOption( pItem->GetItemData().m_SocketOption, fAtkMagic, iSocketLevel );
		//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업
	}

#ifdef PET_AURA_SKILL
	// 펫 기운스킬 소켓효과 (모든 펫기운스킬은 소켓조합으로 구성된다.)
	switch ( g_pMain->GetNowStateID() )
	{
	case CX2Main::XS_DUNGEON_GAME:
	case CX2Main::XS_TRAINING_GAME:
	case CX2Main::XS_BATTLE_FIELD:
		{
	#ifdef PET_DROP_ITEM_PICKUP
			if( NULL != g_pX2Game && NULL != g_pX2Game->GetDropItemManager() && NULL != g_pX2Game->GetMyUnit())
			{	//적용시키기 전 초기화
				if( GetUnit()->GetUID() == g_pX2Game->GetMyUnit()->GetUnitUID() )
				{				
					g_pX2Game->GetDropItemManager()->SetSummonItemPickupPet( false );
				}
			}
	#endif //PET_DROP_ITEM_PICKUP

			if( GetUnit() != NULL )
			{
				KPetInfo *kPetInfo = GetUnit()->GetPetInfo();
				if( g_pData != NULL && g_pData->GetPetManager() != NULL && kPetInfo != NULL )
				{	
	#ifdef PET_DROP_ITEM_PICKUP
					//펫의 아이템 줍기 스킬이 활성화 되어 있다면 아이템 줍기 설정
					if( NULL != g_pX2Game && NULL != g_pX2Game->GetDropItemManager() && NULL != g_pX2Game->GetMyUnit() )
					{	//자기 유닛에만 적용
						if( GetUnit()->GetUID() == g_pX2Game->GetMyUnit()->GetUnitUID() )
						{								
							g_pX2Game->GetDropItemManager()->SetSummonItemPickupPet( kPetInfo->m_bAutoLooting );
						}
					}
	#endif //PET_DROP_ITEM_PICKUP

#ifdef SERV_PETID_DATA_TYPE_CHANGE //2013.07.02
					CX2PetManager::PetTemplet *pPetTemplet = g_pData->GetPetManager()->GetPetTemplet( (CX2PetManager::PET_UNIT_ID)kPetInfo->m_iPetID );
#else //SERV_PETID_DATA_TYPE_CHANGE
					CX2PetManager::PetTemplet *pPetTemplet = g_pData->GetPetManager()->GetPetTemplet( (CX2PetManager::PET_UNIT_ID)kPetInfo->m_cPetID );
#endif //SERV_PETID_DATA_TYPE_CHANGE
					if( pPetTemplet != NULL )
					{ 
						// 포만도가 40% 이상일 경우만 기운스킬 적용되도록 한다.
						if( (float)kPetInfo->m_sSatiety / CX2PetManager::MAX_OF_SATIETY >= CX2PetManager::SATIETY_RATIO_TO_BE_ABLE_TO_APPLY_AURA )
						{
							int iStep = 0;
#ifdef DEFENCE_CODE_FOR_CRASH
							if( kPetInfo->m_cEvolutionStep < pPetTemplet->m_vecPetStatus.size() )
#endif DEFENCE_CODE_FOR_CRASH
							iStep = pPetTemplet->m_vecPetStatus[kPetInfo->m_cEvolutionStep];
							if( iStep > 0 )
							{			
								for(int i=0; i < iStep; ++i)
								{
									//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업
									// 펫 기운스킬은 소켓 레벨을 유저의 레벨로 전달
									SumSocketOption( pPetTemplet->m_vecAuraSkillOption[ i ], 1.f, GetUnitLevel() );
									//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업							 
								}	// for
							}	// if
						}	// if
					}	// if
				}	// if
			}	// if
		} break;

	default:
		break;
	}	// switch
	
#endif

#ifdef RIDING_SYSTEM
	/// 라이딩 펫을 탔을 경우에 탑승 소켓 옵션 적용
	if ( GetRidingOn() && m_ptrRidingPet )
	{
		CX2RidingPetManager::RidingPetTemplet* pRidingPetTemplet =
			CX2RidingPetManager::GetInstance()->GetRidingPetTemplet( static_cast<CX2RidingPetManager::RIDING_PET_UNIT_ID>( m_ptrRidingPet->GetInfo().m_Id ) );
		if ( NULL != pRidingPetTemplet )
			SumSocketOption( pRidingPetTemplet->m_vecSocketOption, 1.0f, GetUnitLevel() );
	}
#endif // RIDING_SYSTEM


#ifndef WORLD_TOOL	// 090519 태완 임시수정코드
//#ifdef TITLE_SYSTEM   
	if( g_pData->GetTitleManager()->GetTitleInfo(GetUnit()->GetTitleId()) != NULL )
	{
		m_vecTitleOptions = g_pData->GetTitleManager()->GetTitleInfo( GetUnit()->GetTitleId() )->m_vecSocketOption;

		//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업
		// 칭호는 소켓 레벨을 유저의 레벨로 전달
		SumSocketOption( m_vecTitleOptions, 1.f, GetUnitLevel() );
		//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업	
	}
//#endif TITLE_SYSTEM
#endif WORLD_TOOL

	// 세트 아이템 옵션에 의한 소켓효과
	InitSetItemOptions();


	m_DamageData.m_SocketExtraDamage	= m_SocketData.m_SocketExtraDamage;
	m_DamageData.m_MultipleExtraDamage	= m_SocketData.m_MultipleSocketExtraDamage;

#ifdef BUFF_TEMPLET_SYSTEM	
	// 버프에 의한 소켓효과
	vector<int> vecBuffSocketOptions;
	g_pData->GetPremiumBuffManager()->GetSocketOptions( GetUnit()->GetUnitData().GetPremiumBuffList(), vecBuffSocketOptions );

	if ( !vecBuffSocketOptions.empty() )
		SumSocketOption( vecBuffSocketOptions, 1.f, GetUnitLevel() );  
#endif BUFF_TEMPLET_SYSTEM

	// 최대치 제한
	m_SocketData.LimitMaximum();

	InitAdditionalStatOptionValue();

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환
	/// 소켓으로 인한 추가 스킬 증가 효과 설정
	if ( NULL != GetUnit() )
		GetUnit()->ResetIncreaseSkillLevelBySocket();
#endif // UPGRADE_SKILL_SYSTEM_2013
}



//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업
void CX2GUUser::SumSocketOption( const vector<int>& vecSocketOption, const float fAtkMagic, const int iSocketLevel_ )
//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업
{
#ifdef SERV_GROW_UP_SOCKET
	// 성장 소켓이면, 성장 정도에 따라서 소켓 그룹을 백터에 집어 넣자.
	vector<int> vecTempSocketOption;
	g_pData->GetSocketItem()->GetGrowUpSocketData( vecSocketOption, vecTempSocketOption );
	for each( int socketOptionID in vecTempSocketOption )
#else //SERV_GROW_UP_SOCKET
	for( UINT j=0; j<vecSocketOption.size(); j++ )
#endif //SERV_GROW_UP_SOCKET
	{
#ifdef SERV_GROW_UP_SOCKET
#else //SERV_GROW_UP_SOCKET
		int socketOptionID = vecSocketOption[j];
#endif //SERV_GROW_UP_SOCKET
		const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( socketOptionID );

		if( NULL == pSocketData )
			continue;
        const CX2SocketItem::SocketData& kSocketData = *pSocketData;


		if ( !CanApplySocketDataByGameType( kSocketData ) )
			continue;


#ifdef PET_AURA_SKILL
		AddEnchantAttack( kSocketData );
#endif
		AddEnchantResist( kSocketData );

		//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업

#ifdef SERV_9TH_NEW_CHARACTER // 김태환
		if ( NULL != g_pData &&
			 NULL != g_pData->GetMyUser() &&
			 NULL != g_pData->GetMyUser()->GetSelectUnit()  )
		{
			CX2Unit::UNIT_TYPE eUnitType = g_pData->GetMyUser()->GetSelectUnit()->GetType();

			m_SocketData.ConvertAndAdd( kSocketData, iSocketLevel_, eUnitType );
		}
#else // SERV_9TH_NEW_CHARACTER
		m_SocketData.ConvertAndAdd( kSocketData, iSocketLevel_ );
#endif // SERV_9TH_NEW_CHARACTER
		
		//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업
		
		if( false == kSocketData.m_vecSkillLevelUpID.empty() )
		{
			m_SocketData.m_vecSkillLevelUpID.insert( m_SocketData.m_vecSkillLevelUpID.end(), kSocketData.m_vecSkillLevelUpID.begin(), kSocketData.m_vecSkillLevelUpID.end() );
		}
#ifdef SERV_NEW_ITEM_SYSTEM_2013_05 // 스킬 레벨
		if( false == kSocketData.m_vecSkillLevelUpGroupID.empty() &&
			NULL != g_pData->GetSocketItem() )
		{
			BOOST_FOREACH( int iGroupID, kSocketData.m_vecSkillLevelUpGroupID )
			{
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 오현빈
				vector<SkillLevelUpIDAndNum> vecSkillLevelUPIDAndNumList;
				g_pData->GetSocketItem()->GetSkillIDByUnicClassAndGropID( vecSkillLevelUPIDAndNumList, GetUnitClass(), iGroupID );

				// 그룹 ID에 해당하는 모든 스킬 리스트 얻기.
				BOOST_FOREACH( const SkillLevelUpIDAndNum& SkillLevelUPIDAndNumList, vecSkillLevelUPIDAndNumList )
				{
					m_SocketData.m_vecSkillLevelUpID.push_back( SkillLevelUPIDAndNumList );
				}
#else
				CX2SkillTree::SKILL_ID eSkillID = 
					g_pData->GetSocketItem()->GetSkillIDByUnicClassAndGropID( GetUnitClass(), iGroupID );

				if( CX2SkillTree::SI_NONE != eSkillID )
				{
					m_SocketData.m_vecSkillLevelUpID.push_back( eSkillID );
				}
#endif // UPGRADE_SKILL_SYSTEM_2013
			}
		}
#endif // SERV_NEW_ITEM_SYSTEM_2013_05

//{{ kimhc // 2010.4.1 // 비밀던전 작업(셋트아이템효과)
#ifdef SERV_SECRET_HELL
		if ( InitSocketEffectEx( kSocketData ) )
			continue;
#endif SERV_SECRET_HELL
//}} kimhc // 2010.4.1 // 비밀던전 작업(셋트아이템효과)


		/// 예전 버전의 강타류 공격 설정 구문 ---------------------------------------------------------------------------------------------------------------------
		if( CX2DamageManager::EDT_NONE != kSocketData.m_SocketExtraDamage.m_ExtraDamageType )
		{
			m_SocketData.m_SocketExtraDamage.Copy( kSocketData.m_SocketExtraDamage );


			// 패션템에 EDT_FIRE, EDT_POISON 소켓인 경우에 각각 unit stat의 magicAtk
			if( 0.f == fAtkMagic ) // note!! 패션템인 경우에 무기 공격력이 0이다
			{
				switch( kSocketData.m_SocketExtraDamage.m_ExtraDamageType )
				{
				case CX2DamageManager::EDT_FIRE:
					{
						m_SocketData.m_SocketExtraDamage.m_DamagePerSec = GetStat().GetStat().m_fAtkMagic * kSocketData.m_SocketExtraDamage.m_DamagePerSec;
					} break;

				case CX2DamageManager::EDT_POISON:
					{
						m_SocketData.m_SocketExtraDamage.m_DamagePerSec = GetStat().GetStat().m_fAtkMagic * kSocketData.m_SocketExtraDamage.m_DamagePerSec;
					} break;

				default:
					{
						ASSERT( !"unexpected" );
						m_SocketData.m_SocketExtraDamage.m_DamagePerSec = GetStat().GetStat().m_fAtkMagic * kSocketData.m_SocketExtraDamage.m_DamagePerSec;
					} break;
				}
			}
			else
			{
				m_SocketData.m_SocketExtraDamage.m_DamagePerSec = fAtkMagic * kSocketData.m_SocketExtraDamage.m_DamagePerSec;
			}
		}

		if( false == kSocketData.m_MultipleSocketExtraDamage.empty() )
		{
			m_SocketData.m_MultipleSocketExtraDamage.insert( m_SocketData.m_MultipleSocketExtraDamage.begin(), 
				kSocketData.m_MultipleSocketExtraDamage.begin(), kSocketData.m_MultipleSocketExtraDamage.end() );
		}
		/// -----------------------------------------------------------------------------------------------------------------------------------------------------



		if ( NULL != kSocketData.m_ptrBuffFactor )
			CreateAndInsertSkillAndSocketBuffFactorToList( kSocketData.m_ptrBuffFactor );
		
		if ( kSocketData.m_fDamageUpPerAtSpecificMonster > 0 )
		{	
			for( set<int>::const_iterator sit = kSocketData.m_setMonsterIDForDamageUp.begin(); sit != kSocketData.m_setMonsterIDForDamageUp.end(); sit++ )
			{
				map<int,float>::iterator mit = m_mapNpcIdNDamageUpPercent.find( *sit );
				if ( mit != m_mapNpcIdNDamageUpPercent.end() )
				{
					mit->second += kSocketData.m_fDamageUpPerAtSpecificMonster;
				}
				else
				{
					m_mapNpcIdNDamageUpPercent.insert( std::make_pair( *sit, kSocketData.m_fDamageUpPerAtSpecificMonster ) );
				}
			}
		}


		if ( kSocketData.m_fEvadePercentByMonsterAttack > 0 )
		{
			for( set<int>::const_iterator sit = kSocketData.m_setMonsterIDForEvade.begin(); sit != kSocketData.m_setMonsterIDForEvade.end(); sit++ )
			{
				map<int,float>::iterator mit = m_mapNpcIDNDEvadeUpPercent.find( *sit );
				if ( mit != m_mapNpcIDNDEvadeUpPercent.end() )
				{
					mit->second += kSocketData.m_fEvadePercentByMonsterAttack;
				}
				else
				{
					m_mapNpcIDNDEvadeUpPercent.insert( std::make_pair( *sit, kSocketData.m_fEvadePercentByMonsterAttack ) );
				}
			}
		}	


		if ( kSocketData.m_ImmuneExtraDamageType != CX2DamageManager::EDT_NONE )
		{
			AddExtraDamageImmuneData( kSocketData.m_ImmuneExtraDamageType, kSocketData.m_fPercentImmuneExtraDamage );
		}

		if( kSocketData.m_iSummonNpcId > 0 && kSocketData.m_fSummonNpcRate > 0.f )
		{
			SummonNpcSocket tSummonNpc = {CX2UnitManager::NUI_NONE, 0.f, 20.f};
			tSummonNpc.m_iNpcId = (CX2UnitManager::NPC_UNIT_ID)kSocketData.m_iSummonNpcId;
			tSummonNpc.m_fSummonRate = kSocketData.m_fSummonNpcRate;
			tSummonNpc.m_fSummonNpcCoolTime = kSocketData.m_fSummonNpcCoolTime;

			m_vecSummonNpcSocket.push_back(tSummonNpc);
		}

#ifdef HAMEL_SECRET_DUNGEON // 김태환
		/// 소켓으로 인한 각성시 특정 효과를 적용하는 기능 추가
		if ( CX2SocketItem::HMET_NONE != kSocketData.m_eHyperModeEffectiveType )
		{	
			/// 사용 가능 지역
			CX2SocketItem::POSSIBLE_USE_PLACE bPossibleUsePlace = CX2SocketItem::PUP_ALL;

			/// 던전전용이랑 대전전용이 각각 블리언 값으로 구분 되어 있어서, 우선순위 선정이 어렵다...
			/// 그냥 던전전용부터 검사하자.
			if ( true == kSocketData.m_bDungeonOnly )
				bPossibleUsePlace = CX2SocketItem::PUP_DUNGEON_ONLY;
			else if ( true == kSocketData.m_bDungeonOnly )
				bPossibleUsePlace = CX2SocketItem::PUP_PVP_ONLY;

			/// 각성시 사용되는 버프 정보 생성
			CX2SocketItem::InfoByUseHyperMode sInfoByUseHyperMode;
			sInfoByUseHyperMode.m_ePossibleUsePlace			= bPossibleUsePlace;						/// 사용 위치
			sInfoByUseHyperMode.m_eHyperModeEffectiveType	= kSocketData.m_eHyperModeEffectiveType;	/// 사용 타입
			sInfoByUseHyperMode.m_fEffectiveValue			= kSocketData.m_fEffectiveValue;			/// 적용 값
#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
			sInfoByUseHyperMode.m_fCoolTime					= kSocketData.m_fIntervalTime;				/// 쿨타임
#endif //ADJUST_SECRET_ITEM_OPTION

			if ( NULL != kSocketData.m_ptrBuffFactorCustomUse )				/// 버프를 사용한다면, 버프 정보 저장
				sInfoByUseHyperMode.m_pBuffFactorPtr = kSocketData.m_ptrBuffFactorCustomUse;

			/// 각성시 사용되는 버프 정보 저장
			m_SocketData.m_vecInfoByUseHyperMode.push_back( sInfoByUseHyperMode );
		}
#endif // HAMEL_SECRET_DUNGEON
	}
}



void CX2GUUser::InitSetItemOptions()
{
	//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업
	m_vecSetItemOptions.resize(0);

	// first: 세트ID, second: 세트를 이루는 장비의 갯수
	map<int,int> mapSetIDNParts;
	GetUnit()->GetSetIDNPartsNum( mapSetIDNParts );
	
	if ( false == mapSetIDNParts.empty() )
	{
		map< int, int >::const_iterator mItr = mapSetIDNParts.begin();
		vector<int> vecOptions;

		while ( mItr != mapSetIDNParts.end() )
		{	
			// SetID 별로 Option들과 SetItem의 최대 적용 레벨을 얻어옴
			const int iMaxLevel = g_pData->GetItemManager()->GetSetItemOptions( mItr->first, mItr->second, vecOptions );

			// Option이 있는 경우
			if ( false == vecOptions.empty() )
			{
				// SetItem에 요구 레벨이 있으면 요구레벨중 최대값을 소켓의 레벨로 사용
				if ( 0 < iMaxLevel )
					SumSocketOption( vecOptions, 1.f, iMaxLevel );
				// 없으면 유저의 레벨을 소켓의 레벨로 사용
				else
					SumSocketOption( vecOptions, 1.f, GetUnit()->GetUnitData().m_Level );

				// 옵션들을 GUUser가 가지고 있는 m_vecSetItemOptions에 넣어줌
				m_vecSetItemOptions.insert( m_vecSetItemOptions.end(), vecOptions.begin(), vecOptions.end() );
				vecOptions.resize(0);
			}
			++mItr;
		}		
	}
	//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업
}

//{{ robobeg : 2012-11-16
/*static*/
CX2DamageManager::EXTRA_DAMAGE_TYPE	CX2GUUser::CalcWeaponEnchantExtraDamageType( CX2Unit* pX2Unit_ )
{
	if ( pX2Unit_ != NULL )
	{
		CX2Item* pItem = pX2Unit_->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_WEAPON_HAND, false );
		if( NULL != pItem &&	
			// 내구도 없는 무기관련 예외처리
			//pItem->GetItemData().m_Endurance > 0 
			( (	pItem->GetItemData().m_PeriodType == CX2Item::PT_ENDURANCE && pItem->GetItemData().m_Endurance > 0) || 
				pItem->GetItemData().m_PeriodType == CX2Item::PT_INFINITY ) )
		{
			return	g_pData->GetEnchantItem()->GetExtraDamageType( pItem->GetItemData().m_EnchantedAttribute );
		}
	}//if

	return	CX2DamageManager::EDT_NONE;
}
//}} robobeg : 2012-11-16


void CX2GUUser::CalcWeaponEnchantExtraDamageType()
{
	// 무기 인챈트 속성
	m_eWeaponEnchantExtraDamageType = CalcWeaponEnchantExtraDamageType( GetUnit() );

}

#ifdef ADD_UPGRADE_WEAPON_PARTICLE

int CX2GUUser::CalcWeaponEnchantLevel( CX2Unit* pX2Unit_ )		/// 현제 무기의 강화 레벨 반환
{
	if ( pX2Unit_ != NULL )
	{
		CX2Item* pItem = pX2Unit_->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_WEAPON_HAND, false );
		if( NULL != pItem &&
			( (	pItem->GetItemData().m_PeriodType == CX2Item::PT_ENDURANCE && pItem->GetItemData().m_Endurance > 0) || 
			pItem->GetItemData().m_PeriodType == CX2Item::PT_INFINITY ) )
		{
			return pItem->GetItemData().m_EnchantLevel;
		}
	}//if

	return	0;
}

#endif ADD_UPGRADE_WEAPON_PARTICLE

void CX2GUUser::InitEnchantData()
{
	if( NULL == GetUnit() )
	{
		return; 
	}

	// 무기 인챈트 속성
	CalcWeaponEnchantExtraDamageType();


	// 방어구 인챈트 속성
	// 현재는 아래의 4개의 장착위치에 해당하는 아이템만 속성저항이 있음
	//EP_DEFENCE_BODY,		//상의
	//EP_DEFENCE_LEG,		//하의
	//EP_DEFENCE_HAND,		//장갑
	//EP_DEFENCE_FOOT,		//신발
	for ( int i = CX2Unit::EP_DEFENCE_BODY; i <= CX2Unit::EP_DEFENCE_FOOT; i++ )
	{
		CX2Item* pItem = GetUnit()->GetInventory().GetEquippingItemByEquipPos( (CX2Unit::EQIP_POSITION)i, false );
		if ( pItem != NULL )
		{

			//{{ kimhc // 실시간 엘소드 중 실시간 내구도 감소
#ifdef REAL_TIME_ELSWORD
			if ( pItem->GetItemData().m_PeriodType == CX2Item::PT_ENDURANCE && pItem->GetItemData().m_Endurance <= 0 )
				continue;
#endif REAL_TIME_ELSWORD
			//}} kimhc // 실시간 엘소드 중 실시간 내구도 감소


			CX2DamageManager::EXTRA_DAMAGE_TYPE extraDamageType = g_pData->GetEnchantItem()->GetExtraDamageType( pItem->GetItemData().m_EnchantedAttribute );
			CX2DamageManager::EXTRA_DAMAGE_TYPE eDecomposedEDT[2] = { CX2DamageManager::EDT_NONE, };
			CX2EnchantItem::DecomposeEnchantExtraDamage( extraDamageType, eDecomposedEDT[0], eDecomposedEDT[1] );


			map< CX2EnchantItem::ENCHANT_TYPE, int >::iterator mit;
			for( int i=0; i<2; i++ )
			{
				if( eDecomposedEDT[i] == CX2DamageManager::EDT_NONE )
					continue;

				CX2EnchantItem::ENCHANT_TYPE enchantType = GetEnchantTypeFromExtraDamageType( eDecomposedEDT[i] );
				AddDefenceEnchantData( enchantType, CX2EnchantItem::GetEnchantResistValue( eDecomposedEDT[i] ) );
			}
		}
	}

	//{{ kimhc // 2011.4.24 // 월드버프 2단계, 드래곤의 숨결
#ifdef	SERV_INSERT_GLOBAL_SERVER
	 if ( CX2Game::GT_PVP != g_pX2Game->GetGameType() )
		 AddEnchantStatFromDragonBreathToDefenceEnchantData();	
#endif	SERV_INSERT_GLOBAL_SERVER
	//}} kimhc // 2011.4.24 // 월드버프 2단계, 드래곤의 숨결
}

//{{ kimhc // 2011.1.14 // 청 1차 전직
#ifdef	CHUNG_FIRST_CLASS_CHANGE
/** @function : AddDefenceEnchantData
	@brief : m_mapDefenceEnchantData내에 Key가 eEnchantType인것을 찾아서 더 해주거나 추가 함
	@param : CX2EnchantItem::ENCHANT_TYPE eEnchantType(더해질 인첸트 종류), int iEnchantValue (더해질 인첸트 값)
*/
void CX2GUUser::AddDefenceEnchantData( CX2EnchantItem::ENCHANT_TYPE eEnchantType, int iEnchantValue )
{
	map<CX2EnchantItem::ENCHANT_TYPE, int>::iterator mItr = m_mapDefenceEnchantData.find( eEnchantType );
	
	if( m_mapDefenceEnchantData.end() != mItr )
	{
		mItr->second += iEnchantValue;

		if( mItr->second > CX2EnchantItem::EAR_MAX_VALUE )
			mItr->second = CX2EnchantItem::EAR_MAX_VALUE;
	}
	else
	{
		if( iEnchantValue > CX2EnchantItem::EAR_MAX_VALUE )
			m_mapDefenceEnchantData[ eEnchantType ] = CX2EnchantItem::EAR_MAX_VALUE;
		else
			m_mapDefenceEnchantData[ eEnchantType ] = iEnchantValue;
	}
}

/** @function : AddExtraDamageImmuneData
	@brief : m_mapExtraDamageNImmunePer내에 Key가 eExtraDamageType인것을 찾아서 더 해주거나 추가 함
	@param : CX2DamageManager::EXTRA_DAMAGE_TYPE eExtraDamageType(더해질 ExtraDamage 종류), float fImmuneValue (Immune 값)
*/
void CX2GUUser::AddExtraDamageImmuneData( CX2DamageManager::EXTRA_DAMAGE_TYPE eExtraDamageType, float fImmuneValue )
{
	map<CX2DamageManager::EXTRA_DAMAGE_TYPE, float> ::iterator mItr = m_mapExtraDamageNImmunePer.find( eExtraDamageType );

	if( m_mapExtraDamageNImmunePer.end() != mItr )
	{
		mItr->second += fImmuneValue;
	}
	else
	{
		m_mapExtraDamageNImmunePer[ eExtraDamageType ] = fImmuneValue;
	}
}

/** @function : AddEnchantStatFromPassiveSkillToDefenceEnchantData
	@brief : 패시브 스킬에 의해서 증가된 EnchantStat을 m_mapDefenceEnchantData에 더함
*/
void CX2GUUser::AddEnchantStatFromPassiveSkillToDefenceEnchantData()
{
	for ( int iEnchantType = CX2EnchantItem::ET_NONE + 1; iEnchantType < CX2EnchantItem::ET_END; ++iEnchantType )
	{
		const float fEnchantValue = GetEnchantStatFromPassiveSkillByEnchantType( iEnchantType );

		if ( 0.0f < fEnchantValue )
		{
			CX2EnchantItem::ENCHANT_TYPE eEnchantType = CX2EnchantItem::ENCHANT_TYPE( iEnchantType );
			AddDefenceEnchantData( eEnchantType, static_cast<int>( fEnchantValue ) );
		} // if	
	} // for
}

/** @function : AddExtraDamageImmuneRateFromPassiveSkillToImmuneData
	@brief : 패시브 스킬에 의해서 증가된 ExtraDamageImmune 확률을 m_mapExtraDamageNImmunePer에 더함
*/
void CX2GUUser::AddExtraDamageImmuneRateFromPassiveSkillToImmuneData()
{
	const CX2UserSkillTree& refUserSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	CX2SkillTree* pSkillTree = g_pData->GetSkillTree();
	int iSkillLevel = 0;
	
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = refUserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_A, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = refUserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_A );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0)
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = pSkillTree->GetSkillTemplet( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_A );
		if( pSkillTemplet != NULL )
		{
			float fImmuneValue = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_FIRE_RESIST_REL, iSkillLevel );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_FIRE, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_FROZEN_RESIST_REL, iSkillLevel );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_FROZEN, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_ICE_RESIST_REL, iSkillLevel );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_COLD, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_POISON_RESIST_REL, iSkillLevel );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_POISON, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_Y_PRESSED_RESIST_REL, iSkillLevel );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_Y_PRESSED, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_LEG_WOUND_RESIST_REL, iSkillLevel );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_LEG_WOUND, fImmuneValue );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = pSkillTree->GetSkillTemplet( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_A, iSkillLevel );
		if( pSkillTemplet != NULL )
		{
			float fImmuneValue = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_FIRE_RESIST_REL );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_FIRE, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_FROZEN_RESIST_REL );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_FROZEN, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_ICE_RESIST_REL );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_COLD, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_POISON_RESIST_REL );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_POISON, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_Y_PRESSED_RESIST_REL );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_Y_PRESSED, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_LEG_WOUND_RESIST_REL );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_LEG_WOUND, fImmuneValue );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = refUserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_B, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = refUserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_B );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0)
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = pSkillTree->GetSkillTemplet( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_B );
		if( pSkillTemplet != NULL )
		{
			float fImmuneValue = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_STUN_RESIST_REL, iSkillLevel );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_STUN, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_CURSE_RESIST_REL, iSkillLevel );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_CURSE, fImmuneValue );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = pSkillTree->GetSkillTemplet( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_B, iSkillLevel );
		if( pSkillTemplet != NULL )
		{
			float fImmuneValue = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_STUN_RESIST_REL );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_STUN, fImmuneValue );

			fImmuneValue		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EDT_CURSE_RESIST_REL );
			AddExtraDamageImmuneData( CX2DamageManager::EDT_CURSE, fImmuneValue );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}
}
/** @function : GetEnchantStatFromPassiveSkillByEnchantType
	@brief : 인첸트 타입별 수치 값 리턴
	@param : CX2EnchantItem::ENCHANT_TYPE eType (수치를 알고싶은 인첸트 타입)
	@return : const float (해당 인첸트 타입의 수치 값)
*/
const float CX2GUUser::GetEnchantStatFromPassiveSkillByEnchantType( int iEnchantType )
{
	switch ( static_cast<CX2EnchantItem::ENCHANT_TYPE>( iEnchantType ) )
	{
	case CX2EnchantItem::ET_BLAZE:
		return m_EnchantStatFromPassiveSkill.m_fDefBlaze;
		break;

	case CX2EnchantItem::ET_WATER:
		return m_EnchantStatFromPassiveSkill.m_fDefWater;
		break;

	case CX2EnchantItem::ET_NATURE:
		return m_EnchantStatFromPassiveSkill.m_fDefNature;
		break;

	case CX2EnchantItem::ET_WIND:
		return m_EnchantStatFromPassiveSkill.m_fDefWind;
		break;

	case CX2EnchantItem::ET_LIGHT:
		return m_EnchantStatFromPassiveSkill.m_fDefLight;
		break;

	case CX2EnchantItem::ET_DARK:
		return m_EnchantStatFromPassiveSkill.m_fDefDark;
		break;

	default:
		return 0.0f;
		break;
	} // switch
	
}
#endif	CHUNG_FIRST_CLASS_CHANGE
//}} kimhc // 2011.1.14 // 청 1차 전직

//{{ kimhc // 2011.4.24 // 월드버프 2단계, 드래곤의 숨결
#ifdef	SERV_INSERT_GLOBAL_SERVER

/** @function : AddEnchantStatFromDragonBreathToDefenceEnchantData
	@brief : 월드 버프 2단계, 드래곤의 숨결에 의해서 증가된 EnchantStat을 m_mapDefenceEnchantData에 더함
*/
void CX2GUUser::AddEnchantStatFromDragonBreathToDefenceEnchantData()
{
	// 월드버프 2단계가 적용되지 않았으면 그냥 리턴함
	if ( NULL == g_pData->GetWorldMissionManager() || 
		 true == g_pData->GetWorldMissionManager()->IsNullWorldBuffDragonBreath() )
		 return;

	// 월드버프 2단계가 적용되었으면
	for ( int iEnchantType = CX2EnchantItem::ET_NONE + 1; iEnchantType < CX2EnchantItem::ET_END; ++iEnchantType )
	{
		const float fEnchantValue = g_pData->GetWorldMissionManager()->GetEnchantStatFromDrgonBreath( iEnchantType );

		if ( 0.0f < fEnchantValue )
		{
			CX2EnchantItem::ENCHANT_TYPE eEnchantType = CX2EnchantItem::ENCHANT_TYPE( iEnchantType );
			AddDefenceEnchantData( eEnchantType, static_cast<int>( fEnchantValue ) );
		} // if	
	} // for
}
#endif	SERV_INSERT_GLOBAL_SERVER
//}} kimhc // 2011.4.24 // 월드버프 2단계, 드래곤의 숨결

//{{ kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트
#ifdef	SERV_TOONILAND_CHANNELING_EVENT
void CX2GUUser::SetShowTooniLandEventEffectSet( bool bShow_ )
{
	if ( true == bShow_ )
	{
		if ( CX2Game::GT_DUNGEON == g_pX2Game->GetGameType() &&
			true == g_pData->GetPremiumBuffManager()->IsTooniLandChannelingEvent() &&
			INVALID_EFFECTSET_HANDLE == m_hEffectTooniLandEvent )
		{
			m_hEffectTooniLandEvent = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_TooniLand_Event", this );
		}
	}
	else
		g_pX2Game->GetEffectSet()->StopEffectSet( m_hEffectTooniLandEvent );
}
#endif	SERV_TOONILAND_CHANNELING_EVENT
//}} kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트

#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD


/*static*/
void	CX2GUUser::InitComponent( InitData& OutInit_, KLuaManager& luaManager_)
{
	CX2GameUnit::InitComponent( OutInit_.m_device, luaManager_ );
}

/*static*/
void	CX2GUUser::AppendComponentToDeviceList( CKTDXDeviceDataList& listInOut_, CX2Unit* pX2Unit_ )
{
	g_pX2Game->GetMajorParticle()->AppendToDeviceList( listInOut_, L"HoldCenter" );
	g_pX2Game->GetMajorParticle()->AppendToDeviceList( listInOut_, L"HoldCircle" );
	g_pX2Game->GetMajorParticle()->AppendToDeviceList( listInOut_, L"HeadMarkerRed3D" );
	g_pX2Game->GetMajorParticle()->AppendToDeviceList( listInOut_, L"HeadMarkerBlue3D" );

	if ( pX2Unit_ != NULL )
	{

//#ifdef TITLE_SYSTEM
		int titleId = pX2Unit_->GetTitleId();
		if(titleId > 0)
		{
			wstring titleName = g_pData->GetTitleManager()->GetTitleModel(titleId);
			g_pData->GetUIMajorParticle()->AppendToDeviceList( listInOut_, titleName );
		}
//#endif	TITLE_SYSTEM

		switch( pX2Unit_->GetType() )
		{
		case CX2Unit::UT_NONE:
			break;
		case CX2Unit::UT_ELSWORD:
			CX2GUElsword_SwordMan::AppendComponentToDeviceList( listInOut_ );
			break;
		case CX2Unit::UT_ARME:
			CX2GUArme_VioletMage::AppendComponentToDeviceList( listInOut_ );
			break;
		case CX2Unit::UT_LIRE:
			CX2GULire_ElvenRanger::AppendComponentToDeviceList( listInOut_ );
			break;
		case CX2Unit::UT_RAVEN:
			CX2GURaven::AppendComponentToDeviceList( listInOut_ );
			break;
		case CX2Unit::UT_EVE:
			CX2GUEve::AppendComponentToDeviceList( listInOut_ );
			break;
		case CX2Unit::UT_CHUNG:
			CX2GUChung::AppendComponentToDeviceList( listInOut_ );
			break;
#ifdef ARA_CHARACTER_BASE
		case CX2Unit::UT_ARA:
			CX2GUAra::AppendComponentToDeviceList( listInOut_ );
			break;
#endif
#ifdef NEW_CHARACTER_EL
		case CX2Unit::UT_ELESIS:
			CX2GUEL::AppendComponentToDeviceList( listInOut_ );
			break;
#endif // NEW_CHARACTER_EL
#ifdef SERV_9TH_NEW_CHARACTER // 김태환 ( 캐릭터 추가용 )
		case CX2Unit::UT_ADD:
			CX2GUAdd::AppendComponentToDeviceList( listInOut_ );
			break;
#endif //SERV_9TH_NEW_CHARACTER
		}	
	}

}

#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD


void CX2GUUser::InitComponent()
{
	CX2GameUnit::InitComponent();

	if( m_LuaManager.BeginTable( "INIT_COMPONENT" ) == true )
	{
		//ResetMaxHP();
		m_LuaManager.GetValue( "MP_CHANGE_RATE",		m_fOriginalMPChangeRate );

	//{{ kimhc // 2010.6.14	// 드래고닉셋트 효과 적용 여부 포함 
	// GetOriginalMPChangeRate() 에서 드래고닉셋트 효과가 아직 적용 중인지를 판단함
#ifdef	SERV_SECRET_HELL
		
		ResetMPChangeRate( GetOriginalMPChangeRate() );
#else	SERV_SECRET_HELL
		ResetMPChangeRate( m_fOriginalMPChangeRate );
#endif	SERV_SECRET_HELL
	//}} kimhc // 2010.6.14 // 드래고닉셋트 효과 적용 여부 포함
		
		ResetMaxHP();
		ResetMaxMP();		

		if ( !IsMyUnit() )
		{
			SetNowHp( GetMaxHp() );
			SetNowMp( 0.f );
			SetMaxSoul( 100.f );
			SetNowSoul( 0.f ); 
		}
		else
		{
			ASSERT( NULL != g_pX2Game );
			switch ( g_pX2Game->GetGameType() )
			{
			case CX2Game::GT_PVP:
				{
					CX2GageManager::GetInstance()->SaveGageData();	

#ifdef SERV_9TH_NEW_CHARACTER
					if( CX2Unit::UT_ADD != GetUnitType() )
#endif // SERV_9TH_NEW_CHARACTER
					{
						if( true == m_bHasHyperModeItem )
							GetGageData()->SetHyperModeCount(1);
						else
							GetGageData()->SetHyperModeCount(0);

						m_bHasHyperModeItem = false;;
					}

					GetGageData()->SetHyperModeRemainTime(0.f);
					SetNowHp( GetMaxHp() );
					SetNowMp( 0.f );
					SetMaxSoul( 100.f );
					SetNowSoul( 0.f ); 		
				} break;

			default:
				{
					if ( g_pMain->GetNowStateID() == CX2Main::XS_TRAINING_GAME )
					{
						CX2GageManager::GetInstance()->SaveGageData();

						SetNowHp( GetMaxHp() );
						SetNowMp( 0.f );
						SetMaxSoul( 100.f );
						SetNowSoul( 0.f );
					}
					else
					{
						CX2GageManager::GetInstance()->RestoreGageData();
						if( NULL != CX2GageManager::GetInstance()->GetMyGageData())
							m_pGageData = CX2GageManager::GetInstance()->GetMyGageData()->GetCloneGageData();
						ResetMaxHP();
						ResetMaxMP();
						SetNowHp( GetMaxHp() * CX2GageManager::GetInstance()->GetMyNowHpPercent() );
						SetNowMp( GetMaxMp() * CX2GageManager::GetInstance()->GetMyNowMpPercent() );
					}
				} break;
			}
		}		
		float fData = 0.f;
		m_LuaManager.GetValue( "MP_CHARGE_RATE",		fData );
		SetChangeRateChargeMpForDetonation( fData ); 

		SetMaxForceDown( 100.f );
		SetNowForceDown( 0.f );

		GetGageData()->SetEnable( true );

		m_FrameDataFuture.syncData.fNowHP				= GetNowHp();
		m_FrameDataFuture.syncData.fNowMP				= GetNowMp();
		

		AccessStat().AccessAddOnStat().Init();
		AccessStat().AccessAddOnTime().Init();


		for( UINT i=0; i<m_vecpWeapon.size(); ++i )
		{
			Weapon* pWeapon = m_vecpWeapon[i];
			pWeapon->LoadDataForUser( m_LuaManager );
		}


		m_hHoldEffCenter = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HoldCenter", 0,0,0, 0, 0 );
#ifdef  X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
        CKTDGParticleSystem::CParticleEventSequence* pSeqHoldCenter = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hHoldEffCenter );	
#else   X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
		CKTDGParticleSystem::CParticleEventSequence* pSeqHoldCenter = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHoldEffCenter );	
#endif  X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
		if( NULL != pSeqHoldCenter )
		{
			pSeqHoldCenter->SetTrace( true );
		}

		m_hHoldEffCircle = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HoldCircle", 0,0,0, 0, 0 );
#ifdef  X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
        CKTDGParticleSystem::CParticleEventSequence* pSeqHoldCircle = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hHoldEffCircle );
#else   X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
		CKTDGParticleSystem::CParticleEventSequence* pSeqHoldCircle = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHoldEffCircle );	
#endif  X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
		if( NULL != pSeqHoldCircle )
		{
			pSeqHoldCircle->SetTrace( true );
		}


		if ( m_pAfterImage == NULL )
		{
			if( g_pX2Room->GetMySlot()->GetUnit()->GetUID() == m_UnitUID )
			{
				m_pAfterImage = CKTDGXSkinAfterImage::CreateSkinAfterImage( m_pXSkinAnim.get(), 10, XL_EFFECT_0 );
			}
			else
			{
				m_pAfterImage = CKTDGXSkinAfterImage::CreateSkinAfterImage( m_pXSkinAnim.get(), 5, XL_EFFECT_0 );
			}

			if ( m_pAfterImage != NULL )
			{
				m_pAfterImage->SetAfterImageColor( 0xffcccccc );
				m_pAfterImage->AddMesh( m_pMotion );
#ifdef MODIFY_AFTER_IMAGE
				// 모자 착용 중 애프터 이미지에 현재 착용중인 Hair를 추가 하기 위해 저장
				m_pAfterImage->SetpHairSkinMesh(m_pHairXSkinMesh);
				UpdateAfterImageEquip();
#endif // MODIFY_AFTER_IMAGE
// #ifdef FIX_MEMLEAK01
// 				m_pAfterImageMotion = g_pKTDXApp->GetDeviceManager()->OpenXSkinMesh( m_pMotion->GetDeviceID() );
// 				m_pAfterImage->AddMesh( m_pAfterImageMotion );
// #else
// 				m_pAfterImage->AddMesh( g_pKTDXApp->GetDeviceManager()->OpenXSkinMesh( m_pMotion->GetDeviceID() ) );
// #endif
			}
		}

#ifndef X2TOOL
		if( m_hSeqHeadMarker == INVALID_PARTICLE_SEQUENCE_HANDLE )
		{
			if( IsMyUnit() == true )
			{
				if ( g_pData->GetPVPRoom() != NULL && g_pData->GetPVPRoom()->GetPVPGameType() == CX2PVPRoom::PGT_SURVIVAL )
				{
					m_hSeqHeadMarker = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HeadMarkerRedMy3D", 0.0f, 0.0f, 0.0f, 0.0f, 0.0f );
				}
				else
				{
					if( m_TeamNum == CX2Room::TN_RED )
						m_hSeqHeadMarker = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HeadMarkerRedMy3D", 0.0f, 0.0f, 0.0f, 0.0f, 0.0f );
					else if( m_TeamNum == CX2Room::TN_BLUE )
						m_hSeqHeadMarker = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HeadMarkerBlueMy3D", 0.0f, 0.0f, 0.0f, 0.0f, 0.0f );
				}
			}
			else
			{
				if ( g_pData->GetPVPRoom() != NULL && g_pData->GetPVPRoom()->GetPVPGameType() == CX2PVPRoom::PGT_SURVIVAL )
				{
					m_hSeqHeadMarker = INVALID_PARTICLE_SEQUENCE_HANDLE;
				}
				else 
				{
					if( m_TeamNum == CX2Room::TN_RED )
						m_hSeqHeadMarker = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HeadMarkerRed3D", 0.0f, 0.0f, 0.0f, 0.0f, 0.0f );
					else if( m_TeamNum == CX2Room::TN_BLUE )
						m_hSeqHeadMarker = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HeadMarkerBlue3D", 0.0f, 0.0f, 0.0f, 0.0f, 0.0f );
				}		
			}
		}
	


		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqHeadMarker );
		if( NULL != pSeq )
		{
			pSeq->SetTrace( true );
			pSeq->SetBillBoardType( CKTDGMatrix::BT_Y );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
            if ( m_hHeadMarkerParticle == INVALID_PARTICLE_HANDLE )
            {
                m_hHeadMarkerParticle = pSeq->CreateNewParticleHandle( D3DXVECTOR3(0.0f,0.0f,0.0f) );
                pSeq->SetShowObject(false);
            }
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			if( m_pHeadMarkerParticle == NULL )
			{
				m_pHeadMarkerParticle = pSeq->CreateNewParticle( D3DXVECTOR3(0.0f,0.0f,0.0f) );
				pSeq->SetShowObject(false);
			}
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		}
#endif

		if( NULL != GetUnit() )
		{
//#ifdef TITLE_SYSTEM

			int titleId = GetUnit()->GetTitleId();
			
			if ( IsMyUnit() == true )
			{
				// pc방 칭호 예외처리
				int localTitleId = g_pData->GetMyUser()->GetSelectUnit()->GetTitleId();
				if( localTitleId == 10390 && titleId != localTitleId )
				{
					// 강제로 pc방 타이틀로 교체시킨다.
					g_pData->GetTitleManager()->EqipTitle(localTitleId); //SelectTitle(localTitleId)
				}
			}

			if(titleId > 0)
			{
				if( m_hSeqEmblem == INVALID_PARTICLE_SEQUENCE_HANDLE )
				{
#ifdef SERV_GROW_UP_TITLE
					// 해당 타이틀이 갖고 있는 소켓의 타입을 이용하여 레벨을 찾아내도록 수정하였음 by 박진웅
					int iLevel = 0;
					if( m_pUnit != NULL )
						iLevel = m_pUnit->AccessUnitData().GetGrowUpLevelByTitle( titleId );
					wstring titleName = g_pData->GetTitleManager()->GetTitleModel( titleId, iLevel );
#else
					wstring titleName = g_pData->GetTitleManager()->GetTitleModel(titleId);
#endif
					m_hSeqEmblem = g_pData->GetUIMajorParticle()->CreateSequenceHandle( NULL,  titleName.c_str(), 0.0f, 0.0f, 0.0f, 0.0f, 0.0f );
				}

				CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem = g_pData->GetUIMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
				if( pSeqEmblem != NULL )
				{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                    if ( m_hPart_Emblem_200 == INVALID_PARTICLE_HANDLE )
                    {
						m_hPart_Emblem_200 = pSeqEmblem->CreateNewParticleHandle( D3DXVECTOR3(0.0f,0.0f,0.0f) );
						pSeqEmblem->SetShowObject(false);
                    }
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
					if( m_pPart_Emblem_200 == NULL )
					{
						m_pPart_Emblem_200 = pSeqEmblem->CreateNewParticle( D3DXVECTOR3(0.0f,0.0f,0.0f) );
						pSeqEmblem->SetShowObject(false);
					}
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
				}

			}
//#else
//			// fix!! 임시로 머리위에 엠블렘 아이템은 이렇게 따로 렌더링
//			const int MAGIC_EMBLEM_ITEM_ID				= 129785;
//			const int MAGIC_EMBLEM_ITEM_ID_GOLD_MEDAL	= 130002;
//
//			bool bEquippedEmblem = false;
//
//            const CX2Item::ItemTemplet* pItemTempet = g_pData->GetItemManager()->GetItemTemplet( MAGIC_EMBLEM_ITEM_ID );
//			if( NULL != pItemTempet )
//			{
//				CX2Item* pEmblemItem = GetUnit()->GetInventory().GetEquippingItemByEquipPos( pItemTempet->GetEqipPosition(), false );
//                if( NULL != pEmblemItem && pEmblemItem->GetItemTemplet()->GetItemID() == pItemTempet->GetItemID() )
//				{
//					bEquippedEmblem = true;
//
//					if( m_hSeqEmblem == INVALID_PARTICLE_SEQUENCE_HANDLE )
//					{
//						m_hSeqEmblem = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"UnitEmblem200", 0.0f, 0.0f, 0.0f, 0.0f, 0.0f );
//					}
//
//					CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
//					if( pSeqEmblem != NULL )
//					{
//						if( m_pPart_Emblem_200 == NULL )
//						{
//							m_pPart_Emblem_200 = pSeqEmblem->CreateNewParticle( D3DXVECTOR3(0.0f,0.0f,0.0f) );
//							pSeqEmblem->SetShowObject(false);
//						}
//					}
//				}
//			}
//
//			if( false == bEquippedEmblem )
//			{
//				pItemTempet = g_pData->GetItemManager()->GetItemTemplet( MAGIC_EMBLEM_ITEM_ID_GOLD_MEDAL );
//				if( NULL != pItemTempet )
//				{
//					CX2Item* pEmblemItem = GetUnit()->GetInventory().GetEquippingItemByEquipPos( pItemTempet->GetEqipPosition(), false );
//					if( NULL != pEmblemItem && 
//                        pEmblemItem->GetItemTemplet()->GetItemID() == pItemTemplet->GetItemID()
//                        )
//					{
//						bEquippedEmblem = true;
//
//						if( m_hSeqEmblem == INVALID_PARTICLE_SEQUENCE_HANDLE )
//						{
//							m_hSeqEmblem = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"UnitEmblemGoldMedal", 0.0f, 0.0f, 0.0f, 0.0f, 0.0f );
//						}
//
//						CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
//						if( pSeqEmblem != NULL )
//						{
//							if( m_pPart_Emblem_200 == NULL )
//							{
//								m_pPart_Emblem_200 = pSeqEmblem->CreateNewParticle( D3DXVECTOR3(0.0f,0.0f,0.0f) );
//								pSeqEmblem->SetShowObject(false);
//							}
//						}
//					}
//				}
//			}
//#endif
		}

		

#ifdef ATTACK_DELAY_GAGE
		//{{AFX
		m_bAddAttackDelayThisState		= false;
		m_fLastAttackPassTime			= 0.0f;
		//}}AFX
#endif ATTACK_DELAY_GAGE
		
		m_bAddForceDownGageThisState	= false;
		m_fLastDamagePassTime			= 0.0f;
#ifdef BALANCE_PATCH_20110303
		m_fMaxDownForce = -9999.f;
#endif


		m_LuaManager.EndTable();
	}

}

#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
/*static*/
void	CX2GUUser::AppendEffectToDeviceList( CKTDXDeviceDataList& listInOut_, CX2Unit* pX2Unit_ )
{
	CX2DamageManager::EXTRA_DAMAGE_TYPE	eDamageType = CalcWeaponEnchantExtraDamageType( pX2Unit_ );

	AppendEnchantedWeaponEffectAtHandToDeviceList( listInOut_, eDamageType );

	AppendMajorParticleToDeviceList( listInOut_ );
	AppendMinorParticleToDeviceList( listInOut_ );

	if ( pX2Unit_ != NULL )
	{
		switch( pX2Unit_->GetType() )
		{
		case CX2Unit::UT_NONE:
			break;
		case CX2Unit::UT_ELSWORD:
			CX2GUElsword_SwordMan::AppendEffectToDeviceList( listInOut_, eDamageType );
			break;
		case CX2Unit::UT_ARME:
			CX2GUArme_VioletMage::AppendEffectToDeviceList( listInOut_, eDamageType );
			break;
		case CX2Unit::UT_LIRE:
			CX2GULire_ElvenRanger::AppendEffectToDeviceList( listInOut_, eDamageType );
			break;
		case CX2Unit::UT_RAVEN:
			CX2GURaven::AppendEffectToDeviceList( listInOut_, eDamageType );
			break;
		case CX2Unit::UT_EVE:
			CX2GUEve::AppendEffectToDeviceList( listInOut_, eDamageType );
			break;
		case CX2Unit::UT_CHUNG:
			CX2GUChung::AppendEffectToDeviceList( listInOut_, eDamageType );
			break;
#ifdef ARA_CHARACTER_BASE
		case CX2Unit::UT_ARA:
			CX2GUAra::AppendEffectToDeviceList( listInOut_, eDamageType );
			break;
#endif
#ifdef NEW_CHARACTER_EL
		case CX2Unit::UT_ELESIS:
			CX2GUEL::AppendEffectToDeviceList( listInOut_, eDamageType );
			break;
#endif // NEW_CHARACTER_EL
#ifdef SERV_9TH_NEW_CHARACTER // 김태환
		case CX2Unit::UT_ADD:
			CX2GUAdd::AppendEffectToDeviceList( listInOut_, eDamageType );
			break;
#endif //SERV_9TH_NEW_CHARACTER
		}

#ifdef ADD_UPGRADE_WEAPON_PARTICLE		/// 강화 무기 이펙트 선로딩
		int					iUpgradeWeaponLevel = CalcWeaponEnchantLevel( pX2Unit_ );	/// 강화 레벨
		CX2Unit::UNIT_TYPE	eUnitType			= pX2Unit_->GetType();					/// 유닛 타입

		AppendUpgradeWeaponParticleToDeviceList( listInOut_, eUnitType, iUpgradeWeaponLevel );

#endif ADD_UPGRADE_WEAPON_PARTICLE
	}

}
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD


void CX2GUUser::InitEffect()
{
	CX2GameUnit::InitEffect();

	InitEnchantedWeaponEffectAtHand();
	InitEnchantWeaponEffectUnitSpecific();

	if( GetUnit() != NULL && IsMyUnit() == true )
	{
		if(m_pComboGuide != NULL) 
			m_pComboGuide->InitComboGuide( GetUnit()->GetClass() );
	}	

#ifdef ADD_UPGRADE_WEAPON_PARTICLE
	BOOST_FOREACH( Weapon* pWeapon, m_vecpWeapon )		/// 강화 무기 이펙트 설정
	{
		if( NULL != pWeapon )
		{
			pWeapon->DeleteUpgradeWeaponParticle();		/// 설정되어 있을지도 모르니, 삭제
			pWeapon->InitUpgradeWeaponParticle();		/// 강화 무기 이펙트 초기화
		}
	}
#endif ADD_UPGRADE_WEAPON_PARTICLE
}

void CX2GUUser::InitializeGUUserMajorParticleArray()
{
	for ( int index = 0; index < COMMON_MAJOR_PII_END; index++ )
	{
		m_ahCommonMajorParticleInstance[index] = INVALID_PARTICLE_SEQUENCE_HANDLE;
	}
}

#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
/*static*/
void	CX2GUUser::AppendMajorParticleToDeviceList( CKTDXDeviceDataList& listInOut_ )
{
	if ( g_pData->GetGameMajorParticle() == NULL )
		return;

	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"RevengeImpactSlashCW" );
	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"RevengeImpactSlashCCW" );
	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"RevengeImpact" );
	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"RevengeImpactTick" );
	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"MagicFail" );
}
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD


/*virtual*/ void CX2GUUser::CreateMajorParticleArray()
{
	CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

	// 반격기에 당하기 직전에 나오는 파티클
	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_REVENGE_IMPACT_SLASH_CW,	L"RevengeImpactSlashCW",		1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_REVENGE_IMPACT_SLASH_CCW,	L"RevengeImpactSlashCCW",	1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_REVENGE_IMPACT,	L"RevengeImpact",						1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_REVENGE_IMPACT_TICK,	L"RevengeImpactTick",				2 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	// MP가 없는 상태에서 마법 공격을 ㎱ 때 나오는 파티클(만두)
	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_MAGIC_FAIL,	L"MagicFail" );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	// 여기 이외의 것은 각 캐릭터마다 쓰이는 곳은 같지만, 이펙트 생성 이름이 달라서 각 캐릭터의 InitializeCommonMajorParticleArray()에서 초기화
}

CKTDGParticleSystem::CParticleEventSequence* CX2GUUser::SetCommonMajorParticleByEnum( COMMON_MAJOR_PARTICLE_INSTANCE_ID eVal_, wstring wstrParticleName_, int iDrawCount_ /*= -1 */ )
{
	if ( INVALID_PARTICLE_SEQUENCE_HANDLE == GetHandleCommonMajorParticleByEnum( eVal_ ) )
	{
		ParticleEventSequenceHandle hHandle = 
			g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  wstrParticleName_.c_str(), D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), 0, 0, iDrawCount_, 0 );

		SetHandleCommonMajorParticleByEnum( eVal_, hHandle );

	}
	
	CKTDGParticleSystem::CParticleEventSequence* pSeq =
		g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( eVal_) );

	return pSeq;
}

void CX2GUUser::InitializeGUUserMinorParticleArray()
{
	for ( int index = 0; index < COMMON_MINOR_PII_END; index++ )
	{
		m_ahCommonMinorParticleInstance[index] = INVALID_PARTICLE_SEQUENCE_HANDLE;
	}
}

#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
/*static*/
void	CX2GUUser::AppendMinorParticleToDeviceList( CKTDXDeviceDataList& listInOut_ )
{
	if ( g_pData->GetGameMinorParticle() == NULL )
		return;

	g_pData->GetGameMinorParticle()->AppendToDeviceList( listInOut_, L"StepSmoke" );
	g_pData->GetGameMinorParticle()->AppendToDeviceList( listInOut_, L"Water_Particle01" );
	g_pData->GetGameMinorParticle()->AppendToDeviceList( listInOut_, L"HyperModeChangeLine" );
	g_pData->GetGameMinorParticle()->AppendToDeviceList( listInOut_, L"HyperModeChangeCenter" );
	g_pData->GetGameMinorParticle()->AppendToDeviceList( listInOut_, L"GroundShockWave" );
	g_pData->GetGameMinorParticle()->AppendToDeviceList( listInOut_, L"WhiteShockWave" );
	g_pData->GetGameMinorParticle()->AppendToDeviceList( listInOut_, L"ImpactTick" );
	g_pData->GetGameMinorParticle()->AppendToDeviceList( listInOut_, L"STR_ToKang" );
	g_pData->GetGameMinorParticle()->AppendToDeviceList( listInOut_, L"AirDownTick" );
	g_pData->GetGameMinorParticle()->AppendToDeviceList( listInOut_, L"DownSmoke" );
}
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD


void CX2GUUser::CreateMinorParticleArray()
{
	CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

	pSeq = SetCommonMinorParticleByEnum( COMMON_MINOR_PII_STEP_SMOKE,					L"StepSmoke",				-1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMinorParticleByEnum( COMMON_MINOR_PII_STEP_WATER,					L"Water_Particle01",		-1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMinorParticleByEnum( COMMON_MINOR_PII_HYPER_MODE_CHANGE_LINE,		L"HyperModeChangeLine",		3 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMinorParticleByEnum( COMMON_MINOR_PII_HYPER_MODE_CHANGE_CENTER,	L"HyperModeChangeCenter",	-1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMinorParticleByEnum( COMMON_MINOR_PII_GROUND_SHOCK_WAVE,			L"GroundShockWave",			-1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMinorParticleByEnum( COMMON_MINOR_PII_WHITE_SHOCK_WAVE,			L"WhiteShockWave",			3 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMinorParticleByEnum( COMMON_MINOR_PII_IMPACT_TICK,					L"ImpactTick",				2 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMinorParticleByEnum( COMMON_MINOR_PII_STR_TOKANG,					L"STR_ToKang",				-1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMinorParticleByEnum( COMMON_MINOR_PII_AIR_DOWN_TICK,				L"AirDownTick",				-1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMinorParticleByEnum( COMMON_MINOR_PII_DOWN_SMOKE,					L"DownSmoke",				-1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );
}

CKTDGParticleSystem::CParticleEventSequence* CX2GUUser::SetCommonMinorParticleByEnum( COMMON_MINOR_PARTICLE_INSTANCE_ID eVal_, wstring wstrPatricleName_, int iDrawCount_ /*= -1 */ )
{
	if ( INVALID_PARTICLE_SEQUENCE_HANDLE == GetHandleCommonMinorParticleByEnum( eVal_ ) )
	{
		ParticleEventSequenceHandle hHandle = 
			g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  wstrPatricleName_.c_str(), D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), 0, 0, iDrawCount_, 0 );

		SetHandleCommonMinorParticleByEnum( eVal_, hHandle );
	}

	CKTDGParticleSystem::CParticleEventSequence* pSeq =
		g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( eVal_ ) );

	return pSeq;
}

void CX2GUUser::CreateEnchantedWeaponParticleAtHand( const WCHAR* pName1, const WCHAR* pName2 /*= NULL*/, const WCHAR* pName3 /*= NULL*/, const WCHAR* pName4 /*= NULL*/ )
{
	if( NULL != pName1 )
	{
		if ( m_hSeqWeaponCommon1 == INVALID_PARTICLE_SEQUENCE_HANDLE )
		{
			m_hSeqWeaponCommon1 = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  pName1, 0,0,0 );
			CKTDGParticleSystem::CParticleEventSequence* pSeqWeaponFire1 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon1 );
			if(pSeqWeaponFire1 != NULL )
				pSeqWeaponFire1->SetEmitRate( 0, 0 );
		}
	}


	if( NULL != pName2 )
	{
		if ( m_hSeqWeaponCommon2 == INVALID_PARTICLE_SEQUENCE_HANDLE )
		{
			m_hSeqWeaponCommon2 = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  pName2, 0,0,0 );
			CKTDGParticleSystem::CParticleEventSequence* pSeqWeaponFire2 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon2 );
			if (pSeqWeaponFire2 != NULL )
				pSeqWeaponFire2->SetEmitRate( 0, 0 );
		}
	}

	if( NULL != pName3 )
	{
		if ( m_hSeqWeaponCommon3 == INVALID_PARTICLE_SEQUENCE_HANDLE )
		{
			m_hSeqWeaponCommon3 = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  pName3, 0,0,0 );
			CKTDGParticleSystem::CParticleEventSequence* pSeqWeaponFire3 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon3 );
			if (pSeqWeaponFire3 != NULL )
				pSeqWeaponFire3->SetEmitRate( 0, 0 );
		}
	}


	if( NULL != pName4 )
	{
		if ( m_hSeqEnchantedWeaponCommon4 == INVALID_PARTICLE_SEQUENCE_HANDLE )
		{
			m_hSeqEnchantedWeaponCommon4 = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  pName4, 0,0,0 );
			CKTDGParticleSystem::CParticleEventSequence* pSeqWeaponFire4 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchantedWeaponCommon4 );
			if (pSeqWeaponFire4 != NULL )
				pSeqWeaponFire4->SetEmitRate( 0, 0 );
		}
	}
}

void CX2GUUser::DeleteGUUserMajorParticle()
{
	CX2GameUnit::DeleteGameUnitMajorParticle();

	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();
	
	for ( int index = 0; index < COMMON_MAJOR_PII_END; index++ )
	{
		pMajorParticleSystem->DestroyInstanceHandle( m_ahCommonMajorParticleInstance[index] );
	}
}

void CX2GUUser::DeleteGUUserMinorParticle()
{
	CX2GameUnit::DeleteGameUnitMinorParticle();

	CKTDGParticleSystem* pMinorParticleSystem = g_pX2Game->GetMinorParticle();

	for ( int index = 0; index < COMMON_MINOR_PII_END; index++ )
	{
		pMinorParticleSystem->DestroyInstanceHandle( m_ahCommonMinorParticleInstance[index] );
	}
}

/*static*/
void    CX2GUUser::InitMotion( InitData& OutInit_, KLuaManager& luaManager_ )
{
	if( luaManager_.BeginTable( "INIT_MOTION" ) == true )
	{
		std::wstring wstrMotionName;
		if ( luaManager_.GetValue( "MOTION_FILE_NAME", wstrMotionName ) == true )
		{
			OutInit_.m_device.m_vecstrReadyXSkinMesh.push_back( wstrMotionName );
		}
		luaManager_.EndTable();
	}
}//CX2GUUser::InitMotion()

#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD

/*static*/
void CX2GUUser::AppendMotionToDeviceList( CKTDXDeviceDataList& listInOut_, CX2Unit* pX2Unit_ )
{
#ifdef  SEPARATION_MOTION      

	if ( pX2Unit_ != NULL && pX2Unit_->GetUnitTemplet() != NULL )
	{
		const CX2Unit::UnitTemplet* pUnitTemplet = pX2Unit_->GetUnitTemplet();

		if( pUnitTemplet->m_GameMotion0.empty() == false )
		{
			g_pKTDXApp->GetDeviceManager()->AppendXSkinMesh( listInOut_, pUnitTemplet->m_GameMotion0 );
		}

		int iGrade = GetX2UnitClassGrade( pUnitTemplet->m_UnitClass );
		switch( iGrade )
		{
		case 2:
			if ( pUnitTemplet->m_GameMotion2.empty() == false )
			{
				g_pKTDXApp->GetDeviceManager()->AppendXSkinMesh( listInOut_, pUnitTemplet->m_GameMotion2 );
			}//if
			break;					
		case 1:
			if ( pUnitTemplet->m_GameMotion1.empty() == false )
			{
				g_pKTDXApp->GetDeviceManager()->AppendXSkinMesh( listInOut_, pUnitTemplet->m_GameMotion1 );
			}//if
			break;
		default:
			break;
		}
		if ( pUnitTemplet->m_EmotionMotion.empty() == false )
		{
			g_pKTDXApp->GetDeviceManager()->AppendXSkinMesh( listInOut_, pUnitTemplet->m_EmotionMotion );
		}//if
	}//if

#endif  SEPARATION_MOTION    
}

#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD

void CX2GUUser::InitMotion()
{
	if( m_LuaManager.BeginTable( "INIT_MOTION" ) == true )
	{
		wstring motion;
		LUA_GET_VALUE( m_LuaManager, "MOTION_FILE_NAME", motion, L"" );

		m_pMotionFuture		= g_pKTDXApp->GetDeviceManager()->OpenXSkinMesh( motion.c_str() );
		m_pMotion			= g_pKTDXApp->GetDeviceManager()->OpenXSkinMesh( motion.c_str() );

		m_pXSkinAnimFuture	= CKTDGXSkinAnim::CreateSkinAnim();
		m_pXSkinAnim		= CKTDGXSkinAnim::CreateSkinAnimPtr();

		m_pXSkinAnimFuture->SetAnimXSkinMesh( m_pMotionFuture );
		m_pXSkinAnim->SetAnimXSkinMesh( m_pMotion );

#ifdef SEPARATION_MOTION
		std::vector<wstring> vecMotion;		
		CKTDXDeviceXSkinMesh* pMixMotion = NULL;
		int iGrade = GetX2UnitClassGrade( GetUnit()->GetUnitTemplet()->m_UnitClass );

		vecMotion.push_back( GetUnit()->GetUnitTemplet()->m_GameMotion0 );

		switch( iGrade )
		{
		case 2:
			vecMotion.push_back( GetUnit()->GetUnitTemplet()->m_GameMotion2 );						
		case 1:
			vecMotion.push_back( GetUnit()->GetUnitTemplet()->m_GameMotion1 );
			break;
		default:
			break;
		}
		
		vecMotion.push_back( GetUnit()->GetUnitTemplet()->m_EmotionMotion );

		if( GetUnit()->GetUnitTemplet()->m_GameMotion0 == L"" )
		{
			vecMotion.clear();
		}
		
		for(UINT i=0; i<vecMotion.size(); ++i)
		{
			pMixMotion = g_pKTDXApp->GetDeviceManager()->OpenXSkinMesh( vecMotion[i] );
			if(  pMixMotion != NULL )
			{
				m_pXSkinAnimFuture->MixAnim( pMixMotion );
				m_pXSkinAnim->MixAnim( pMixMotion );
				SAFE_CLOSE( pMixMotion );
			}	
		}
#endif


		m_pXSkinAnimFuture->SetModelDetailPercent( g_pData->GetModelDetailPercent() );
		m_pXSkinAnim->SetModelDetailPercent( g_pData->GetModelDetailPercent() );


		m_pFrame_Bip01				= m_pXSkinAnim->GetCloneFrame( L"Bip01" );
		m_pFrame_Bip01_Head			= m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );
		m_pFrame_Bip01_R_Foot		= m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Foot" );
		m_pFrame_Bip01_L_Foot		= m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Foot" );
		m_pFrame_Bip01_R_UpperArm	= m_pXSkinAnim->GetCloneFrame( L"Bip01_R_UpperArm" );
		m_pFrame_Bip01_L_UpperArm	= m_pXSkinAnim->GetCloneFrame( L"Bip01_L_UpperArm" );
		m_pFrame_Bip01_Spine		= m_pXSkinAnim->GetCloneFrame( L"Bip01_Spine" );
	
#ifdef ELSWORD_SECOND_CLASS_CHANGE
		SetUnitReForm();
#endif

		m_LuaManager.EndTable();
	}
}

void CX2GUUser::InitEqip()
{

#ifndef EFFECT_TOOL
	#ifdef EQUIP_STRIP_TEST
	g_pData->GetItemManager()->UpdateEqip( GetUnit(), m_pXSkinAnim, m_pMotion, m_pAniXET, OUT m_ViewEqipList, OUT m_mapBasicEquip );
	BOOST_TEST_FOREACH( CX2ItemManager::EquipPositionMap::value_type&, value, m_mapBasicEquip )
	{
		CX2EqipPtr pEquip = value.second;
		if( pEquip == NULL )
			continue;

		pEquip->SetManagerObject( this );
		pEquip->SetShowObject( false );

	}
	#else EQUIP_STRIP_TEST
	//{{AFX
	g_pData->GetItemManager()->UpdateEqip( GetUnit(), m_pXSkinAnim, m_pMotion, m_pAniXET, OUT m_ViewEqipList );
	//}}AFX
	#endif EQUIP_STRIP_TEST
#endif //EFFECT_TOOL




	for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
	{
		CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];

		//{{ robobeg : 2008-10-28
		if ( pCX2Eqip != NULL )
		{
			pCX2Eqip->SetManagerObject( this );
			if ( IsRecursivelyManagedByDGManager() )
				g_pKTDXApp->GetDGManager()->AddObjectChain( pCX2Eqip.get() );
		}//if
		//}} robobeg : 2008-10-28



		ASSERT( pCX2Eqip != NULL );
		ASSERT( pCX2Eqip->GetItem() != NULL );
		ASSERT( pCX2Eqip->GetItem()->GetItemTemplet() != NULL );


		if ( pCX2Eqip != NULL && 
			NULL != pCX2Eqip->GetItem() && 
			NULL != pCX2Eqip->GetItem()->GetItemTemplet() 
            )
		{
            const CX2Item::ItemTemplet* pItemTemplet = pCX2Eqip->GetItem()->GetItemTemplet();

			switch( pItemTemplet->GetEqipPosition() )
			{
			case CX2Unit::EP_WEAPON_HAND:
				{
					//{{ robobeg : 2008-10-28
					CX2GameUnit::Weapon* pWeapon = CX2GameUnit::Weapon::CreateWeapon( *this );
					ASSERT( pWeapon != NULL );
					//}} robobeg : 2008-10-28
					pWeapon->m_iWeaponIndex = 0;
					pWeapon->m_pUserWeaponEquip		= pCX2Eqip;
					pWeapon->m_bUseSlashTrace		= true;


#ifdef ITEM_SLASH_TRACE_COLOR_TEST
#ifdef	X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING				
					if( NULL != GetUnit() )
					{
						pItemTemplet->GetSlashTraceColors( pWeapon->m_coSlashTrace, pWeapon->m_coSlashTraceTip
							, pWeapon->m_coSlashTraceHyper, pWeapon->m_coSlashTraceTipHyper, GetUnit()->GetType() );
					}
#else   //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
					pWeapon->m_coSlashTrace			= pItemTemplet->m_coSlashTrace;
					pWeapon->m_coSlashTraceHyper	= pItemTemplet->m_coSlashTraceHyper;
					pWeapon->m_coSlashTraceTip		= pItemTemplet->m_coSlashTraceTip;
					pWeapon->m_coSlashTraceTipHyper	= pItemTemplet->m_coSlashTraceTipHyper;
#endif  //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
#endif ITEM_SLASH_TRACE_COLOR_TEST
					

					m_vecpWeapon.push_back( pWeapon );

#ifdef USER_WEAPON_PARTICLE_SCRIPT_TEST
					if( NULL != g_pX2Game &&
						NULL != g_pX2Game->GetMajorParticle() )
					{
                        unsigned uNumParticle = pItemTemplet->GetNumAttachedParticleData();
						for( UINT j=0; j<uNumParticle; j++ )
						{

                            const wchar_t*  pwszParticleName = L"";
                            const wchar_t*  pwszBoneName = L"";
#ifdef	X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
                            pItemTemplet->GetAttachedParticleData( j, &pwszParticleName, &pwszBoneName );
#else   //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
							const CX2Item::AttachedParticleData& particleData = pItemTemplet->GetAttachedParticleData(j);
                            pwszParticleName = particleData.wstrParticleName.c_str();
                            pwszBoneName = particleData.wstrBoneName.c_str();
#endif  //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
							CKTDGParticleSystem::CParticleEventSequence* pSeq = 
								g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  pwszParticleName, D3DXVECTOR3( 0, 0, 0 ) );
							if( NULL != pSeq )
							{
								AttachWeaponParticle( pWeapon->m_iWeaponIndex, true, pwszBoneName, pSeq->GetHandle() );
							}
						}
					}
#endif USER_WEAPON_PARTICLE_SCRIPT_TEST


				} break;

			case CX2Unit::EP_WEAPON_SECOND:
				{
					//{{ robobeg : 2008-10-28
					CX2GameUnit::Weapon* pWeapon = CX2GameUnit::Weapon::CreateWeapon( *this );
					ASSERT( pWeapon != NULL );
					//}} robobeg : 2008-10-28
					pWeapon->m_iWeaponIndex = 1;
					pWeapon->m_pUserWeaponEquip		= pCX2Eqip;
					pWeapon->m_bUseSlashTrace		= true;


#ifdef ITEM_SLASH_TRACE_COLOR_TEST
#ifdef	X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
					if( NULL != GetUnit() )
					{
						pItemTemplet->GetSlashTraceColors( pWeapon->m_coSlashTrace, pWeapon->m_coSlashTraceTip
							, pWeapon->m_coSlashTraceHyper, pWeapon->m_coSlashTraceTipHyper, GetUnit()->GetType() );
					}
#else   //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
					pWeapon->m_coSlashTrace			= pItemTemplet->m_coSlashTrace;
					pWeapon->m_coSlashTraceHyper	= pItemTemplet->m_coSlashTraceHyper;
					pWeapon->m_coSlashTraceTip		= pItemTemplet->m_coSlashTraceTip;
					pWeapon->m_coSlashTraceTipHyper	= pItemTemplet->m_coSlashTraceTipHyper;
#endif  //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
#endif ITEM_SLASH_TRACE_COLOR_TEST


					m_vecpWeapon.push_back( pWeapon );

#ifdef USER_WEAPON_PARTICLE_SCRIPT_TEST

					if( NULL != g_pX2Game &&
						NULL != g_pX2Game->GetMajorParticle() )
					{
                        unsigned uNumParticle = pItemTemplet->GetNumAttachedParticleData();
						for( UINT j=0; j<uNumParticle; j++ )
						{

                            const wchar_t*  pwszParticleName = L"";
                            const wchar_t*  pwszBoneName = L"";
#ifdef	X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
                            pItemTemplet->GetAttachedParticleData( j, &pwszParticleName, &pwszBoneName );
#else   //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
							const CX2Item::AttachedParticleData& particleData = pItemTemplet->GetAttachedParticleData(j);
                            pwszParticleName = particleData.wstrParticleName.c_str();
                            pwszBoneName = particleData.wstrBoneName.c_str();
#endif  //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
							CKTDGParticleSystem::CParticleEventSequence* pSeq = 
								g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  pwszParticleName, D3DXVECTOR3( 0, 0, 0 ) );
							if( NULL != pSeq )
							{
								AttachWeaponParticle( pWeapon->m_iWeaponIndex, true, pwszBoneName, pSeq->GetHandle() );
							}
						}
					}

#endif USER_WEAPON_PARTICLE_SCRIPT_TEST

				} break;
			}
		}
	}
#ifdef FIX_ARA_ONE_PIECE_FOR_BERSERK
	CX2GUUser::UpdateNotRenderingOtherEquipList();
#else //FIX_ARA_ONE_PIECE_FOR_BERSERK
#ifdef	NOT_RENDERING_OTHER_EQUIP_POS
#ifdef FACE_OFF_MONSTER_HEAD_TEST
	SetHideNoRenderable(false);
#endif FACE_OFF_MONSTER_HEAD_TEST

#ifdef ONE_PIECE_AVATAR
	bool bOnePieceAvatarCheck = false;

#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
	CX2Item* pItemBody = GetUnit()->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_ONEPIECE_FASHION, true );
#else //SERV_NEW_ONE_PIECE_AVATAR_SLOT
	CX2Item* pItemBody = GetUnit()->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_DEFENCE_BODY, true );
#endif //SERV_NEW_ONE_PIECE_AVATAR_SLOT

	if ( pItemBody != NULL && 
		pItemBody->GetItemTemplet() != NULL 
		) 
	{
#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
		if ( IsOnePieceAvatarRenderHair( pItemBody->GetItemData().m_ItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				if( IsOnePieceAvatarWithNotRenderHairItem( pViewEquip->GetItemID() ) == true )
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_AC_FACE2:
					case CX2Unit::EP_DEFENCE_LEG:
					case CX2Unit::EP_DEFENCE_HAND:
					case CX2Unit::EP_DEFENCE_FOOT:
					case CX2Unit::EP_DEFENCE_BODY:
						{
							pViewEquip->SetShowObject( false );
							bOnePieceAvatarCheck = true;
						}
						break;

					default:
						break;
					}
				}
				else
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_DEFENCE_LEG:
					case CX2Unit::EP_DEFENCE_HAND:
					case CX2Unit::EP_DEFENCE_FOOT:
					case CX2Unit::EP_DEFENCE_BODY:
						{
							pViewEquip->SetShowObject( false );
							bOnePieceAvatarCheck = true;
						}
						break;

					default:
						break;
					}
				}
				vItr++;
			}
		}
#endif SERV_NEW_ONE_PIECE_AVATAR_SLOT
		if ( IsOnePieceAvatar( pItemBody->GetItemData().m_ItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
				case CX2Unit::EP_DEFENCE_LEG:
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_DEFENCE_FOOT:
#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
				case CX2Unit::EP_DEFENCE_BODY:
#endif //SERV_NEW_ONE_PIECE_AVATAR_SLOT
					{
						(*vItr)->SetShowObject( false );
						bOnePieceAvatarCheck = true;
					}
					break;
				default:
					break;
				}
				vItr++;
			}
		}
		if ( IsOnePieceAvatarNotRenderFace1( pItemBody->GetItemData().m_ItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
				case CX2Unit::EP_DEFENCE_LEG:
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_DEFENCE_FOOT:
				case CX2Unit::EP_AC_FACE1:
#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
				case CX2Unit::EP_DEFENCE_BODY:
#endif //SERV_NEW_ONE_PIECE_AVATAR_SLOT
					{
						(*vItr)->SetShowObject( false );
						bOnePieceAvatarCheck = true;
					}
					break;
				default:
					break;
				}
				vItr++;
			}
		}
		if ( IsOnePieceAvatarNotRenderFace( pItemBody->GetItemData().m_ItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			SetHideNoRenderable(true);
			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
				case CX2Unit::EP_DEFENCE_LEG:
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_DEFENCE_FOOT:
				case CX2Unit::EP_AC_FACE2:
				case CX2Unit::EP_AC_FACE3:
#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
				case CX2Unit::EP_DEFENCE_BODY:
#endif //SERV_NEW_ONE_PIECE_AVATAR_SLOT
					{
						(*vItr)->SetShowObject( false );
						bOnePieceAvatarCheck = true;
					}
					break;
				default:
					break;
				}
				vItr++;
			}
		}
	}
#endif ONE_PIECE_AVATAR

	if ( pItemBody != NULL && 
		pItemBody->GetItemTemplet() != NULL 
		)
	{
		if ( IsNoRenderNasodHand( pItemBody->GetItemData().m_ItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_RAVEN_LEFT_ARM:
					{
						(*vItr)->SetShowObject( false );
					}
					break;
				default:
					break;
				}
				vItr++;
			}
		}
	} 

#ifdef FACE_OFF_MONSTER_HEAD_TEST
	CX2Item* pItemACArm = GetUnit()->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_AC_ARM, true );

	if ( pItemACArm != NULL && 
		pItemACArm->GetItemTemplet() != NULL 
		) 
	{
		if ( IsNoRenderHandEquip( pItemACArm->GetItemData().m_ItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAND:
					{
						(*vItr)->SetShowObject( false );
					}
					break;
				default:
					break;
				}
				vItr++;
			}
		}
	}
#endif FACE_OFF_MONSTER_HEAD_TEST

#ifdef HIDE_HAIR_BY_EP_AC_FACE2
	for( int i = 0; i < 2; ++i )
	{
		CX2Item* pItem;
		if( i == 0)
			pItem = GetUnit()->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_AC_FACE1, false );
		else if( i == 1)
			pItem = GetUnit()->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_AC_FACE2, false );
#else
	CX2Item* pItem = GetUnit()->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_AC_FACE1, false );
#endif HIDE_HAIR_BY_EP_AC_FACE2
	if ( pItem != NULL && 
		pItem->GetItemTemplet() != NULL 
		) 
	{
		// kimhc // 이 이상 안보여야 할 분류가 달라 진다면
		// 안보여야할 부위 및 그런 기능을 가지고 있는 아이템을 스크립트로 빼야할듯
		// 현재는 헤어만 안보이게 하는 아이템과 헤어, 얼굴 악세(중,하)를 안보이게 하는 아이템이 같은 위치 이므로
		// 한개만 착용 할 수 있음
		DWORD   dwItemID = pItem->GetItemTemplet()->GetItemID();

		if ( IsNoRenderHairFace2Face3Equip( dwItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
				case CX2Unit::EP_AC_FACE2:
				case CX2Unit::EP_AC_FACE3:
					(*vItr)->SetShowObject( false );
					break;

				default:
					break;
				}
				vItr++;
			}
		}
		else if ( IsNoRenderHairFace2Equip( dwItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
				case CX2Unit::EP_AC_FACE2:
					(*vItr)->SetShowObject( false );
					break;

				default:
					break;
				}
				vItr++;
			}
		}
		else if ( IsNoRenderHair( pItem->GetItemData().m_ItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();
#ifdef ONE_PIECE_AVATAR
			if(bOnePieceAvatarCheck)
			{
				while ( vItr != m_ViewEqipList.end() )
				{
					switch ( (*vItr)->GetEqipPos() )
					{
					case CX2Unit::EP_AC_FACE1:
						(*vItr)->SetShowObject( false );
						break;

					default:
						break;
					}
					vItr++;
				}
			}
			else
#endif ONE_PIECE_AVATAR
			{
				while ( vItr != m_ViewEqipList.end() )
				{
					switch ( (*vItr)->GetEqipPos() )
					{
					case CX2Unit::EP_DEFENCE_HAIR:
						(*vItr)->SetShowObject( false );
						break;

					default:
						break;
					}
					vItr++;
				}
			}
		}
#ifdef FACE_OFF_MONSTER_HEAD_TEST
		else if ( IsNoRenderHairFaceFace2Face3Equip( dwItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();
#ifdef ONE_PIECE_AVATAR
			if(bOnePieceAvatarCheck)
			{
				while ( vItr != m_ViewEqipList.end() )
				{
					switch ( (*vItr)->GetEqipPos() )
					{
					case CX2Unit::EP_AC_FACE1:
						(*vItr)->SetShowObject( false );
						break;

					default:
						break;
					}
					vItr++;
				}
			}
			else
#endif ONE_PIECE_AVATAR
			{
				SetHideNoRenderable(true);
				while ( vItr != m_ViewEqipList.end() )
				{
					switch ( (*vItr)->GetEqipPos() )
					{
					case CX2Unit::EP_DEFENCE_HAIR:
#ifdef FIX_ARA_ONE_PIECE_FOR_BERSERK
#endif //FIX_ARA_ONE_PIECE_FOR_BERSERK
					case CX2Unit::EP_AC_FACE2:
					case CX2Unit::EP_AC_FACE3:
						(*vItr)->SetShowObject( false );
						break;

					default:
						break;
					}
					vItr++;
				}
			}
		}
		else if ( IsNoRenderHairFaceFace1Face3Equip( dwItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();
#ifdef ONE_PIECE_AVATAR
			if(bOnePieceAvatarCheck)
			{
				while ( vItr != m_ViewEqipList.end() )
				{
					switch ( (*vItr)->GetEqipPos() )
					{
					case CX2Unit::EP_AC_FACE2:
						(*vItr)->SetShowObject( false );
						break;

					default:
						break;
					}
					vItr++;
				}
			}
			else
#endif ONE_PIECE_AVATAR
			{
				SetHideNoRenderable(true);
				while ( vItr != m_ViewEqipList.end() )
				{
					switch ( (*vItr)->GetEqipPos() )
					{
					case CX2Unit::EP_DEFENCE_HAIR:
#ifdef FIX_ARA_ONE_PIECE_FOR_BERSERK
#endif //FIX_ARA_ONE_PIECE_FOR_BERSERK
					case CX2Unit::EP_AC_FACE1:
					case CX2Unit::EP_AC_FACE3:
						(*vItr)->SetShowObject( false );
						break;

					default:
						break;
					}
					vItr++;
				}
			}
		}
#endif FACE_OFF_MONSTER_HEAD_TEST
	}

#endif	NOT_RENDERING_OTHER_EQUIP_POS
#endif //FIX_ARA_ONE_PIECE_FOR_BERSERK


	//{{ kimhc // 2010.12.10 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
	UpdateEquipCollisionData( m_ViewEqipList );
#else	NEW_CHARACTER_CHUNG
	UpdateEquipCollisionData();
#endif	NEW_CHARACTER_CHUNG
	//}} kimhc // 2010.12.10 //  2010-12-23 New Character CHUNG



	//{{ dmlee 2008.04.11 - 장착 캐시 아이템 ability
	if( NULL != g_pX2Game )
	{
#ifdef TEMP_HERO_MATCH_NO_ITEM_ABILITY
		// 대회채널에는 속성, 소켓, 세트, 강화 아무것도 적용안되고, 1레벨 기본 unit stat만 적용된다.
		if( CX2Main::XS_PVP_GAME != g_pMain->GetNowStateID() || 
			KPVPChannelInfo::PCC_TOURNAMENT != g_pMain->GetPVPChannelClass( g_pMain->GetConnectedChannelID() ) )
#endif TEMP_HERO_MATCH_NO_ITEM_ABILITY
		{
			for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
			{
				CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];

				ASSERT( pCX2Eqip != NULL );
				ASSERT( pCX2Eqip->GetItem() != NULL );
				ASSERT( pCX2Eqip->GetItem()->GetItemTemplet() != NULL );

				if ( pCX2Eqip != NULL && pCX2Eqip->GetItem() != NULL && 
                    pCX2Eqip->GetItem()->GetItemTemplet() != NULL 
                    )
				{
                    const CX2Item::ItemTemplet* pItemTemplet = pCX2Eqip->GetItem()->GetItemTemplet();
					g_pX2Game->UseItemSpecialAbility( pItemTemplet, this );
				}
			}
		}
	}
	//}} dmlee 2008.04.11 - 장착 캐시 아이템 ability

}

/*virtual*/ void CX2GUUser::UpdateEquipCollisionData()
{
	
	//{{ kimhc // 2010.12.10 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
	UpdateEquipCollisionData( m_ViewEqipList );
#else	NEW_CHARACTER_CHUNG
	KTDXPROFILE();
	m_CollisionListSet.clear();
	m_AttackListSet.clear();

	for( int i =0; i < (int)m_ViewEqipList.size(); i++ )
	{
		CKTDGXSkinAnim* pAnim = NULL;
		CX2EqipPtr pEqip = m_ViewEqipList[i];
		if ( pEqip == NULL )
			continue;

		if( pEqip->GetEqipType() == CX2Item::UT_ATTACH_ANIM )
		{
			for( int j=0; j<CX2Item::MAX_MODEL_COUNT_A_ITEM; j++ )
			{
				pAnim = pEqip->GetNormalAnim(j);
				if( pAnim != NULL)
				{
					m_CollisionListSet.insert( &pAnim->GetCollisionDataList() );
					m_AttackListSet.insert( &pAnim->GetAttackDataList() );
				}
			}
		}
	}

	m_CollisionListSet.insert( &m_pXSkinAnim->GetCollisionDataList() );
	m_AttackListSet.insert( &m_pXSkinAnim->GetAttackDataList() );
#endif	NEW_CHARACTER_CHUNG
	//}} kimhc // 2010.12.10 // 2010-12-23 New Character CHUNG
}


//{{ kimhc // 2010.12.10 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
void CX2GUUser::UpdateEquipCollisionData( IN vector<CX2EqipPtr>& m_vecEquipList )
{
	KTDXPROFILE();
	m_CollisionListSet.clear();
	m_AttackListSet.clear();


	for( int i =0; i < (int)m_vecEquipList.size(); i++ )
	{
		CKTDGXSkinAnim* pAnim = NULL;
		CX2EqipPtr pEqip = m_vecEquipList[i];
		if ( pEqip == NULL )
			continue;

		if( pEqip->GetEqipType() == CX2Item::UT_ATTACH_ANIM )
		{
			for( int j=0; j<CX2Item::MAX_MODEL_COUNT_A_ITEM; j++ )
			{
				pAnim = pEqip->GetNormalAnim(j);
				if( pAnim != NULL)
				{
					if ( false == pAnim->GetCollisionDataList().empty() )
						m_CollisionListSet.insert( &pAnim->GetCollisionDataList() );

					if ( false == pAnim->GetAttackDataList().empty() )
						m_AttackListSet.insert( &pAnim->GetAttackDataList() );
				}
			}
		}
	}

	m_CollisionListSet.insert( &m_pXSkinAnim->GetCollisionDataList() );
	m_AttackListSet.insert( &m_pXSkinAnim->GetAttackDataList() );
}
#endif	NEW_CHARACTER_CHUNG
//}} kimhc // 2010.12.10 //  2010-12-23 New Character CHUNG



void CX2GUUser::UpdateSlashTraceTextureName()
{
	for( UINT i=0; i<m_vecpWeapon.size(); ++i )
	{
		Weapon* pWeapon = m_vecpWeapon[i];
		if( NULL == pWeapon )
			continue;

		pWeapon->UpdateSlashTraceTextureName();
	}
}

/** @function : ParseCommonRandomState
	@brief : Start, Win, Lose 스테이트를 랜덤하게 로드한다
	@param : 각 랜덤한 start, win, lose 스테이트가 들어있는 직업별 테이블명
*/
void CX2GUUser::ParseCommonRandomState( const char* tableName )
{
	if( true == m_LuaManager.BeginTable( tableName ) )
	{
		if( true == m_LuaManager.BeginTable( "START_STATE_LIST" ) )
		{
			CommonRandomState commonRandomState;
			for( int i=1; ; i+=2 )
			{
				if( false == m_LuaManager.GetValueUtf8( i, commonRandomState.m_StateName ) )
					break;

				if( false == m_LuaManager.GetValue( i+1, commonRandomState.m_iPercent ) )
					break;

				m_vecRandomStartState.push_back( commonRandomState );
			}

			m_LuaManager.EndTable(); // tableName.c_str() 
		}



		if( true == m_LuaManager.BeginTable( "WIN_STATE_LIST" ) )
		{
			CommonRandomState commonRandomState;
			for( int i=1; ; i+=2 )
			{
				if( false == m_LuaManager.GetValueUtf8( i, commonRandomState.m_StateName ) )
					break;

				if( false == m_LuaManager.GetValue( i+1, commonRandomState.m_iPercent ) )
					break;

				m_vecRandomWinState.push_back( commonRandomState );
			}

			m_LuaManager.EndTable(); // tableName.c_str() 
		}



		if( true == m_LuaManager.BeginTable( "LOSE_STATE_LIST" ) )
		{
			CommonRandomState commonRandomState;
			for( int i=1; ; i+=2 )
			{
				if( false == m_LuaManager.GetValueUtf8( i, commonRandomState.m_StateName ) )
					break;

				if( false == m_LuaManager.GetValue( i+1, commonRandomState.m_iPercent ) )
					break;

				m_vecRandomLoseState.push_back( commonRandomState );
			}

			m_LuaManager.EndTable(); // tableName.c_str() 
		}

		m_LuaManager.EndTable(); // tableName.c_str(), ELSWORD_SWORDMAN
	}
}



void CX2GUUser::InitState()
{
	UserUnitStateDataMap::iterator iter;
	for( iter = m_StateList.begin(); iter != m_StateList.end(); iter++ )
	{
		UserUnitStateData* pData = &(iter->second);
		if( pData->StateInit != NULL )
			pData->StateInit();
	}
}


void CX2GUUser::ProcessAcceleraterBuff( CX2SkillTree::SKILL_ID eSkillID, bool bHyperMode )
{
	if( NULL == GetUnit() )
		return;


	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( eSkillID );
	if( NULL == pSkillTemplet )
		return;

	D3DXVECTOR3 vMyPos = GetPos();
	vMyPos.y += 100.0f;

	switch ( eSkillID )
	{
#ifndef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	case CX2SkillTree::SI_SA_COMMON_POWER_ACCEL:
	case CX2SkillTree::SI_SA_COMMON_MAGIC_ACCEL:
	case CX2SkillTree::SI_SA_COMMON_SHIELD_ACCEL:
		{
			/// 액셀러레이터의 경우 추가 시간을 구함
			ApplyAcceleratorBuffToGameUnit( pSkillTemplet, GetAdditionalAccelBuffTime( eSkillID ), vMyPos );
		}
		break;
	case CX2SkillTree::SI_SA_COMMON_AURA_POWER_ACCEL:
	case CX2SkillTree::SI_SA_COMMON_AURA_MAGIC_ACCEL:
	case CX2SkillTree::SI_SA_COMMON_AURA_SHIELD_ACCEL:
	case CX2SkillTree::SI_SA_COMMON_AURA_SPEED_ACCEL:
#endif //UPGRADE_SKILL_SYSTEM_2013

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 공통 스킬 개편, 김종훈

	case CX2SkillTree::SI_SA_COMMON_AURA_POWER_ACCEL:
	case CX2SkillTree::SI_SA_COMMON_AURA_MAGIC_ACCEL:
	case CX2SkillTree::SI_SA_COMMON_AURA_SHIELD_ACCEL:
	case CX2SkillTree::SI_SA_COMMON_AURA_SPEED_ACCEL:

	// 보호, 섬멸, 승리의 문장 추가
	case CX2SkillTree::SI_SA_COMMON_AURA_EL_DEFENCE_ACCEL:				
	case CX2SkillTree::SI_SA_COMMON_AURA_CRITICAL_ACCEL:				
	case CX2SkillTree::SI_SA_COMMON_AURA_ADDATK_ACCEL:
#endif // UPGRADE_SKILL_SYSTEM_2013 // 공통 스킬 개편, 김종훈

		{
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"BuffRingX", vMyPos );
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"BuffRingY", vMyPos );
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"BuffRingZ", vMyPos );

			/// 액셀러레이터의 경우 추가 시간을 구함
			ApplyAuraAcceleratorBuffToGameUnit( pSkillTemplet, GetAdditionalAccelBuffTime( eSkillID ), vMyPos );
		} break;
#ifndef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	case CX2SkillTree::SI_SA_COMMON_POWER_ADRENALIN:
	case CX2SkillTree::SI_SA_COMMON_MAGIC_ADRENALIN:
	case CX2SkillTree::SI_SA_COMMON_SHIELD_ADRENALIN:
		{
			ApplyAcceleratorBuffToGameUnit( pSkillTemplet, 0.f, vMyPos );
		}
		break;
#endif //UPGRADE_SKILL_SYSTEM_2013
	default:
		{
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"BuffRingX", vMyPos );
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"BuffRingY", vMyPos );
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"BuffRingZ", vMyPos );

			ApplyAuraAcceleratorBuffToGameUnit( pSkillTemplet, 0.f, vMyPos );
		}
		break;
	}	
}

/** @function : ApplyAcceleratorBuffToGameUnit
	@brief : 액셀러레이터버프를 자신에게 적용
	@param : 앨셀러레이터스킬템플릿(pSkillTemplet_), 외부요인(fAddtionalAccelBuffTime_)
*/
void CX2GUUser::ApplyAcceleratorBuffToGameUnit( const CX2SkillTree::SkillTemplet* pSkillTemplet_, const float fAddtionalAccelBuffTime_, const D3DXVECTOR3& vMyPos_ )
{
	/// 버프에 걸릴수있는 유닛인지, 사용한 액셀러레이터에 버프팩터가 있는지 검사
	if ( CanApplyBuffToGameUnit() && false == pSkillTemplet_->m_vecBuffFactorPtr.empty() )
	{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		if ( NULL == GetUnit()  )
			return;

		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
		const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet_->m_eID ) );	/// 스킬 레벨
	
		CX2BuffFactorPtr ptrBuffFactorClone = pSkillTemplet_->m_vecBuffFactorPtr[0]->GetClonePtr( iSkillTempletLevel );
#else //UPGRADE_SKILL_SYSTEM_2013
		CX2BuffFactorPtr ptrBuffFactorClone = pSkillTemplet_->m_vecBuffFactorPtr[0]->GetClonePtr();
#endif //UPGRADE_SKILL_SYSTEM_2013
		if ( NULL != ptrBuffFactorClone )
		{
			ptrBuffFactorClone->SetGameUnitBuffFactor( this );	/// 엑셀러레이터 버프팩터 셋팅
			ptrBuffFactorClone->ApplyExternalFactorToFinalizer( BFT_TIME, fAddtionalAccelBuffTime_ );
			if ( SetBuffFactorToGameUnit( *ptrBuffFactorClone ) )
			{
				const WCHAR* pwsCoreParticleName = CX2SkillTree::GetAccelCoreParticleName( pSkillTemplet_->m_eID );	
				ASSERT( NULL != pwsCoreParticleName );

				CKTDGParticleSystem::CParticleEventSequence* pBuffPart = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  pwsCoreParticleName, vMyPos_ );
				if ( NULL != pBuffPart )
					pBuffPart->SetBlackHolePosition( vMyPos_ );
			}
		}
	}
}

/** @function : ApplyAuraAcceleratorBuffToGameUnit
	@brief : 액셀러레이터버프를 특정 범위내의 유닛에게 적용
	@param : 앨셀러레이터스킬템플릿(pSkillTemplet_), 외부요인(fAddtionalAccelBuffTime_)
*/
/*virtual*/ void CX2GUUser::ApplyAuraAcceleratorBuffToGameUnit( const CX2SkillTree::SkillTemplet* pSkillTemplet_, const float fAddtionalAccelBuffTime_, const D3DXVECTOR3& vMyPos_ )
{
	if ( false == pSkillTemplet_->m_vecBuffFactorPtr.empty() )
	{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		if ( NULL == GetUnit()  )
			return;

		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
		const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet_->m_eID ) );	/// 스킬 레벨

		CX2BuffFactorPtr ptrBuffFactorClone = pSkillTemplet_->m_vecBuffFactorPtr[0]->GetClonePtr( iSkillTempletLevel );
#else //UPGRADE_SKILL_SYSTEM_2013
		CX2BuffFactorPtr ptrBuffFactorClone = pSkillTemplet_->m_vecBuffFactorPtr[0]->GetClonePtr();
#endif //UPGRADE_SKILL_SYSTEM_2013

		if ( NULL != ptrBuffFactorClone )
		{
			ptrBuffFactorClone->SetGameUnitBuffFactor( this );
			ptrBuffFactorClone->ApplyExternalFactorToFinalizer( BFT_TIME, fAddtionalAccelBuffTime_ );

			const WCHAR* pwsCoreParticleName = CX2SkillTree::GetAccelCoreParticleName( pSkillTemplet_->m_eID );	
			ASSERT( NULL != pwsCoreParticleName );

			for ( int i = 0; i < g_pX2Game->GetUnitNum(); i++ )
			{
				CX2GameUnit* pGameUnit = g_pX2Game->GetUnit( i );
				if( pGameUnit != NULL && 
					pGameUnit->GetTeam() == GetTeam() &&
					GetDistance3Sq( vMyPos_, pGameUnit->GetPos() ) < 490000.0f &&
					pGameUnit->CanApplyBuffToGameUnit() &&
					( (g_pX2Game->GetGameType() == CX2Game::GT_PVP &&
						pGameUnit->GetGameUnitType() == CX2GameUnit::GUT_USER )	/// PVP에서는 같은 편 유저들에게만
						|| pGameUnit->GetUnitUID() == GetUnitUID() ||	/// 자기 자신에게도
						/// 그외(자기자신이 아니고, PVP의 유저가 아닌 경우)에는 파티원에게
					( NULL != g_pData && NULL != g_pData->GetPartyManager() && true == g_pData->GetPartyManager()->IsMyPartyMember( pGameUnit->GetUnitUID() ) ) ) )
				{
					if ( pGameUnit->SetBuffFactorToGameUnit( *ptrBuffFactorClone ) )
					{
						D3DXVECTOR3 vGameUnitPos = pGameUnit->GetPos();
						vGameUnitPos.y += 100.0f; 
						g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  pwsCoreParticleName, vGameUnitPos );
					}
				}
			}	// for
		}
	}
}

/** @function : CanApplyBuffToGameUnit
	@brief : 버프에 걸릴수 있는 상태인지 알아내는 함수
	@return : 걸릴수 있으면 true, 없으면 false
*/
/*virtual*/ bool CX2GUUser::CanApplyBuffToGameUnit() const
{
	/// GameUnit에서 체크 한 것이 true 인 경우 다시 한번 체크
	if ( CX2GameUnit::CanApplyBuffToGameUnit() 
		&& GetNowStateID() != USI_DIE_FRONT && GetNowStateID() != USI_DIE_BACK )
		return true;
	else
		return false;	/// GameUnit에서 체크한 것이 false면 바로 false로 리턴 함
}

void CX2GUUser::InitEquippedActiveSkillState( bool bOnlySkillLevel /*= false*/ )
{
	ASSERT( NULL != GetUnit() );

	if( NULL == GetUnit() )
		return;

	CX2Unit::UnitData& kUnitData = GetUnit()->AccessUnitData();
	
	CalcEquippedSkillLevelPlusAndMPCost( kUnitData );
	
	if( false == bOnlySkillLevel )
	{
		SetEquippedSkillFunc( kUnitData, false );		// SetEquippedSkillLevel()을 호출하기전에 해야한다.
		SetEquippedSkillFunc( kUnitData, true );		
	}
	
	m_ComboAndSkillChainSystem.ResetStateIdMatchedToChain();
	m_ComboAndSkillChainSystem.ResetChaining();
	m_ComboAndSkillChainSystem.InitSkillStateChained( this );

	SetEquippedSkillLevelCommon( kUnitData, true );
	SetEquippedSkillLevelCommon( kUnitData, false );

	SetEquippedSkillLevel( CX2SkillTree::SI_NONE, true );	
}
void CX2GUUser::InitPassiveSkillState()
{
	InitAdditionalPassive();	/// 패시브로 증가된 효과에 대한 초기화

	m_vecDelegateProcessInAttackResult.resize( 0 );
	m_vecDelegateProcessInDamageReact.resize( 0 );
	m_vecDelegateProcessInCommonFrameMove.resize( 0 );
	m_vecDelegateProcessWithDamageDataInDamageReact.resize( 0 );
	
	// kimhc // 2009-11-27 // 패시브 스킬 초기화 시에 ability값 항등원으로 초기화
	m_SkillRelatedData.SetForceDownValueRateOfMeleeAttack( 1.f );
	m_SkillRelatedData.SetForceDownValueRateOfRangeAttack( 1.f );

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_RF_INDUCE_DESIRE_WINNING, true );

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_RF_INDUCE_DESIRE_WINNING );

		if( NULL != pSkillTemplet )
		{
			float fAddForceDownRate = CalculateIncreasingRate( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_REL, iSkillLevel ) );

			m_SkillRelatedData.SetForceDownValueRateOfMeleeAttack( m_SkillRelatedData.GetForceDownValueRateOfMeleeAttack() + fAddForceDownRate );
			m_SkillRelatedData.SetForceDownValueRateOfRangeAttack( m_SkillRelatedData.GetForceDownValueRateOfRangeAttack() + fAddForceDownRate );
		}
	}
#else //UPGRADE_SKILL_SYSTEM_2013
	int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_INDUCE_DESIRE_WINNING );

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_INDUCE_DESIRE_WINNING, iSkillLevel );

		if( NULL != pSkillTemplet )
		{
			float fAddForceDownRate = CalculateIncreasingRate( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_REL ) );

			m_SkillRelatedData.SetForceDownValueRateOfMeleeAttack( m_SkillRelatedData.GetForceDownValueRateOfMeleeAttack() + fAddForceDownRate );
			m_SkillRelatedData.SetForceDownValueRateOfRangeAttack( m_SkillRelatedData.GetForceDownValueRateOfRangeAttack() + fAddForceDownRate );
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013
	
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_RF_HARDEN_BODY, true );

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_RF_HARDEN_BODY );

		if( NULL != pSkillTemplet )
		{
			const float fDamageRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGED_REL, iSkillLevel );
			m_AdditionalFinalDefenceMultiplier.SetPassiveMultiple( m_AdditionalFinalDefenceMultiplier.GetPassiveMultiple() * fDamageRate );
		}
	}
#else //UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_HARDEN_BODY );

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_HARDEN_BODY, iSkillLevel );

		if( NULL != pSkillTemplet )
		{
			const float fDamageRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGED_REL );
			m_AdditionalFinalDefenceMultiplier.SetPassiveMultiple( m_AdditionalFinalDefenceMultiplier.GetPassiveMultiple() * fDamageRate );
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013

	// kimhc // 2009-11-27 // 패시브 스킬 초기화 시에 ability값 항등원으로 초기화
	m_SkillRelatedData.m_iNoDownDamageAtStandUpAttackPercent = 0;
	
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_GET_CHANCE, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_GET_CHANCE );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_GET_CHANCE );
		if( NULL != pSkillTemplet )
		{
			m_SkillRelatedData.m_iNoDownDamageAtStandUpAttackPercent += 
				(int) (pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE, iSkillLevel ) * 100.f );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_GET_CHANCE, iSkillLevel );
		if( NULL != pSkillTemplet )
		{
			m_SkillRelatedData.m_iNoDownDamageAtStandUpAttackPercent += (int) (pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE ) * 100.f );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}

	/// 길드 스킬 역전의 기회
	const CX2SkillTree::SkillTemplet* pSkillTempletChanceToReverse = 
		GetUnit()->GetUnitData().m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_GP_COMMON_CHANCE_TO_REVERSE, GetUnit()->GetUnitData().m_byMemberShipGrade );
	if ( NULL != pSkillTempletChanceToReverse )
		m_GuildSkillData.m_bLearnChanceToReverse = true;


#ifdef ARA_CHANGE_CLASS_FIRST		/// 아라 1차 전직 소선 - 패시브 기력 활성화 : 다운 수치 감소
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_ALH_VIGOR_ENERGIZE, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_ALH_VIGOR_ENERGIZE );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_ALH_VIGOR_ENERGIZE );
		if( NULL != pSkillTemplet )
		{
			float fAddForceDownRate = CalculateIncreasingRate( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_REL, iSkillLevel ) );

			m_SkillRelatedData.SetForceDownValueRateOfMeleeAttack( m_SkillRelatedData.GetForceDownValueRateOfMeleeAttack() + fAddForceDownRate );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_ALH_VIGOR_ENERGIZE, iSkillLevel );
		if( NULL != pSkillTemplet )
		{
			float fAddForceDownRate = CalculateIncreasingRate( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_REL ) );

			m_SkillRelatedData.SetForceDownValueRateOfMeleeAttack( m_SkillRelatedData.GetForceDownValueRateOfMeleeAttack() + fAddForceDownRate );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}
#endif ARA_CHANGE_CLASS_FIRST

#ifdef CHUNG_FIRST_CLASS_CHANGE // 오현빈
	m_EnchantStatFromPassiveSkill.Init();
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const int iSkillLevelElementalDefenceA = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_A, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	const int iSkillLevelElementalDefenceA = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_A );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if ( 0 < iSkillLevelElementalDefenceA )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_A );
		if( NULL != pSkillTemplet )
		{
			m_EnchantStatFromPassiveSkill.m_fDefBlaze	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FIRE_DEFENCE_ABS, iSkillLevel );
			m_EnchantStatFromPassiveSkill.m_fDefWater	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_WATER_DEFENCE_ABS, iSkillLevel );
			m_EnchantStatFromPassiveSkill.m_fDefNature	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_NATURE_DEFENCE_ABS, iSkillLevel );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_A, iSkillLevelElementalDefenceA );
		if( NULL != pSkillTemplet )
		{
			m_EnchantStatFromPassiveSkill.m_fDefBlaze	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FIRE_DEFENCE_ABS );
			m_EnchantStatFromPassiveSkill.m_fDefWater	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_WATER_DEFENCE_ABS );
			m_EnchantStatFromPassiveSkill.m_fDefNature	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_NATURE_DEFENCE_ABS );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	} // if

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const int iSkillLevelElementalDefenceB = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_B, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	const int iSkillLevelElementalDefenceB = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_B );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if ( 0 < iSkillLevelElementalDefenceB )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_B );
		if( NULL != pSkillTemplet )
		{
			m_EnchantStatFromPassiveSkill.m_fDefWind	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_WIND_DEFENCE_ABS, iSkillLevel );
			m_EnchantStatFromPassiveSkill.m_fDefLight	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_LIGHT_DEFENCE_ABS, iSkillLevel );
			m_EnchantStatFromPassiveSkill.m_fDefDark	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DARK_DEFENCE_ABS, iSkillLevel );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_CFG_ELEMENTAL_DEFENCE_B, iSkillLevelElementalDefenceB );
		if( NULL != pSkillTemplet )
		{
			m_EnchantStatFromPassiveSkill.m_fDefWind	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_WIND_DEFENCE_ABS );
			m_EnchantStatFromPassiveSkill.m_fDefLight	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_LIGHT_DEFENCE_ABS );
			m_EnchantStatFromPassiveSkill.m_fDefDark	+=	pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DARK_DEFENCE_ABS );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	} // if
#ifdef NEW_CHARACTER_EL
	// 불의 신체
	{				
		const CX2SkillTree::SKILL_ID eSkillID = CX2SkillTree::SI_P_SPK_BODY_OF_FIRE;
		const int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( eSkillID );
		if ( 0 < iSkillLevel )
		{
			const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( eSkillID );
			if( NULL != pSkillTemplet )
			{
				m_EnchantStatFromPassiveSkill.m_fDefBlaze += pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FIRE_DEFENCE_ABS, iSkillLevel );
			}
		}
	}
#endif //NEW_CHARACTER_EL

	AddEnchantStatFromPassiveSkillToDefenceEnchantData();
	AddExtraDamageImmuneRateFromPassiveSkillToImmuneData();
#endif // CHUNG_FIRST_CLASS_CHANGE
}

void CX2GUUser::ChangeEquippedSkillState( const int iSkillSlotId_, const int iSkillId_ )
{
	ASSERT( NULL != GetUnit() );
	if ( NULL == GetUnit() )
		return;

	CX2Unit::UnitData& kUnitData = GetUnit()->AccessUnitData();
	 
	// iSkillSlotId_가 B슬롯인지 아닌지..
	bool bSlotB = false;
	// B슬롯이면 B슬롯의 시작 슬롯을 현재 인자로 넘겨진 아이디에서 빼서 (0~3) 사이의 슬롯 Index를 구함
	int iSlotIndex = 0;

	CX2UserSkillTree::GetSlotIndexAndSlotB( IN iSkillSlotId_, OUT iSlotIndex, OUT bSlotB );
	const CX2SkillTree::SKILL_ID eSkillId = static_cast<CX2SkillTree::SKILL_ID>( iSkillId_ );
	const int iSkillLevel = kUnitData.m_UserSkillTree.UpdateEquippedSkillLevelFromAcqureidMap( eSkillId, iSlotIndex, bSlotB );

	// 스킬 변경 장착시 쿨타임 적용
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( eSkillId );
	if ( NULL != pSkillTemplet )
	{
		kUnitData.m_UserSkillTree.SetSkillCoolTimeLeft( eSkillId, pSkillTemplet->GetSkillCoolTimeValue( iSkillLevel ) );
	}
#else // UPGRADE_SKILL_SYSTEM_2013
	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( eSkillId, iSkillLevel );
	if ( NULL != pSkillTemplet )
		pUnitData->m_UserSkillTree.SetSkillCoolTimeLeft( eSkillId, pSkillTemplet->m_fSkillCoolTime );
#endif // UPGRADE_SKILL_SYSTEM_2013
	ChangeEquippedSkillState( kUnitData, eSkillId, iSlotIndex, bSlotB );

}

void CX2GUUser::ChangeEquippedSkillState( CX2Unit::UnitData& kUnitData_, const CX2SkillTree::SKILL_ID eSkillId_, const int iSlotIndex_, const bool bSlotB_ )
{
	// 아이템에의해 스킬레벨이 증가 되거나 MP 양이 변경 된것 처리
	CalcEquippedSkillLevelPlusAndMPCostBySlotID( kUnitData_.m_UserSkillTree, iSlotIndex_, bSlotB_ );

	// 스킬 장착 처리
	SetEquippedSkillFuncBySkillSlotIndex( eSkillId_, iSlotIndex_, bSlotB_ );

	// 장착한 스킬의 Level에 따라는 정보 셋팅(PowerRate 등)
	SetEquippedSkillLevelCommon( kUnitData_, bSlotB_ );

	// 장착한 스킬의 SubState 들 셋팅(필살기가 두개 이상의 스테이트로 이루어진 것들)
	SetEquippedSkillLevel( eSkillId_, false );
}

void CX2GUUser::CalcEquippedSkillLevelPlusAndMPCostBySlotID( CX2UserSkillTree& cUserSkillTree_, const int iSlotIndex_, const bool bSlotB_ )
{
	const CX2UserSkillTree::SkillSlotData* pSkillSlotData = cUserSkillTree_.GetSkillSlot( iSlotIndex_, bSlotB_ );

	if( NULL != pSkillSlotData )
	{
		const int iEquippedSkillLevelPlus = GetSkillLevelUpNum( pSkillSlotData->m_eID );


		float fMpConsumption = GetActualMPConsume( pSkillSlotData->m_eID, pSkillSlotData->m_iSkillLevel + iEquippedSkillLevelPlus );
		
		cUserSkillTree_.SetMpConsumption( iSlotIndex_, bSlotB_, fMpConsumption );		

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경

		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID );
		if ( NULL != pSkillTemplet )
		{
	#ifdef ACTUAL_CB_CONSUME		/// 메모로 인한 캐논볼 추가 소비량 변동에 대한 처리
			const USHORT usAdditionalCBConsumption = GetActualCBConsume( pSkillSlotData->m_eID, pSkillSlotData->m_iSkillLevel + iEquippedSkillLevelPlus );
			cUserSkillTree_.SetCBConsumption( iSlotIndex_, bSlotB_, usAdditionalCBConsumption );
	#else  ACTUAL_CB_CONSUME
			cUserSkillTree_.SetCBConsumption( iSlotIndex_, bSlotB_, pSkillTemplet->m_usCBConsumption );
	#endif ACTUAL_CB_CONSUME

	#ifdef ARA_CHARACTER_BASE
			cUserSkillTree_.SetFPConsumption( iSlotIndex_, bSlotB_, pSkillTemplet->m_usFPConsumtion );
			cUserSkillTree_.SetFPGainCount( iSlotIndex_, bSlotB_, pSkillTemplet->m_usFPGainCount );
	#endif
		}

#else // UPGRADE_SKILL_SYSTEM_2013

		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID, pSkillSlotData->m_iSkillLevel + iEquippedSkillLevelPlus );
		if ( NULL != pSkillTemplet )
		{
	#ifdef ACTUAL_CB_CONSUME		/// 메모로 인한 캐논볼 추가 소비량 변동에 대한 처리
			const USHORT usAdditionalCBConsumption = GetActualCBConsume( pSkillSlotData->m_eID, pSkillTemplet->m_iSkillLevel );
			cUserSkillTree_.SetCBConsumption( iSlotIndex_, bSlotB_, usAdditionalCBConsumption );
	#else  ACTUAL_CB_CONSUME
			cUserSkillTree_.SetCBConsumption( iSlotIndex_, bSlotB_, pSkillTemplet->m_usCBConsumption );
	#endif ACTUAL_CB_CONSUME

	#ifdef ARA_CHARACTER_BASE
			cUserSkillTree_.SetFPConsumption( iSlotIndex_, bSlotB_, pSkillTemplet->m_usFPConsumtion );
			cUserSkillTree_.SetFPGainCount( iSlotIndex_, bSlotB_, pSkillTemplet->m_usFPGainCount );
	#endif
		}

#endif // UPGRADE_SKILL_SYSTEM_2013

		cUserSkillTree_.SetEquippedSkillLevelPlusBySlotIndex( iEquippedSkillLevelPlus, iSlotIndex_, bSlotB_ );
		cUserSkillTree_.UpdateEquippedSkillLevelFromAcqureidMap( pSkillSlotData->m_eID, iSlotIndex_, bSlotB_ );
	}	
}

// 아이템에 의한 현재장착 스킬의 레벨증가 계산
void CX2GUUser::CalcEquippedSkillLevelPlusAndMPCost( CX2Unit::UnitData& kUnitData )
{
	CX2UserSkillTree& cUserSkillTree = kUnitData.m_UserSkillTree;

	for( int i = 0; i < EQUIPPED_SKILL_SLOT_COUNT*2; ++i )
	{
		bool bSlotB = (i > 3) ? true : false;
		int iSlotIndex = (i > 3) ? i-4 : i;
		CalcEquippedSkillLevelPlusAndMPCostBySlotID( cUserSkillTree, iSlotIndex, bSlotB );
	}
}

/** @function : SetEquippedSkillLevelCommon
	@brief : 스킬 슬롯 스테이트의 스킬ID, 스킬 레벨, 파워레이트 등을 스테이트데이터에 초기화
	@param : UnitData*, B슬롯인지 여부
*/
void CX2GUUser::SetEquippedSkillLevelCommon( const CX2Unit::UnitData& kUnitData_, bool bSlotB_ )
{
    const CX2UserSkillTree& userSkillTree = kUnitData_.m_UserSkillTree;

	for( int i=0; i< EQUIPPED_SKILL_SLOT_COUNT; i++ )
	{
		const CX2UserSkillTree::SkillSlotData* pSkillSlotData = userSkillTree.GetSkillSlot( i, bSlotB_ );
		ASSERT( NULL != pSkillSlotData );
		if( NULL == pSkillSlotData )
			continue;

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID );
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = 
			g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID, pSkillSlotData->m_iSkillLevel + pSkillSlotData->m_iSkillLevelPlus );
	#endif // UPGRADE_SKILL_SYSTEM_2013
		if( NULL == pSkillTemplet )
			continue;

		int normalStateID = 0;
		int hyperStateID = 0;

		if( bSlotB_ == false )
		{
			normalStateID	= _CONST_GUUSER_::aNormalSkillStateID[i];
			hyperStateID	= _CONST_GUUSER_::aHyperSkillStateID[i];
		}
		else
		{
			normalStateID	= _CONST_GUUSER_::aNormalSkillStateIDSlotB[i];
			hyperStateID	= _CONST_GUUSER_::aHyperSkillStateIDSlotB[i];
		}

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	
	
		const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
		
		UserUnitStateData& normalStateData = m_StateList[ normalStateID ];
		normalStateData.m_SPLevel = pSkillSlotData->m_iSkillLevel + pSkillSlotData->m_iSkillLevelPlus;
		normalStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( pSkillSlotData->m_iSkillLevel + pSkillSlotData->m_iSkillLevelPlus );
		normalStateData.m_eSkillID = pSkillTemplet->m_eID;


		UserUnitStateData& hyperStateData = m_StateList[ hyperStateID ];
		hyperStateData.m_SPLevel = pSkillSlotData->m_iSkillLevel + pSkillSlotData->m_iSkillLevelPlus;
		hyperStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( pSkillSlotData->m_iSkillLevel + pSkillSlotData->m_iSkillLevelPlus );
		hyperStateData.m_eSkillID = pSkillTemplet->m_eID;
	#else // UPGRADE_SKILL_SYSTEM_2013
		UserUnitStateData& normalStateData = m_StateList[ normalStateID ];
		normalStateData.m_SPLevel = pSkillSlotData->m_iSkillLevel + pSkillSlotData->m_iSkillLevelPlus;
		normalStateData.m_fPowerRate = pSkillTemplet->m_fPowerRate;
		normalStateData.m_eSkillID = pSkillTemplet->m_eID;


		UserUnitStateData& hyperStateData = m_StateList[ hyperStateID ];
		hyperStateData.m_SPLevel = pSkillSlotData->m_iSkillLevel + pSkillSlotData->m_iSkillLevelPlus;
		hyperStateData.m_fPowerRate = pSkillTemplet->m_fPowerRate;
		hyperStateData.m_eSkillID = pSkillTemplet->m_eID;
	#endif // UPGRADE_SKILL_SYSTEM_2013
		
		CX2ComboAndSkillChainInfoPtr ptrComboAndSkillChainInfo
			= m_ComboAndSkillChainSystem.GetSkillChainInfoPtrBySkillID( pSkillTemplet->m_eID );
		if ( NULL != ptrComboAndSkillChainInfo )
		{
			ptrComboAndSkillChainInfo->SetStateIdMatchedToChain( normalStateID );
			ptrComboAndSkillChainInfo->SetHyperStateIdMatchedToChain( hyperStateID );

			normalStateData.m_ptrComboAndSkillChainInfo = ptrComboAndSkillChainInfo;
			hyperStateData.m_ptrComboAndSkillChainInfo = ptrComboAndSkillChainInfo;
		}
	}
}


const CX2SkillTree::SkillTemplet* CX2GUUser::GetEquippedActiveSkillTemplet( CX2SkillTree::SKILL_ID eSkillID ) const
{
	const CX2Unit::UnitData* pUnitData = &GetUnit()->GetUnitData();

	bool bSlotB = false;
	int iSkillSlotIndex = pUnitData->m_UserSkillTree.GetSkillEquippedSlotIndex( eSkillID, bSlotB );
	if( iSkillSlotIndex < 0 )
	{
		bSlotB = true;
		iSkillSlotIndex = pUnitData->m_UserSkillTree.GetSkillEquippedSlotIndex( eSkillID, bSlotB );
		if( iSkillSlotIndex < 0 )
		{
			return pUnitData->m_UserSkillTree.GetUserSkillTemplet( eSkillID );;
		}
	}


	const CX2UserSkillTree::SkillSlotData* pSkillSlotData = pUnitData->m_UserSkillTree.GetSkillSlot( iSkillSlotIndex, bSlotB );
	if( NULL == pSkillSlotData )
		return pUnitData->m_UserSkillTree.GetUserSkillTemplet( eSkillID );;

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const CX2SkillTree::SkillTemplet* pSkillTemplet 
		= g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID );
#else // UPGRADE_SKILL_SYSTEM_2013
	const CX2SkillTree::SkillTemplet* pSkillTemplet 
		= g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID, min( pSkillSlotData->m_iSkillLevel + pSkillSlotData->m_iSkillLevelPlus, 10 ) );
#endif // UPGRADE_SKILL_SYSTEM_2013

	if ( NULL == pSkillTemplet )
		pSkillTemplet = pUnitData->m_UserSkillTree.GetUserSkillTemplet( eSkillID );
	
	return pSkillTemplet;
}

#ifdef SERV_SKILL_NOTE
bool CX2GUUser::GetEqippedSkillMemo(CX2SkillTree::SKILL_MEMO_ID eMemoId) const
{	
#if defined( _IN_HOUSE_ ) || defined( _OPEN_TEST_ ) || defined( _OPEN_TEST_2_ )
	if( g_pInstanceData != NULL )
	{
		if( g_pInstanceData->GetFrameScale() == true )
		{
			return true;
		}
	}		
#endif

	const CX2Unit::UnitData* pUnitData = &GetUnit()->GetUnitData();
	
	return pUnitData->m_UserSkillTree.GetEqipSkillMemo( eMemoId );
}
#endif


//{{ kimhc // 2009-11-18 // 길드스킬과 관련한 Action_ID 처리를 위해 변경
#ifdef	GUILD_SKILL_PART_2

///*virtual*/ bool	CX2GUUser::SpecialAttackNoStageChange( const CX2SkillTree::SkillTemplet* pSkillTemplet )
//{
//	switch ( pSkillTemplet->m_eID )
//	{
//	case CX2SkillTree::SI_GP_COMMON_CHANCE_TO_REVERSE:	// 역전의 기회
//		{
//			// 50% 확률 발동 처리
//			if ( pSkillTemplet != NULL && 
//				 m_SkillRelatedData.m_TimedNCountedCriticalBuff.m_bProcessingBuff == false &&
//				 GetRandomFloat() > 0.5f )
//				 m_FrameDataFuture.syncData.nowAction = UAI_GUILD_CHANGE_TO_REVERSE;
//		}
//		break;
//
//	default:
//		return false;
//	}
//
//	return true;
//}

//void	CX2GUUser::NoStateChangeGuildActionFrameMove()
//{
//	switch ( m_FrameDataNow.syncData.nowAction )
//	{
//	case UAI_GUILD_SACRIFICE_OF_HERO:
//		break;
//
//	default:
//		{
//			if( m_FrameDataFuture.syncData.nowState == GUSI_DIE )
//				return;
//		}
//	}
//
//	switch ( m_FrameDataNow.syncData.nowAction )
//	{
//	case UAI_GUILD_CHANGE_TO_REVERSE:
//		{
//			const CX2Unit::UnitData*	pUnitData	= &GetUnit()->GetUnitData();
//
//			const CX2SkillTree::SkillTemplet* pSkillTemplet = pUnitData->m_UserSkillTree.GetSkillTemplet( CX2SkillTree::SI_GP_COMMON_CHANCE_TO_REVERSE, 
//				pUnitData->m_byMemberShipGrade );	
//
//			if ( pSkillTemplet != NULL )
//			{
//				m_SkillRelatedData.m_TimedNCountedCriticalBuff.m_bProcessingBuff	= true;
//				m_SkillRelatedData.m_TimedNCountedCriticalBuff.m_byCountLeft		= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_COUNT );
//				m_SkillRelatedData.m_TimedNCountedCriticalBuff.m_fTimeLeft			= 30.0f;
//				
//				if ( m_SkillRelatedData.m_TimedNCountedCriticalBuff.m_hSeq == INVALID_PARTICLE_SEQUENCE_HANDLE )
//					m_SkillRelatedData.m_TimedNCountedCriticalBuff.m_hSeq = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"BuffAttack", 0,0,0, 0, 0 );
//
//				CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_SkillRelatedData.m_TimedNCountedCriticalBuff.m_hSeq );
//				if( NULL != pSeq )
//				{
//					pSeq->SetEmitRate( CMinMax<float>(1000,1000) );
//					pSeq->SetPosition( GetPos() );
//				}
//
//			}
//		}
//		break;
//
//	default:
//		break;
//	}
//}

#endif	GUILD_SKILL_PART_2
//}} kimhc // 2009-11-18 // 길드스킬과 관련한 Action_ID 처리를 위해 변경


#ifdef ADD_MEMO_1ST_CLASS //김창한
bool CX2GUUser::CheckSkillUseCondition( CX2SkillTree::ACTIVE_SKILL_USE_CONDITION eActiveSkillUseCondition, CX2SkillTree::ACTIVE_SKILL_USE_CONDITION eActiveSkillUseConditionSkillTemplet )
{


	if( true == GetEntangled() )	// 레나의 인탱글에 걸리면 스킬 사용못함
		return false;

	if( GetNoSkillTime() > 0.f )	// silence 상태일 때 
		return false;

	if( CX2SkillTree::ASUT_NONE == eActiveSkillUseCondition ||
		CX2SkillTree::ASUT_NONE == eActiveSkillUseConditionSkillTemplet )
	{
		return false;
	}


	switch( eActiveSkillUseCondition )
	{
	case CX2SkillTree::ASUT_AIR:
		{
			switch( eActiveSkillUseConditionSkillTemplet )
			{
			default:
				{
					return false;
				} break;

			case CX2SkillTree::ASUT_AIR_ONLY:
			case CX2SkillTree::ASUT_AIR:
				{
				} break;
			}
		} break;

	case CX2SkillTree::ASUT_ANYTIME:
		{
			if( CX2SkillTree::ASUT_ANYTIME_EXCEPT_AIR == eActiveSkillUseConditionSkillTemplet )
			{
				if( false == IsOnSomethingFuture() )
					return false;
			}
			else if( eActiveSkillUseCondition != eActiveSkillUseConditionSkillTemplet )
			{
				return false;
			}
		} break;

	case CX2SkillTree::ASUT_GROUND: 
		{
			switch( eActiveSkillUseConditionSkillTemplet )
			{
			case CX2SkillTree::ASUT_AIR_ONLY:
			case CX2SkillTree::ASUT_ANYTIME:
				{
					return false;
				} break;
			}
		} break;
	}

	return true;
}
#else //ADD_MEMO_1ST_CLASS
bool CX2GUUser::CheckSkillUseCondition( CX2SkillTree::ACTIVE_SKILL_USE_CONDITION eActiveSkillUseCondition, const CX2SkillTree::SkillTemplet* pSkillTemplet )
{


	if( true == GetEntangled() )	// 레나의 인탱글에 걸리면 스킬 사용못함
		return false;

	if( GetNoSkillTime() > 0.f )	// silence 상태일 때 
		return false;

	if( CX2SkillTree::ASUT_NONE == eActiveSkillUseCondition ||
		CX2SkillTree::ASUT_NONE == pSkillTemplet->m_eActiveSkillUseCondtion )
	{
		return false;
	}


	switch( eActiveSkillUseCondition )
	{
	case CX2SkillTree::ASUT_AIR:
		{
			switch( pSkillTemplet->m_eActiveSkillUseCondtion )
			{
			default:
				{
					return false;
				} break;

			case CX2SkillTree::ASUT_AIR_ONLY:
			case CX2SkillTree::ASUT_AIR:
				{
				} break;
			}
		} break;

	case CX2SkillTree::ASUT_ANYTIME:
		{
			if( CX2SkillTree::ASUT_ANYTIME_EXCEPT_AIR == eActiveSkillUseConditionSkillTemplet )
			{
				if( false == IsOnSomethingFuture() )
					return false;
			}
			else if( eActiveSkillUseCondition != pSkillTemplet->m_eActiveSkillUseCondtion )
			{
				return false;
			}
		} break;

	case CX2SkillTree::ASUT_GROUND: 
		{
			switch( pSkillTemplet->m_eActiveSkillUseCondtion )
			{
			case CX2SkillTree::ASUT_AIR_ONLY:
			case CX2SkillTree::ASUT_ANYTIME:
				{
					return false;
				} break;
			}
		} break;
	}

	return true;
}
#endif //ADD_MEMO_1ST_CLASS



bool CX2GUUser::CheckSkillUsePVPOfficial( CX2SkillTree::SKILL_ID eSkill_ID_ )
{
	bool bCheck = true;

	if( NULL != g_pX2Game && CX2Game::GT_PVP != g_pX2Game->GetGameType() )
		return bCheck;

#ifdef NOT_USING_RELATIONSHIP_SKILL_IN_TOURNAMENT_CHANNEL
	bool bIsOfficalChannel = false;	// 공식 대전인가? 공식 대전이 아니고 bCheck 가 false 이면 영웅 대전으로 판단한다.
	// 자유 채널, 연습 채널이 아니면 사용하지 못하게 한다.
	if( g_pMain->GetConnectedChannelID() != KPVPChannelInfo::PCC_E3 &&	// 연습 채널
		g_pMain->GetConnectedChannelID() != KPVPChannelInfo::PCC_E5 )	// 자유 채널
#else // NOT_USING_RELATIONSHIP_SKILL_IN_TOURNAMENT_CHANNEL
	if( g_pMain->GetConnectedChannelID() == KPVPChannelInfo::PCC_OFFICIAL )
#endif // NOT_USING_RELATIONSHIP_SKILL_IN_TOURNAMENT_CHANNEL
	{
#ifdef ADDED_RELATIONSHIP_SYSTEM
		if( CX2SkillTree::SI_ETC_WS_COMMON_LOVE == eSkill_ID_ )
		{
#ifdef NOT_USING_RELATIONSHIP_SKILL_IN_TOURNAMENT_CHANNEL				
			if ( g_pMain->GetConnectedChannelID() == KPVPChannelInfo::PCC_OFFICIAL )
				bIsOfficalChannel = true;
#endif // NOT_USING_RELATIONSHIP_SKILL_IN_TOURNAMENT_CHANNEL		
			bCheck = false;
		}
#endif //ADDED_RELATIONSHIP_SYSTEM
	}

	if( false == bCheck )
	{
#ifdef NOT_USING_RELATIONSHIP_SKILL_IN_TOURNAMENT_CHANNEL				
		if ( false == bIsOfficalChannel )
		{	// 공식 대전이 아닌 경우, 즉 영웅 대전일 때
			g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_28982 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
		}
		else
#endif // NOT_USING_RELATIONSHIP_SKILL_IN_TOURNAMENT_CHANNEL		
		{	// 공식 대전 일 경우 
			g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_24675 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
		}
	}

	return bCheck;
}

void CX2GUUser::DoStateEndStartFuture()
{
	KTDXPROFILE();

	if( m_FrameDataFuture.syncData.stateChangeNum != m_FrameDataFuture.unitCondition.stateChangeNum )
	{

		bool bTableOpen = m_LuaManager.BeginTableByReference( m_FutureStateData.stateID );
		{
			m_FrameDataFuture.syncData.stateChangeNum = m_FrameDataFuture.unitCondition.stateChangeNum ;
			if( m_FutureStateData.StateEndFuture != NULL )
				m_FutureStateData.StateEndFuture();
			else
				CommonStateEndFuture();

		}

		if( true == bTableOpen )
			m_LuaManager.EndTable();



		m_FrameDataFuture.syncData.nowState			= m_FrameDataFuture.unitCondition.nextState;
		m_FrameDataFuture.syncData.nowSubState		= m_FrameDataFuture.unitCondition.nextSubState;
		//m_FrameDataFuture.unitCondition.nextState	= GUSI_NONE;

		m_FutureStateData			= m_StateList[m_FrameDataFuture.syncData.nowState];
		//m_FutureStateData.stateID	= m_FrameDataFuture.syncData.nowState;	/// FieldFix: 이게 필요 한가?? 이것만 없으면 그냥 포인터 형식으로 사용해도 될듯.
		//{{ robobeg : 2008-10-28
		//m_StateTableNameFuture		= m_FutureStateData.stateTable;
		//}} robobeg : 2008-10-28


		bTableOpen = m_LuaManager.BeginTableByReference( m_FutureStateData.stateID );
		{
			if( m_FutureStateData.StateStartFuture != NULL )
				m_FutureStateData.StateStartFuture();
			else
				CommonStateStartFuture();
		}

		if( true == bTableOpen )
			m_LuaManager.EndTable();

	}
}

void CX2GUUser::DoStateEndStart()
{
	KTDXPROFILE();

	if( m_FrameDataNow.syncData.stateChangeNum != m_FrameDataNow.unitCondition.stateChangeNum )
	{
		m_FrameDataNow.unitCondition.stateChangeNum = m_FrameDataNow.syncData.stateChangeNum;

		bool bTableOpen = m_LuaManager.BeginTableByReference( m_NowStateData.stateID );
		{
			if( m_NowStateData.StateEnd != NULL )
				m_NowStateData.StateEnd();
			else
				CommonStateEnd();

		}

		if( true == bTableOpen )
			m_LuaManager.EndTable();


		//m_FrameDataNow.unitCondition.nextState	= GUSI_NONE;

		m_NowStateData			= m_StateList[m_FrameDataNow.syncData.nowState];
		m_NowStateData.stateID	= m_FrameDataNow.syncData.nowState;
		//{{ robobeg : 2008-10-28
		//m_StateTableName		= m_NowStateData.stateTable;
		//}} robobeg : 2008-10-28

		bTableOpen = m_LuaManager.BeginTableByReference( m_NowStateData.stateID );
		{
			if( m_NowStateData.StateStart != NULL )
				m_NowStateData.StateStart();
			else
				CommonStateStart();

		}
		if( true == bTableOpen )
			m_LuaManager.EndTable();

	}
}

void CX2GUUser::DoFrameMoveFuture()
{
	KTDXPROFILE();


	bool bTableOpen = m_LuaManager.BeginTableByReference( m_FutureStateData.stateID );
	{
		if( m_FutureStateData.OnFrameMoveFuture != NULL )
			m_FutureStateData.OnFrameMoveFuture();
		else
			CommonFrameMoveFuture();

		if( m_FutureStateData.OnEventProcess != NULL )
			m_FutureStateData.OnEventProcess();
	}

	if( true == bTableOpen )
		m_LuaManager.EndTable();

}

void CX2GUUser::DoFrameMove()
{
	KTDXPROFILE();


	bool bTableOpen = m_LuaManager.BeginTableByReference( m_NowStateData.stateID );
	{
		if( m_NowStateData.OnFrameMove != NULL )
			m_NowStateData.OnFrameMove();
		else
			CommonFrameMove();
	}

	if( true == bTableOpen )
		m_LuaManager.EndTable();


#ifdef DASH_CAMERA_ANGLE_TEST

	// 사용되지 않는 코드 입니다
//{{AFX
	bool bCheck = false;
	if ( CheckDashAngleChangeTime() == true )
	{
		if ( g_pX2Game->GetInputData()->pureRight == true || g_pX2Game->GetInputData()->pureLeft == true )
		{
			bCheck = true;
			m_fTimeToReturnCameraAngle = 0.5f;
			m_fTimeToDashCameraChange += m_fElapsedTime;
		}
	}


	//손가락에서 띤 다음에 어느정도 카운트 세다가 0.0f로 옮겨볼까??
	if ( bCheck == false )
	{
		m_fTimeToReturnCameraAngle -= m_fElapsedTime;

		if ( m_fTimeToReturnCameraAngle <= 0.0f )
		{
			m_fAngleDegree = 0.0f;
			m_fTimeToDashCameraChange = 0.0f;
			m_fTimeToReturnCameraAngle = 0.0f;
		}
	}
//}}AFX

#endif DASH_CAMERA_ANGLE_TEST
}





HRESULT CX2GUUser::OnFrameMove( double fTime, float fElapsedTime )
{
	KTDXPROFILE();

	CX2GameUnit::OnFrameMove( fTime, fElapsedTime );

//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
    IncrementLocalRelativePosTimers( fElapsedTime );
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC

	m_fConnectTimeOut += m_fElapsedTime;

	if( m_fSocketSuperArmor > 0.f )
	{
		m_fSocketSuperArmor -= fElapsedTime;
		if( m_fSocketSuperArmor <= 0.f )
			m_fSocketSuperArmor = 0.f;
	}

	if( g_pX2Room != NULL )
	{
		CX2Room::SlotData* pSlotData = g_pX2Room->GetSlotDataByUnitUID( GetUnitUID() );
		if( pSlotData != NULL )
		{
			// fix!! 여기에서 이렇게 pointer만 교체해주면 될 문제가 아닌 것 같은데...
			if( pSlotData->m_pUnit != GetUnit() )
			{
				StateLog( L"who am I? possible slotdata error" );
				ASSERT( !"who am I" );
				m_pUnit = pSlotData->m_pUnit;
			}
		}
		else
		{
			//이런 일이 생기면 안됨. 생기면 유닛 객체 지우고 리브룸 처리 해야 함

			ASSERT( !"my slot data is null" );
			m_pUnit = NULL;

#ifdef GUUSER_UNIT_POINTER_CRASH_FIX // test error log
			ErrorLogMsg( XEM_ERROR1, L"my slot data is null!!!" );
#endif GUUSER_UNIT_POINTER_CRASH_FIX			
		}
	}

	if( m_fConnectTimeOut >= 10.0f )
	{		
		if( m_bConnectSend == false )
		{
			if( m_bConnect == false )
			{
				//이 유닛은 P2P 접속에 실패했다
				KEGS_GAME_P2P_CONNECT_RESULT_REQ kPacket;
				kPacket.m_UnitUID			= m_UnitUID;
				kPacket.m_bConnectSuccess	= false;
				//g_pData->GetServerProtocol()->SendPacket( EGS_GAME_P2P_CONNECT_RESULT_REQ, kPacket );
				ErrorLogMsg( XEM_ERROR87, L"P2PFail" );
			}
			else
			{
				//이 유닛은 P2P 접속에 성공했다
				KEGS_GAME_P2P_CONNECT_RESULT_REQ kPacket;
				kPacket.m_UnitUID			= m_UnitUID;
				kPacket.m_bConnectSuccess	= true;
				//g_pData->GetServerProtocol()->SendPacket( EGS_GAME_P2P_CONNECT_RESULT_REQ, kPacket );
			}

			m_bConnectSend = true;
		}
	}

	if( g_pKTDXApp->GetIsNowVeryfy() == true )
	{
		Verify();
	}

	if( GetNowHp() <= 0.f )
	{
		m_fDieAfterTime += m_fElapsedTime;
		m_fRebirthTime -= m_fElapsedTime;
		if( m_fRebirthTime < 0.0f )
			m_fRebirthTime = 0.0f;
	}

	if ( m_pXSkinAnim != NULL )
	{	
#ifdef VERIFY_STAT_BY_BUFF
		m_pXSkinAnim->GetMatrix().Scale( m_vTransScale.GetVector3() * m_fBasicBoneScale );
#else	// VERIFY_STAT_BY_BUFF
		m_pXSkinAnim->GetMatrix().Scale( m_vTransScale * m_fBasicBoneScale );
#endif // VERIFY_STAT_BY_BUFF
	}

	if ( m_pXSkinAnimFuture != NULL )
	{
#ifdef VERIFY_STAT_BY_BUFF
		m_pXSkinAnimFuture->GetMatrix().Scale( m_vTransScale.GetVector3() * m_fBasicBoneScale );
#else	// VERIFY_STAT_BY_BUFF
		m_pXSkinAnim->GetMatrix().Scale( m_vTransScale * m_fBasicBoneScale );
#endif // VERIFY_STAT_BY_BUFF
	}

	if( m_NowStateData.stateID == GUSI_DIE )
	{
		return S_OK;
	}

	//{{ kimhc // 2009-11-20 // 길드 스킬 3, 4라인
#ifdef	GUILD_SKILL_PART_2
	if ( GetNowMp() > 0.0f )
	{
		// 길드스킬 3라인, 끝없는 체력
		if ( m_GuildSkillData.m_InfiniteStrength.m_byCountLeft != 0 )
		{
			if ( m_GuildSkillData.m_InfiniteStrength.IsElaspedTimeOverGap( fElapsedTime ) == true )
			{
				// 회복
				UpNowHp( m_GuildSkillData.m_InfiniteStrength.m_fRecoveryHpOnce );

				if ( m_GuildSkillData.m_InfiniteStrength.m_byCountLeft == 0 )
					PlaySound( L"GS_Infinite_Strength.ogg" );

				std::wstringstream strStream;
				strStream << L"HP+ " << static_cast< int >( m_GuildSkillData.m_InfiniteStrength.m_fRecoveryHpOnce );
				D3DXVECTOR3 pos = GetPos();
				pos.y += 50.0f;
				if( NULL != g_pData->GetPicCharGreen() )
					g_pData->GetPicCharGreen()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );
			}
		}

		if ( m_GuildSkillData.m_InfiniteStrength.m_hSeqEffect != INVALID_PARTICLE_SEQUENCE_HANDLE )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_GuildSkillData.m_InfiniteStrength.m_hSeqEffect );

			if ( pSeq != NULL )
			{
				D3DXVECTOR3 pos = GetPos();
				pos.y += 60.0f;
				pSeq->SetBlackHolePosition( pos );
				if( pSeq->GetTime() > 1.5f )
				{
					pSeq->SetGravity( CMinMax<D3DXVECTOR3>(D3DXVECTOR3(0.0f, 0.0f, 0.0f), D3DXVECTOR3(0.0f, 0.0f, 0.0f)) );
					pSeq->SetUseLand( false );
				}
			}
			else
			{
				m_GuildSkillData.m_InfiniteStrength.m_hSeqEffect = INVALID_PARTICLE_SEQUENCE_HANDLE;
			}
		}
	}
#endif	GUILD_SKILL_PART_2
	//}} kimhc // 2009-11-20 // 길드 스킬 3, 4라인


//{{ kimhc // 2010.4.6 // 비밀던전 작업(셋트아이템효과)
#ifdef SERV_SECRET_HELL
	CheckNChangeManaRecoveryValueNTime( fElapsedTime );
	CheckNChangeIntervalTimeForCureDebuff( fElapsedTime );
	CheckAndDeleteBoneShield( fElapsedTime );

#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
	CheckSocketOptionCoolTime( fElapsedTime );
	CheckSocketOptionHyperCoolTime( fElapsedTime );
	CheckSocketMpUpAttackedCoolTime( fElapsedTime );
#endif //ADJUST_SECRET_ITEM_OPTION

#endif SERV_SECRET_HELL
//}} kimhc // 2010.4.6 // 비밀던전 작업(셋트아이템효과)

	//////////////////////////////////////////////////
	// Future 
	//////////////////////////////////////////////////
	if( IsLocalUnit() == true )
	{	
		ResetNotBusyTimerOnSpecificState();

		// 일정시간마다 random seed를 변경해서 sync를 맞춘다. 
		// 원래는 상태가 바뀔때 마다 random seed를 바꿨는데 상태가 바뀌지 않으면 random seed가 바뀌지 않는 문제가 있어서 
		// 일단은 상태가 바뀔 때 random seed를 새로 갱신하는 코드도 그대로 남겨둔다
		if( m_TimerRandomSeedSync.elapsed() > CX2GameUnit::RANDOM_SEED_RESET_TIME )
		{
			m_TimerRandomSeedSync.restart();

#ifdef NEW_RANDOM_TABLE_TEST
			m_FrameDataFuture.syncData.m_usRandomTableIndex = (USHORT) ( rand() % CKTDXRandomNumbers::RANDOM_NUMBER_COUNT );
#else NEW_RANDOM_TABLE_TEST
//{{AFX
			m_FrameDataFuture.syncData.m_RandSeed = rand() % 100;
			m_FrameDataFuture.syncData.m_RandSeed2 = rand() % 100;
//}}AFX
#endif NEW_RANDOM_TABLE_TEST		
		}


		if( m_FrameDataFuture.unitCondition.fStopTime <= 0.0f && 
			m_FrameDataFuture.unitCondition.fStop2Time <= 0.0f )
		{
			m_FrameDataFuture.syncData.bFrameStop = false;

			DoStateEndStartFuture();
			DoFrameMoveFuture();
		}
		else
		{
			m_FrameDataFuture.syncData.bFrameStop = true;

			m_FrameDataFuture.unitCondition.fStopTime -= fElapsedTime;
			if( m_FrameDataFuture.unitCondition.fStopTime < 0.0f )
				m_FrameDataFuture.unitCondition.fStopTime = 0.0f;
			m_FrameDataFuture.unitCondition.fStop2Time -= fElapsedTime;
			if( m_FrameDataFuture.unitCondition.fStop2Time < 0.0f )
				m_FrameDataFuture.unitCondition.fStop2Time = 0.0f;
		}

//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
        if ( IsMyUnit() == true )
        {
            PhysicProcess_UpdateRelativePos();
        }
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC

//#ifdef  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
        PushFrameData( ( g_pX2Game->IsHost() == true && g_pX2Game->IsPacketSendFrame() == true ) ? true : false );
//#else   SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
//		PushFrameData();
//#endif  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
	}

	//////////////////////////////////////////////////
	// Now
	//////////////////////////////////////////////////

//#ifdef  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
    bool    bPopOnce = false;
    bool    bPopAgain = false;
    m_bPopAgain = false;
//#endif  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    bool    bFrameBufferPass = false;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	do
	{
//#ifdef  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        bFrameBufferPass = false;
        bPopAgain = PopFrameData( bPopOnce, bFrameBufferPass );
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        bPopAgain = PopFrameData( bPopOnce );
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        if ( bPopAgain == true )
        {
            m_bPopAgain = true;
            bPopOnce = true;
        }
        else
        {
            m_bPopAgain = false;
        }
//#else   SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
//		PopFrameData();
//#endif  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        if( bFrameBufferPass == false )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		if( m_FrameDataNow.unitCondition.bFrameBufferPass == false )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		{
			DoStateEndStart();
			DoFrameMove();
		}

		// weapon 
		for( UINT i=0; i<m_vecpWeapon.size(); i++ )
		{
			Weapon* pWeapon = m_vecpWeapon[i];
			pWeapon->OnFrameMove( fTime, fElapsedTime );
		}

	} while( m_bPopAgain == true );


	// 더블어택 처리
	m_fDoubleAttackTime += fElapsedTime;
	if(m_fDoubleAttackTime >= 0.2f && m_bDoubleAttack == true )
	{
		DamageDoubleAttack();
	}

#ifdef BALANCE_PATCH_20110303
	if( m_fMaxDownForce > -9999.f &&
		g_pX2Game->GetGameType() == CX2Game::GT_PVP )
	{
		m_fLastDamagePassTime = 0.f;
		AddForceDownGage( m_fMaxDownForce );		
	}
	m_fMaxDownForce = -9999.f;
#endif

#ifdef FIX_SKILL_SLOT_CHANGE_BUG
	if( m_fSlotChangeLeftCoolTime > 0.f )
		m_fSlotChangeLeftCoolTime -= fElapsedTime;
#endif // FIX_SKILL_SLOT_CHANGE_BUG

	return S_OK;
}

HRESULT CX2GUUser::OnCameraMove()
{


#ifdef CAMERA_SCRIPTING_TEST
	g_pX2Game->GetX2Camera()->GetLineScriptedCameraData().m_vFinalRelativeEyePosition = D3DXVECTOR3( 0, 0, 0 );
#endif CAMERA_SCRIPTING_TEST


#ifdef BUBBLE_BOBBLE_TEST
	if( true == g_pX2Game->GetFixedCamera() )
	{
		CX2World* pWorld = g_pX2Game->GetWorld();
		CKTDGLineMap* pLineMap = pWorld->GetLineMap();
		if( NULL != pWorld && NULL != pLineMap )
		{
			g_pX2Game->GetX2Camera()->FixedCamera( this, pWorld->GetLookAt(), pWorld->GetEye(), pLineMap->GetXMin(), pLineMap->GetXMax(),
				pLineMap->GetYMin(), pLineMap->GetYMax() );
		}
	}
	else
#endif BUBBLE_BOBBLE_TEST
	{

#ifdef WORLD_TRIGGER
		if( g_pX2Game != NULL && g_pX2Game->GetWorld() != NULL )
		{
			int iCameraIndex = g_pX2Game->GetWorld()->GetTriggerCamera();
			if( iCameraIndex >= 0 )
			{
				const CKTDGLineMap::CameraData* pCameraData = g_pX2Game->GetWorld()->GetLineMap()->GetCameraDataList( iCameraIndex );
				if( pCameraData != NULL )
				{
					g_pX2Game->GetX2Camera()->GameLineCamera( this, pCameraData->m_vEye, pCameraData->m_vLookAt, pCameraData->m_bFocusUnit, 0.4f );	
					return S_OK;
				}				
			}
		}
#endif

		if( g_pMain->GetGameOption().GetOptionList().m_bDynamicCamera == false &&
			g_pX2Game != NULL && g_pX2Game->GetWorld() != NULL && g_pX2Game->GetWorld()->GetLineMap() != NULL )
		{ 
#ifdef FIX_BATTLE_FIELD_DYNAMIC_CAMERA
			if( 0.f < fPreWorldNear )
			{ // 다이나믹 카메라에 의해 SetNear값을 10으로 보정 한 상태라면 원복
				g_pKTDXApp->GetDGManager()->SetNear(fPreWorldNear);
				fPreWorldNear = -1.f;

				g_pKTDXApp->GetDGManager()->SetProjection( 
					g_pKTDXApp->GetDGManager()->GetNear(),
					g_pKTDXApp->GetDGManager()->GetFar(), true );
			}
#endif // FIX_BATTLE_FIELD_DYNAMIC_CAMERA

			const CKTDGLineMap::CameraData* pCameraData = g_pX2Game->GetWorld()->GetLineMap()->GetCameraData( m_FrameDataFuture.syncData.lastTouchLineIndex );
			if( NULL != pCameraData )
			{
#ifdef CHECK_CAMERA_INFO
				m_bIsLineMapCamera = true;
#endif //CHECK_CAMERA_INFO

				switch( pCameraData->m_eType )
				{
				case CKTDGLineMap::LCT_ABSOULTE_POSITION:
					{
						g_pX2Game->GetX2Camera()->GameLineCamera( this, pCameraData->m_vEye, pCameraData->m_vLookAt, pCameraData->m_bFocusUnit, 0.4f );			
					} break;
				case CKTDGLineMap::LCT_RELATIE_POSITION:
					{
#ifdef CAMERA_SCRIPTING_TEST
						g_pX2Game->GetX2Camera()->GetLineScriptedCameraData().m_vFinalRelativeEyePosition = pCameraData->m_vRelativeEye;
						g_pX2Game->GetX2Camera()->GetLineScriptedCameraData().m_fSpeed = pCameraData->m_fCameraRepositionSpeed;
#endif CAMERA_SCRIPTING_TEST

						g_pX2Game->GetX2Camera()->NomalTrackingCamera( this, g_pMain->GetGameOption().GetCameraDistance() );

					} break;

				default:
					{
						g_pX2Game->GetX2Camera()->NomalTrackingCamera( this, g_pMain->GetGameOption().GetCameraDistance() );

					} break;
				}
			}
			else
			{
#ifdef CHECK_CAMERA_INFO
				m_bIsLineMapCamera = false;
#endif //CHECK_CAMERA_INFO

#ifdef SERV_CHUNG_TACTICAL_TROOPER
				if( m_GameCameraOffset.bEnable == true )
				{
					g_pX2Game->GetX2Camera()->NomalTrackingCamera( this, g_pMain->GetGameOption().GetCameraDistance() + m_GameCameraOffset.fCameraDistance,
																		200.f + m_GameCameraOffset.fHeight,
																		0.f + m_GameCameraOffset.fAngleDegree,				
																		0.f + m_GameCameraOffset.fEyeDistance,
																		0.f + m_GameCameraOffset.fLookatDistance,
																		0.3f + m_GameCameraOffset.fTrackingTime,
																		0.0f + m_GameCameraOffset.fTrackingAtTime );

				}
				else
					g_pX2Game->GetX2Camera()->NomalTrackingCamera( this, g_pMain->GetGameOption().GetCameraDistance() );
#else
				g_pX2Game->GetX2Camera()->NomalTrackingCamera( this, g_pMain->GetGameOption().GetCameraDistance() );
#endif SERV_CHUNG_TACTICAL_TROOPER
			}			
		}
		else
		{
			if( true == m_LuaManager.BeginTableByReference( m_NowStateData.stateID ) )
			{
				// 다른 카메라 무브가 있는 경우 자신의 유닛 또는 거리가 일정거리 내에 있는 유닛이 아니면 카메라 발동 안함
				if( m_NowStateData.OnCameraMove != NULL )
					//&& ( IsMyUnit() || GetDistance3Sq( g_pX2Game->GetMyUnit()->GetPos(), GetPos() ) ) )
					m_NowStateData.OnCameraMove();
				else
#ifdef RIDING_SYSTEM
				{
					if ( true == GetRidingOn() && NULL != m_ptrRidingPet )
						m_ptrRidingPet->CommonCameraFrameMove();
					else
						CommonCameraMove();
				}
#else //RIDING_SYSTEM
					CommonCameraMove();
#endif //RIDING_SYSTEM
					


				m_LuaManager.EndTable();
			}
		}
	}

	return S_OK;
}


//{{ robobeg : 2008-10-28

/*virtual*/
RENDER_HINT CX2GUUser::OnFrameRender_Prepare()
{
	if ( m_bFirstDataReceive == false )
		return RENDER_HINT_NORENDER;

	bool bTableOpen = false;
	RENDER_HINT renderHint;
	//{{ robobeg : 2008-10-28
	//bTableOpen = m_LuaManager.BeginTable( m_StateTableName.c_str() );
	bTableOpen = m_LuaManager.BeginTableByReference( m_NowStateData.stateID );
	//}} robobeg : 2008-10-28
	{
		renderHint = CommonRender_Prepare();
	}
	if( bTableOpen == true )
		m_LuaManager.EndTable();

	return renderHint;
}//CX2GUUser::OnFrameRender_Prepare()


/*virtual*/
RENDER_HINT CX2GUUser::CommonRender_Prepare()
{
	if ( m_pXSkinAnim == NULL )
		return RENDER_HINT_NORENDER;

	m_pXSkinAnim->SetInstantShow( false );
	if ( !m_pXSkinAnim->GetShowObject() )
		return RENDER_HINT_NORENDER;

	CKTDGXRenderer::RenderParam* pRenderParam = m_pXSkinAnim->GetRenderParam();
	*pRenderParam = m_RenderParam;



	//{{ 2011-04 에 패치될 청 캐시 스킬
#ifdef	CASH_SKILL_FOR_CHUNG_2011_04				
	// ExtraDamage Pain이 적용 중이면
	if ( 0 < m_ExtraDamagePack.m_Pain.m_Accumulation )
		pRenderParam->renderType = CKTDGXRenderer::RT_CARTOON_FADE;	
#endif	CASH_SKILL_FOR_CHUNG_2011_04
	//}} 2011-04 에 패치될 청 캐시 스킬

	//{{ kimhc // 2009-12-29 // 영웅의 희생이 발동 중이면 RT_CARTOON_FADE_NONTEX로 셋팅
#ifdef	GUILD_SKILL_PART_2
	if ( m_bHaveSacrificeOfHero == true )
		pRenderParam->renderType = CKTDGXRenderer::RT_CARTOON_FADE_NONTEX;
#endif	GUILD_SKILL_PART_2
	//}} kimhc // 2009-12-29 // 영웅의 희생이 발동 중이면 RT_CARTOON_FADE_NONTEX로 셋팅

	if( g_pX2Game->GetWorld() != NULL && m_bUseWorldColor == true )
	{
		pRenderParam->lightPos = g_pX2Game->GetWorld()->GetLightPos();
	}

#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE //김창한
	if( false == m_bSetCustomRenderParam )
#endif //SERV_ELESIS_SECOND_CLASS_CHANGE
		ApplyRenderParam( pRenderParam );

	if( GetDistanceToCamera() > 700.0f )
	{
		pRenderParam->fOutLineWide = GetDistanceToCamera() / 1000.0f ;
	}
	else
	{
		pRenderParam->fOutLineWide = GetDistanceToCamera() / 500.0f ;
	}

	if( IsSuperArmor() && m_FrameDataNow.stateParam.bSuperArmorNotRed == false)
	{
		if( pRenderParam->renderType == CKTDGXRenderer::RT_CARTOON_BLACK_EDGE )
		{
			pRenderParam->renderType = CKTDGXRenderer::RT_CARTOON_COLOR_EDGE;
			pRenderParam->outLineColor = 0xffff0000;
		}
	}

	if( g_pMain->GetGameOption().GetOptionList().m_UnitDetail == CX2GameOption::OL_MEDIUM )
	{
		pRenderParam->renderType = CKTDGXRenderer::RT_CARTOON;
	}
	else if( g_pMain->GetGameOption().GetOptionList().m_UnitDetail == CX2GameOption::OL_LOW )
	{
		pRenderParam->renderType = CKTDGXRenderer::RT_REAL_COLOR;
	}

	if( m_DamageLightTime > 0.0f && g_pMain->GetGameOption().GetOptionList().m_UnitDetail != CX2GameOption::OL_LOW )
	{
		if( m_FrameDataNow.unitCondition.bAttackerFront == true )
		{
			if( m_FrameDataNow.syncData.bIsRight == true )
			{
				pRenderParam->lightPos = GetPos() + GetDirVector() * 1000.0f;
				pRenderParam->lightPos -= GetPos();
			}
			else
			{
				pRenderParam->lightPos = GetPos() - GetDirVector() * 1000.0f;
				pRenderParam->lightPos -= GetPos();
			}
		}
		else
		{
			if( m_FrameDataNow.syncData.bIsRight == true )
			{
				pRenderParam->lightPos = GetPos() - GetDirVector() * 1000.0f;
				pRenderParam->lightPos -= GetPos();
			}
			else
			{
				pRenderParam->lightPos = GetPos() + GetDirVector() * 1000.0f;
				pRenderParam->lightPos -= GetPos();
			}
		}

		pRenderParam->cartoonTexType	= CKTDGXRenderer::CTT_DAMAGE;

		switch( pRenderParam->renderType )
		{
		case CKTDGXRenderer::RT_CARTOON_BLACK_EDGE:
			pRenderParam->renderType = CKTDGXRenderer::RT_ADD_CARTOON_BLACK_EDGE;
			break;

		case CKTDGXRenderer::RT_CARTOON_COLOR_EDGE:
			pRenderParam->renderType = CKTDGXRenderer::RT_ADD_CARTOON_COLOR_EDGE;
			break;

		case CKTDGXRenderer::RT_CARTOON:
			pRenderParam->renderType = CKTDGXRenderer::RT_ADD_CARTOON;
			break;
		}
	}


	if( m_fShowInvincibleTime > 0.0f && m_bShowInvincibleWhite == true )
	{
		pRenderParam->cartoonTexType	= CKTDGXRenderer::CTT_INVINCIBLE;
		pRenderParam->renderType		= CKTDGXRenderer::RT_ADD_CARTOON;
	}

	//{{ 2011-04 에 패치될 청 캐시 스킬
#ifdef	CASH_SKILL_FOR_CHUNG_2011_04				
	// EDT_PAIN이 걸려있으면 다른 EDT에 의한 색 변경은 일어나지 않는다.
	if ( m_ExtraDamagePack.m_Pain.m_Accumulation == 0 )
#endif	CASH_SKILL_FOR_CHUNG_2011_04				
	//}} 2011-04 에 패치될 청 캐시 스킬
	{
		//특수데미지 체크
		if( m_ExtraDamagePack.m_Frozen.m_fTime > 0.f )
		{
			pRenderParam->renderType			= CKTDGXRenderer::RT_CARTOON_FADE;
			m_RenderParam.color = D3DXCOLOR( 160.f/255.f, 235.f/255.f, 1.f, 0.7f );
		}
		else if( m_ExtraDamagePack.m_EnchantShock.m_fTime > 0.f )
		{
			pRenderParam->renderType			= CKTDGXRenderer::RT_CARTOON_BLACK_EDGE;
			pRenderParam->cartoonTexType		= CKTDGXRenderer::CTT_PETRIFIED;
			pRenderParam->outLineColor			= D3DXCOLOR( 0.7f, 0.7f, 0.7f, 1.f );
		}
		else if( m_ExtraDamagePack.m_Cold.m_fTime > 0.0f || 
			m_ExtraDamagePack.m_EnchantFrozen.m_fTime > 0.0f )
		{
			pRenderParam->color = D3DXCOLOR(0.15f, 0.8f, 1.f, 1.f );
		}
		else if( m_ExtraDamagePack.m_Fire.m_fTime > 0.0f || 
			m_ExtraDamagePack.m_EnchantBlaze.m_fTime > 0.0f )
		{
			pRenderParam->color = 0xffff0000;
		}
		else if( m_ExtraDamagePack.m_Poison.m_fTime  > 0.0f )
		{
			pRenderParam->color = 0xff00ff00;
		}
		else if( m_ExtraDamagePack.m_Curse.m_fTime > 0.0f )
		{
			pRenderParam->color = 0xff6600ff;
		}
		else if( m_fPepperRunTime > 0.f )
		{
			pRenderParam->color = 0xffff0000;
		}
	}

	if( m_bUnderWaterHead == true || m_bForceChagneColor == true )
	{
		pRenderParam->color.r -= m_cLineUnitColor.r;
		pRenderParam->color.g -= m_cLineUnitColor.g;
		pRenderParam->color.b -= m_cLineUnitColor.b;
	}	
	

	pRenderParam->color.a = m_RenderParam.color.a;
	if ( g_pX2Room != NULL )
	{
		CX2Room::SlotData* pSlotData = g_pX2Room->GetSlotDataByUnitUID( m_UnitUID );
		if( pSlotData != NULL 
			&& pSlotData->GetSlotState() != CX2Room::SS_CLOSE 
			&& pSlotData->GetSlotState() != CX2Room::SS_EMPTY
			&& pSlotData->m_pUnit != GetUnit() )
			m_pUnit = pSlotData->m_pUnit;
	}//if



	RENDER_HINT renderHintResult = m_pXSkinAnim->OnFrameRender_Prepare();
	if ( renderHintResult.m_eHint != RENDER_HINT::NORENDER )
		m_pXSkinAnim->SetInstantShow( true );

	if ( !IsRecursivelyManagedByDGManager() && !m_ViewEqipList.empty() )
	{
		RENDER_HINT renderHint;
		for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
		{
			CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];
			ASSERT( pCX2Eqip != NULL && !pCX2Eqip->IsManagedByDGManager() );
			if ( pCX2Eqip == NULL || pCX2Eqip->IsManagedByDGManager() )
				continue;
			pCX2Eqip->SetInstantShow( false );
			if ( !pCX2Eqip->GetShowObject() )
				continue;
			renderHint = pCX2Eqip->OnFrameRender_Prepare();
			if ( renderHint.m_eHint != RENDER_HINT::NORENDER )
			{
				pCX2Eqip->SetInstantShow( true );
				renderHintResult.MergeRenderHint( renderHint );
			}//if
		}//for
	}//if

	return  renderHintResult;

}//CX2GUUser::CommonRender_Prepare()


/*virtual*/
void    CX2GUUser::OnFrameRender_Draw()
{
	KTDXPROFILE();

	if ( m_pXSkinAnim == NULL || !m_pXSkinAnim->GetShowObject() )
		return;

#ifdef FACE_OFF_MONSTER_HEAD_TEST
	if(m_bHideNoRenderable == true)
	{
		m_pXSkinAnim->SetHideNoRenderable(true);
	}
#endif FACE_OFF_MONSTER_HEAD_TEST
	if ( m_pXSkinAnim->IsInstantShow() )
	{
		m_pXSkinAnim->OnFrameRender_Draw();
	}
#ifdef FACE_OFF_MONSTER_HEAD_TEST
	if(m_bHideNoRenderable == true)
	{
		m_pXSkinAnim->SetHideNoRenderable(false);
	}
#endif FACE_OFF_MONSTER_HEAD_TEST

	if ( !IsRecursivelyManagedByDGManager() )
	{
		for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
		{
			CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];
			ASSERT( pCX2Eqip != NULL && !pCX2Eqip->IsManagedByDGManager() );
			if ( pCX2Eqip == NULL || pCX2Eqip->IsManagedByDGManager() )
				continue;
			if ( pCX2Eqip->GetShowObject() && pCX2Eqip->IsInstantShow() )
				pCX2Eqip->OnFrameRender_Draw();
		}//if
	}//if

	//{{ robobeg : 2008-10-28

	// 콤보 매니저의 렌더링에서는 현재 아무 일도 하지 않는다.
	// CX2GUUser::OnFrameRender_Draw 에서 캐릭터 스킨만 렌더링한다는 것을 명확히 하기 위해 
	// 아래 코드를 제거

	//if ( g_pX2Game->GetMyUnit() == this )
	//{
	//	if( NULL != m_pComboManager )
	//		m_pComboManager->OnFrameRender();
	//}
	//}} robobeg : 2008-10-28
}

//}} robobeg : 2008-10-28


void CX2GUUser::PreRenderForce()
{
	/** 이 함수의 목적은 메시 데이터를 pre-load하는 것이지만,
	BeginScene()되지 않은 상태에서, DrawPrimitive()를 호출하므로
	Invalid하다. - jintaeks on 2008-10-15, 14:19 */
	if ( NULL != m_pXSkinAnim )
		m_pXSkinAnim->OnFrameRender();

	if ( !IsRecursivelyManagedByDGManager() )
	{
		for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
		{
			CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];

			//if( pCX2Eqip->GetEqipType() == CX2Item::ET_SKIN )
			//    continue;
			if ( pCX2Eqip == NULL )
				continue;
			ASSERT( !pCX2Eqip->IsManagedByDGManager() );
			pCX2Eqip->OnFrameRender();
		}
	}//if

	/* //{{ seojt on 2008-10-18
	// 아래와 같이 수정하였으나, D3D 내부의 memory leak이 보고되어 일단 위처럼
	// 원래대로 되돌려 두었다. background thread loading 작업이 끝나면
	// 다시 보도록 하자. - jintaeks on 2008-10-18, 12:03
	m_pXSkinAnim->PreLoad();

	for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
	{
	CX2Eqip* pCX2Eqip = m_ViewEqipList[i];
	if ( pCX2Eqip == NULL )
	continue;

	if( pCX2Eqip->GetEqipType() == CX2Item::ET_SKIN )
	continue;
	pCX2Eqip->PreLoad();
	}
	/**/ //}} seojt on 2008-10-18
}//CX2GUUser::PreRenderForce()


HRESULT CX2GUUser::OnResetDevice()
{

	if ( !IsRecursivelyManagedByDGManager() )
	{
		for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
		{
			CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];
			//{{ robobeg : 2008-10-28
			if ( pCX2Eqip == NULL )
				continue;
			ASSERT( !pCX2Eqip->IsManagedByDGManager() );
			pCX2Eqip->OnResetDevice();
			//}} robobeg : 2008-10-28

		}//for
	}//if




#ifdef EQUIP_STRIP_TEST
	BOOST_TEST_FOREACH( CX2ItemManager::EquipPositionMap::value_type&, value, m_mapBasicEquip )
	{
		CX2EqipPtr pEquip = value.second;
		if( pEquip == NULL )
			continue;

		pEquip->OnResetDevice();
	}
#endif EQUIP_STRIP_TEST



	return S_OK; 
}

HRESULT CX2GUUser::OnLostDevice()
{
	if ( !IsRecursivelyManagedByDGManager() )
	{
		for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
		{
			CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];
			//{{ robobeg : 2008-10-28
			if ( pCX2Eqip == NULL )
				continue;
			ASSERT( !pCX2Eqip->IsManagedByDGManager() );
			pCX2Eqip->OnLostDevice();
			//}} robobeg : 2008-10-28
		}
	}//if


#ifdef EQUIP_STRIP_TEST
	BOOST_TEST_FOREACH( CX2ItemManager::EquipPositionMap::value_type&, value, m_mapBasicEquip )
	{
		CX2EqipPtr pEquip = value.second;
		if( pEquip == NULL )
			continue;

		pEquip->OnLostDevice();
	}
#endif EQUIP_STRIP_TEST

	return S_OK; 
}

bool CX2GUUser::StateChange( int state, bool bDirectChange )
{
	KTDXPROFILE();

#ifndef BALANCE_ELEMENTAL_MASTER_20130117		/// 버프에 있는 엠피 회복 기능을 사용하므로, 해당 부분은 필요 없다.
#ifdef FIX_MEDITATION_RUN
	if( GetUnit()->GetType() == CX2Unit::UT_ARME )
	{
		CX2GUArme_VioletMage* pkAisha = (CX2GUArme_VioletMage*)this;

#ifdef BALANCE_PATCH_20120329
		if ( NULL != pkAisha)
		{
			if( pkAisha->IsInMeditation() == true )
			{
				float fMPChangeRate = GetOriginalMPChangeRate();
				
				if ( state == (int)USI_WAIT || state == (int)USI_WALK || state == (int)USI_JUMP_READY ||
					 state == (int)USI_JUMP_UP || state == (int)USI_JUMP_DOWN || state == (int)USI_DASH || state == (int)USI_DASH_JUMP )
					fMPChangeRate = pkAisha->GetMeditationMPChangeRate();

				ResetMPChangeRate( (fMPChangeRate + pkAisha->GetAddMPChargeRate() ) * (1.f + m_SocketData.m_fSpeedUpManaGather) );
			}
		}
#else
		if( pkAisha->IsInMeditation() == true && state == (int)USI_DASH )
			return false;
#endif
	}
#endif FIX_MEDITATION_RUN
#endif  BALANCE_ELEMENTAL_MASTER_20130117

#ifdef TEST_GROUP_GRAP
///	if ( GetGrap() == true ) return;
#endif TEST_GROUP_GRAP

#ifdef UNIT_EMOTION
	m_ePlayedEmotion = CX2Unit::ET_NONE;
#endif

	if( IsLocalUnit() == false )
		return false;

	if ( GetNowHp() > 0.f )
	{
		if( m_ExtraDamagePack.m_EnchantShock.m_fTime > 0.f ||
			m_ExtraDamagePack.m_Frozen.m_fTime > 0.f )
		{
			return false;
		}
	}


	m_FrameDataFuture.unitCondition.nextState			= state;
	m_FrameDataFuture.unitCondition.nextSubState		= -1;
	m_FrameDataFuture.syncData.bDirectChange			= bDirectChange;


#ifdef NEW_RANDOM_TABLE_TEST
	m_FrameDataFuture.syncData.m_usRandomTableIndex		= (USHORT) ( rand() % CKTDXRandomNumbers::RANDOM_NUMBER_COUNT );
#else NEW_RANDOM_TABLE_TEST
//{{AFX
	m_FrameDataFuture.syncData.m_RandSeed				= rand()%100;
	m_FrameDataFuture.syncData.m_RandSeed2				= rand()%100;
//}}AFX
#endif NEW_RANDOM_TABLE_TEST
	m_FrameDataFuture.unitCondition.stateChangeNum++;
//#ifndef SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//#ifdef OPTIMIZED_P2P
//    if( m_FrameDataFuture.unitCondition.stateChangeNum == 7 )
//        m_FrameDataFuture.unitCondition.stateChangeNum = 0;
//#else
//	if( m_FrameDataFuture.unitCondition.stateChangeNum == 15 )
//		m_FrameDataFuture.unitCondition.stateChangeNum = 0;
//#endif // OPTIMIZED_P2P
//#endif SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	GetGageData()->SetEnable( false );


	if( bDirectChange == true )
	{
		m_LuaManager.EndTable();
		

		//m_FrameDataFuture.syncData		= m_FrameDataNow.syncData;
		//m_FrameDataFuture.unitCondition = m_FrameDataNow.unitCondition;
		//m_FrameDataFuture.stateParam	= m_FrameDataNow.stateParam;

		int receiveSize	= (int)m_ReceiveSyncDataList.size();
		int sendSize	= (int)m_SendSyncDataList.size();

#ifdef MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT // Local Unit
		map< int, UCHAR > mapActionSyncData;
		GetActionSyncData( mapActionSyncData, m_ReceiveSyncDataList );
#endif // MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT


		m_ReceiveSyncDataList.resize(0);
		m_SendSyncDataList.resize(0);
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
        int lastSentSize = (int) m_LastSendSyncDataList.size();
        DWORD dwFrameMoveCount = m_FrameDataNow.syncData.dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

		DoStateEndStartFuture();

		//m_StopAdvanceTimeFuture = true;
		for( int i = 0; i < receiveSize; i++ )
		{
			DoFrameMoveFuture();
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
            ++dwFrameMoveCount;
            m_FrameDataFuture.syncData.dwFrameMoveCount = dwFrameMoveCount;
			m_FrameDataFuture.syncData.bDirectChange = bDirectChange;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
			m_ReceiveSyncDataList.push_back( m_FrameDataFuture.syncData );			
		}

#ifdef MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT // Local Unit
		SetActionSyncData( m_ReceiveSyncDataList, mapActionSyncData );
#endif // MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

        int iMinSize = __min( lastSentSize, receiveSize );
        if ( iMinSize > 0 )
        {
            std::vector<SyncData>::iterator iterDst = m_LastSendSyncDataList.end() - iMinSize;
            std::vector<SyncData>::const_iterator iterSrc = m_ReceiveSyncDataList.end() - iMinSize;
            for( int i = 0; i < iMinSize; i++ )
            {
                *(iterDst++) = *(iterSrc++);
            }
        }

		m_adwInitFrameMoveCount[0] = dwFrameMoveCount - receiveSize + 1;
		m_adwInitFrameMoveCount[1] = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

		for( int i = 0; i < sendSize; i++ )
		{
			DoFrameMoveFuture();
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
            ++dwFrameMoveCount;
            m_FrameDataFuture.syncData.dwFrameMoveCount = dwFrameMoveCount;
			m_FrameDataFuture.syncData.bDirectChange = bDirectChange;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
			m_SendSyncDataList.push_back( m_FrameDataFuture.syncData );		
		}
		//m_StopAdvanceTimeFuture = false;
		//m_pXSkinAnimFuture->OnFrameMove( m_fTime, m_fElapsedTime * (receiveSize+sendSize) );
	}
	GetGageData()->SetEnable( true );

	// 훈련소 관련
	m_iNowSpecialAttack = 0;

#ifdef FIX_SKILL_SLOT_CHANGE_BUG
	SetSlotChangeCoolTime(0.5f);
#endif // FIX_SKILL_SLOT_CHANGE_BUG
    return true;
}

bool CX2GUUser::StateChange( int state, int subState, bool bDirectChange /* = false */ )
{
	KTDXPROFILE();

#ifdef TEST_GROUP_GRAP
	//if ( GetGrap() == true ) 		return;
#endif TEST_GROUP_GRAP

#ifdef UNIT_EMOTION
	m_ePlayedEmotion = CX2Unit::ET_NONE;
#endif

	if( IsLocalUnit() == false )
		return false;

	if ( GetNowHp() > 0.f )
	{
		if( m_ExtraDamagePack.m_EnchantShock.m_fTime > 0.f ||
			m_ExtraDamagePack.m_Frozen.m_fTime > 0.f ||
			false == m_vecFreezePtr.empty() )
		{
			return false;
		}
	}

	m_FrameDataFuture.unitCondition.nextState			= state;
	m_FrameDataFuture.unitCondition.nextSubState		= subState;
	m_FrameDataFuture.syncData.bDirectChange			= bDirectChange;

#ifdef NEW_RANDOM_TABLE_TEST
	m_FrameDataFuture.syncData.m_usRandomTableIndex = (USHORT) ( rand() % CKTDXRandomNumbers::RANDOM_NUMBER_COUNT );
#else NEW_RANDOM_TABLE_TEST
//{{AFX
	m_FrameDataFuture.syncData.m_RandSeed				= rand()%100;
	m_FrameDataFuture.syncData.m_RandSeed2				= rand()%100;
//}}AFX
#endif NEW_RANDOM_TABLE_TEST


	m_FrameDataFuture.unitCondition.stateChangeNum++;
//#ifndef SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//#ifdef OPTIMIZED_P2P
//    if( m_FrameDataFuture.unitCondition.stateChangeNum == 7 )
//        m_FrameDataFuture.unitCondition.stateChangeNum = 0;
//#else
//	if( m_FrameDataFuture.unitCondition.stateChangeNum == 15 )
//		m_FrameDataFuture.unitCondition.stateChangeNum = 0;
//#endif // OPTIMIZED_P2P
//#endif SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK


	GetGageData()->SetEnable( false );


	if( bDirectChange == true )
	{
		m_LuaManager.EndTable();
		bool bTableOpen = false;

		//m_FrameDataFuture.syncData		= m_FrameDataNow.syncData;
		//m_FrameDataFuture.unitCondition = m_FrameDataNow.unitCondition;
		//m_FrameDataFuture.stateParam	= m_FrameDataNow.stateParam;

		int receiveSize	= (int)m_ReceiveSyncDataList.size();
		int sendSize	= (int)m_SendSyncDataList.size();
#ifdef MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT // Local Unit
		map< int, UCHAR > mapActionSyncData;
		GetActionSyncData( mapActionSyncData, m_ReceiveSyncDataList );
#endif // MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT
		m_ReceiveSyncDataList.resize(0);
		m_SendSyncDataList.resize(0);
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
        int lastSentSize = (int) m_LastSendSyncDataList.size();
        DWORD dwFrameMoveCount = m_FrameDataNow.syncData.dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

		DoStateEndStartFuture();

		//m_StopAdvanceTimeFuture = true;
		for( int i = 0; i < receiveSize; i++ )
		{
			DoFrameMoveFuture();
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
            ++dwFrameMoveCount;
            m_FrameDataFuture.syncData.dwFrameMoveCount = dwFrameMoveCount;
			m_FrameDataFuture.syncData.bDirectChange = bDirectChange;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
			m_FrameDataFuture.syncData.bDirectChange = bDirectChange;
			m_ReceiveSyncDataList.push_back( m_FrameDataFuture.syncData );			
		}

#ifdef MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT // Local Unit
		SetActionSyncData( m_ReceiveSyncDataList, mapActionSyncData );
#endif // MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

        int iMinSize = __min( lastSentSize, receiveSize );
        if ( iMinSize > 0 )
        {
            std::vector<SyncData>::iterator iterDst = m_LastSendSyncDataList.end() - iMinSize;
            std::vector<SyncData>::const_iterator iterSrc = m_ReceiveSyncDataList.end() - iMinSize;
            for( int i = 0; i < iMinSize; i++ )
            {
                *(iterDst++) = *(iterSrc++);
            }
        }

		m_adwInitFrameMoveCount[0] = dwFrameMoveCount - receiveSize + 1;
		m_adwInitFrameMoveCount[1] = dwFrameMoveCount;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

		for( int i = 0; i < sendSize; i++ )
		{
			DoFrameMoveFuture();
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
            ++dwFrameMoveCount;
            m_FrameDataFuture.syncData.dwFrameMoveCount = dwFrameMoveCount;
			m_FrameDataFuture.syncData.bDirectChange = bDirectChange;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
			m_FrameDataFuture.syncData.bDirectChange = bDirectChange;
			m_SendSyncDataList.push_back( m_FrameDataFuture.syncData );		
		}
		//m_StopAdvanceTimeFuture = false;
		//m_pXSkinAnimFuture->OnFrameMove( m_fTime, m_fElapsedTime * (receiveSize+sendSize) );
	}
	GetGageData()->SetEnable( true );

	// 훈련소 관련
	m_iNowSpecialAttack = 0;

#ifdef FIX_SKILL_SLOT_CHANGE_BUG
	SetSlotChangeCoolTime(0.5f);
#endif // FIX_SKILL_SLOT_CHANGE_BUG
    return true;
}

void CX2GUUser::DamageReact( CX2DamageManager::DamageData* pDamageData )
{
#if defined( _SERVICE_ ) 
	ELSWORD_VIRTUALIZER_START
#endif

	KTDXPROFILE();
	//{{ kimhc // 2010.2.17 //
#ifdef	APPLY_MOTION_OFFSET
	m_bApplyMotionOffset = pDamageData->m_bApplyMotionOffset;
#endif	APPLY_MOTION_OFFSET
	//}} kimhc // 2010.2.17 //

	m_bHitedDrainMana = false;
	m_bDoubleAttack = false;
	m_FrameDataNow.unitCondition.bAttackerFront = true;

#ifdef NO_DETONATION

#ifdef SERV_9TH_NEW_CHARACTER // 김태환
	/// DT_BUFF일 때, 기폭 불가능 설정 되어 있으면 유지 시켜 주자
	if ( true != GetNoDetonation() || CX2DamageManager::DT_BUFF != pDamageData->damageType )
#endif //SERV_9TH_NEW_CHARACTER
		SetNoDetonation( pDamageData->m_bNoDetonation );

	m_bNowStateDamageReact = true;
#endif

#ifdef SERV_PET_SYSTEM
	float	fMpPet			= 0.f;
#endif

#ifdef UPGRADE_RAVEN
	m_bParryingState = false;
#endif

#ifdef ARA_CHANGE_CLASS_FIRST
	m_bQuickenGuardBlocking = false;
	m_bQuickenGuardTurning = false;
#endif

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	// 이브의 기동 코어 Parrying 상태 인가?
	m_bManeuverParryingState = false;
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

	if( pDamageData->bForceFly == true )
	{
		m_FlyCount = 0;
	}
	else
	{
		switch( pDamageData->reActResult )
		{
		case CX2DamageManager::RT_UP:
		case CX2DamageManager::RT_FLY:
#ifdef BOUNDING_COMBO_TEST
		case CX2DamageManager::RT_BOUNDING:
#endif BOUNDING_COMBO_TEST

//{{ kimhc // 2010.2.8 // 위치보정 없이 위로 계속 끌어 올리는 공격
#ifdef	EVE_SECOND_CLASS_CHANGE
		case CX2DamageManager::RT_DRAG_UP:
#endif	EVE_SECOND_CLASS_CHANGE
//}} kimhc // 2010.2.8 // 위치보정 없이 위로 계속 끌어 올리는 공격
			{
				m_FlyCount++;
			} break;
		}
	}

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    CX2DamageEffect::CEffect*   pAttackerEffect = g_pX2Game->GetDamageEffect()->GetInstance( pDamageData->hAttackerEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE


	CX2GameUnit*	pAttackerUnit = NULL;
	D3DXVECTOR3		dirUnitToAttacker = D3DXVECTOR3(0,0,0);

	if( null != pDamageData->optrAttackerGameUnit )
	{
		pAttackerUnit		= pDamageData->optrAttackerGameUnit.GetObservable();
	}

	if( pAttackerUnit != NULL )
	{
		switch(pDamageData->attackerType)
		{
		case CX2DamageManager::AT_UNIT:
			{
				dirUnitToAttacker	= pAttackerUnit->GetPos() - GetPos();
			} break;
		case CX2DamageManager::AT_MESH:
			{
				dirUnitToAttacker	= pDamageData->pAttackerAnim->GetMatrix().GetPos() - GetPos();
			} break;
		case CX2DamageManager::AT_MANUAL_COLLISION_DATA:
			{
				dirUnitToAttacker	= pDamageData->pCollisionData->GetPointStart() - GetPos();
			} break;
		case CX2DamageManager::AT_EFFECT:
			{
#ifndef X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
				CX2DamageEffect::CEffect* pAttackerEffect = (CX2DamageEffect::CEffect*)pDamageData->pAttackerEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
				if( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = ( pAttackerEffect != NULL ) ? pAttackerEffect->GetMainEffect() : NULL )
					dirUnitToAttacker	= pMeshInstance->GetMatrix().GetPos() - GetPos();
			} break;
		default:
			{
				ASSERT( !"Unexpected Attacker Type" );
			} break;
		}
	}

#ifdef ARRANGED_FLY_DAMAGE_TEST
	//{{ oasis907 : 김상윤 [2010.2.11] // 
	bool IsDamageDirRight = false;
	if ( pDamageData->bArrangedFly == true )
	{
		if( pAttackerUnit )
		{
			switch(pDamageData->attackerType)
			{
			case CX2DamageManager::AT_UNIT:
				{
					IsDamageDirRight =pAttackerUnit->GetIsRight();
				} break;
			case CX2DamageManager::AT_MESH:
				{
					IsDamageDirRight = pAttackerUnit->GetIsRight();
				} break;
			case CX2DamageManager::AT_MANUAL_COLLISION_DATA:
				{
					IsDamageDirRight = pAttackerUnit->GetIsRight();
				} break;
			case CX2DamageManager::AT_EFFECT:
				{
#ifndef X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
					CX2DamageEffect::CEffect* pAttackerEffect = (CX2DamageEffect::CEffect*)pDamageData->pAttackerEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
					if( pAttackerEffect != NULL )
						IsDamageDirRight = pAttackerEffect->GetFollowLineRight();
				} break;
			default:
				{
					ASSERT( !"Unexpected Attacker Type" );
				} break;
			}
		}
	}
	//}} oasis907 : 김상윤 [2010.2.11] // 
#endif ARRANGED_FLY_DAMAGE_TEST



#ifdef GRAPPLING_TEST
	switch( pDamageData->reActType )
	{
	case CX2DamageManager::RT_GRAPPLE:
		{
			if( IsSuperArmor() )
				break;

			ASSERT( NULL != pAttackerUnit );
			if( NULL != pAttackerUnit )
			{
				SetUnitGrapplingMe( true, pAttackerUnit->GetGameUnitType(), pAttackerUnit->GetUnitUID() );
				SetUnitGrapplingMe( false, pAttackerUnit->GetGameUnitType(), pAttackerUnit->GetUnitUID() );

				pAttackerUnit->SetUnitGrappledByMe( true, GetGameUnitType(), GetUnitUID() );
				pAttackerUnit->SetUnitGrappledByMe( false, GetGameUnitType(), GetUnitUID() );
			}
		} break;

	case CX2DamageManager::RT_THROW:
		{
			// 잡혀있는 상태를 풀어주고, 내가 던져질 때 나의 위치를 라인맵 위로 옮겨 준다
			ResetGrapplingState();
		} break;
	}

#endif GRAPPLING_TEST





	if( m_FrameDataNow.stateParam.bInvincible == true &&
#ifdef DUNGEON_ITEM
		pDamageData->m_fHpPercentUp == 0.f && 
		pDamageData->m_fMpPercentUp == 0.f && 
#endif
		CX2DamageManager::RT_THROW != pDamageData->reActType )
	{
		pDamageData->reActResult = CX2DamageManager::RT_NO_DAMAGE;
		return;
	}

	//캐쉬샵 입장 중일 때 데미지 받지 않도록 수정
	if( true == m_bEnterCashShop )
	{
		pDamageData->reActResult = CX2DamageManager::RT_NO_DAMAGE;
		return;
	}

	switch( pDamageData->reActType )
	{
	case CX2DamageManager::RT_CREATE_DAMAGE_EFFECT:
	case CX2DamageManager::RT_CREATE_EFFECT_SET:
		{
#ifdef RAVEN_SECOND_CLASS_CHANGE
			if( IsSuperArmor() != true && pDamageData->reActResult != CX2DamageManager::RT_DUMMY_DAMAGE && pDamageData->fStopTimeDef > 0.f )
			{
				SetStopTime( pDamageData->fStopTimeDef );
				SetStop2Time( 0.0f );	
			}
#endif
			return;
		} break;
	}




#ifdef SKILL_CASH_10_TEST	
	m_optrLastAttackUnit.Reset();

	if( pAttackerUnit != NULL && pDamageData->m_bDrainHpParticle == true )
	{
		if( CX2GameUnit::GUT_USER == pAttackerUnit->GetGameUnitType() )
		{			
			if( m_hSeqDrainParticle == INVALID_PARTICLE_SEQUENCE_HANDLE )
			{
				D3DXVECTOR3 pos = GetPos();
				pos.y = pos.y + 100.0f;		

				m_optrLastAttackUnit = pAttackerUnit;

				CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GameUnitCreateSequence_LUA( this, "DrainLight",	pos, D3DXVECTOR2(-1,-1), D3DXVECTOR2(3,-1) );								
				if( pSeq != NULL )
				{
					D3DXVECTOR3 pos = m_optrLastAttackUnit->GetWeaponBonePos( 0, L"TRACE_END0", 0 );			

					pSeq->SetLandPosition( GetLandPosition().y );					
					pSeq->SetBlackHolePosition( pos );
					m_hSeqDrainParticle = pSeq->GetHandle();
				}				
			}
		}		
	}
#endif

#ifdef SKILL_CASH_10_TEST
	if ( AbsorbEffectAttackProcess( pDamageData ) )
		return;
#endif

// #ifdef ELSWORD_SHEATH_KNIGHT
// 	if( pAttackerUnit != NULL ) // Valid 체크는 위에서 함
// 	{
// 		if ( pDamageData->attackerType == CX2DamageManager::AT_UNIT && 
// 			pAttackerUnit->GetGameUnitType() == GUT_USER &&
// 			pDamageData->attackType == CX2DamageManager::AT_NORMAL )
// 		{
// 			CX2GUUser* pAttackerUser = static_cast<CX2GUUser*>( pAttackerUnit );
// 			if( pAttackerUser->GetUnitClass() == CX2Unit::UC_ELSWORD_SHEATH_KNIGHT 
// #ifdef SERV_ELSWORD_INFINITY_SWORD
// 				|| pAttackerUser->GetUnitClass() == CX2Unit::UC_ELSWORD_INFINITY_SWORD
// #endif
// 				)
// 			{
// 				if( GetRandomFloat() <= pAttackerUser->GetBrutalSlayerManaBurnRate() )
// 				{
// 					float fBurnMP = pAttackerUser->GetBrutalSlayerManaBurnABS();
// 					UpNowMp( -fBurnMP );
// 					
// 					std::wstringstream strStream;
// 					strStream << L"MP -" << (int)fBurnMP;
// 					D3DXVECTOR3 numPos;
// 					GetFramePos( &numPos, m_pFrame_Bip01_Head );
// 					if( numPos.x == 0.0f && numPos.y == 0.0f && numPos.z == 0.0f )
// 					{
// 						numPos = GetPos();
// 						numPos.y += 150.0f;
// 					}
// 					numPos.y += -50.0f;
// 					if( NULL != g_pData->GetPicCharRed() )
// 						g_pData->GetPicCharRed()->DrawText( strStream.str().c_str(), numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );
// 
// #ifdef SERV_ELSWORD_INFINITY_SWORD
// 					pAttackerUser->SetMindOfFighterCount();
// #endif
// 				}
// 			}
// 		}
// 	}
// #endif ELSWORD_SHEATH_KNIGHT


	//적이 전방에 있는가 후방에 있는가
#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
    dirUnitToAttacker.y = 0.f;
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION

#ifdef CHEAT_SELF_DAMAGE // 김태환
	/// 자신에게 데미지를 주는 치트중 피격 방향 설정
	if ( -1 != m_iFrontDamage )
	{
		const bool bFrontDamage = m_iFrontDamage == 0 ? false : true;
		m_FrameDataNow.unitCondition.bAttackerFront = static_cast<bool>( bFrontDamage );
	}
	else
#endif //CHEAT_SELF_DAMAGE
	{
		if( D3DXVec3Dot( &GetDirVector(), &dirUnitToAttacker ) >= 0 )
			m_FrameDataNow.unitCondition.bAttackerFront = true;
		else
			m_FrameDataNow.unitCondition.bAttackerFront = false;

		if( m_FrameDataNow.syncData.bIsRight == false )
		{
			m_FrameDataNow.unitCondition.bAttackerFront = !m_FrameDataNow.unitCondition.bAttackerFront;			
		}
	}

#ifdef ARRANGED_FLY_DAMAGE_TEST
	// 데미지의 방향성과 캐릭터의 방향이 일치하는지 
	bool bViewDamageDir = false;
	if ( pDamageData->bArrangedFly == true )
	{
		if( IsDamageDirRight == GetIsRight() )
		{
			bViewDamageDir = true;
			m_FrameDataNow.unitCondition.bAttackerFront = false;
		}
		else
		{
			bViewDamageDir = false;
			m_FrameDataNow.unitCondition.bAttackerFront = true;
		}
	}
#endif ARRANGED_FLY_DAMAGE_TEST

#ifdef ADD_BACKATTACK
	bool bCriticalHit = false;
	bool bBackAttack = false;
	if( pDamageData->m_bApplyBackAttack == true && 
		IsSuperArmor() != true && 
		m_FrameDataNow.unitCondition.bAttackerFront == false )
	{
		bBackAttack = true;
	}
#endif

#ifdef NEW_SKILL_2010_11
	if( IsSuperArmor() != true &&
		pDamageData->reActType != CX2DamageManager::RT_DUMMY_DAMAGE) // oasis907 : 김상윤 [2010.12.3] // 더미 데미지가 이속에 영향 주지 않도록
#else
	if( IsSuperArmor() != true )	// 빙결시 움직이지 않도록 수정
#endif NEW_SKILL_2010_11
	{
		if( pDamageData->m_bWBackSpeed == true )
		{
			if( m_FrameDataNow.syncData.bIsRight == true )
			{
				m_PhysicParam.nowSpeed.x = -pDamageData->backSpeed.x;
			}
			else
			{
				m_PhysicParam.nowSpeed.x = pDamageData->backSpeed.x;
			}
		}
#ifdef ARRANGED_FLY_DAMAGE_TEST
//{{ oasis907 : 김상윤 [2010.2.10] // 
		else if ( pDamageData->bArrangedFly == true )
		{
			if( bViewDamageDir == true )
			{
				m_PhysicParam.nowSpeed.x = pDamageData->backSpeed.x;
			}
			else		
			{
				m_PhysicParam.nowSpeed.x = -pDamageData->backSpeed.x;
			}			
		}
//}} oasis907 : 김상윤 [2010.2.10] // 
#endif ARRANGED_FLY_DAMAGE_TEST
		else
		{

#ifdef GRAPPLING_TEST
			if( CX2DamageManager::RT_THROW == pDamageData->reActType )
			{
				if( pAttackerUnit->GetIsRight() == GetIsRight() )
				{
					m_PhysicParam.nowSpeed.x = pDamageData->backSpeed.x;
				}
				else
				{
					m_PhysicParam.nowSpeed.x = -pDamageData->backSpeed.x;
				}
			}
			else
#endif GRAPPLING_TEST
			switch( pDamageData->reActType )
			{
#ifdef CHUNG_FIRST_CLASS_CHANGE // 해외팀 수정
			case CX2DamageManager::RT_FLIP_SAME_DIR:
				{
					// 앞 또는 뒤쪽 으로만
					m_PhysicParam.nowSpeed.x = -pDamageData->backSpeed.x;
				} break;
#endif CHUNG_FIRST_CLASS_CHANGE
			case CX2DamageManager::RT_NO_DAMAGE:
			case CX2DamageManager::RT_DUMMY_DAMAGE:
				{

				} break;
			default:
				{
					if( m_FrameDataNow.unitCondition.bAttackerFront == true )
					{
						m_PhysicParam.nowSpeed.x = -pDamageData->backSpeed.x;
					}
					else		
					{
						m_PhysicParam.nowSpeed.x = pDamageData->backSpeed.x;
					}
				}
				break;
			}
		}		
	}




	m_FrameDataFuture.unitCondition.bAttackerFront = m_FrameDataNow.unitCondition.bAttackerFront;

	bool bRevenge = false;
	bool bReflexMagic = false;	

	// 반격여부검사
	if( m_FrameDataNow.stateParam.fRevengeStartTime < m_pXSkinAnim->GetNowAnimationTime() 
		&& m_FrameDataNow.stateParam.fRevengeEndTime > m_pXSkinAnim->GetNowAnimationTime() 
		&& m_FrameDataNow.unitCondition.bAttackerFront == true )
	{
		bRevenge = true;
	}	
	// 마법반사여부 검사
	if( m_FrameDataNow.stateParam.fReflexMagicStartTime < m_pXSkinAnim->GetNowAnimationTime() 
		&& m_FrameDataNow.stateParam.fReflexMagicEndTime > m_pXSkinAnim->GetNowAnimationTime() 
		&& m_FrameDataNow.unitCondition.bAttackerFront == true )
	{
		bReflexMagic = true;
	}

#ifdef NEW_SKILL_2010_11
	bool bDamageReactReflectMagic = false;
	//{{ oasis907 : 김상윤 [2010.11.1] // 룬 슬레이어 - 마법저항 수련
	if( CX2Unit::UC_ELSWORD_RUNE_SLAYER == GetUnitClass() )
	{
		CX2GUElsword_SwordMan* pElsword = (CX2GUElsword_SwordMan*) this;

		if(GetRandomFloat() <= pElsword->GetMagicReflectRate())
		{
			bReflexMagic = true;
			bDamageReactReflectMagic = true;
		}
	}
	//}
#endif NEW_SKILL_2010_11

#ifdef SERV_ARA_CHANGE_CLASS_SECOND // 김태환
	/// 버프로 인한 마법 증가 효과 검사
	if ( false == m_vecReflectMagicByBuffPtr.empty() )
		bReflexMagic = true;
#endif // SERV_ARA_CHANGE_CLASS_SECOND

#ifdef FIX_REVENGE_HIT_SOUND_INIT_BUG
	// 반격에 의해 피격음이 변경 된 이후, 이전 피격음으로 복구 시켜주기 위한 임시 저장 값
	CX2DamageManager::HIT_TYPE eOldHitType = ( NULL != pDamageData) ? pDamageData->hitType : CX2DamageManager::HT_NO_SOUND;
#endif // FIX_REVENGE_HIT_SOUND_INIT_BUG

	if(bRevenge == true || bReflexMagic == true)
	{

		if( (bRevenge == true && pDamageData->bCanRevenge == true) || 
			(bReflexMagic == true && pDamageData->bCanReflexMagic == true) )
		{
			pDamageData->fStopTimeDef				= 0.f;

			m_fRevengeAddDamage					= pDamageData->damage.GetAllDamage();

#ifdef NEW_SKILL_2010_11 // oasis907 : 김상윤 [2010.11.1] // 룬 슬레이어 - 마법저항 수련
			if(bDamageReactReflectMagic == true && bRevenge == false )
				pDamageData->reActResult			= CX2DamageManager::RT_REFLECT;
			else
				pDamageData->reActResult			= CX2DamageManager::RT_REVENGE;
#else
			pDamageData->reActResult			= CX2DamageManager::RT_REVENGE;
#endif NEW_SKILL_2010_11

#ifdef NEW_SKILL_TREE
			if(bReflexMagic == true && pDamageData->bCanReflexMagic == true)
			{
				float fPowerRate = 1.f;


				const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_LE_REFLEX_MAGIC );
				if( NULL != pSkillTemplet )
				{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
					if ( NULL == GetUnit()  )
						return;
	
					const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
					const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
					fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
					fPowerRate = pSkillTemplet->m_fPowerRate;
	#endif // UPGRADE_SKILL_SYSTEM_2013
				}

#ifdef SERV_ARA_CHANGE_CLASS_SECOND // 김태환
				/// 버프로 인한 마법 반사가 적용중이라면
				if ( false == m_vecReflectMagicByBuffPtr.empty() )
				{
					vector<CX2ReflectMagicByBuffPtr>::iterator vit = m_vecReflectMagicByBuffPtr.begin();

					/// 버프로부터 반사체 데미지 증가값 반환
					if ( NULL != vit->get() )
						fPowerRate = vit->get()->GetValue();
				}
#endif // SERV_ARA_CHANGE_CLASS_SECOND

#ifndef X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
				CX2DamageEffect::CEffect* pAttackerEffect = static_cast<CX2DamageEffect::CEffect*>( pDamageData->pAttackerEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
				if(pAttackerEffect != NULL)
				{
					pAttackerEffect->SetPowerRate( pAttackerEffect->GetPowerRate() * fPowerRate );
				}
			}			
#endif NEW_SKILL_TREE

			switch( pDamageData->hitType )
			{
			default:
			case CX2DamageManager::HT_SWORD_SLASH:
			case CX2DamageManager::HT_SWORD_HIT:
				pDamageData->hitType				= CX2DamageManager::HT_SWORD_CRASH;
				break;

			case CX2DamageManager::HT_ROD_SLASH:
			case CX2DamageManager::HT_ROD_HIT:
				pDamageData->hitType				= CX2DamageManager::HT_ROD_CRASH;
				break;

			case CX2DamageManager::HT_PUNCH_HIT:
			case CX2DamageManager::HT_PUNCH_HIT2:
				pDamageData->hitType				= CX2DamageManager::HT_PUNCH_CRASH;
				break;

			case CX2DamageManager::HT_KICK_SLASH:
			case CX2DamageManager::HT_KICK_HIT:
				pDamageData->hitType				= CX2DamageManager::HT_KICK_CRASH;
				break;

			case CX2DamageManager::HT_ARROW_HIT:
				pDamageData->hitType				= CX2DamageManager::HT_ARROW_CRASH;
				break;
			}

			m_FrameDataNow.unitCondition.bHit	= true;
		}
#ifdef ARA_CHANGE_CLASS_FIRST
		else if( true == bRevenge && false == pDamageData->bCanRevenge &&
				true == m_bCanAvoidance )
		{
			pDamageData->fStopTimeDef				= 0.f;
			pDamageData->reActResult = CX2DamageManager::RT_AVOIDANCE;
		}
#endif //ARA_CHANGE_CLASS_FIRST
	}

	//타격 방식에 따른 반응(사운드 등)
	wstring wstrHitSound = L"";
	if( pDamageData->reActResult != CX2DamageManager::RT_NO_DAMAGE 
		&& pDamageData->reActResult != CX2DamageManager::RT_SENSOR )
		//&& pDamageData->reActResult != CX2DamageManager::RT_REVENGE )
	{
		const WCHAR* wszSoundName = NULL;
	//{{ kimhc // 2011.1.21 // 청 1차 전직

#ifdef	CHUNG_FIRST_CLASS_CHANGE
		if ( CX2DamageManager::HTD_NO_SOUND != m_eHittedTypeAtState)
			wszSoundName = g_pData->GetDamageManager()->GetDamageSound( pDamageData->hitType, m_eHittedTypeAtState );
		else
#endif	CHUNG_FIRST_CLASS_CHANGE
	//}} kimhc // 2011.1.21 // 청 1차 전직
			wszSoundName = g_pData->GetDamageManager()->GetDamageSound( pDamageData->hitType, m_HittedType );		
		
		if( NULL != wszSoundName )
		{
			PlaySound( wszSoundName );
			wstrHitSound = wszSoundName;
		}

#ifdef FIX_REVENGE_HIT_SOUND_INIT_BUG
		if( NULL != pDamageData && 
			CX2DamageManager::HT_NO_SOUND != eOldHitType )
		{
			pDamageData->hitType = eOldHitType;
		}
#endif // FIX_REVENGE_HIT_SOUND_INIT_BUG

	}


	if( IsFocusUnit() == true )
	{

		switch( pDamageData->m_eCameraShakeType )
		{
		case CKTDGCamera::DECT_UP:
			{
				// fix!! not yet!!

			} break;
		case CKTDGCamera::DECT_DOWN:
			{
				// fix!! not yet!!

			} break;
		case CKTDGCamera::DECT_UP_DOWN:
			{
				UpDownCrashCamera( pDamageData->fCameraCrashGap, pDamageData->fCameraCrashTime );

			} break;
		case CKTDGCamera::DECT_UP_DOWN_NO_RESET:
			{
				UpDownCrashCameraNoReset( pDamageData->fCameraCrashGap, pDamageData->fCameraCrashTime );
			} break;

		case CKTDGCamera::DECT_LEFT:
			{
				// fix!! not yet!!

			} break;

		case CKTDGCamera::DECT_RIGHT:
			{
				// fix!! not yet!!

			} break;

		case CKTDGCamera::DECT_LEFT_RIGHT:
			{
				ShakeLeftRight( pDamageData->fCameraCrashGap, pDamageData->fCameraCrashTime, 0.05f );
			} break;
		case CKTDGCamera::DECT_LEFT_RIGHT_NO_RESET:
			{
				LeftRightCrashCameraNoReset( pDamageData->fCameraCrashGap, pDamageData->fCameraCrashTime );
			} break;



		case CKTDGCamera::DECT_RANDOM:
			{
				// fix!! not yet!!
			} break;
		}

#ifdef CLEAR_SCREEN_ON_HIT
	#ifdef VERTICAL_SYNC_OPTION
		if ( false == g_pMain->GetGameOption().GetFlashEffect() )
		{
			g_pKTDXApp->GetDGManager()->ClearScreen( pDamageData->clearScreen );
			g_pKTDXApp->GetDGManager()->SetClearScreenColor( pDamageData->clearScreenColor );
		}
	#else
		g_pKTDXApp->GetDGManager()->ClearScreen( pDamageData->clearScreen );
		g_pKTDXApp->GetDGManager()->SetClearScreenColor( pDamageData->clearScreenColor );
	#endif
#endif // CLEAR_SCREEN_ON_HIT
	}	

#ifdef SKILL_CASH_10_TEST

#ifndef NOT_CANCEL_BBT_STUN_BY_HIT		/// 피격시 BBT_STUN 기능 유지
	// 스턴이 걸려있을경우 피격시 스턴이 풀리도록 한다.
	if ( !m_vecStunPtr.empty() )
		EraseBuffTempletFromGameUnit( BTI_DEBUFF_STUN );
#endif  NOT_CANCEL_BBT_STUN_BY_HIT

#endif

	


	if( true == IsDamagedReaction( pDamageData ) )
	{
		DoCustomFunctionByBuffInDamageReact( *pDamageData );
		const bool bBuffApplied = ApplyBuffToGameUnitInDamageReact( pDamageData );
		PlayEffectSetHittedByBuff();
		DoDelegateProcessInDamageReact();
		DoDelegateProcessWithDamageDataInDamageReact( *pDamageData );

//{{ kimhc // 2010.4.6 // 비밀던전 작업(셋트아이템효과)
#ifdef SERV_SECRET_HELL

		switch ( pDamageData->reActType )
		{
		case CX2DamageManager::RT_NO_DAMAGE:
		case CX2DamageManager::RT_DUMMY_DAMAGE:
		case CX2DamageManager::RT_GUARD:
		case CX2DamageManager::RT_SENSOR:
			break;

		default:
			{
				ProcessSocketEffectEx( CX2SocketItem::SIEE_CURE_DEBUFF, this );
				ProcessSocketEffectEx( CX2SocketItem::SIEE_DEBUFF_ATTACKER, pAttackerUnit  );

				//{{ kimhc // 2010.12.31 // 하멜 마을 추가시 들어가는 ExtraDamage
			#ifdef	ADD_HAMEL_VILLAGE
				ProcessSocketEffectEx( CX2SocketItem::SIEE_ICE_NOVA, this  );
			#endif	ADD_HAMEL_VILLAGE
				//}} kimhc // 2010.12.31 // 하멜 마을 추가시 들어가는 ExtraDamage

			#ifdef ADD_SOCKET_FOR_SECRET_SET
				ProcessSocketEffectEx( CX2SocketItem::SIEE_POISON_BURST, this  );
				ProcessSocketEffectEx( CX2SocketItem::SIEE_ABSORB_HP, this  );
			#endif

			#ifdef HAMEL_SECRET_DUNGEON // 김태환
				ProcessSocketEffectEx( CX2SocketItem::SIEE_ABSORB_HP_NO_REACT, this  );		/// 피격 시 HP 흡수 세트 효과 ( 경직 제거 )
				ProcessSocketEffectEx( CX2SocketItem::SIEE_ACTIVE_BUFF, this  );			/// 피격 시 버프 적용 효과
			#endif // HAMEL_SECRET_DUNGEON

			}
			break;
		}
		
#endif SERV_SECRET_HELL
//}} kimhc // 2010.4.6 // 비밀던전 작업(셋트아이템효과)

#ifdef UPGRADE_RAVEN		
		bool bCheckExtraDamage = false;

		switch( pDamageData->m_ExtraDamage.m_ExtraDamageType )
		{
		case CX2DamageManager::EDT_MANA_DAMAGE:
		case CX2DamageManager::EDT_DAMAGE_RATE:
		case CX2DamageManager::EDT_WATER_HOLD:
		case CX2DamageManager::EDT_ATTACK_ALL_TEAM:
			bCheckExtraDamage = true;
			break;
		default:
			break;
		}

		if( GetUnit() != NULL && GetUnit()->GetType() == CX2Unit::UT_RAVEN &&
			bCheckExtraDamage == false &&
			pDamageData->m_bNoDamage == false &&
			pDamageData->m_fHpPercentUp <= 0.f &&
#ifdef SERV_CHUNG_TACTICAL_TROOPER		/// 택티컬 필드 추가
			pDamageData->m_fIncreaseMP <= 0.f &&
#endif SERV_CHUNG_TACTICAL_TROOPER
			pDamageData->reActResult != CX2DamageManager::RT_DUMMY_DAMAGE &&
			pDamageData->reActResult != CX2DamageManager::RT_SENSOR &&
			pDamageData->hitType != CX2DamageManager::HT_GROUND_HIT &&
			GetHold() == false && GetGrap() == false
#ifdef RIDING_SYSTEM
			&& false == GetRidingOn()
#endif //RIDING_SYSTEM 레이븐 가드 막기
			)
		{
			CX2GURaven *pRaven = (CX2GURaven*)this;
			if( pRaven != NULL &&
				pRaven->IsAttackNasodBall() == false &&
				( pRaven->CanParryingState() == true || pRaven->GetParrying() == true ) &&
				GetRemainHyperModeTime() > 0.f && 
				( pRaven->GetNasodBall() > 0 || pRaven->CanParrying() == true ) &&				
				IsSuperArmor() != true &&
				m_FrameDataFuture.unitCondition.bAttackerFront == true &&
				true == pRaven->GetFrameData().unitCondition.bFootOnLine )
			{
				m_bParryingState = true;
// 				pDamageData->fStopTimeDef = 0.f;				
// 				pDamageData->m_ExtraDamage.Init();				
			}
			else
			{
				DamageReact_ExtraDamage( pDamageData, true );
			}				
		}
#ifdef ARA_CHANGE_CLASS_FIRST
		else if ( GetUnit() != NULL && GetUnit()->GetType() == CX2Unit::UT_ARA && GetUnit()->GetClass() == CX2Unit::UC_ARA_SAKRA_DEVANAM
			&& bCheckExtraDamage == false && CX2DamageManager::AT_NORMAL == pDamageData->attackType && pDamageData->m_bNoDamage == false 
			&& pDamageData->m_fHpPercentUp <= 0.f && pDamageData->m_fIncreaseMP <= 0.f 
			&& pDamageData->reActResult != CX2DamageManager::RT_DUMMY_DAMAGE
			&& pDamageData->reActResult != CX2DamageManager::RT_SENSOR && pDamageData->hitType != CX2DamageManager::HT_GROUND_HIT
			&& GetHold() == false && GetGrap() == false 
#ifdef RIDING_SYSTEM
			&& false == GetRidingOn()
#endif //RIDING_SYSTEM 아라 가드 막기
			)
		{
			CX2GUAra *pAra = static_cast<CX2GUAra*>(this);
			if( pAra != NULL && IsSuperArmor() != true && true == pAra->GetFrameData().unitCondition.bFootOnLine )
			{
				float fBlockingRate = pAra->GetBlockingRate();

				switch ( GetNowStateID() )
				{
				case USI_WAIT:
				case USI_WALK:
				case USI_DASH:
					fBlockingRate *= 2.f;
					break;
				default:
					break;
				}
				switch ( g_pX2Game->GetGameType() )
				{
				case CX2Game::GT_DUNGEON:
				case CX2Game::GT_BATTLE_FIELD:
					fBlockingRate *= 1.f;
					break;
				default:
					break;
				}

				if ( GetRandomFloat() < fBlockingRate && m_FrameDataFuture.unitCondition.bAttackerFront == true )
					m_bQuickenGuardBlocking = true;

				if ( GetRandomFloat() < pAra->GetTurnigRate() && m_FrameDataFuture.unitCondition.bAttackerFront == false )
					m_bQuickenGuardTurning = true;

#ifdef FIX_NOT_ACTIVE_EXTRA_DAMAGE_TO_ARA // 번득이는 기지 방어 실패시, 특수 데미지 적용할 수 있도록 추가 ( 뒤돌아 보는 동작은 제외 )
				if ( true != m_bQuickenGuardBlocking )
					DamageReact_ExtraDamage( pDamageData, true );
#endif // FIX_NOT_ACTIVE_EXTRA_DAMAGE_TO_ARA
			}
			else
			{
				DamageReact_ExtraDamage( pDamageData, true );
			}
		}
#endif
#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
		// 이브의 기동 코어 Parrying 상태 인가?
		else if( GetUnit() != NULL && GetUnit()->GetType() == CX2Unit::UT_EVE &&
			bCheckExtraDamage == false &&
			pDamageData->m_bNoDamage == false &&
			pDamageData->m_fHpPercentUp <= 0.f &&
#ifdef SERV_CHUNG_TACTICAL_TROOPER		/// 택티컬 필드 추가
			pDamageData->m_fIncreaseMP <= 0.f &&
#endif SERV_CHUNG_TACTICAL_TROOPER
			pDamageData->reActResult != CX2DamageManager::RT_DUMMY_DAMAGE &&
			pDamageData->reActResult != CX2DamageManager::RT_SENSOR &&
			pDamageData->hitType != CX2DamageManager::HT_GROUND_HIT &&
			GetHold() == false && GetGrap() == false
#ifdef RIDING_SYSTEM
			&& false == GetRidingOn()
#endif //RIDING_SYSTEM
			)
		{
			CX2GUEve *pEve = static_cast<CX2GUEve*> ( this );
			if( pEve != NULL &&
				pEve->IsAttackManeuverCore() == false &&
				( pEve->CanParryingState() == true || pEve->GetParrying() == true ) &&
				GetRemainHyperModeTime() > 0.f && 
				( pEve->GetManeuverCoreLevel() > 0 || pEve->CanParrying() == true ) && IsSuperArmor() != true &&
				m_FrameDataFuture.unitCondition.bAttackerFront == true &&
				true == pEve->GetFrameData().unitCondition.bFootOnLine )
			{
				m_bManeuverParryingState = true;
				// 				pDamageData->fStopTimeDef = 0.f;				
				// 				pDamageData->m_ExtraDamage.Init();				
			}
			else
			{
				DamageReact_ExtraDamage( pDamageData, true );
			}				
		}
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

		else
		{
			DamageReact_ExtraDamage( pDamageData, true );
		}
#else
		DamageReact_ExtraDamage( pDamageData, true );
#endif		

#ifdef GRAPPLING_TEST
		ResetGrapplingState();
#endif GRAPPLING_TEST


		// 공격자의 속성 인챈트 extra_damage
#ifdef TEMP_HERO_MATCH_NO_ITEM_ABILITY
		// 대회채널에는 속성, 소켓, 세트, 강화 아무것도 적용안되고, 1레벨 기본 unit stat만 적용된다.
		if( CX2Main::XS_PVP_GAME != g_pMain->GetNowStateID() || 
			KPVPChannelInfo::PCC_TOURNAMENT != g_pMain->GetPVPChannelClass( g_pMain->GetConnectedChannelID() ) )
#endif TEMP_HERO_MATCH_NO_ITEM_ABILITY
		{
#ifdef UPGRADE_RAVEN
	#ifdef ARA_CHANGE_CLASS_FIRST
		#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
			if( false == m_bParryingState && false == m_bQuickenGuardBlocking && 
				false == pDamageData->m_bNoDamage && false == m_bManeuverParryingState )
		#else  // ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
			if( false == m_bParryingState && false == m_bQuickenGuardBlocking && 
				false == pDamageData->m_bNoDamage )
		#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	#else
			if( m_bParryingState == false )
	#endif
#endif
			{
				const float fRandomValue1 = GetRandomFloat( CKTDXRandomNumbers::SRO_ATTACK_EXTRA_DAMAGE_ENCHANT );
				const float fRandomValue2 = GetRandomFloat( CKTDXRandomNumbers::SRO_ATTACK_EXTRA_DAMAGE_ENCHANT + 1 );

				//{{ kimhc // 2010.4.2 // 비밀던전 작업(셋트아이템효과)
#ifdef	SERV_SECRET_HELL

	#ifdef FIX_NOT_ACTIVE_ENCHANT_ATTACK_TO_ELSWORD
		#ifdef BALANCE_PATCH_20131107
				const bool bApplyEnchant = g_pData->GetEnchantItem()->ProcessEnchant( this, pDamageData, fRandomValue1, fRandomValue2 );
				
				if ( bApplyEnchant == true || bBuffApplied )
		#else //BALANCE_PATCH_20131107
				/// 버프가 적용되면 인첸트 공격 설정을 건너뛰기 때문에, 순서 변경
				if ( g_pData->GetEnchantItem()->ProcessEnchant( this, pDamageData, fRandomValue1, fRandomValue2 ) == true || bBuffApplied )
		#endif //BALANCE_PATCH_20131107
	#else // FIX_NOT_ACTIVE_ENCHANT_ATTACK_TO_ELSWORD
				/// 위에서 새로운 버프시스템의 버프/디버프가 적용 되었거나 edt가 적용되면
				if ( bBuffApplied || g_pData->GetEnchantItem()->ProcessEnchant( this, pDamageData, fRandomValue1, fRandomValue2 ) == true )
	#endif // FIX_NOT_ACTIVE_ENCHANT_ATTACK_TO_ELSWORD
				{
					ProcessSocketEffectEx( CX2SocketItem::SIEE_STAT_UP, this  );
					ProcessSocketEffectEx( CX2SocketItem::SIEE_UP_MANA_RECOVERY_VALUE, this  );
				}
#else	SERV_SECRET_HELL
				g_pData->GetEnchantItem()->ProcessEnchant( this, pDamageData, fRandomValue1, fRandomValue2 );
#endif	SERV_SECRET_HELL

#ifdef BALANCE_PATCH_20131107
				if( true == bApplyEnchant )
					SetSpecificValueByEnchant();
#endif //BALANCE_PATCH_20131107

				//}} kimhc // 2010.4.2 // 비밀던전 작업(셋트아이템효과)		
			}			
		}




		if ( pDamageData->m_bPenetrate == false )
		{
			float fFinalDamagePerSec = 0.0f;

			fFinalDamagePerSec = m_ExtraDamagePack.m_Fire.m_DamagePerSec;
			GetDamageReduceByResistExtraDamage( m_ExtraDamagePack.m_Fire.m_ExtraDamageType, fFinalDamagePerSec );
			m_ExtraDamagePack.m_Fire.m_DamagePerSec = fFinalDamagePerSec;

			fFinalDamagePerSec = m_ExtraDamagePack.m_Lightning.m_DamagePerSec;
			GetDamageReduceByResistExtraDamage( m_ExtraDamagePack.m_Lightning.m_ExtraDamageType, fFinalDamagePerSec );
			m_ExtraDamagePack.m_Lightning.m_DamagePerSec = fFinalDamagePerSec;
		}


#ifdef DRAIN_MANA

		float fPercentMPUp = 0.0f;
		float fMPUp = 0.0f;
		//세트아이템용으로 스킬 올라가는 녀석이 있는지 검사해보자.
#ifdef SUPER_SOCKET_IN_TITLE
		if( false == pDamageData->m_bNoDamage )
		{
			SetSuperArmorSocket();
		}
#else
		for ( int i = 0; i < (int)m_vecSetItemOptions.size(); i++ )
		{
			const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( m_vecSetItemOptions[i] );
			if ( pSocketData != NULL )
			{
				//{{ kimhc // 2011-05-25 // SetOption, TitleOption에만 적용 되는 option 모든 itemOption에 적용 되도록 수정
				//}} kimhc // 2011-05-25 // SetOption, TitleOption에만 적용 되는 option 모든 itemOption에 적용 되도록 수정

				


				// 피격시 일정확율로 슈퍼아머
				float fRandomValueForSuperArmor = GetRandomFloat( CKTDXRandomNumbers::SRO_SUPER_ARMOR_WHEN_ATTACKED );
				if( pSocketData->m_bDungeonOnly == true)
				{
					if ( g_pX2Game != NULL && g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON )
					{
						if( fRandomValueForSuperArmor <= pSocketData->m_fPercentSuperArmor && IsSuperArmor() == false)
						{
							m_fSocketSuperArmor = pSocketData->m_fTimeSuperArmor;
							m_bSocketSuperArmor = true;							
						}
					}
				}
				else if( pSocketData->m_bPVPOnly == true)
				{
					if ( g_pX2Game != NULL && g_pX2Game->GetGameType() == CX2Game::GT_PVP )
					{
						if(fRandomValueForSuperArmor <= pSocketData->m_fPercentSuperArmor && IsSuperArmor() == false)
						{
							m_fSocketSuperArmor = pSocketData->m_fTimeSuperArmor;
							m_bSocketSuperArmor = true;							
						}
					}
				}
				else
				{
					if(fRandomValueForSuperArmor <= pSocketData->m_fPercentSuperArmor && IsSuperArmor() == false)
					{
						m_fSocketSuperArmor = pSocketData->m_fTimeSuperArmor;
						m_bSocketSuperArmor = true;
					}
				}
			}
		}
#endif

		if ( IsSuperArmor() == false && m_bSocketSuperArmor == true)
		{
			m_FrameDataNow.stateParam.bSuperArmor = true;
			m_FrameDataNow.stateParam.bSuperArmorNotRed = false;
		}

		//{{ kimhc // 2011-05-25 // SetOption, TitleOption에만 적용 되는 option 모든 itemOption에 적용 되도록 수정
		//}} kimhc // 2011-05-25 // SetOption, TitleOption에만 적용 되는 option 모든 itemOption에 적용 되도록 수정



#ifdef FIX_ADD_MANA_WHEN_ATTACKED
		if ( pAttackerUnit != NULL )
		{
#ifdef SERV_CHUNG_TACTICAL_TROOPER				/// 택티컬 필드는 예외
			if ( 0.f >= pDamageData->m_fHpPercentUp && 0.f >= pDamageData->m_fMpPercentUp && 
				0.f >= pDamageData->m_fIncreaseMP )
#else  SERV_CHUNG_TACTICAL_TROOPER
			if ( 0.f >= pDamageData->m_fHpPercentUp && 0.f >= pDamageData->m_fMpPercentUp )
#endif SERV_CHUNG_TACTICAL_TROOPER
			{
				//{{ kimhc // 2011-05-25 // SetOption, TitleOption에만 적용 되는 option 모든 itemOption에 적용 되도록 수정

				// 공격시 증가 할 HP Percent
				float fHPPercentToBeUp = CalculateHpUpPercentBySocketOption( m_SocketData.m_vecHpUpByAttacked );
				float fHPUp = GetMaxHp() * fHPPercentToBeUp;

				if( 0.0f < fHPUp )
				{
					UpNowHp( fHPUp );

					std::wstringstream strStream;
					strStream << L"HP+ " << (int)fHPUp;
					D3DXVECTOR3 pos = GetPos();
					pos.y += 50.0f;
					if( NULL != g_pData->GetPicCharGreen() )
						g_pData->GetPicCharGreen()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );
				}
#ifdef FIX_HP_DOWN_SOCKET_OPTION
				else if( 0.0f > fHPUp )
				{
					UpNowHp( fHPUp );
				}
#endif FIX_HP_DOWN_SOCKET_OPTION
#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
				fMPUp = CalculateMpUpAttackedBySocketOption( m_SocketData.m_vecMpUpByAttacked );
#else //ADJUST_SECRET_ITEM_OPTION
				fMPUp = CalculateMpUpBySocketOption( m_SocketData.m_vecMpUpByAttacked );
#endif //ADJUST_SECRET_ITEM_OPTION

				//}} kimhc // 2011-05-25 // SetOption, TitleOption에만 적용 되는 option 모든 itemOption에 적용 되도록 수정

				if( 0.f < fMPUp )
				{
					UpNowMp( fMPUp );

					std::wstringstream strStream;
					strStream << L"MP+ " << (int)fMPUp;
					D3DXVECTOR3 pos = GetPos();
					pos.y += 50.0f;
					if( NULL != g_pData->GetPicCharBlue() )
						g_pData->GetPicCharBlue()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );
				}
			}
		}
#else
		if (  pAttackerUnit != NULL )
		{
			if( GetRandomFloat( CKTDXRandomNumbers::SRO_ADD_MANA_WHEN_ATTACKED ) < fPercentMPUp && 
				pDamageData->m_fHpPercentUp <= 0.f && pDamageData->m_fMpPercentUp <= 0.f )
			{
				UpNowMp( fMPUp );

				std::wstringstream strStream;
				strStream << L"MP+ " << (int)fMPUp;
				D3DXVECTOR3 pos = GetPos();
				pos.y += 50.0f;
				if( NULL != g_pData->GetPicCharBlue() )
					g_pData->GetPicCharBlue()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );
			}
		}
#endif

#endif //DRAIN_MANA

	}
	
#ifdef DUNGEON_ITEM	

	if(pDamageData->m_fHpPercentUp > 0.f)
	{
		float fUpRate = GetMaxHp() * pDamageData->m_fHpPercentUp;
#ifdef REFACTORING_BY_TOOL_TEAM
		UpNowHp( fUpRate );
#else REFACTORING_BY_TOOL_TEAM
		float fHpUp = GetNowHp() + fUpRate;
		SetNowHp( fHpUp );
#endif REFACTORING_BY_TOOL_TEAM


		std::wstringstream strStream;
		strStream << L"HP+ " << (int)fUpRate;
		D3DXVECTOR3 pos = GetPos();
		pos.y += 50.0f;
		if( NULL != g_pData->GetPicCharGreen() )
			g_pData->GetPicCharGreen()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );

		g_pX2Game->GetEffectSet()->PlayEffectSet(L"EffectSet_Heal", (CX2GameUnit*)this );	
		PlaySound( L"Nasod_Healer_Heal.ogg" );
	}

#ifdef TOGETHER_FESTIVAL_2012_AUTUMN
	else if(pDamageData->m_fHpPercentUp < 0.f) /// 체력 % 회복 음수 처리 ( 불안정한 엘 데미지 처리 )
	{
		float fUpRate = GetMaxHp() * pDamageData->m_fHpPercentUp;
#ifdef REFACTORING_BY_TOOL_TEAM
		UpHP( fUpRate );
#else REFACTORING_BY_TOOL_TEAM
		float fHpUp = GetNowHp() + fUpRate;
		SetNowHp( fHpUp );
#endif REFACTORING_BY_TOOL_TEAM

		std::wstringstream strStream;
		strStream << static_cast<int>( -1 * fUpRate );
		D3DXVECTOR3 pos = GetPos();
		pos.y += 50.0f;

		if( NULL != g_pData->GetPicChar() )
			g_pData->GetPicChar()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );
	}
#endif TOGETHER_FESTIVAL_2012_AUTUMN

	if( pDamageData->m_fMpPercentUp > 0.f )
	{
		float fUpRate = GetMaxMp() * pDamageData->m_fMpPercentUp;
#ifdef REFACTORING_BY_TOOL_TEAM
		UpNowMp( fUpRate );
#else
		float fMpUp = GetNowMp() + fUpRate;
		SetNowMp( fMpUp );
#endif

		std::wstringstream strStream;
		strStream << L"MP+ " << (int)fUpRate;
		D3DXVECTOR3 pos = GetPos();
		pos.y += 30.0f;
		if( NULL != g_pData->GetPicCharGreen() )
			g_pData->GetPicCharBlue()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );
	}
#endif
	// modified by wonpok. 20090821. dummy damage에 대해서는 StopTime을 풀지 않는다.
	//if( m_FrameDataNow.stateParam.bSuperArmor != true )
	if ( IsSuperArmor() != true && pDamageData->reActResult != CX2DamageManager::RT_DUMMY_DAMAGE )
	{
#ifdef DAMAGE_REACT_STOPTIME_CONDITION_FIX
		if(pDamageData->reActResult != CX2DamageManager::RT_NO_DAMAGE)
		{
#endif DAMAGE_REACT_STOPTIME_CONDITION_FIX
			SetStopTime( pDamageData->fStopTimeDef );
			SetStop2Time( 0.0f );	
#ifdef DAMAGE_REACT_STOPTIME_CONDITION_FIX
		}
#endif DAMAGE_REACT_STOPTIME_CONDITION_FIX
	}

	m_DamageLightTime = 0.2f;

	if( true == IsDamagedReaction( pDamageData ) &&
		false == pDamageData->m_bNoDamage )
	{

#ifdef EQUIP_STRIP_TEST

		if( NULL != g_pX2Game &&
			g_pX2Game->GetGameType() == CX2Game::GT_PVP )
		{
			const int MAGIC_SUCCESIVE_HIT_COUNT_FOR_EQUIP_STRIP = 3;
			const float MAGIC_TIME_FOR_SUCCESIVE_HIT_COUNT = 3.f;

			m_iSuccessiveHitCount++;
			m_fTimeLeftToClearOutSuccessiveHit = MAGIC_TIME_FOR_SUCCESIVE_HIT_COUNT;

			if( m_iSuccessiveHitCount > MAGIC_SUCCESIVE_HIT_COUNT_FOR_EQUIP_STRIP )
			{
				m_iSuccessiveHitCount = 0;


				SetEquipStrippedState( CX2Unit::EP_DEFENCE_BODY, true );	// fix!!!!
				SetEquipStrippedState( CX2Unit::EP_DEFENCE_LEG, true );		// fix!!!!
				SetEquipStrippedState( CX2Unit::EP_DEFENCE_HAND, true );	// fix!!!!
				SetEquipStrippedState( CX2Unit::EP_DEFENCE_FOOT, true );	// fix!!!!
			}
		}

#endif EQUIP_STRIP_TEST




#ifdef NEW_SKILL_TREE
		// 마나실드와 같은 타격방어시에 사운드 어떻게 할지 결정후 구현해야함
		// m_iDefenceCount		
#endif

// 		if ( null != pDamageData->optrAttackerGameUnit )
// 			pDamageData->optrAttackerGameUnit->ModifyFinalDamageByGameUnitType( pDamageData );

		float fFinalDamage = GetFinalDamage( pDamageData );

#ifdef UPGRADE_RAVEN
		// 레이븐 패링
		if( m_bParryingState == true )
		{
			CX2GURaven *pRaven = (CX2GURaven*)this;
			if( pRaven != NULL )
			{
				m_PhysicParam.nowSpeed.x *= 0.7f;
				m_PhysicParam.nowSpeed.y = 0.f;

				fFinalDamage *= ( 1.f - 0.75 );

				D3DXVECTOR3 vDirVec = pRaven->GetDirVector();
				D3DXVECTOR3 vPos = pRaven->GetPos();
				
#ifdef VERIFY_STAT_BY_BUFF
				const PROTECT_VECTOR3 &vScale = pRaven->GetScaleByUnit();
#else	VERIFY_STAT_BY_BUFF
				const D3DXVECTOR3 &vScale = pRaven->GetScaleByUnit();
#endif // VERIFY_STAT_BY_BUFF
				D3DXVECTOR3 vOffset = vScale.x * vDirVec * 70.f;
				float fOffsetY = vScale.y * 100.f;

				vPos = vPos +  vOffset + D3DXVECTOR3( 0.f, fOffsetY, 0.f );

				g_pX2Game->GetEffectSet()->PlayEffectSetWithCustomPos_LUA( "EffectSet_RAVEN_PARRING", this, vPos, vDirVec );	

				PlaySound(L"Raven_NasodCore_Guard.ogg");
			}			
		}
#endif

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
		// 이브 패링
		if( m_bManeuverParryingState == true )
		{
			CX2GUEve *pEve = static_cast<CX2GUEve*> ( this );
			if( pEve != NULL )
			{
				m_PhysicParam.nowSpeed.x *= 0.7f;
				m_PhysicParam.nowSpeed.y = 0.f;

				fFinalDamage *= ( 1.f - 0.75 );

				D3DXVECTOR3 vDirVec = pEve->GetDirVector();
				D3DXVECTOR3 vPos = pEve->GetPos();

				const PROTECT_VECTOR3 &vScale = pEve->GetScaleByUnit();
				D3DXVECTOR3 vOffset = vScale.x * vDirVec * 70.f;
				float fOffsetY = vScale.y * 100.f;

				vPos = vPos +  vOffset + D3DXVECTOR3( 0.f, fOffsetY, 0.f );

				g_pX2Game->GetEffectSet()->PlayEffectSetWithCustomPos_LUA( "EffectSet_Eve_PARRING", this, vPos, vDirVec );	

				// PlaySound(L"Raven_NasodCore_Guard.ogg");
			}			
		}
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
		float fReducedDamagePercent = GetBasicReducedDamagePercent();

		if ( pAttackerUnit != NULL )
		{
			if ( pAttackerUnit->GetGameUnitType() == CX2GameUnit::GUT_NPC )
			{
				CX2GUNPC* pGUNPC = static_cast<CX2GUNPC*>( pAttackerUnit );

				fReducedDamagePercent += GetReducedDamagePercentByMonsterAttack( pGUNPC->GetNPCTemplet().m_nNPCUnitID );
			}
		}

		if ( pDamageData->m_bPenetrate == false )
		{
			fFinalDamage -= fFinalDamage * fReducedDamagePercent;
		}		

//{{ kimhc // 2010.4.7 // 비밀던전 작업(셋트아이템효과)
#ifdef SERV_SECRET_HELL
		if ( m_pBoneShieldData != NULL )
		{
			if ( m_pBoneShieldData->m_fTimeLeft > 0.0f && m_pBoneShieldData->m_byCountLeft > 0 )
			{
				fFinalDamage -= fFinalDamage * m_pBoneShieldData->m_fReducePercent;
				m_pBoneShieldData->m_byCountLeft--;
				g_pX2Game->GetEffectSet()->PlayEffectSet( m_pBoneShieldData->m_wstrEffectName, this, this );
			}
		}
		else
			ProcessSocketEffectEx( CX2SocketItem::SIEE_BONE_SHIELD, this  );
#endif SERV_SECRET_HELL
//}} kimhc // 2010.4.7 // 비밀던전 작업(셋트아이템효과)

		if ( IsMyUnit() )
		{
#ifdef ADD_RENA_SYSTEM
			/// NF를 통해 발생된 폭발은 HitCount에 추가하지 않는다.
			if ( CX2DamageManager::NFT_RESULT_BOMB != pDamageData->m_NaturalForceType )
				SetHittedCount( GetHittedCount() + 1 );
#else // ADD_RENA_SYSTEM
			SetHittedCount( GetHittedCount() + 1 );
#endif // ADD_RENA_SYSTEM
		}

#ifdef DUNGEON_ITEM
		if( (CX2EnchantItem::ENCHANT_TYPE)pDamageData->m_ResistType != CX2EnchantItem::ET_NONE )
		{			
			ApplyEnchantResist( (CX2EnchantItem::ENCHANT_TYPE)pDamageData->m_ResistType, fFinalDamage );		
		}
#endif

		D3DXVECTOR3 numPos;
		GetFramePos( &numPos, m_pFrame_Bip01_Head );
		numPos.y += 70.0f;


		D3DXVECTOR3 criticalNumPos = numPos;
		criticalNumPos.y += 40.0f;

		//{{ dmlee 2009.5.13 공격형태에 관계없이 크리티컬 터질수 있게 수정, 아이샤 라이트닝볼트와 구체연타, 엘소드 필살기 중 일부가 AT_MESH, AT_MANUAL_COLLISION_DATA를 사용하고 있음
		//if ( ( pDamageData->attackerType == CX2DamageManager::AT_UNIT ||
		//	pDamageData->attackerType == CX2DamageManager::AT_EFFECT ) &&
		//	pDamageData->pAttackerUnit != NULL )
		//{

		bool bShowRedPicture = false;	// 감소된 HP를 빨간색으로 보여줘야 하는지 여부
		if( pAttackerUnit != NULL )
		{
		//}} dmlee 2009.5.13 공격형태에 관계없이 크리티컬 터질수 있게 수정, 아이샤 라이트닝볼트와 구체연타, 엘소드 필살기 중 일부가 AT_MESH, AT_MANUAL_COLLISION_DATA를 사용하고 있음			

			//{{ 2011-04 에 패치될 청 메모 헤드샷
#ifdef	CHUNG_MEMO_01			
			// 헤드샷이 적용될 것인지 판단 후 수행함
			ApplyHeadShotDamage( &fFinalDamage );
#endif	CHUNG_MEMO_01				
			//}} 2011-04 에 패치될 청 메모 헤드샷

			float fCriticalRate = pAttackerUnit->GetCriticalPercent( pDamageData->damageType, pDamageData->m_fCriticalRate );

#ifdef ELSWORD_WAY_OF_SWORD
			pAttackerUnit->SetCriticalPercent_WayOfSword( IN pDamageData->m_WayofSwordType, OUT fCriticalRate );
#endif // ELSWORD_WAY_OF_SWO

#ifdef ADD_BACKATTACK			
			if( bBackAttack == true )
			{
				fCriticalRate *= 1.5f;
			}
#endif

#ifdef CHUNG_SECOND_CLASS_CHANGE
			if( 0.f < m_fAntiCriticalRate )
			{
				fCriticalRate -= m_fAntiCriticalRate;
				if(fCriticalRate < 0.f)
					fCriticalRate = 0.f;
			}
#endif CHUNG_SECOND_CLASS_CHANGE	

			//{{ 2011-04 에 패치될 청 캐시 스킬
#ifdef	CASH_SKILL_FOR_CHUNG_2011_04
			if( GetCriticalValueFromDefender() <= fCriticalRate )
#else	CASH_SKILL_FOR_CHUNG_2011_04				
			if( GetRandomFloat( CKTDXRandomNumbers::SRO_ATTACK_CRITICAL ) <= fCriticalRate )
#endif	CASH_SKILL_FOR_CHUNG_2011_04				
				//}} 2011-04 에 패치될 청 캐시 스킬
			{

				bShowRedPicture = true; 
				float fDefenderCriticalValue = 0.f;

#ifdef RENA_SECOND_CLASS_CHANGE
				// 레나 낙인의 사격에 피해를 받은 상태인 경우에 받는 크리티컬 데미지가 증가한다
				if( m_ExtraDamagePack.m_StigmaDebuff.m_fTime > 0.f )
				{
					fDefenderCriticalValue = m_ExtraDamagePack.m_StigmaDebuff.m_DamagePerSec;	// 크리티컬 데미지 증가 비율을 곱한다
				}
#endif RENA_SECOND_CLASS_CHANGE

#ifdef NEW_CHARACTER_EL
				// 마법 공격에만 적용되는 크리티컬 데미지 배율 설정
				if( CX2GUUser::GUT_USER	== pAttackerUnit->GetGameUnitType() )
				{
					CX2GUUser* pGUUser = static_cast<CX2GUUser*>(pAttackerUnit);
					if( NULL != pGUUser )
					{
						switch( pDamageData->damageType )
						{
						case CX2DamageManager::DT_MAGIC:
						case CX2DamageManager::DT_MIX:
						case CX2DamageManager::DT_WEAPON_MAGIC:
						case CX2DamageManager::DT_WEAPON_MIX:
							{
								// 기본 크리티컬 공격 배율 + 마법 공격 크리티컬 배율
								float fCriticalDamageRate = pGUUser->GetCriticalValue( fDefenderCriticalValue );
								fCriticalDamageRate += pGUUser->GetAddMagicAttackCriticalDamageRate();

#ifdef ADD_MEMO_1ST_CLASS //김창한
								fCriticalDamageRate += pDamageData->m_fApplyCriticalDamage ;
#endif //ADD_MEMO_1ST_CLASS
								// 크리티컬 공격 방어력 적용
								fCriticalDamageRate *= GetCriticalDefence();

								// FinalDamage 에 크리티컬 공격 적용
								fFinalDamage *= fCriticalDamageRate;
							} break;
						default:
							{
								float fCritical = pAttackerUnit->GetCriticalValue( fDefenderCriticalValue );

#ifdef ADD_MEMO_1ST_CLASS //김창한
								fCritical += pDamageData->m_fApplyCriticalDamage ;
#endif //ADD_MEMO_1ST_CLASS

								// 크리티컬 공격 방어력 적용
								fCritical *= GetCriticalDefence();

								if ( fCritical >= 1.0f )
									fFinalDamage *= fCritical;
							} break;
						}
					}
				}
				else
#endif // NEW_CHARACTER_EL
				{
					float fCritical = pAttackerUnit->GetCriticalValue( fDefenderCriticalValue ) * GetCriticalDefence();
					if ( fCritical >= 1.0f )
						fFinalDamage *= fCritical;
				}

				//크리티컬~~
				D3DXVECTOR3 criticalEffPos = criticalNumPos;
				criticalEffPos.y += 20.f;

				g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"CriticalHit01", criticalEffPos );

#ifdef ADD_BACKATTACK
				g_pX2Game->GetX2Camera()->GetCamera().ImpactForward( 25.f, 150.f, 15.f, 0.6f, 1 );
#else
				UpDownCrashCamera(40.f, 0.3f);
#endif
				//pDamageData->fCameraCrashGap = 40.0f;
				//pDamageData->fCameraCrashTime = 0.3f;

				PlaySound( L"Critical_Hit.wav" );

#ifdef ADD_BACKATTACK
				bCriticalHit = true;
#endif
			}
		}
				
#ifdef ADD_BACKATTACK
		if( bBackAttack == true && bCriticalHit == false )
		{
			bShowRedPicture = true;
			fFinalDamage *= 1.1f;
			g_pX2Game->GetX2Camera()->GetCamera().UpDownCrashCamera(50.f, 0.3f);
			

			PlaySound( L"HitKingNasod.wav", true, false );

			D3DXVECTOR3 vBackAttackPos = GetHeadBonePos();
			vBackAttackPos.y += 110.f;
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"damage_backAttack_P01", vBackAttackPos );
		}
#endif
		
		/// 더블 어택 디버프 발동 여부 연산
		if(  CX2DamageManager::AT_NORMAL ==  pDamageData->attackType )
		{
			if( IsDoubleAttackByBuff() )
				m_bDoubleAttack = true;
		}

		// 더블어택은 데미지를 2배로 주지만, UI에 표시하기는 데미지를 반반씩 2번 보여준다. (UI 분리는 뒷부분에..)
		if ( true == m_bDoubleAttack )
		{
			fFinalDamage *= 2.f;	// 실제 데미지만 증가
			bShowRedPicture = true; // 더블어택의 경우 빨간색으로 표시!!
		}
		
		bool bCanDrainHp = false;

#ifdef BALANCE_BLADE_MASTER_20130117		/// 이펙트에도 피 흡수를 적용 시킬 수 있도록 수정
		CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
		if( NULL != pAttackerUnit )
		{
			pAttackerUnit->GetDrainHpBuffValue( pDamageData );

		}
#endif BALANCE_BLADE_MASTER_20130117

		if( pDamageData->m_fDrainHpRate > 0.f && pDamageData->attackType != CX2DamageManager::AT_SPECIAL )
		{
			bCanDrainHp = true;
		}
	
		if( bCanDrainHp == true )
		{			
			if( pAttackerUnit != NULL && pAttackerUnit->GetGageData() != NULL )
			{				
				float fDrainDamage = fFinalDamage * pDamageData->m_fDrainHpRate;				

				if( fDrainDamage > 0.f )
				{
					std::wstringstream strStream;
					strStream << L"HP+ " << (int)fDrainDamage;
					D3DXVECTOR3 pos = pAttackerUnit->GetPos();
					pos.y += 50.0f;
					if( NULL != g_pData->GetPicCharGreen() )
						g_pData->GetPicCharGreen()->DrawText( strStream.str().c_str(), pos, pAttackerUnit->GetDirVector(), CKTDGPicChar::AT_CENTER );

					//if( IsMyUnit() == true )
					{
						pAttackerUnit->UpNowHp( fDrainDamage ); 
					}					
				}					
			}				
		}		

#ifdef SERV_ADD_ARME_BATTLE_MAGICIAN
		if( pDamageData->m_fDrainMpByReact > 0.f )
		{
			if( pAttackerUnit != NULL && pAttackerUnit->GetGageData() != NULL )
			{				
				pAttackerUnit->UpNowMp( pDamageData->m_fDrainMpByReact * pDamageData->m_fDrainMpRate);
				std::wstringstream strStream;
				strStream << L"MP+ " << (int)(pDamageData->m_fDrainMpByReact * pDamageData->m_fDrainMpRate);
				D3DXVECTOR3 pos = pAttackerUnit->GetPos();				
				pos.y += 70.0f;
				if( NULL != g_pData->GetPicCharGreen() )
					g_pData->GetPicCharGreen()->DrawText( strStream.str().c_str(), pos, pAttackerUnit->GetDirVector(), CKTDGPicChar::AT_CENTER );

				UpNowMp( -1.f * pDamageData->m_fDrainMpByReact );
				std::wstringstream strStreamDamage;
				strStreamDamage << L"MP -" << (int)pDamageData->m_fDrainMpByReact;
				D3DXVECTOR3 posTarget = GetPos();
				pos.y += 70.f;
				if( NULL != g_pData->GetPicCharRed() )
					g_pData->GetPicCharRed()->DrawText( strStreamDamage.str().c_str(), posTarget, GetDirVector(), CKTDGPicChar::AT_CENTER );
			}
		}
#endif

#ifdef ARA_CHANGE_CLASS_FIRST
		if ( true == m_bQuickenGuardBlocking )
		{
			CX2GUAra *pAra = static_cast<CX2GUAra*>(this);

			if ( NULL != pAra )
			{
				fFinalDamage *= 0.f;
			}
		}
#endif

#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE	  // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
		bool bIsPossibleProvoke = false;			// 반격이 가능한 상태 인가?
		if ( GetUnit() != NULL && GetUnit()->GetType() == CX2Unit::UT_ELESIS && GetUnit()->GetClass() == CX2Unit::UC_ELESIS_GRAND_MASTER )
		{
			CX2GUEL * pElesisUser = static_cast<CX2GUEL *> ( this );

			if ( NULL != pElesisUser && true == pElesisUser->GetIsProvokeStateChange() )
			{
				pElesisUser->SetIsProvokeStateChange(false);	// 실패한 경우로 초기화 한다, 성공한다면 true 로 변경한다.
				if ( NULL != g_pData->GetDamageManager() )
				{
					// 반격이 가능한 상태이고, Attack Type 이 노말 이고, NO_DAMAGE 가 아니고
					// 피나 마나를 채워주는 형태가 아니고 더미 데미지 타입이 아니고, 센서 타입도 아니고
					// 그라운드 히트 형태도 아니고 홀드 상태나 그랩 상태도 아니고 라이딩 펫 탄 상태도 아니고
					// 때린 애가 자기 앞에 있고 Provoke Loop 상태 일 때만.........
					if (  CX2DamageManager::AT_NORMAL == pDamageData->attackType && pDamageData->m_bNoDamage == false 
						&& true == g_pData->GetDamageManager()->GetIsPossibleProvokeExtraDamage(pDamageData)
						&& pDamageData->m_fHpPercentUp <= 0.f && pDamageData->m_fIncreaseMP <= 0.f 
						&& pDamageData->reActResult != CX2DamageManager::RT_DUMMY_DAMAGE
						&& pDamageData->reActResult != CX2DamageManager::RT_SENSOR && pDamageData->hitType != CX2DamageManager::HT_GROUND_HIT
						&& GetHold() == false && GetGrap() == false 
						&& false == GetRidingOn() && true == m_FrameDataFuture.unitCondition.bAttackerFront 
						)
					{
						pDamageData->reActResult = CX2DamageManager::RT_SMALL_DAMAGE;
						pElesisUser->SetIsProvokeStateChange(true);	// 반격이 가능한 상태이다, true 로 변경한다.
						bIsPossibleProvoke = true;	
						fFinalDamage *= 0.f;
					}
				}
			}
		}
#endif // SERV_ELESIS_SECOND_CLASS_CHANGE // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트


		////////////////////////// fFinalDamage의 변경은 이 위로 해주세요!!! (옵션 수치화 제외)///////////////////////////////////

		//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업
#ifdef SERV_ADD_ARME_BATTLE_MAGICIAN
		if( pDamageData->m_bLvDamage == false )
#endif
		{
			// 모든 계산을 거친 최종 대미지에 옵션 수치화의 데미지 감소를 적용 (snatch에 영향을 주지 않음)
			if ( 0.0f < GetAdditionalDefence() )
			{
				fFinalDamage -= min( fFinalDamage * GetAdditionalDefence(), fFinalDamage );
			}
		}


#ifdef SERV_ADD_ARME_BATTLE_MAGICIAN
		if( pDamageData->m_bLvDamage == false )
#endif
		{
			if( NULL != pAttackerUnit )
			{
				const float fAdditionalAttackValue = pAttackerUnit->GetAdditionalAttackDamage( pDamageData );
				if ( 0.0f < fAdditionalAttackValue )
				{
					fFinalDamage += fAdditionalAttackValue;

					// 더블 어택의 경우 한번 더 더해준다.
					if ( true == m_bDoubleAttack )
						fFinalDamage += fAdditionalAttackValue;
				}
			}
		}


#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE	  // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
		if ( true == bIsPossibleProvoke )	// 엘리시스 반격이 성공한 상태라면
		{
			fFinalDamage = 0;				//추댐 영향도 받지 않기 위해 여기에 예외 처리 
		}
#endif // SERV_ELESIS_SECOND_CLASS_CHANGE // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
		//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업

#ifdef SERV_9TH_NEW_CHARACTER // 김태환
		if ( null != pDamageData->optrAttackerGameUnit && GUT_USER == pDamageData->optrAttackerGameUnit->GetGameUnitType() )
		{
			CX2GUUser* pUser = static_cast< CX2GUUser* >( pDamageData->optrAttackerGameUnit.GetObservable() );

			if ( NULL != pUser && 
				 NULL != pUser->GetUnit() && 
				 NULL != pUser->GetUnit()->GetUnitTemplet() && 
				 CX2Unit::UT_ADD == pUser->GetUnit()->GetType() )
			{
				/// 스테이시스 필드용 타격 수치 연산해 주자
				pUser->SetStasisfieldHitValue( fFinalDamage );
			}
		}
#endif //SERV_9TH_NEW_CHARACTER

		// UI상 타격된 데미지를 보여주기 위한 용도
		float fFinalDamageToShow = fFinalDamage;
#ifdef ALWAYS_SCREEN_SHOT_TEST
		if( g_pInstanceData->GetScreenShotTest() == false)
		{
			// 더블 어택의 경우
			if ( m_bDoubleAttack )
			{
				// 보여주는 UI상의 수치를 1/2로 하여 두번 보여준다.
				fFinalDamageToShow *= 0.5f;
				SetDoubleAttack(wstrHitSound, fFinalDamageToShow, pDamageData->impactPoint);	// 한번 더 보여줌
			}

			// 크리티컬이거나 더블 어택이면 빨간색으로 표시
			if ( true == bShowRedPicture )
			{
				if( NULL != g_pData->GetPicCharRed() )
					g_pData->GetPicCharRed()->DrawText( static_cast<int>( fFinalDamageToShow ), numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );
			}
			else	// 그렇지 않으면 일반 노란색
			{
				if( NULL != g_pData->GetPicChar() )
					g_pData->GetPicChar()->DrawText( static_cast<int>( fFinalDamageToShow ), numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );
			}
		}
#else 
		// 더블 어택의 경우
		if ( m_bDoubleAttack )
		{
			// 보여주는 UI상의 수치를 1/2로 하여 두번 보여준다.
			fFinalDamageToShow *= 0.5f;
			SetDoubleAttack(wstrHitSound, fFinalDamageToShow, pDamageData->impactPoint);	// 한번 더 보여줌
		}

		// 크리티컬이거나 더블 어택이면 빨간색으로 표시
		if ( true == bShowRedPicture )
		{
			if( NULL != g_pData->GetPicCharRed() )
				g_pData->GetPicCharRed()->DrawText( static_cast<int>( fFinalDamageToShow ), numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );
		}
		else	// 그렇지 않으면 일반 노란색
		{
			if( NULL != g_pData->GetPicChar() )
				g_pData->GetPicChar()->DrawText( static_cast<int>( fFinalDamageToShow ), numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );
		}
#endif ALWAYS_SCREEN_SHOT_TEST



#ifdef NEXON_QA_CHEAT_REQ
		if( NULL != g_pData->GetMyUser() && g_pData->GetMyUser()->GetAuthLevel() >= CX2User::XUAL_SPECIAL_USER )
		if( true == GetInvincibleAndNoMpConsume_Cheat() )
			fFinalDamage = 0.0f;
#endif //NEXON_QA_CHEAT_REQ

#ifdef FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE // 김태환

		/// 죽을 때 발동되는 스킬 검사 및 처리
		ProcessSkillAtDie( fFinalDamage, pDamageData );

#else //FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE

	#ifdef SERV_ARA_CHANGE_CLASS_SECOND // 김태환
		if ( fFinalDamage > GetNowHp() )
		{
			/// 아라 2차 전직 명왕 - 회광반조
			int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_AYR_RESURRECTION, true );

			if( iSkillLevel > 0 )
			{
				CX2GUAra* pAra = static_cast<CX2GUAra*>( this );

				/// 아라일 때, 회광반조 동작
				if ( NULL != pAra && NULL != GetUnit() && CX2Unit::UT_ARA == GetUnit()->GetType() )
				{
					pAra->SetResurrection( iSkillLevel );					/// 회광반조 설정

		#ifdef SET_INVINCIBLE_AT_RESURRECTION
					SetForceInvincible( 1.f );								/// 일정시간 무적 설정
		#endif // SET_INVINCIBLE_AT_RESURRECTION

					pDamageData->reActResult = CX2DamageManager::RT_DOWN;	/// 강제로 넘어뜨려 버리자
				}
			}
		}
	#endif // SERV_ARA_CHANGE_CLASS_SECOND

#endif //FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE

	#ifdef SERV_9TH_NEW_CHARACTER // 김태환
		if ( NULL != GetUnit() && CX2Unit::UT_ADD == GetUnit()->GetType() )
		{
			/// 스테이시스 필드용 피격 수치 연산해 주자
			SetStasisfieldDamageValue( fFinalDamage );

	#ifdef SERV_ADD_LUNATIC_PSYKER // 김태환
			switch ( GetUnit()->GetClass() )
			{
			case CX2Unit::UC_ADD_LUNATIC_PSYKER:
				{
					/// 리버스 리액터용 피격 데미지 설정
					SetReverseReactorTransitionDamage( fFinalDamage );
				} break;
			}
	#endif //SERV_ADD_LUNATIC_PSYKER
		}
	#endif //SERV_9TH_NEW_CHARACTER

		if( IsMyUnit() == true )
		{
			m_nDamageCount++;

	#ifdef SERV_9TH_NEW_CHARACTER // 김태환
			/// 애드일 땐, 피격시 DP 수치 올려 주자
			if ( NULL != GetUnit() && CX2Unit::UT_ADD == GetUnit()->GetType() )
			{
				/// 한 프레임당 한번만 수행
				if ( false == GetUpDPByDamageThisFrame() )
				{
					UpNowDPValueByDamage( fFinalDamage );
					SetUpDPByDamageThisFrame( true );
				}
				
			}
	#endif //SERV_9TH_NEW_CHARACTER

			float fOldHP = GetNowHp();

//#ifdef PVP_BOSS_COMBAT_TEST
//
//			if( CX2Game::GT_PVP == g_pX2Game->GetGameType() )
//			{
//				CX2PVPRoom* pPVPRoom = (CX2PVPRoom*) g_pX2Room;
//				if( CX2PVPRoom::PGT_TEAM_DEATH == pPVPRoom->GetPVPGameType() &&
//					NULL != g_pX2Room &&
//					NULL != g_pX2Room->GetSlotDataByUnitUID( GetUnitUID() ) &&
//					false == g_pX2Room->GetSlotDataByUnitUID( GetUnitUID() )->GetIsBoss() )
//				{
//					if( m_TeamNum == m_TeamNumOriginal )
//					{
//						if( fOldHP - fFinalDamage <= 1.f )
//						{
//							SetNowHp( 1.f );
//							pDamageData->reActResult = CX2DamageManager::RT_NO_DAMAGE;
//
//							m_TeamNum = 9;
//							StateChange( m_FrozenState );
//						}
//						else
//						{
//							UpNowHp( -fFinalDamage );
//						}
//					}
//					else
//					{
//
//						if( NULL != pAttackerUnit && 
//							m_TeamNumOriginal == pAttackerUnit->GetTeam() )
//						{
//							// fix!! 얼음 상태에서 피격 모션 추가해야 함!!
//							const int MAGIC_FRIENDLY_HIT_COUNT_TO_MELT = 5;
//							if( m_iFriendlyHittedCountAtFrozenState > MAGIC_FRIENDLY_HIT_COUNT_TO_MELT )
//							{
//								SetNowHp( GetMaxHp() * 0.9f );
//								m_TeamNum = m_TeamNumOriginal;
//								StateChange( USI_DAMAGE_AIR_FALL );							
//							}
//							else
//							{
//								m_iFriendlyHittedCountAtFrozenState++;
//								fFinalDamage = 0;
//								pDamageData->reActResult = CX2DamageManager::RT_NO_DAMAGE;
//							}
//						}
//						else
//						{
//							fFinalDamage = 0.f;
//							pDamageData->reActResult = CX2DamageManager::RT_NO_DAMAGE;
//						}
//					}
//				}
//				else
//				{
//					UpNowHp( -fFinalDamage );
//				}
//			}
//			else
//			{
//				UpNowHp( -fFinalDamage );
//			}
//#else PVP_BOSS_COMBAT_TEST
			//{{AFX
			UpNowHp( -fFinalDamage );
			//}}AFX
//#endif PVP_BOSS_COMBAT_TEST

			if( g_pMain->GetNowStateID() == CX2Main::XS_TRAINING_GAME )
			{
				if( GetNowHp() <= 0.f )
					SetNowHp( 1.f );
			}

		/// 죽을 때 발동되는 스킬들을 함수 하나에 통합
#ifndef FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE // 김태환

			if( m_SkillRelatedData.m_fSkillCoolTimeLeft_SI_P_COMMON_SOFTBODY <= 0.f &&
				fOldHP > 0.f &&
				GetNowHp() <= 0.f ) 
			{
		#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
				int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_LCR_SOFTBODY, true );

				if( iSkillLevel > 0 )
				{
					const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_LCR_SOFTBODY );

					if( NULL != pSkillTemplet )
					{
						if( GetRandomFloat() < pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE, iSkillLevel ) )
						{
							SetNowHp( 1.f );							
							pDamageData->reActResult = CX2DamageManager::RT_DOWN;

							m_SkillRelatedData.m_fSkillCoolTimeLeft_SI_P_COMMON_SOFTBODY = pSkillTemplet->GetSkillCoolTimeValue( iSkillLevel );
						#ifdef FIX_SKILL_BALANCE_AISHA_LENA //JHKang
							SetBuffFactorToGameUnit( pSkillTemplet, 0 );
						#endif //FIX_SKILL_BALANCE_AISHA_LENA
						}
					}
		#else //UPGRADE_SKILL_SYSTEM_2013
				int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_SOFTBODY );

				if( iSkillLevel > 0 )
				{
					const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_SOFTBODY, iSkillLevel );

					if( NULL != pSkillTemplet )
					{
						if( GetRandomFloat() < pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE ) )
						{
							SetNowHp( 1.f );							
							pDamageData->reActResult = CX2DamageManager::RT_DOWN;


							m_SkillRelatedData.m_fSkillCoolTimeLeft_SI_P_COMMON_SOFTBODY = pSkillTemplet->m_fSkillCoolTime;
						}
					}
		#endif //UPGRADE_SKILL_SYSTEM_2013
				}	
			}

#endif //FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE

			if( m_bUpMPThisFrame == false )
			{
				int		redAdv						= 0;
				int		blueAdv						= 0;
				float	fIncreaseMpRate				= 1.0f;		// 피*타격시 마나 + 증가치(1.0은 증가가 없는 비율)
				float	fIncreaseSoulRate			= 1.0f;		// 피*타격시 각성 + 증가치
#ifdef ELSWORD_WAY_OF_SWORD
				if( CX2GameUnit::GUT_USER == GetGameUnitType() )
				{
					if( CX2Unit::UT_ELSWORD == GetUnit()->GetType() )
					{
						fIncreaseMpRate *= g_pData->GetDamageManager()->CalcVigorMpUpOnDamageReact( GetWayOfSwordState() );
					}
				}
#endif ELSWORD_WAY_OF_SWORD

			//{{ kimhc // 2009-11-17 // 길드 스킬 중 정신집중, 집중된 마력, 격노, 분노해방
#ifdef	GUILD_SKILL
				
				const CX2Unit::UnitData* pUnitData = &GetUnit()->GetUnitData();

				// 정신집중
				const CX2SkillTree::SkillTemplet* pSkillTemplet = pUnitData->m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_GP_COMMON_CONCENTRATION_OF_SPIRIT, pUnitData->m_byMemberShipGrade );
				
				if( NULL != pSkillTemplet )
				{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
					const int iSkillTempletLevel = max( 1, pUnitData->m_UserSkillTree.GetSkillLevel( pSkillTemplet->m_eID, true ) );	/// 스킬 레벨
	
					fIncreaseMpRate *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_GET_HIT_REL, iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
					fIncreaseMpRate *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_GET_HIT_REL );
	#endif // UPGRADE_SKILL_SYSTEM_2013
				}

				// 격노

				pSkillTemplet = pUnitData->m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_GP_COMMON_VIOLENT, pUnitData->m_byMemberShipGrade );

				if( NULL != pSkillTemplet )
				{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
					const int iSkillTempletLevel = max( 1, pUnitData->m_UserSkillTree.GetSkillLevel( pSkillTemplet->m_eID, true ) );	/// 스킬 레벨

					float fRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SOUL_GAIN_GET_HIT_REL, iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
					float fRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SOUL_GAIN_GET_HIT_REL );
	#endif // UPGRADE_SKILL_SYSTEM_2013

					fIncreaseSoulRate += CalculateIncreasingRate( fRate );					
				}
#endif	GUILD_SKILL
			//}} kimhc // 2009-11-17 // 길드 스킬 중 정신집중, 집중된 마력, 격노, 분노해방
				
				//{{ kimhc // 2010.11.3 // 레피 - 승화된 분노
#ifdef	NEW_SKILL_2010_11
				const CX2SkillTree::SkillTemplet* pSkillTempletSpritualizedFury 
					= pUnitData->m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_P_RRF_SPIRITUALIZED_FURY );

				if ( NULL != pSkillTempletSpritualizedFury )
				{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
					const int iSkillTempletLevel = max( 1, pUnitData->m_UserSkillTree.GetSkillLevel( pSkillTempletSpritualizedFury->m_eID, true ) );	/// 스킬 레벨

					float fRate = pSkillTempletSpritualizedFury->GetSkillAbilityValue( CX2SkillTree::SA_SOUL_GAIN_GET_HIT_REL, iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
					float fRate = pSkillTempletSpritualizedFury->GetSkillAbilityValue( CX2SkillTree::SA_SOUL_GAIN_GET_HIT_REL );
	#endif // UPGRADE_SKILL_SYSTEM_2013
					
					fIncreaseSoulRate += CalculateIncreasingRate( fRate );
				} // if
#endif	NEW_SKILL_2010_11
				//}} kimhc // 2010.11.3 // 레피 - 승화된 분노

				if( g_pX2Room != NULL && g_pData->GetPVPRoom() != NULL )
				{
					if( g_pX2Room->GetRoomType() == CX2Room::RT_PVP )
					{
						if( g_pData->GetPVPRoom()->GetPVPGameType() == CX2PVPRoom::PGT_TEAM
							|| g_pData->GetPVPRoom()->GetPVPGameType() == CX2PVPRoom::PGT_TEAM_DEATH )
						{
							int redNum		= g_pX2Room->GetTeamNum( CX2Room::TN_RED, true );
							int blueNum		= g_pX2Room->GetTeamNum( CX2Room::TN_BLUE, true );
							if( redNum > blueNum )
							{
								blueAdv = redNum - blueNum;
							}
							else if( redNum < blueNum )
							{
								redAdv = blueNum - redNum;
							}
						}					
					}
				}

				//{{ dmlee 2008.04.11 캐시 아이템 착용시
				if( 0.f != m_CashItemAbility.m_fUpMPAtAttackOrDamage )
				{
					UpNowMp( m_CashItemAbility.m_fUpMPAtAttackOrDamage );
				}
				//}} dmlee 2008.04.11 캐시 아이템 착용시

				//{{ 박진웅 : 대전 블루팀 마나 회복률 보너스 없던 문제 수정
				float teamAdv = 0.f;
				if( GetTeam() == CX2Room::TN_RED )
					teamAdv = (float)redAdv;
				else if( GetTeam() == CX2Room::TN_BLUE )
					teamAdv = (float)blueAdv;

				switch ( g_pX2Game->GetGameType() )
				{
				case CX2Game::GT_PVP:
					{
						//float fIncreaseMp = (3.0f + (2.0f * teamAdv)) * fIncreaseMpRate;
						SetBasicStatValueChargeMpHitted( (3.0f + (2.0f * teamAdv)) * fIncreaseMpRate );
						CheckAndUpdateAdditionalChargeMpHitted();

						UpNowMp( GetChargeMpHitted() );
#ifdef SERV_PET_SYSTEM
						fMpPet = (3.0f + (2.0f * teamAdv)) * fIncreaseMpRate;
#endif
					} break;

				case CX2Game::GT_DUNGEON:
				case CX2Game::GT_BATTLE_FIELD:
					{
						SetBasicStatValueChargeMpHitted( (3.0f + (2.0f * teamAdv))*0.8f * fIncreaseMpRate );
						CheckAndUpdateAdditionalChargeMpHitted();

						UpNowMp( GetChargeMpHitted() );
#ifdef SERV_PET_SYSTEM
						fMpPet = (3.0f + (2.0f * teamAdv))*0.8f * fIncreaseMpRate;
#endif
					} break;

				default:
					ASSERT( !L"wrong path" );
					break;
				}
		
				if( GetHyperModeCount() < 3 && pDamageData->m_fHpPercentUp <= 0.f )
				{
		#ifdef SERV_ADD_LUNATIC_PSYKER // 김태환
					/// 버프 적용 구조로 변경
					UpNowSoul( ( (2.0f * (1.0f + GetHyperChargeSpeed() ) ) + (2.0f * teamAdv) ) * fIncreaseSoulRate );
		#else // SERV_ADD_LUNATIC_PSYKER
					UpNowSoul( ( (2.0f * (1.0f + CX2SocketItem::GetFinalHyperGageChargeSpeedPercent( GetSocketData().m_fHyperModeChargeRate, GetUnitLevel() ) ) ) + (2.0f * teamAdv) ) * fIncreaseSoulRate );
		#endif // SERV_ADD_LUNATIC_PSYKER
					//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업
				}

				m_bUpMPThisFrame = true;

#ifdef SERV_PET_SYSTEM
				CX2PET *pPet = g_pData->GetPetManager()->GetPet( GetUnitUID() );
				if( pPet != NULL )
				{
					pPet->DamageReact( fMpPet );
				}
#endif

			}

			// 마지막으로 타격한 사람을 체크하기 위해
			if( pAttackerUnit != NULL )
			{
				if( pAttackerUnit->GetGameUnitType() == CX2GameUnit::GUT_USER )
				{
					AddToDamagedMap( pAttackerUnit, fFinalDamage );
					SetGameUnitWhoAttackedMe( pAttackerUnit );
#ifndef X2OPTIMIZE_UNITTYPE_BUG_FIX
					m_bAttackedByUserUnit = true;
#endif  X2OPTIMIZE_UNITTYPE_BUG_FIX
				}
				else
				{
					CX2GUNPC* pNPC = (CX2GUNPC*) pAttackerUnit;
					if( NULL != pNPC->GetNPCAI() &&
						CX2NPCAI::NAT_ALLY == pNPC->GetNPCAI()->GetAIType() )	// 유저가 소환한 몬스터 이면, 유저가 때린걸로 카운트 한다
					{
						CX2AllyNPCAI* pAllyAI = (CX2AllyNPCAI*) pNPC->GetNPCAI();
						if( CX2GameUnit::GUT_USER == pAllyAI->GetAllyUnitType() )
						{
							CX2GameUnit* pAllyGameUnit = pAllyAI->GetAllyGameUnit();
							AddToDamagedMap( pAllyGameUnit, fFinalDamage );
#ifdef  X2OPTIMIZE_UNITTYPE_BUG_FIX
                            if ( pAllyGameUnit != NULL && pAllyGameUnit->GetGameUnitType() == CX2GameUnit::GUT_USER )
                                SetGameUnitWhoAttackedMe( pAllyGameUnit );
                            else
                            {
                                ResetGameUnitAttackedByMe();
                                SetAttackedByUserUnit( true );
                            }
#else   X2OPTIMIZE_UNITTYPE_BUG_FIX
							SetGameUnitWhoAttackedMe( pAllyGameUnit );
							m_bAttackedByUserUnit = true;
#endif  X2OPTIMIZE_UNITTYPE_BUG_FIX

						}
						else 
						{
							SetGameUnitWhoAttackedMe( pAttackerUnit );
#ifndef X2OPTIMIZE_UNITTYPE_BUG_FIX
							m_bAttackedByUserUnit = false;
#endif  X2OPTIMIZE_UNITTYPE_BUG_FIX
						}
					}
					else
					{
#ifdef	SERV_TRAPPING_RANGER_TEST
						//	동맹 팀이 있을 경우에도 유저가 때린 것으로 카운트
						if( pAttackerUnit->GetAllyTeam() != CX2Room::TN_NONE && pAttackerUnit->IsPvpBot() == false )
						{
                            SetGameUnitWhoAttackedMe( pNPC->GetOwnerGameUnit() );
#ifndef  X2OPTIMIZE_UNITTYPE_BUG_FIX
							m_bAttackedByUserUnit = true;
#endif  X2OPTIMIZE_UNITTYPE_BUG_FIX
						}
						else
#endif	SERV_TRAPPING_RANGER_TEST
						{
							SetGameUnitWhoAttackedMe( pAttackerUnit );
#ifndef X2OPTIMIZE_UNITTYPE_BUG_FIX
							m_bAttackedByUserUnit = false;
#endif  X2OPTIMIZE_UNITTYPE_BUG_FIX
						}
					}
				}
			}

#ifdef SERV_SKILL_NOTE
			float fForceDownValue = pDamageData->fForceDownValue;
			fForceDownValue -= pDamageData->m_fDecreaseForceDown;
#ifdef ENCHANT_BALANCE_101014 // oasis907 : 김상윤 [2010.10.5] // 속성 피어싱 데미지시 강제 다운 수치 -10
			if(pDamageData->m_bPenetrate == true)
			{
				if(fForceDownValue < 0.f)
					fForceDownValue -= 10.f;
				else
					fForceDownValue = -10.f;
			}
#endif ENCHANT_BALANCE_101014

#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE	  // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
			/// 상급 기사 숙련, 다운 수치 조정
			if  ( NULL != GetUnit() )
			{
				const CX2Unit::UnitData* pUnitData = &GetUnit()->GetUnitData();

				int iSkillLevel = pUnitData->m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_SGM_ADVANCED_KNIGHT_MASTERY, true );
				const CX2SkillTree::SkillTemplet* pSkillTempletAdvancedKnightMastery = pUnitData->m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_P_SGM_ADVANCED_KNIGHT_MASTERY );

				if ( NULL != pSkillTempletAdvancedKnightMastery )
				{
					const int iSkillTempletLevel = max( 1, pUnitData->m_UserSkillTree.GetSkillLevel( pSkillTempletAdvancedKnightMastery->m_eID, true ) );	/// 스킬 레벨

					float fRate = pSkillTempletAdvancedKnightMastery->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_REL, iSkillTempletLevel );
					fForceDownValue = fForceDownValue * fRate;
				
				}
			}
#endif // SERV_ELESIS_SECOND_CLASS_CHANGE // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
			AddForceDownDelay( fForceDownValue );
#else
			AddForceDownDelay( pDamageData->fForceDownValue );
#endif
			
			if ( IsMyUnit() )
				CX2GageManager::GetInstance()->CrashMyStateGageUI( D3DXVECTOR2( -7, -7 ), D3DXVECTOR2( 7, 7 ), D3DXCOLOR( 1, 0, 0, 1) );
			
		}

		//{{ kimhc // 2009-11-24 // 길드 스킬 중 끝없는 체력
#ifdef	GUILD_SKILL_PART_2
		if ( pAttackerUnit != NULL &&
			pDamageData->m_bNoDamage == false )
		{
			GuildSkillProcess( CX2SkillTree::SI_GP_COMMON_INFINITE_STRENGTH );

			if ( m_GuildSkillData.m_InfiniteStrength.m_byCountLeft > 0 )
			{				
#ifdef BALANCE_PATCH_20120329
				float fRecoveryHpOnce = 0.3f;
#else 
				float fRecoveryHpOnce = 0.5f;
#endif
				if ( fFinalDamage > ( GetMaxHp() * fRecoveryHpOnce ) ) // MAX_HP의 50%보다 데미지가 크면
				{
					m_GuildSkillData.m_InfiniteStrength.m_fRecoveryHpOnce = ( GetMaxHp() * fRecoveryHpOnce ) / m_GuildSkillData.m_InfiniteStrength.m_byCountLeft;
				}
				else
				{
					m_GuildSkillData.m_InfiniteStrength.m_fRecoveryHpOnce = fFinalDamage * m_GuildSkillData.m_InfiniteStrength.m_fRecoveryPerOneDamage;
				}

				m_GuildSkillData.m_InfiniteStrength.m_hSeqEffect = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( NULL, L"InfiniteStrengthLight", 
					pAttackerUnit->GetPos().x, pAttackerUnit->GetPos().y + 100.0f, pAttackerUnit->GetPos().z, -1, -1, -1, 3, -1  );

				CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_GuildSkillData.m_InfiniteStrength.m_hSeqEffect );
				if ( pSeq != NULL )
					pSeq->SetLandPosition( pAttackerUnit->GetLandPos().y );
			}
		}
#endif	GUILD_SKILL_PART_2
		//}} kimhc // 2009-11-24 // 길드 스킬 중 끝없는 체력

		//{{ JHKang / 강정훈 / 2011/01/17 / 최종 데미지 값을 저장할 멤버 변수
#ifdef SEASON3_MONSTER_2010_12
		m_fRealDamage = fFinalDamage;
#endif SEASON3_MONSTER_2010_12
		//}} JHKang / 강정훈 / 2011/01/17 / 최종 데미지 값을 저장할 멤버 변수

		//{{ JHKang / 강정훈 / 2011/02/14 / 던전 랭크 개선 관련
#ifdef DUNGEON_RANK_NEW
		m_iTotalAttackedDamage += static_cast<int>( fFinalDamage );
#endif DUNGEON_RANK_NEW
		//}} JHKang / 강정훈 / 2011/02/14 / 던전 랭크 개선 관련

#ifdef UPGRADE_RAVEN
		if( GetUnit() != NULL && GetUnit()->GetType() == CX2Unit::UT_RAVEN )
		{
			CX2GURaven *pRaven = (CX2GURaven*)this;
			if( pRaven != NULL && GetRemainHyperModeTime() > 0.f )
			{
				float fMaxHp = pRaven->GetMaxHp();
				float fRage = fFinalDamage / fMaxHp * 500.f;
				pRaven->AddRageGuage( fRage );
			}
		}
#endif

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
		if( GetUnit() != NULL && GetUnit()->GetType() == CX2Unit::UT_EVE )
		{
			CX2GUEve *pEve = static_cast<CX2GUEve *> ( this );
			if( pEve != NULL && GetRemainHyperModeTime() > 0.f )
			{
				float fMaxHp = pEve->GetMaxHp();
				float fRage = fFinalDamage / fMaxHp * 500.f;
				pEve->AddManeuverGauge( fRage );
			}
		}
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	}

	// 타격받았을경우 이펙트 종료를 위해
	// DELETE_EFFECT_SET_ON_DAMAGE_REACT가 TRUE인 경우 등록된 현재 스테이트의 effectset들을 지운다.	
	if ( IsSuperArmor() == false && 
		m_FrameDataNow.stateParam.bInvincible == false &&
		CX2DamageManager::RT_DUMMY_DAMAGE != pDamageData->reActResult 
		&& CX2DamageManager::RT_FLIP_DIFF_DIR_DUMMY_DAMAGE != pDamageData->reActResult 
		)
	{
		DeleteEffectSetOnDamageReact();

#ifdef CUSTOM_DELETE_EFFECT_ON_DAMAGE_REACT
		// 지정한 스테이트에서 이펙트셋 지우는 기능, 피격 시 수행 하도록 처리
		if( true == m_bIsCustomStateDeleteEffectOnDamageReact )
			DeleteEffectSetOnCustomState();
#endif // CUSTOM_DELETE_EFFECT_ON_DAMAGE_REACT
	}

#ifdef PVP_ZOOM_CAMERA
	SetSubZoomCameraTimer();
#endif
	
#ifdef PLAY_EMOTION_BY_DAMAGE_EFFECT
	if( true == pDamageData->m_bIsLaughterDamage )
	{
		g_pChatBox->SendEmotionId( GET_STRING( STR_ID_2508 ) );
	}
#endif // PLAY_EMOTION_BY_DAMAGE_EFFECT

	PostProcessEnchantDamage( pDamageData );

#if defined( _SERVICE_ ) 
	ELSWORD_VIRTUALIZER_END
#endif
}

void CX2GUUser::DamageDoubleAttack()
{
	m_bDoubleAttack = false;
	m_fDoubleAttackTime = 0.f;

	if( m_wstrHitSound.empty() == false )
	{
		PlaySound( m_wstrHitSound.c_str() );
	}

	D3DXVECTOR3 numPos;
	GetFramePos( &numPos, m_pFrame_Bip01_Head );
	numPos.y += 70.0f;

	if( g_pData->GetPicCharRed() != NULL )
		g_pData->GetPicCharRed()->DrawText( (int)m_fFinalDamage, numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );

	int randVal = rand() % 1001;
	int iRandX = randVal % 21 - 10;
	int iRandZ = (randVal / 100) % 21 - 10;
	int iRandY = (rand() % 21 - 10);
	m_vImpactPoint.x += (float)iRandX;
	m_vImpactPoint.y += (float)iRandY;
	m_vImpactPoint.z += (float)iRandZ;

	CKTDGParticleSystem::CParticleEventSequence* pSeq1 = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"RevengeImpact", m_vImpactPoint, 50, 50, 1, 1 );
	CKTDGParticleSystem::CParticleEventSequence* pSeq2 = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DamageImpact", m_vImpactPoint, 100, 200, 2, 10 );
	CKTDGParticleSystem::CParticleEventSequence* pSeq3 = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DamageImpactCore", m_vImpactPoint, 100, 200, 2, 10 );
	CKTDGParticleSystem::CParticleEventSequence* pSeq4 = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DamageImpactSlash", m_vImpactPoint, 50, 50, 2, 2 );

	if(pSeq1 != NULL)		
		pSeq1->SetScaleFactor(D3DXVECTOR3(1.5f, 1.5f, 1.5f));
	if(pSeq2 != NULL)		
		pSeq2->SetScaleFactor(D3DXVECTOR3(1.5f, 1.5f, 1.5f));
	if(pSeq3 != NULL)		
		pSeq3->SetScaleFactor(D3DXVECTOR3(1.5f, 1.5f, 1.5f));
	if(pSeq4 != NULL)		
		pSeq4->SetScaleFactor(D3DXVECTOR3(1.5f, 1.5f, 1.5f));


	UpDownCrashCamera(20.f);
}



// @bApplyExtraDamageOfAttacker: pDamageData->pAttackerUnit의 damagedata를 적용할지 말지
void CX2GUUser::DamageReact_ExtraDamage( CX2DamageManager::DamageData* pDamageData, bool bApplyExtraDamageOfAttacker )
{
#if defined( _SERVICE_ ) 
	ELSWORD_VIRTUALIZER_START
#endif

	if( NULL == pDamageData )
		return;




#ifdef GRAPPLING_TEST
	switch( pDamageData->reActType )
	{
	case CX2DamageManager::RT_GRAPPLE:
	case CX2DamageManager::RT_THROW:
		{
			return;
		} break;
	}
#endif GRAPPLING_TEST



#ifdef NEW_EXTRA_DAMAGE					

	// oasis907 : 김상윤 [2010.3.22] // 함수 하나로 묶었습니다
	LevelCorrectionExtraDamage(pDamageData, &pDamageData->m_ExtraDamage);
	LevelCorrectionExtraDamage(pDamageData, &pDamageData->m_BufExtraDamage);
#ifdef SOCKET_EXTRA_DAMAGE_LEVEL_CORRECTION
	LevelCorrectionExtraDamage(pDamageData, &pDamageData->m_SocketExtraDamage);
#ifdef MULTIPLE_EXTRA_DAMAGE_LEVEL_CORRECTION
	// oasis907 : 김상윤 [2010.10.11] // 중복 가능한 EDT가 빠져서 추가합니다.
	for( int i=0; i<(int)pDamageData->m_MultipleExtraDamage.size(); i++ )
	{
		LevelCorrectionExtraDamage(pDamageData, &pDamageData->m_MultipleExtraDamage[i]);
	}
#endif MULTIPLE_EXTRA_DAMAGE_LEVEL_CORRECTION
#endif SOCKET_EXTRA_DAMAGE_LEVEL_CORRECTION
	//}} 

#endif



	float randVal = GetRandomFloat();
	const CX2DamageManager::ExtraDamageData& extraDamageData = pDamageData->m_ExtraDamage;
	if( CX2DamageManager::EDT_NONE != extraDamageData.m_ExtraDamageType )
	{
		ASSERT( extraDamageData.m_fRate >= 0.f && extraDamageData.m_fRate <= 1.f );
		if( extraDamageData.m_fRate > randVal )
		{
			Process_ExtraDamage( pDamageData, extraDamageData );
		}
	}	

	// 버프용 extra damage
	if( pDamageData != NULL && null != pDamageData->optrAttackerGameUnit
		//&& pDamageData->optrAttackerGameUnit->GetDamageData() != NULL
        )
	{
		const CX2DamageManager::ExtraDamageData& bufExtraDamageData = pDamageData->optrAttackerGameUnit->GetDamageData().m_BufExtraDamage;
		if( CX2DamageManager::EDT_NONE != bufExtraDamageData.m_ExtraDamageType &&
			bufExtraDamageData.m_fRate > (float)randVal )
		{
			if( pDamageData->attackerType != CX2DamageManager::AT_EFFECT ||
				pDamageData->optrAttackerGameUnit->GetDamageData().m_bApplyExtraDamage == true )
			{
				if( pDamageData->m_bNoBuff == false && pDamageData->attackType != CX2DamageManager::AT_SPECIAL )
					Process_ExtraDamage( pDamageData, bufExtraDamageData );
			}
		}
	}

	if( pDamageData->attackType != CX2DamageManager::AT_SPECIAL )
	{
		const CX2DamageManager::ExtraDamageData& socketExtraDamageData = pDamageData->m_SocketExtraDamage;
		if( CX2DamageManager::EDT_NONE != socketExtraDamageData.m_ExtraDamageType )
		{
			ASSERT( socketExtraDamageData.m_fRate >= 0.f && socketExtraDamageData.m_fRate <= 1.f );
			if( socketExtraDamageData.m_fRate > randVal )
			{
				Process_ExtraDamage( pDamageData, socketExtraDamageData );
			}
		}

		// 중첩가능한 extra damage
		for( int i=0; i<(int)pDamageData->m_MultipleExtraDamage.size(); i++ )
		{
			const CX2DamageManager::ExtraDamageData& multipleExtraDamageData = pDamageData->m_MultipleExtraDamage[i];
			ASSERT( multipleExtraDamageData.m_fRate >= 0.f && multipleExtraDamageData.m_fRate <= 1.f );
			if( GetRandomFloat( CKTDXRandomNumbers::SRO_ATTACK_EXTRA_DAMAGE_MULTIPLE + i ) < multipleExtraDamageData.m_fRate )
			{
				Process_ExtraDamage( pDamageData, multipleExtraDamageData );
			}
		}

		// 공격 형태가 AT_EFFECT이면 (예를들면, 화살이나 파이어볼) 공격자의 소켓옵션 extra_damage도 적용한다.
		if( true == bApplyExtraDamageOfAttacker &&
			CX2DamageManager::AT_EFFECT == pDamageData->attackerType &&
			null != pDamageData->optrAttackerGameUnit )
		{		
			pDamageData->optrAttackerGameUnit->GetDamageData().optrAttackerGameUnit = pDamageData->optrAttackerGameUnit;
#ifdef SOCKET_EXTRA_DAMAGE_LEVEL_CORRECTION
			//{{ oasis907 : 김상윤 [2010.3.23] // 
			pDamageData->optrAttackerGameUnit->GetDamageData().optrDefenderGameUnit = pDamageData->optrDefenderGameUnit;
			//}}
#endif SOCKET_EXTRA_DAMAGE_LEVEL_CORRECTION
			pDamageData->optrAttackerGameUnit->GetDamageData().impactPoint = pDamageData->impactPoint;

			//{{ 오현빈 // 2012-06-28 // AT_EFFECT 공격에 의도하지 않은 공격자의 익스트라데미지가 적용되는 문제 수정
#ifdef FIX_EXTRA_DAMAGE_BUG
			//소켓옵션은 적용 받을 수 있도록 m_SocketExtraDamage, m_MultipleExtraDamage 만 처리하도록 수정
			const CX2DamageManager::ExtraDamageData& SocketExtraDamage = pDamageData->optrAttackerGameUnit->GetDamageData().m_SocketExtraDamage;
			if( CX2DamageManager::EDT_NONE != SocketExtraDamage.m_ExtraDamageType &&
				SocketExtraDamage.m_fRate > (float)randVal )
			{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
				LevelCorrectionExtraDamage( pDamageData, &pDamageData->optrAttackerGameUnit->GetDamageData().m_SocketExtraDamage );
#endif //UPGRADE_SKILL_SYSTEM_2013
				Process_ExtraDamage( pDamageData, SocketExtraDamage );
			}

			for( int i=0; i<(int)pDamageData->optrAttackerGameUnit->GetDamageData().m_MultipleExtraDamage.size(); i++ )
			{
				const CX2DamageManager::ExtraDamageData& multipleExtraDamageData = pDamageData->optrAttackerGameUnit->GetDamageData().m_MultipleExtraDamage[i];
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
				LevelCorrectionExtraDamage( pDamageData, &pDamageData->optrAttackerGameUnit->GetDamageData().m_MultipleExtraDamage[i] );
#endif //UPGRADE_SKILL_SYSTEM_2013

				float r = GetRandomFloat( CKTDXRandomNumbers::SRO_ATTACK_EXTRA_DAMAGE_MULTIPLE + i );
				if( r < multipleExtraDamageData.m_fRate )
				{
					Process_ExtraDamage( pDamageData, multipleExtraDamageData );
				}
			}
#else
			DamageReact_ExtraDamage( &pDamageData->optrAttackerGameUnit->GetDamageData(), false );
#endif //FIX_EXTRA_DAMAGE_BUG
		}
	}	

#if defined( _SERVICE_ ) 
	ELSWORD_VIRTUALIZER_END
#endif
}

//{{ oasis907 : 김상윤 [2010.3.22] // 소켓 아이템 ExtraDamage 레벨 보정
void CX2GUUser::LevelCorrectionExtraDamage( const CX2DamageManager::DamageData* pDamageData, CX2DamageManager::ExtraDamageData* pExtraDamageData )
{
	int iLevel = pExtraDamageData->m_iLevel;
#ifdef ADDITIONAL_MEMO
	if( iLevel == 0 )
	{
		if( pExtraDamageData->m_bDefenderLevel == false && null != pDamageData->optrAttackerGameUnit )
			iLevel = pDamageData->optrAttackerGameUnit->GetUnitLevel();
		else if( pExtraDamageData->m_bDefenderLevel == true && null != pDamageData->optrDefenderGameUnit )
			iLevel = pDamageData->optrDefenderGameUnit->GetUnitLevel();
	}
#else
	if(iLevel == 0 && null != pDamageData->optrAttackerGameUnit )
		iLevel = pDamageData->optrAttackerGameUnit->GetUnitLevel();
#endif

	CX2EnchantItem::ENCHANT_TYPE eEnchantType = GetEnchantTypeFromExtraDamageType( pExtraDamageData->m_ExtraDamageType );
	float fResist = GetEnchantResist(eEnchantType); // 피격자 속성 저항치

	pExtraDamageData->m_DamagePerSec = pExtraDamageData->GetCalcPerDamage(iLevel, fResist);	

#ifdef EXTRADAMAGE_RATE_BUG_FIX
	float fRate = pExtraDamageData->m_fPureRate;
	float fPureRate = pExtraDamageData->m_fPureRate;
#else
	float fRate = pExtraDamageData->m_fRate;
	float fPureRate = pExtraDamageData->m_fRate;
#endif EXTRADAMAGE_RATE_BUG_FIX

	if( pExtraDamageData->m_bIgnoreResist == true )
	{
		fRate = 1.f;
	}
	else if( null != pDamageData->optrAttackerGameUnit && null != pDamageData->optrDefenderGameUnit && pExtraDamageData->m_iLevel >= 0)
	{
		// ( ( (공격자 레벨 - 피격자 레벨) * 0.025f ) + 0.5f ) * (1.f - (피격자 속성저항치 / 500.f))		
		int attackerLv = pDamageData->optrAttackerGameUnit->GetUnitLevel();
		int defencerLv = pDamageData->optrDefenderGameUnit->GetUnitLevel();

		fRate = ( ( (attackerLv - defencerLv) * 0.025f ) + 0.5f ) * (1.f - (fResist / CX2EnchantItem::EAR_MAX_VALUE));
		if(fPureRate >= 1.f) // oasis907 : 김상윤 [2011.5.25] 스크립트 파싱시 디폴트 fRate는 1.f, 
		{					// 외부에서 Rate설정을 따로해주지 않으면 최대 Rate를 0.5로 한정
			if( fRate > 0.5f )
				fRate = 0.5f;
		}
		else
		{
			if( fRate > fPureRate )
				fRate = fPureRate;
		}
		
		//{{ 엑스트라데미지 확률이 음수일 때 0으로 처리 (ASSERT 제거)
#ifdef EXTRA_DAMAGE_CUT_NEGATIVE_RATE
		if( fRate < 0.f )
			fRate = 0.f;
#endif EXTRA_DAMAGE_CUT_NEGATIVE_RATE
		//}} 엑스트라데미지 확률이 음수일 때 0으로 처리 (ASSERT 제거)
	}

	pExtraDamageData->m_fRate = fRate;

#ifdef DAMAGEDATA_RATE_MODIFIER
	// oasis907 : 김상윤 [2010.10.5] // 소켓 옵션 발동 확률 조정
	if( pExtraDamageData->m_bIgnoreResist == false )
	{
#ifndef CHUNG_MEMO_01
		if(pDamageData->m_fRateModifier < 1.f)
#endif CHUNG_MEMO_01
#ifdef EXTRADAMAGE_RATE_BUG_FIX	
		{
			float fRateModifier = 1.f;
			if( iLevel >= 0 )
			{
				fRateModifier = pExtraDamageData->m_fRate;
			}
			else
			{
				fRateModifier = pExtraDamageData->m_fPureRate;
			}			
			pExtraDamageData->m_fRate = fRateModifier * pDamageData->m_fRateModifier;
		}
#else
			pExtraDamageData->m_fRate *= pDamageData->m_fRateModifier;
#endif EXTRADAMAGE_RATE_BUG_FIX
	}
#endif DAMAGEDATA_RATE_MODIFIER

	return;
}
//}} oasis907 : 김상윤 [2010.3.22] // 


// @pDamageData : 기타 필요한 정보를 얻어 오기 위한
// @extraDamageData : 실제 처리해야할 extra damage
void CX2GUUser::Process_ExtraDamage( const CX2DamageManager::DamageData* pDamageData, const CX2DamageManager::ExtraDamageData &extraDamageData )
{
	ASSERT( pDamageData != NULL );
	
	// kimhc / 2010-04-02 // 비밀던전 셋트아이템 작업으로 추가
	bool bGetExtraDamage = false;	// 상태이상에 걸렸는가?

	switch( extraDamageData.m_ExtraDamageType )
	{
	case CX2DamageManager::EDT_POISON:
		{
			if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
			{
				m_ExtraDamagePack.m_Poison = extraDamageData;
#ifdef NEW_EXTRA_DAMAGE
				if(extraDamageData.m_iLevel < 0.f)
#endif
				{
					float fDuration = extraDamageData.m_fTime;
					ApplyEnchantResist( CX2EnchantItem::ET_NATURE, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
					m_ExtraDamagePack.m_Poison.m_fTime = fDuration;
				}					
#ifdef SERV_SKILL_NOTE
				if( extraDamageData.m_fRunJumpRate > 0.f && m_ExtraDamagePack.m_Poison.m_fTime > 0.f )
				{						
					SetMoveSpeedFactor(extraDamageData.m_fRunJumpRate, m_ExtraDamagePack.m_Poison.m_fTime);
					SetJumpSpeedFactor(extraDamageData.m_fRunJumpRate, m_ExtraDamagePack.m_Poison.m_fTime);
					SetPoisonDeBuff(m_ExtraDamagePack.m_Poison.m_fTime);
				}					
#endif
				bGetExtraDamage = true;
			}
		}
		break;

	case CX2DamageManager::EDT_SLOW:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
					m_ExtraDamagePack.m_Slow = extraDamageData;

					float fDuration = extraDamageData.m_fTime;
					ApplyEnchantResist( CX2EnchantItem::ET_DARK, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
					m_ExtraDamagePack.m_Slow.m_fTime = fDuration;

					bGetExtraDamage = true;
				}
			}
		}
		break;

	case CX2DamageManager::EDT_FIRE:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{	
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
#ifdef REITERATION_EXTRA_DAMAAGE
					bool bNewExtra = true;
					if( m_ExtraDamagePack.m_Fire.m_fTime > 0.f )
					{
						if( m_ExtraDamagePack.m_Fire.m_DamagePerSec > extraDamageData.m_DamagePerSec )
						{
							bNewExtra = false;
						}
						else if( m_ExtraDamagePack.m_Fire.m_DamagePerSec < extraDamageData.m_DamagePerSec )
						{
							bNewExtra = true;
						}
						else
						{
							if( m_ExtraDamagePack.m_Fire.m_fTime >  extraDamageData.m_fTime )
							{
								bNewExtra = false;
							}
							else
							{
								bNewExtra = true;
							}
						}
					}

					if( bNewExtra == true )
					{
						m_ExtraDamagePack.m_Fire = extraDamageData;

#ifdef NEW_EXTRA_DAMAGE
						if(extraDamageData.m_iLevel < 0.f)
#endif
						{
							float fDuration = extraDamageData.m_fTime;
							ApplyEnchantResist( CX2EnchantItem::ET_BLAZE, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
							m_ExtraDamagePack.m_Fire.m_fTime = fDuration;
						}
					}				
#else
					m_ExtraDamagePack.m_Fire = extraDamageData;

#ifdef NEW_EXTRA_DAMAGE
					if(extraDamageData.m_iLevel < 0.f)
#endif
					{
						float fDuration = extraDamageData.m_fTime;
						ApplyEnchantResist( CX2EnchantItem::ET_BLAZE, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
						m_ExtraDamagePack.m_Fire.m_fTime = fDuration;
					}
#endif

					bGetExtraDamage = true;
				}
			}
		}
		break;

	case CX2DamageManager::EDT_CURSE:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
					m_ExtraDamagePack.m_Curse = extraDamageData;

					float fDuration = extraDamageData.m_fTime;
					ApplyEnchantResist( CX2EnchantItem::ET_DARK, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
					m_ExtraDamagePack.m_Curse.m_fTime = fDuration;

					bGetExtraDamage = true;
				}
			}
		}
		break;

	case CX2DamageManager::EDT_LIGHTNING:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
					m_ExtraDamagePack.m_Lightning = extraDamageData;

					float fDuration = extraDamageData.m_fTime;
					ApplyEnchantResist( CX2EnchantItem::ET_WIND, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
					m_ExtraDamagePack.m_Lightning.m_fTime = fDuration;

					bGetExtraDamage = true;
				}
			}
		}
		break;

	case CX2DamageManager::EDT_COLD:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
					m_ExtraDamagePack.m_Cold = extraDamageData;

					float fDuration = extraDamageData.m_fTime;
					ApplyEnchantResist( CX2EnchantItem::ET_WATER, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
					m_ExtraDamagePack.m_Cold.m_fTime = fDuration;

					bGetExtraDamage = true;
				}
			}
		} break;

	case CX2DamageManager::EDT_MANA_DAMAGE:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				//{{ JHKang / 강정훈 / 2010/11/05 / 루나 블레이드, 현재 마나의 비율로 감소 추가
#ifdef NEW_SKILL_2010_11
				if ( extraDamageData.m_fDamageRate > 0.f && extraDamageData.m_Damage < 0.f )
				{
					float fDamageMP = GetNowMp() * extraDamageData.m_fDamageRate;
					SetNowMp( fDamageMP );

					std::wstringstream strStream;
					strStream << L"MP -" << (1.f - extraDamageData.m_fDamageRate) * 100.f << L"%";
					D3DXVECTOR3 pos = GetPos();
					pos.y += 50.0f + (0 * 30.0f);
					if( NULL != g_pData->GetPicCharRed() )
						g_pData->GetPicCharRed()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );

					m_bHitedDrainMana = false;

					bGetExtraDamage = true;
				}
				else
				{
					UpNowMp(-1* extraDamageData.m_Damage);

					std::wstringstream strStream;
					strStream << L"MP -" << (int)extraDamageData.m_Damage;
					D3DXVECTOR3 pos = GetPos();
					pos.y += 50.0f + (0 * 30.0f);
					if( NULL != g_pData->GetPicCharRed() )
						g_pData->GetPicCharRed()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );

					m_bHitedDrainMana = true;

					bGetExtraDamage = true;
				}
#else
				UpNowMp(-1* extraDamageData.m_Damage);

				std::wstringstream strStream;
				strStream << L"MP -" << (int)extraDamageData.m_Damage;
				D3DXVECTOR3 pos = GetPos();
				pos.y += 50.0f + (0 * 30.0f);
				if( NULL != g_pData->GetPicCharRed() )
					g_pData->GetPicCharRed()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );

				m_bHitedDrainMana = true;

				bGetExtraDamage = true;
#endif NEW_SKILL_2010_11
				//}} JHKang / 강정훈 / 2010/11/05 / 루나 블레이드, 현재 마나의 비율로 감소 추가
			}
		} break;

	case CX2DamageManager::EDT_FIRE_SMASH:
		{								
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Fire_Smash_Smoke_FireWave04_Nasod_Element_Fire", pDamageData->impactPoint );
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Fire_Smash_Flare_FireWave05_Nasod_Element_Fire", pDamageData->impactPoint );

			UpDownCrashCamera( 20.0f, 0.5f );

			bGetExtraDamage = true;
		} break;

	case CX2DamageManager::EDT_COLD_SMASH:
		{								
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Cold_Smash_Smoke_IceWave04_Nasod_Element_Ice", pDamageData->impactPoint );
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Cold_Smash_Flare_IceWave05_Nasod_Element_Ice", pDamageData->impactPoint );

			UpDownCrashCamera( 20.0f, 0.5f );

			bGetExtraDamage = true;
		} break;


	case CX2DamageManager::EDT_EVENT_SMASH:
		{								
			D3DXVECTOR3 vPos = GetPos();
			vPos.y += m_FrameDataFuture.unitCondition.fUnitHeight + 120.f;
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"STR_CoupleHell", vPos );

			UpDownCrashCamera( 30.0f, 0.5f );

			bGetExtraDamage = true;
		} break;
#ifdef CAMILLA_SMASH
	case CX2DamageManager::EDT_CAMILLA_SMASH:
		{	
			D3DXVECTOR3 vPos = GetPos();
			vPos.y += m_FrameDataFuture.unitCondition.fUnitHeight + 120.f;
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"STR_FightKing", vPos );

			g_pX2Game->GetX2Camera()->GetCamera().UpDownCrashCamera( 30.0f, 0.5f );

			bGetExtraDamage = true;
		} break;
#endif CAMILLA_SMASH
#ifdef EDT_EVENT_SMASH_THIRD
	case CX2DamageManager::EDT_EVENT_SMASH_3:
		{	
			D3DXVECTOR3 vPos = GetPos();
			vPos.y += m_FrameDataFuture.unitCondition.fUnitHeight + 120.f;
			g_pX2Game->GetMajorParticle()->CreateSequence(  this,  L"STR_EventSmash2", vPos );

			g_pX2Game->GetX2Camera()->GetCamera().UpDownCrashCamera( 30.0f, 0.5f );

			bGetExtraDamage = true;

		} break;
#endif //EDT_EVENT_SMASH_THIRD
#ifdef EDT_EVENT_SMASH_SECOND
	case CX2DamageManager::EDT_EVENT_SMASH_2:
		{								
			D3DXVECTOR3 vPos = GetPos();
			vPos.y += m_FrameDataFuture.unitCondition.fUnitHeight + 120.f;
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"STR_EventSmash2", vPos );

			UpDownCrashCamera( 30.0f, 0.5f );

			bGetExtraDamage = true;
		} break;
#endif EDT_EVENT_SMASH_SECOND

	case CX2DamageManager::EDT_POISON_CLOUD:
		{
			if( null != pDamageData->optrAttackerGameUnit )
			{
				const float MAGIC_POWER_RATE = 1.f;
				CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( pDamageData->optrAttackerGameUnit.GetObservable(), L"EXTRA_DAMAGE_POISON_CLOUD", MAGIC_POWER_RATE,
					pDamageData->impactPoint, GetRotateDegree(), GetRotateDegree(), GetLandPosition().y );

				UpDownCrashCamera( 20.0f, 0.5f );

				bGetExtraDamage = true;
			}
		} break;

	case CX2DamageManager::EDT_DOUBLE_ATTACK:
		{
			if ( pDamageData->attackType != CX2DamageManager::AT_SPECIAL )
			{
				m_bDoubleAttack = true;
			
				bGetExtraDamage = true;
			}
			//g_pX2Game->GetX2Camera()->GetCamera().UpDownCrashCamera( 20.0f, 0.5f );
		} break;

#ifdef SKILL_30_TEST

	case CX2DamageManager::EDT_FROZEN:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
					m_ExtraDamagePack.m_Frozen = extraDamageData;

					float fDuration = extraDamageData.m_fTime;
					ApplyEnchantResist( CX2EnchantItem::ET_WATER, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
					m_ExtraDamagePack.m_Frozen.m_fTime = fDuration;

					if( fDuration > 0.f )
					{
						AnimStop();
					}

					m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
					m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );

					UpDownCrashCamera( 20.0f, 0.5f );

					bGetExtraDamage = true;

				}
			}
		} break;

	case CX2DamageManager::EDT_ENTANGLE:
		{

			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
					m_ExtraDamagePack.m_Entangled = extraDamageData;

					float fDuration = extraDamageData.m_fTime;
					//ApplyEnchantResist( CX2EnchantItem::ET_WIND, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
					m_ExtraDamagePack.m_Entangled.m_fTime = fDuration;

					bGetExtraDamage = true;
				}
			}
		} break;

	case CX2DamageManager::EDT_TIME_BOMB:
		{

			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
					if( m_ExtraDamagePack.m_TimeBomb.m_fTime <= 0.f )		// 이미 time bomb 이 걸려있으면 추가로 timebomb을 추가하지 말자~
					{
						m_ExtraDamagePack.m_TimeBomb = extraDamageData;

						float fDuration = extraDamageData.m_fTime;
						//ApplyEnchantResist( CX2EnchantItem::ET_WIND, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
						m_ExtraDamagePack.m_TimeBomb.m_fTime = fDuration;

						bGetExtraDamage = true;
					}
				}
			}
		} break;

#endif SKILL_30_TEST

	case CX2DamageManager::EDT_DAMAGE_RATE:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				float fNowHp = GetNowHp();
				float fDamage = fNowHp * extraDamageData.m_Damage;

				UpNowHp( fDamage * -1.f );

				std::wstringstream strStream;
				strStream << L"HP -" << (int)fDamage;
				D3DXVECTOR3 pos = GetPos();
				pos.y += 50.0f + (0 * 30.0f);
				if( NULL != g_pData->GetPicCharRed() )
					g_pData->GetPicCharRed()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );

				bGetExtraDamage = true;
			}
		} break;


	case CX2DamageManager::EDT_STIGMA_DEBUFF:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				m_ExtraDamagePack.m_StigmaDebuff = extraDamageData;
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Rena_Stigma_User", this ); 

				bGetExtraDamage = true;
			}
		} break;
	
	case CX2DamageManager::EDT_LIGHTNING_SMASH:
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				g_pX2Game->GetDamageEffect()->CreateInstance( pAttackerUnit, L"LIGHTNING_SMASH", pAttackerUnit->GetPowerRate(),
					GetLandPos(), GetRotateDegree(), GetRotateDegree() );
			}
		} break;
#ifdef NEW_SKILL_2010_11 
		//{{ oasis907 : 김상윤 [2010.11.8] // 로드 나이트 - 샌드 스톰 - EDT_BLIND
	case CX2DamageManager::EDT_BLIND:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				m_ExtraDamagePack.m_Blind = extraDamageData;
				float fDuration = extraDamageData.m_fTime;
				m_ExtraDamagePack.m_Blind.m_fTime = fDuration;
				float fEffectiveRate = extraDamageData.m_fDamageRate;
				m_ExtraDamagePack.m_Blind.m_fDamageRate = fEffectiveRate;
			}
		} break;
		//}} oasis907 : 김상윤 [2010.11.8] // 로드 나이트 - 샌드 스톰 - EDT_BLIND
#endif NEW_SKILL_2010_11

		//{{ kimhc // 2010.12.29 // 하멜 마을 추가시 들어가는 ExtraDamage
#ifdef	ADD_HAMEL_VILLAGE
	case CX2DamageManager::EDT_ICE_STING:
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
#ifdef VERIFY_STAT_BY_BUFF
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_ICE_STING", pAttackerUnit, NULL, false,
					-1.f, -1.f, pAttackerUnit->GetVec3ScaleByUnit(), true, pDamageData->impactPoint, 
					pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetDirVector() );
#else	// VERIFY_STAT_BY_BUFF
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_ICE_STING", pAttackerUnit, NULL, false,
					-1.f, -1.f, pAttackerUnit->GetScaleByUnit(), true, pDamageData->impactPoint, 
					pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetDirVector() );
#endif // VERIFY_STAT_BY_BUFF
			} // if
		} break;

	case CX2DamageManager::EDT_FIRE_BALL:
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
#ifdef VERIFY_STAT_BY_BUFF
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_FIRE_BALL", pAttackerUnit, NULL, false,
					-1.f, -1.f, pAttackerUnit->GetVec3ScaleByUnit(), true, pDamageData->impactPoint, 
					pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetDirVector() );
#else	// VERIFY_STAT_BY_BUFF
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_FIRE_BALL", pAttackerUnit, NULL, false,
					-1.f, -1.f, pAttackerUnit->GetScaleByUnit(), true, pDamageData->impactPoint, 
					pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetDirVector() );
#endif // VERIFY_STAT_BY_BUFF
			} // if
		} break;
#endif	ADD_HAMEL_VILLAGE
		//}} kimhc // 2010.12.29 // 하멜 마을 추가시 들어가는 ExtraDamage


#ifdef EDT_WATER_HOLD_TEST
		//{{ lucidash : 김상훈 [2011.1.4] // 시즌3 몬스터 라구즈 마법 공격 
	case CX2DamageManager::EDT_WATER_HOLD:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
					m_ExtraDamagePack.m_WaterHold = extraDamageData;

					float fDuration = extraDamageData.m_fTime;
					ApplyEnchantResist( CX2EnchantItem::ET_WATER, fDuration );	// 속성 저항이 있으면 지속시간을 줄여준다
					m_ExtraDamagePack.m_WaterHold.m_fTime = fDuration;

					if( fDuration > 0.f )
					{
						//StateChange( USI_DAMAGE_SMALL_FRONT );
						SetStopTime( fDuration );
						//AnimStop();
					}

					m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
					m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );
					
					UpDownCrashCamera( 20.0f, 0.5f );

					bGetExtraDamage = true;
				}
			}
		} break;
		//}} lucidash : 김상훈 [2011.1.4] // 시즌3 몬스터 라구즈 마법 공격 
#endif EDT_WATER_HOLD_TEST

		//{{ 2011-04 에 패치될 청 캐시 스킬
#ifdef	CASH_SKILL_FOR_CHUNG_2011_04				
	case CX2DamageManager::EDT_PANIC:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
					m_ExtraDamagePack.m_Panic = extraDamageData;

					UpDownCrashCamera( 20.0f, 0.5f );

					bGetExtraDamage = true;
				}
			}
		} break;

	case CX2DamageManager::EDT_PAIN:
		{
			//if ( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				// Accumulation에 아무것도 없으면 (지금 들어온 extraDamage가 처음 시작된 PAIN 이면)
				if ( 0 == extraDamageData.m_Accumulation )
				{
					// 현재 캐릭터에게 걸린 디버프 갯수를 체크한다.

					vector<KBuffFactor> VecDebuffFactor;
					GetBuffFactorOnlyDebuff(VecDebuffFactor);

					int iNumOfExtraDamage = VecDebuffFactor.size();
#ifdef FIX_EDT_ENCHANT
					if ( m_ExtraDamagePack.m_EnchantBlaze.m_fTime > 0.f ) 
						++iNumOfExtraDamage;
					if ( m_ExtraDamagePack.m_EnchantFrozen.m_fTime > 0.f ) 
						++iNumOfExtraDamage;
					if ( m_ExtraDamagePack.m_EnchantPoison.m_fTime > 0.f ) 
						++iNumOfExtraDamage;
					if ( m_ExtraDamagePack.m_EnchantShock.m_fTime > 0.f ) 
						++iNumOfExtraDamage;
#endif //FIX_EDT_ENCHANT
					// 이전에 걸려있던 Pain이 없거나, 있어도 현재 새로 걸릴 Pain보다 전염횟수가 적으면 적용
					if ( iNumOfExtraDamage > m_ExtraDamagePack.m_Pain.m_Accumulation )
					{
						m_ExtraDamagePack.m_Pain = extraDamageData;
						m_ExtraDamagePack.m_Pain.m_Accumulation = iNumOfExtraDamage;
						m_ExtraDamagePack.m_Pain.m_optrGameUnit	= pDamageData->optrAttackerGameUnit;						
					}
				}
				// Accumulation이 0이 아니면 (다른 유저로 부터 전염 된 것이면)
				else
				{
					// 기존에 EDT_PAIN이 걸려 있었다면, 전염 횟수가 더 많이 남은 것을 선택 함
					if ( extraDamageData.m_Accumulation > m_ExtraDamagePack.m_Pain.m_Accumulation)
					{
						m_ExtraDamagePack.m_Pain = extraDamageData;
						m_ExtraDamagePack.m_Pain.m_optrGameUnit	= pDamageData->optrAttackerGameUnit;
					}
				}
			}
		} break;

	case CX2DamageManager::EDT_HEAD_SHOT:
		{	
			SetHittedExtraDamageHeadShot( true );
			bGetExtraDamage = true;
		} break;
#endif	CASH_SKILL_FOR_CHUNG_2011_04				
		//}} 2011-04 에 패치될 청 캐시 스킬

	case CX2DamageManager::EDT_BIGHEAD:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false )
				{
					float fDuration = extraDamageData.m_fTime;

					// 공속/이속/점속/공격력 감소
					m_ExtraDamagePack.m_Aging = extraDamageData;
					m_ExtraDamagePack.m_Aging.m_fTime = fDuration;					

					// 공격력 감소
// #ifdef SKILL_CASH_10_TEST
// 					SetAttackBuffRate( extraDamageData.m_fDamageRate );
// 					SetAttackBuffTime( fDuration );
// #endif

					m_fExtraBigHead = fDuration;

					bGetExtraDamage = true;
				}
			}

		} break;
#ifdef CHUNG_SECOND_CLASS_CHANGE
		// oasis907 : 김상윤 [2011.6.16] 청 2차 전직 - 아이언 팔라딘
	case CX2DamageManager::EDT_TRANSIT_DEBUFF:
		{	
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				pAttackerUnit->ProcessTransitDebuff( pDamageData, this );
			}
			//bGetExtraDamage = true; extradamage아님
		} break;

	case CX2DamageManager::EDT_ENCHANT_BLAZE:
		{	
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false &&
					IsImmuneToEnchant( CX2EnchantItem::ET_BLAZE ) == false )
				{	
					m_ExtraDamagePack.m_EnchantBlaze = extraDamageData;
					g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"EnchantBlazeAttack", pDamageData->impactPoint );
					UpDownCrashCamera( 20.0f, 0.5f );
					bGetExtraDamage = true;
				}
				else
				{
					if( NULL != g_pData->GetPicCharBlue() )
						g_pData->GetPicCharBlue()->DrawText( L"RESIST", GetHeadBonePos(), GetDirVector(), CKTDGPicChar::AT_CENTER );
				}
			}
		} break;

	case CX2DamageManager::EDT_ENCHANT_FROZEN:
		{	
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false &&
					IsImmuneToEnchant( CX2EnchantItem::ET_WATER ) == false )
				{	
					m_ExtraDamagePack.m_EnchantFrozen = extraDamageData;
					bGetExtraDamage = true;
				}
				else
				{
					if( NULL != g_pData->GetPicCharBlue() )
						g_pData->GetPicCharBlue()->DrawText( L"RESIST", GetHeadBonePos(), GetDirVector(), CKTDGPicChar::AT_CENTER );
				}
			}
		} break;

	case CX2DamageManager::EDT_ENCHANT_POISON:
		{	
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false &&
					IsImmuneToEnchant( CX2EnchantItem::ET_NATURE ) == false )
				{	
					m_ExtraDamagePack.m_EnchantPoison = extraDamageData;
					bGetExtraDamage = true;
				}
				else
				{
					if( NULL != g_pData->GetPicCharBlue() )
						g_pData->GetPicCharBlue()->DrawText( L"RESIST", GetHeadBonePos(), GetDirVector(), CKTDGPicChar::AT_CENTER );
				}
			}
		} break;
	case CX2DamageManager::EDT_ENCHANT_SHOCK:
		{	
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				if ( IsImmuneBySocketOption( extraDamageData.m_ExtraDamageType ) == false &&
					IsImmuneToEnchant( CX2EnchantItem::ET_LIGHT ) == false )
				{	
					m_ExtraDamagePack.m_EnchantShock = extraDamageData;
					bGetExtraDamage = true;
				}
				else
				{
					if( NULL != g_pData->GetPicCharBlue() )
						g_pData->GetPicCharBlue()->DrawText( L"RESIST", GetHeadBonePos(), GetDirVector(), CKTDGPicChar::AT_CENTER );
				}
			}
		} break;
#endif CHUNG_SECOND_CLASS_CHANGE

#ifdef HAMEL_NEW_SETOPTION_EXTRADAMAGE
	case CX2DamageManager::EDT_WIND_STORM:
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
#ifdef VERIFY_STAT_BY_BUFF
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_WIND_STORM", pAttackerUnit, NULL, false,
					-1.f, -1.f, pAttackerUnit->GetVec3ScaleByUnit(), true, pDamageData->impactPoint, 
					pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetDirVector() );
#else	// VERIFY_STAT_BY_BUFF
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_WIND_STORM", pAttackerUnit, NULL, false,
					-1.f, -1.f, pAttackerUnit->GetScaleByUnit(), true, pDamageData->impactPoint, 
					pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetDirVector() );
#endif // VERIFY_STAT_BY_BUFF
			} // if
		} break;

	case CX2DamageManager::EDT_EARTH_QUAKE:
		{
			//if( it_immune == m_mapImmunity.end() || it_immune->second == false )
			{
				m_ExtraDamagePack.m_EarthQuake = extraDamageData;
				float fDuration = extraDamageData.m_fTime;
				m_ExtraDamagePack.m_EarthQuake.m_fTime = fDuration;

				SetMoveSpeedFactor(0.5f, m_ExtraDamagePack.m_EarthQuake.m_fTime);
				SetAnimSpeedFactor(0.75f, m_ExtraDamagePack.m_EarthQuake.m_fTime);
			}
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				D3DXVECTOR3 outPos( 0.0f, 0.0f, 0.0f );
				int iLineIndex = -1;

				CKTDGLineMap* pLineMap = g_pX2Game->GetWorld()->GetLineMap();
				if( NULL != pLineMap )
				{
#ifdef  X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
					if ( true == pLineMap->GetDownNearestWithBound( GetPos(), 100.f, &outPos, &iLineIndex ) )
#else   X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
					float fHeight = pLineMap->GetDownNearest( GetPos(), &outPos, &iLineIndex );
					if( fHeight < 100.f )
#endif  X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
					{
#ifdef VERIFY_STAT_BY_BUFF
						g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_EARTH_QUAKE", pAttackerUnit, NULL, false,
							-1.f, -1.f, pAttackerUnit->GetVec3ScaleByUnit(), true, outPos, 
							pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetDirVector() );
#else	// VERIFY_STAT_BY_BUFF
						g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_EARTH_QUAKE", pAttackerUnit, NULL, false,
							-1.f, -1.f, pAttackerUnit->GetScaleByUnit(), true, outPos, 
							pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetDirVector() );
#endif // VERIFY_STAT_BY_BUFF
					}
				}
			} // if
		} break;
#endif HAMEL_NEW_SETOPTION_EXTRADAMAGE

#ifdef VELDER_SECRET_DUNGEON

	case CX2DamageManager::EDT_CURSE_CLOUD:
		{
			if( null != pDamageData->optrAttackerGameUnit )
			{
				const float MAGIC_POWER_RATE = 1.f;
				CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( pDamageData->optrAttackerGameUnit.GetObservable(), L"EXTRA_DAMAGE_CURSE_CLOUD", MAGIC_POWER_RATE,
					pDamageData->impactPoint, GetRotateDegree(), GetRotateDegree(), GetLandPosition().y );

				UpDownCrashCamera( 20.0f, 0.5f );

				bGetExtraDamage = true;
			}
		} break;

#endif //VELDER_SECRET_DUNGEON
#ifdef UPGRADE_RAVEN
		case CX2DamageManager::EDT_RUNJUMP_SPEED:
			{				
				float fDuration = extraDamageData.m_fTime;
							
				SetVecMoveSpeedFactor(extraDamageData.m_fRunJumpRate, fDuration, CX2GameUnit::SFI_SPEED_9, CX2GameUnit::SFST_UPDATE);
				SetVecJumpSpeedFactor(extraDamageData.m_fRunJumpRate, fDuration, CX2GameUnit::SFI_SPEED_9, CX2GameUnit::SFST_UPDATE);
			}
			break;
#endif

#ifdef EVE_ELECTRA
	case CX2DamageManager::EDT_FLASH_BANG:
		{
			m_ExtraDamagePack.m_FlashBang = extraDamageData;
			float fDuration = extraDamageData.m_fTime;

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
            if ( CX2DamageEffect::CEffect*   pAttackerEffect = g_pX2Game->GetDamageEffect()->GetInstance( pDamageData->hAttackerEffect ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
            if ( CX2DamageEffect::CEffect*   pAttackerEffect = g_pX2Game->GetDamageEffect()->IsLiveInstance( pDamageData->pAttackerEffect ) ? pDamageData->pAttackerEffect : NULL )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			{
				const float CONST_FLASH_BANG_HIGH = 400.f;
				const float CONST_FLASH_BANG_LOW = 800.f;

				D3DXVECTOR3 vFlashCenterPos = pAttackerEffect->GetPos();
				float fDistanceFromCenter3Sq = D3DXVec3LengthSq( &(vFlashCenterPos - GetPos()) );

				if ( fDistanceFromCenter3Sq > CONST_FLASH_BANG_LOW * CONST_FLASH_BANG_LOW )
					fDuration *= 0.25f;
				else if( fDistanceFromCenter3Sq > CONST_FLASH_BANG_HIGH * CONST_FLASH_BANG_LOW )
					fDuration *= 0.5f;
				else
					fDuration *= 1.f;

				if( IsMyUnit() == true )
				{
					g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqWhiteOut );
					m_hSeqWhiteOut = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( NULL,  L"WhiteOutExtraDamageStart", D3DXVECTOR3(0,0,0) );
				}
				m_ExtraDamagePack.m_FlashBang.m_fTime = fDuration;
				m_bWhiteOut = true;
			}
		} break;
#endif EVE_ELECTRA

#ifdef ADD_SOCKET_FOR_SECRET_SET
	case CX2DamageManager::EDT_FLAME_SMASH:
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				g_pX2Game->GetDamageEffect()->CreateInstance( pAttackerUnit, L"DAMAGE_EFFECT_EDT_FLAME_SMASH", pAttackerUnit->GetPowerRate(),
					pDamageData->impactPoint, GetRotateDegree(), GetRotateDegree(), GetLandPosition().y );
			}
		} break;

	case CX2DamageManager::EDT_FIRE_WRAITH:
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				if ( true == pAttackerUnit->GetIsRight() )
				{
					g_pX2Game->GetDamageEffect()->CreateInstance( pAttackerUnit, L"DAMAGE_EFFECT_EDT_FIRE_WRAITH", pAttackerUnit->GetPowerRate(),
						pDamageData->impactPoint, pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetRotateDegree() );
				}
				else
				{
					g_pX2Game->GetDamageEffect()->CreateInstance( pAttackerUnit, L"DAMAGE_EFFECT_EDT_FIRE_WRAITH_INVERSE", pAttackerUnit->GetPowerRate(),
						pDamageData->impactPoint, pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetRotateDegree() );
				}
			}
		} break;
#endif

#ifdef SERV_RENA_NIGHT_WATCHER
	case CX2DamageManager::EDT_START_OF_DELAYED_FIRING:
		{
			float	fDuration	= extraDamageData.m_fTime;		/// 유지 시간
			int		iArrowType	= extraDamageData.m_iLevel;		/// 화살 타입( 0 = 폭발의 화살, 1 = 지연의 신호탄 )

			CX2DamageManager::StartOfDelayedFiringData* pData = NULL;

			if( iArrowType == 0 )	/// 폭발의 화살
				pData = new CX2DamageManager::StartOfDelayedFiringData( CX2DamageEffect::DET_ARROW_OF_EXPLOSION_DELAY, 
					pDamageData->optrAttackerGameUnit->GetUnitIndex(), 100, -1, fDuration );
			else					/// 지연의 신호탄
				pData = new CX2DamageManager::StartOfDelayedFiringData( CX2DamageEffect::DET_START_OF_DELAYED_FIRING, 
					pDamageData->optrAttackerGameUnit->GetUnitIndex(), -1, -1, fDuration );

			if( true == GetStartOfDelayedFiringData().empty() )		/// 지연의 신호탄 EDT 적용중 확인 이펙트
				m_hActiveStartOfDelayedFiringEDT = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Rena_Night_Watcher_ExplosionArrow_Active_EDT", (CX2GameUnit*) this );

			if( NULL != pData )		/// 지연의 신호탄 추가
				AccessStartOfDelayedFiringData().push_back( pData );

			if( iArrowType == 0 )	/// 폭발의 화살일 때만 화살 갯수 연산
			{
				if( null != pDamageData->optrAttackerGameUnit && 
					CX2GameUnit::GUT_USER == pDamageData->optrAttackerGameUnit->GetGameUnitType() )
				{
					CX2GUUser* pAttacker = static_cast<CX2GUUser*>( pDamageData->optrAttackerGameUnit.GetObservable() );

					if( NULL != pAttacker )
						pAttacker->UpdateStartOfDelayedFiring( true );
				}
			}

			SetStartOfDelayedFiringEmoticon();		/// 이모티콘 갱신
		}break;
#endif SERV_RENA_NIGHT_WATCHER

#ifdef STARLIGHT_SMASH
	case CX2DamageManager::EDT_STARLIGHT_SMASH:
		{			
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				g_pX2Game->GetDamageEffect()->CreateInstance( pAttackerUnit, L"DAMAGE_EFFECT_STARLIGHT_SMASH", pAttackerUnit->GetPowerRate(),
					pDamageData->impactPoint, GetRotateDegree(), GetRotateDegree(), GetLandPosition().y );
			}
		} break;
#endif STARLIGHT_SMASH

#ifdef ADD_SOCKET_OPTION_SANDER_SET
	case CX2DamageManager::EDT_FALLING_ROCK:/// 샌더 셋트 효과 - 바위 소환 
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				D3DXVECTOR3 vPos = pDamageData->impactPoint;
				vPos.y += 300.f;

				g_pX2Game->GetDamageEffect()->CreateInstance( pAttackerUnit, L"DAMAGE_EFFECT_EQUIP_FALLING_ROCK", 1.f,
					vPos, pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetRotateDegree(), GetLandPosition().y );
			}
		} break;

	case CX2DamageManager::EDT_SANDSTORM:/// 샌더 셋트 효과 - 모래돌풍 소환
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				D3DXVECTOR3 vPos = pDamageData->impactPoint;
				vPos.y = GetLandPosition().y;

				g_pX2Game->GetDamageEffect()->CreateInstance( pAttackerUnit, L"DAMAGE_EFFECT_EQUIP_SANDSTORM", 1.f,
					vPos, pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetRotateDegree(), GetLandPosition().y );
			}
		} break;
	case CX2DamageManager::EDT_WIND_VIBRATION:/// 샌더 칭호 진동 타격
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				D3DXVECTOR3 vPos = pDamageData->impactPoint;
				g_pX2Game->GetDamageEffect()->CreateInstance( pAttackerUnit, L"DAMAGE_EFFECT_EDT_WIND_VIBRATION", 1.f,
					vPos, pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetRotateDegree(), GetLandPosition().y );
			}
		} break;

	case CX2DamageManager::EDT_BREEZE_ACCEL:///샌더 칭호 산들바람의 기운 생성
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				D3DXVECTOR3 vPos = pAttackerUnit->GetBonePos(L"Bip01");
				g_pX2Game->GetDamageEffect()->CreateInstance( pAttackerUnit, L"DAMAGE_EFFECT_BUFF_BREEZE_ACCEL", 1.f,
					vPos, pAttackerUnit->GetRotateDegree(), pAttackerUnit->GetRotateDegree(), GetLandPosition().y );
			}
		} break;
	case CX2DamageManager::EDT_EVIL_SWORD:
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				D3DXVECTOR3 vPos = pDamageData->impactPoint;
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_EVIL_SWORD", pAttackerUnit, NULL, false, -1.0f, -1.0f, 
					D3DXVECTOR3(1,1,1), true, vPos, pAttackerUnit->GetRotateDegree() );
			}
		} break;
	case CX2DamageManager::EDT_SPIRIT_SWORD:
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				D3DXVECTOR3 vPos = pDamageData->impactPoint;
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_SPIRIT_SWORD", pAttackerUnit, NULL, false, -1.0f, -1.0f, 
					D3DXVECTOR3(1,1,1), true, vPos, pAttackerUnit->GetRotateDegree() );
			}
		} break;
	case CX2DamageManager::EDT_GHOST_SWORD:
		{
			CX2GameUnit* pAttackerUnit = pDamageData->optrAttackerGameUnit.GetObservable();
			if ( NULL != pAttackerUnit )
			{
				D3DXVECTOR3 vPos = pAttackerUnit->GetBonePos(L"Bip01");
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EDT_GHOST_SWORD", pAttackerUnit, NULL, false, -1.0f, -1.0f, 
					D3DXVECTOR3(1,1,1), true, vPos, pAttackerUnit->GetRotateDegree() );
			}
		} break;
#endif //ADD_SOCKET_OPTION_SANDER_SET

#ifdef HAMEL_SECRET_DUNGEON // 김태환
	case CX2DamageManager::EDT_ACTIVE_DEBUFF:	/// 타격시 특정 디버프를 적용
		{
			CX2GameUnit* pDefenderUnit = pDamageData->optrDefenderGameUnit.GetObservable();

			if ( NULL != pDefenderUnit && NULL != extraDamageData.m_ptrBuffFactor )
			{
				CX2BuffFactorPtr pCloneBuffFactorPtr =  extraDamageData.m_ptrBuffFactor->GetClonePtr( 0 );

				if ( NULL != pCloneBuffFactorPtr )
				{
					pCloneBuffFactorPtr->SetGameUnitBuffFactor( this );
					pDefenderUnit->SetBuffFactorToGameUnit( *pCloneBuffFactorPtr );
				}
			}
		} break;
#endif // HAMEL_SECRET_DUNGEON

	default:
		{
			ASSERT( !"EDT_NONE extra damage" );
		} break;
	}

//{{ kimhc // 2010.4.2 // 비밀던전 작업(셋트아이템효과)
#ifdef SERV_SECRET_HELL
	if ( bGetExtraDamage == true )
	{
		ProcessSocketEffectEx( CX2SocketItem::SIEE_STAT_UP, this  );
		ProcessSocketEffectEx( CX2SocketItem::SIEE_UP_MANA_RECOVERY_VALUE, this  );
	}

#endif SERV_SECRET_HELL
//}} kimhc // 2010.4.2 // 비밀던전 작업(셋트아이템효과)
}


#ifdef ARA_CHANGE_CLASS_FIRST
void CX2GUUser::DamageReactStateChange( CX2DamageManager::DamageData* pDamageData, 
										int iRevengeAttack /*= -1*/, 
										int iAvoidance /*= -1*/  )
#else
void CX2GUUser::DamageReactStateChange( CX2DamageManager::DamageData* pDamageData, int iRevengeAttack /*= -1*/ )
#endif //ARA_CHANGE_CLASS_FIRST
{
	if( IsMyUnit() == false )
		return;

	if ( m_bRidingMachine == true )
		return;	

	// note!!! 이 부분 코드가 왜 필요한지 이유를 찾아야 함
	if( NULL != g_pData->GetUIManager() &&
		NULL != g_pData->GetUIManager()->GetUIQuickSlot() )
	{
		if( true == g_pData->GetUIManager()->GetUIQuickSlot()->GetWaiting_EGS_USE_QUICK_SLOT_ACK() )
			return;
	}

#ifdef UPGRADE_RAVEN
	// 레이븐 패링
	if( m_bParryingState == true )
	{
		m_bParryingState = false;

		CX2GURaven *pRaven = (CX2GURaven*)this;
		if( pRaven != NULL )			
		{			
			if( pRaven->CanParrying() == false )
			{
				if( pDamageData->reActResult == CX2DamageManager::RT_SMALL_DAMAGE )
					StateChange(CX2GURaven::RSI_PARRYING_SMALL, true);
				else
					StateChange(CX2GURaven::RSI_PARRYING, true);
			}
			return;
		}
	}	
#endif

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	// 이브 패링
	if( m_bManeuverParryingState == true )
	{
		m_bManeuverParryingState = false;

		CX2GUEve *pEve = static_cast<CX2GUEve*> ( this );
		if( pEve != NULL )			
		{			
			if( pEve->CanParrying() == false )
			{
				if( pDamageData->reActResult == CX2DamageManager::RT_SMALL_DAMAGE )
					StateChange(CX2GUEve::ENSI_PARRYING_SMALL, true);
				else
					StateChange(CX2GUEve::ENSI_PARRYING, true);
			}
			return;
		}
	}	
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

#ifdef ARA_CHANGE_CLASS_FIRST
	if ( true == m_bQuickenGuardBlocking )
	{
		m_bQuickenGuardBlocking = false;

		CX2GUAra *pAra = static_cast<CX2GUAra*>(this);

		if ( NULL != pAra )
		{
			if ( CX2DamageManager::RT_SMALL_DAMAGE == pDamageData->reActResult )
				StateChange( CX2GUAra::ASI_P_ASD_QUICKEN_GUARD_SMALL, true );
			else
				StateChange( CX2GUAra::ASI_P_ASD_QUICKEN_GUARD, true );
		}
		return;
	}

	if ( true == m_bQuickenGuardTurning )
	{
		m_bQuickenGuardTurning = false;

		CX2GUAra *pAra = static_cast<CX2GUAra*>(this);

		if ( NULL != pAra )
		{
			m_FrameDataFuture.syncData.bIsRight	= !m_FrameDataFuture.syncData.bIsRight;
			m_FrameDataFuture.unitCondition.dirDegree.y	+= 180.0f;
			m_FrameDataFuture.unitCondition.bAttackerFront = true;
			m_PhysicParam.nowSpeed.x *= -1.f;
		}
	}
#endif

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환
	/// 레이븐 레크리스 피스트 - 리미트 크러셔 차지 상태
	if ( true == m_bIsLimitCrusherCharge )
	{
		if ( true == pDamageData->bCanRevenge )
			StateChange( CX2GURaven::RSI_A_RRF_LIMIT_CRUSHER_REVENGE_ATTACK );
		else
			StateChange( CX2GURaven::RSI_A_RRF_LIMIT_CRUSHER_AVOID_ATTACK );

		return;
	}
#endif // UPGRADE_SKILL_SYSTEM_2013

	CX2GameUnit*	pAttackerUnit = NULL;

	if( null != pDamageData->optrAttackerGameUnit )
	{
		pAttackerUnit		= pDamageData->optrAttackerGameUnit.GetObservable();
	}

	m_fGroggyTime = 0.f;
	switch( pDamageData->reActResult )
	{
	case CX2DamageManager::RT_DUMMY_DAMAGE:
#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE	  // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
	case CX2DamageManager::RT_FLIP_DIFF_DIR_DUMMY_DAMAGE :
		break;
#endif // SERV_ELESIS_SECOND_CLASS_CHANGE // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
		break;

	case CX2DamageManager::RT_SMALL_DAMAGE:
//{{ kimhc // 2011.1.8 // 청 1차 전직
#ifdef	CHUNG_FIRST_CLASS_CHANGE
	case CX2DamageManager::RT_FLIP_SAME_DIR:
#endif	CHUNG_FIRST_CLASS_CHANGE
//}} kimhc // 2011.1.8 // 청 1차 전직
		//{{ JHKang / 강정훈 / 2010/12/16 / 현재 피격 상태인가?

#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE	  // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
	case CX2DamageManager::RT_FLIP_DIFF_DIR:
#endif // SERV_ELESIS_SECOND_CLASS_CHANGE // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트

#ifdef SEASON3_MONSTER_2010_12
		SetNowHit( true );
#endif SEASON3_MONSTER_2010_12
		//}} JHKang / 강정훈 / 2010/12/16 / 현재 피격 상태인가?

		if ( IsSuperArmor() )
			break;

		if( m_FrameDataFuture.syncData.position.y - m_FrameDataFuture.unitCondition.landPosition.y < LINE_RADIUS * 5.0f
			|| (pAttackerUnit != NULL && pDamageData->attackerType == CX2DamageManager::AT_UNIT && pAttackerUnit->GetPos().y - pAttackerUnit->GetUnitCondition().landPosition.y < LINE_RADIUS * 3.0f) )
		{
			if( m_PhysicParam.nowSpeed.y > 0.0f )
				m_PhysicParam.nowSpeed.y = 0.0f;
			if( m_FrameDataFuture.unitCondition.bAttackerFront == true )
#ifdef RIDING_SYSTEM
			{
				if ( true == GetRidingOn() )
					StateChange( USI_RIDING_DAMAGE_FRONT, true );
				else
					StateChange( USI_DAMAGE_SMALL_FRONT, true );
			}
			else
			{
				if ( true == GetRidingOn() )
					StateChange( USI_RIDING_DAMAGE_BACK, true );
				else
					StateChange( USI_DAMAGE_SMALL_BACK, true );
			}
#else //RIDING_SYSTEM
				StateChange( USI_DAMAGE_SMALL_FRONT, true );
			else
				StateChange( USI_DAMAGE_SMALL_BACK, true );
#endif //RIDING_SYSTEM 데미지 State 변경
		}
		else
		{
			m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y;
#ifdef RIDING_SYSTEM
			/// 탈것 탑승중 공중 피격시, 탈것의 스테이트로 변환되도록 수정
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_DAMAGE_FRONT, true );
			else
#endif // RIDING_SYSTEM
				StateChange( USI_DAMAGE_AIR_SMALL, true );
		}
		break;

	case CX2DamageManager::RT_GROGGY:
		m_fGroggyTime = pDamageData->fGroggyTime;
		StateChange( USI_DAMAGE_GROGGY, true );
		break;


#ifdef NEW_SKILL_2010_11 // oasis907 : 김상윤 [2010.11.1] // 룬 슬레이어 - 마법저항 수련
	case CX2DamageManager::RT_REFLECT: 
#endif NEW_SKILL_2010_11
	case CX2DamageManager::RT_BIG_DAMAGE:
		//{{ JHKang / 강정훈 / 2010/12/16 / 현재 피격 상태인가?
#ifdef SEASON3_MONSTER_2010_12
		SetNowHit( true );
#endif SEASON3_MONSTER_2010_12
		//}} JHKang / 강정훈 / 2010/12/16 / 현재 피격 상태인가?

		if ( IsSuperArmor() )
			break;

		if( m_FrameDataFuture.syncData.position.y - m_FrameDataFuture.unitCondition.landPosition.y < LINE_RADIUS * 5.0f
			|| (pAttackerUnit != NULL && pDamageData->attackerType == CX2DamageManager::AT_UNIT && pAttackerUnit->GetPos().y - pAttackerUnit->GetUnitCondition().landPosition.y < LINE_RADIUS * 3.0f) )
		{
			if( m_PhysicParam.nowSpeed.y > 0.0f )
				m_PhysicParam.nowSpeed.y = 0.0f;
			if( m_FrameDataFuture.unitCondition.bAttackerFront == true )
#ifdef RIDING_SYSTEM
			{
				if ( true == GetRidingOn() )
					StateChange( USI_RIDING_DAMAGE_FRONT, true );
				else
					StateChange( USI_DAMAGE_BIG_FRONT, true );
			}
			else
			{
				if ( true == GetRidingOn() )
					StateChange( USI_RIDING_DAMAGE_BACK, true );
				else
					StateChange( USI_DAMAGE_BIG_BACK, true );
			}
#else
				StateChange( USI_DAMAGE_BIG_FRONT, true );
			else
				StateChange( USI_DAMAGE_BIG_BACK, true );
#endif //RIDING_SYSTEM 데미지 State 변경
		}
		else
		{
			m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y;

#ifdef RIDING_SYSTEM
			/// 탈것 탑승중 공중 피격시, 탈것의 스테이트로 변환되도록 수정
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_DAMAGE_FRONT, true );
			else
#endif // RIDING_SYSTEM
				StateChange( USI_DAMAGE_AIR_SMALL, true );
		}
		break;

	case CX2DamageManager::RT_DOWN:
#ifdef RIDING_SYSTEM
		if ( true == GetRidingOn() && NULL != m_ptrRidingPet )
			SetBuffFactorToGameUnitByBuffFactorID( static_cast<UINT>( BFI_BUFF_SUPER_AMOR_FOR_RIDING ) );
#endif //RIDING_SYSTEM

		if ( IsSuperArmor() )
			break;

		if( true == IsOnSomethingFuture() )
		{
			if( m_PhysicParam.nowSpeed.y > 0.0f )
				m_PhysicParam.nowSpeed.y = 0.0f;
			if( m_FrameDataFuture.unitCondition.bAttackerFront == true )
#ifdef RIDING_SYSTEM
			{
				if ( true == GetRidingOn() )
					StateChange( USI_RIDING_DAMAGE_FRONT, true );
				else
					StateChange( USI_DAMAGE_DOWN_FRONT, true );
			}
			else
			{
				if ( true == GetRidingOn() )
					StateChange( USI_RIDING_DAMAGE_BACK, true );
				else
					StateChange( USI_DAMAGE_DOWN_BACK, true );

			}
#else
				StateChange( USI_DAMAGE_DOWN_FRONT, true );
			else
				StateChange( USI_DAMAGE_DOWN_BACK, true );
#endif //RIDING_SYSTEM 데미지 State 변경
		}
		else
		{
			m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y;

#ifdef RIDING_SYSTEM
			/// 탈것 탑승중 공중 피격시, 탈것의 스테이트로 변환되도록 수정
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_DAMAGE_FRONT, true );
			else
#endif // RIDING_SYSTEM
				StateChange( USI_DAMAGE_AIR_DOWN, true );
		}

//{{ kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함
		SetHoldStateID( USI_DAMAGE_AIR_FALL );
//}} kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함

#ifdef FIX_FORCE_DOWN_INITIALIZE_BUG
		SetNowForceDown(0.f);
#endif // FIX_FORCE_DOWN_INITIALIZE_BUG
		break;

	case CX2DamageManager::RT_UP:
		//{{ JHKang / 강정훈 / 2010/12/16 / 현재 피격 상태인가?
#ifdef SEASON3_MONSTER_2010_12
		SetNowHit( true );
#endif SEASON3_MONSTER_2010_12
		//}} JHKang / 강정훈 / 2010/12/16 / 현재 피격 상태인가?
#ifdef RIDING_SYSTEM
		if ( true == GetRidingOn() && NULL != m_ptrRidingPet )
			SetBuffFactorToGameUnitByBuffFactorID( static_cast<UINT>( BFI_BUFF_SUPER_AMOR_FOR_RIDING ) );
#endif //RIDING_SYSTEM

		if ( IsSuperArmor() )
			break;

		if( m_FlyCount > 2 )
		{
			m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y / (m_FlyCount - 1);
		}
		else
		{
			m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y;
		}			

		ResetOnSomethingFuture();

#ifdef RIDING_SYSTEM
		if( m_FrameDataFuture.unitCondition.bAttackerFront == true )
		{
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_DAMAGE_FRONT, true );
			else
				StateChange( USI_DAMAGE_AIR_UP, true );
		}
		else
		{
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_DAMAGE_BACK, true );
			else
				StateChange( USI_DAMAGE_AIR_UP, true );

		}
#else //RIDING_SYSTEM
		StateChange( USI_DAMAGE_AIR_UP, true );
#endif //RIDING_SYSTEM 데미지 State 변경
		break;

	case CX2DamageManager::RT_FLY:
		//{{ JHKang / 강정훈 / 2010/12/16 / 현재 피격 상태인가?
#ifdef SEASON3_MONSTER_2010_12
		SetNowHit( true );
#endif SEASON3_MONSTER_2010_12
		//}} JHKang / 강정훈 / 2010/12/16 / 현재 피격 상태인가?

#ifdef RIDING_SYSTEM
		if ( true == GetRidingOn() && NULL != m_ptrRidingPet )
			SetBuffFactorToGameUnitByBuffFactorID( static_cast<UINT>( BFI_BUFF_SUPER_AMOR_FOR_RIDING ) );
#endif //RIDING_SYSTEM

		if ( IsSuperArmor() )
			break;

		if( m_FlyCount > 2 )
		{
			m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y / (m_FlyCount - 1);
		}
		else
		{
			m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y;
		}

		ResetOnSomethingFuture();

//{{ kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함
		if( m_FrameDataFuture.unitCondition.bAttackerFront == true )
		{
#ifdef RIDING_SYSTEM
			if ( true == GetRidingOn() )
			{
				StateChange( USI_RIDING_DAMAGE_FRONT, true );
				SetHoldStateID( USI_RIDING_DAMAGE_FRONT );
				SetGrapStateID ( USI_RIDING_DAMAGE_FRONT );
			}
			else
			{
				StateChange( USI_DAMAGE_AIR_FLY_FRONT, true );
				SetHoldStateID( USI_DAMAGE_AIR_FLY_FRONT );
				SetGrapStateID ( USI_DAMAGE_AIR_FLY_FRONT );
			}
#else //RIDING_SYSTEM
			StateChange( USI_DAMAGE_AIR_FLY_FRONT, true );
			SetHoldStateID( USI_DAMAGE_AIR_FLY_FRONT );
#ifdef TEST_GROUP_GRAP
			SetGrapStateID ( USI_DAMAGE_AIR_FLY_FRONT );
#endif TEST_GROUP_GRAP
#endif //RIDING_SYSTEM 데미지 State 변경
		}
		else
		{
#ifdef RIDING_SYSTEM
			if ( true == GetRidingOn() )
			{
				StateChange( USI_RIDING_DAMAGE_BACK, true );
				SetHoldStateID( USI_RIDING_DAMAGE_BACK );
				SetGrapStateID ( USI_RIDING_DAMAGE_BACK );
			}
			else
			{
				StateChange( USI_DAMAGE_AIR_FLY_BACK, true );
				SetHoldStateID( USI_DAMAGE_AIR_FLY_BACK );
				SetGrapStateID ( USI_DAMAGE_AIR_FLY_BACK );
			}
#else //RIDING_SYSTEM
			StateChange( USI_DAMAGE_AIR_FLY_BACK, true );
			SetHoldStateID( USI_DAMAGE_AIR_FLY_BACK );
#ifdef TEST_GROUP_GRAP
			SetGrapStateID ( USI_DAMAGE_AIR_FLY_BACK );
#endif TEST_GROUP_GRAP
#endif //RIDING_SYSTEM 데미지 State 변경
		}
//}} kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함
		
		break;

		//{{ kimhc // 2010.2.8 // 위치보정 없이 위로 계속 끌어 올리는 공격
#ifdef	EVE_SECOND_CLASS_CHANGE
	case CX2DamageManager::RT_DRAG_UP:
		{
			if ( IsSuperArmor() )
				break;

			m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y;
			
			ResetOnSomethingFuture();

			if( m_FrameDataFuture.unitCondition.bAttackerFront == true )
#ifdef RIDING_SYSTEM
			{
				if ( true == GetRidingOn() )
					StateChange( USI_RIDING_DAMAGE_FRONT, true );
				else
					StateChange( USI_DAMAGE_AIR_FLY_FRONT, true );
			}
			else
			{
				if ( true == GetRidingOn() )
					StateChange( USI_RIDING_DAMAGE_BACK, true );
				else
					StateChange( USI_DAMAGE_AIR_FLY_BACK, true );
			}
#else //RIDING_SYSTEM
				StateChange( USI_DAMAGE_AIR_FLY_FRONT, true );
			else
				StateChange( USI_DAMAGE_AIR_FLY_BACK, true );
#endif //RIDING_SYSTEM 데미지 State 변경
		}
		break;
#endif	EVE_SECOND_CLASS_CHANGE
		//}} kimhc // 2010.2.8 // 위치보정 없이 위로 계속 끌어 올리는 공격

	case CX2DamageManager::RT_REVENGE:
		if(iRevengeAttack != -1)
		{
			m_PhysicParam.nowSpeed.x = 0.0f;
			m_PhysicParam.nowSpeed.y = 0.0f;

#ifdef SERV_ARA_CHANGE_CLASS_SECOND // 김태환
			/// 마법 반사 버프가 적용중 이라면, 피격 모션을 없앤다.
			if ( false == m_vecReflectMagicByBuffPtr.empty() )
				return;
			else
#endif // SERV_ARA_CHANGE_CLASS_SECOND

			StateChange( iRevengeAttack, true );
		}		
		break;

#ifdef GRAPPLING_TEST
	case CX2DamageManager::RT_GRAPPLE:
		{
			if ( IsSuperArmor() )
				break;

			INIT_VECTOR2( m_PhysicParam.nowSpeed, 0, 0 );
			INIT_VECTOR2( m_PhysicParam.passiveSpeed, -1, -1 );

			if( m_FrameDataFuture.unitCondition.bAttackerFront == true )
				StateChange( USI_DAMAGE_GRAPPLED_FRONT, true );
			else
				StateChange( USI_DAMAGE_GRAPPLED_FRONT, true );

		} break;

	case CX2DamageManager::RT_THROW:
		{
			m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y;

			ResetOnSomethingFuture();


			if( m_FrameDataFuture.unitCondition.bAttackerFront == true )
				StateChange( USI_DAMAGE_AIR_FLY_FRONT, true );
			else
				StateChange( USI_DAMAGE_AIR_FLY_BACK, true );

		} break;

#endif GRAPPLING_TEST




#ifdef BOUNDING_COMBO_TEST

	case CX2DamageManager::RT_BOUNDING:
		{
			if ( IsSuperArmor() )
				break;

			if( m_FlyCount > 2 )
			{
				m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y / (m_FlyCount - 1);
			}
			else
			{
				m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y;
			}			

			ResetOnSomethingFuture();


#pragma DMLEE_NOTE( "bounding damage 상태를 따로 만들어 주는 것이 좋을 것 같음." )
			StateChange( USI_DAMAGE_AIR_UP, true );

		} break;

#endif BOUNDING_COMBO_TEST
#ifdef NEW_GRAPPLE_ATTACK
	case CX2DamageManager::RT_NEW_GRAPPLE:
		{

			SetGrappled( true );
			StateChange( GetGrappledStateID() , true ); 
		
		}
#endif NEW_GRAPPLE_ATTACK

#ifdef ARA_CHANGE_CLASS_FIRST
	case CX2DamageManager::RT_AVOIDANCE:
		if( -1 != iAvoidance )
		{
			m_PhysicParam.nowSpeed.x = 0.0f;
			m_PhysicParam.nowSpeed.y = 0.0f;

			StateChange( iAvoidance, true );
		}
		break;
#endif //ARA_CHANGE_CLASS_FIRST
	}



	switch( pDamageData->reActResult )
	{
	case CX2DamageManager::RT_SMALL_DAMAGE:
	case CX2DamageManager::RT_BIG_DAMAGE:
		{
			if( true == pDamageData->m_bFlipDirOnHit )
			{
				m_FrameDataFuture.syncData.bIsRight			= !m_FrameDataFuture.syncData.bIsRight;
				m_FrameDataFuture.unitCondition.dirDegree.y	+= 180.0f;


#ifdef UP_SIDE_DOWN_CAMERA_TEST
				g_pX2Game->GetX2Camera()->GetCamera().UpSideDown( 4.f );
#endif UP_SIDE_DOWN_CAMERA_TEST
				
			}
		} break;

		//{{ kimhc // 2011.1.8 // 청 1차 전직
#ifdef	CHUNG_FIRST_CLASS_CHANGE
	case CX2DamageManager::RT_FLIP_SAME_DIR:	// 상대방을 유저
		{
			// 슈퍼아머가 아니면
			if ( false == IsSuperArmor() )
			{
				bool bIsAttackerUnitInRightDirection = false; // 유저의 방향

				if ( null != pDamageData->optrAttackerGameUnit )
				{
					bIsAttackerUnitInRightDirection = pDamageData->optrAttackerGameUnit->GetIsRight();
				} // if

				// 유저의 방향과 NPC의 방향이 반대이면
				if ( bIsAttackerUnitInRightDirection != m_FrameDataFuture.syncData.bIsRight )
				{
					// 회전 시킴
					m_FrameDataFuture.syncData.bIsRight			= !m_FrameDataFuture.syncData.bIsRight;
					m_FrameDataFuture.unitCondition.dirDegree.y	+= 180.0f;
				} // if

			} // if
		} break;
#endif	CHUNG_FIRST_CLASS_CHANGE
		//}} kimhc // 2011.1.8 // 청 1차 전직

#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE	  // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
	case CX2DamageManager::RT_FLIP_DIFF_DIR:	// 상대방을 유저
	case CX2DamageManager::RT_FLIP_DIFF_DIR_DUMMY_DAMAGE :
		{
			// 슈퍼아머가 아니면
			if ( false == IsSuperArmor() )
			{
				bool bIsAttackerUnitInRightDirection = false; // 유저의 방향

				if ( null != pDamageData->optrAttackerGameUnit )
				{
					bIsAttackerUnitInRightDirection = pDamageData->optrAttackerGameUnit->GetIsRight();
				} // if

				// 유저의 방향과 NPC의 방향이 같은 방향이면
				if ( bIsAttackerUnitInRightDirection == m_FrameDataFuture.syncData.bIsRight )
				{
					// 회전 시킴
					m_FrameDataFuture.syncData.bIsRight			= !m_FrameDataFuture.syncData.bIsRight;
					m_FrameDataFuture.unitCondition.dirDegree.y	+= 180.0f;
				} // if

			} // if
		} break;
#endif // SERV_ELESIS_SECOND_CLASS_CHANGE // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
	}



	if( true == IsDamagedReaction( pDamageData ) )
	{
		if( DamageFlushMp()== true )
		{
			DetonationStateChange( pDamageData );
		}
		else if( FlushForceDown() == true )
		{
			if( true == IsOnSomethingFuture() )
			{
				if( m_FrameDataFuture.unitCondition.bAttackerFront == true )
#ifdef RIDING_SYSTEM
				{
					if ( true == GetRidingOn() )
						StateChange( USI_RIDING_DAMAGE_FRONT, true );
					else
						StateChange( USI_DAMAGE_DOWN_FRONT, true );
				}
				else
				{
					if ( true == GetRidingOn() )
						StateChange( USI_RIDING_DAMAGE_BACK, true );
					else
						StateChange( USI_DAMAGE_DOWN_BACK, true );

				}
#else //RIDING_SYSTEM
					StateChange( USI_DAMAGE_DOWN_FRONT, true );
				else
					StateChange( USI_DAMAGE_DOWN_BACK, true );
#endif //RIDING_SYSTEM 데미지 State 변경
			}
			else
			{
				m_PhysicParam.nowSpeed.y = 0.0f;

#ifdef RIDING_SYSTEM
				/// 탈것 탑승중 공중 피격시, 탈것의 스테이트로 변환되도록 수정
				if ( true == GetRidingOn() )
					StateChange( USI_RIDING_DAMAGE_FRONT, true );
				else
#endif // RIDING_SYSTEM
					StateChange( USI_DAMAGE_AIR_DOWN_INVINCIBLE, true );
			}

			if ( m_ExtraDamagePack.m_EnchantShock.m_fTime > 0.0f )
			{
				m_bReserveForceDownForShock = true;
			}
		}
	}

#ifdef NO_DETONATION
	if( pDamageData->m_bNoDetonation == true )
	{
		SetNoDetonation( true );
	}
#endif
}
/** @function : DetonationStateChange()
	@brief : 디토네이션에 의한 스테이트 변경 처리.
			 엘리시스 검의길 효과 구현을 위해 가상함수 처리
*/
/*virtual*/ void CX2GUUser::DetonationStateChange( CX2DamageManager::DamageData* pDamageData )
{
	if( NULL == pDamageData )
		return;

#ifdef SERV_9TH_NEW_CHARACTER // 김태환
	/// DT_BUFF일때는 기폭 못하게 막자
	if ( CX2DamageManager::DT_BUFF == pDamageData->damageType )
		return;
#endif //SERV_9TH_NEW_CHARACTER

	if( true == IsOnSomethingFuture() )
	{
		if( m_FrameDataFuture.unitCondition.bAttackerFront == true )
#ifdef RIDING_SYSTEM
		{
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_DAMAGE_FRONT, true );
			else
				StateChange( USI_DAMAGE_DOWN_FRONT, true );
		}
		else
		{
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_DAMAGE_BACK, true );
			else
				StateChange( USI_DAMAGE_DOWN_BACK, true );
		}
#else //RIDING_SYSTEM
			StateChange( USI_DAMAGE_DOWN_FRONT, true );
		else
			StateChange( USI_DAMAGE_DOWN_BACK, true );
#endif //RIDING_SYSTEM 데미지 State 변경
	}
	else
	{
		m_PhysicParam.nowSpeed.y = pDamageData->backSpeed.y;

#ifdef RIDING_SYSTEM
		/// 탈것 탑승중 공중 피격시, 탈것의 스테이트로 변환되도록 수정
		if ( true == GetRidingOn() )
			StateChange( USI_RIDING_DAMAGE_FRONT, true );
		else
#endif // RIDING_SYSTEM
			StateChange( USI_DAMAGE_AIR_DOWN_INVINCIBLE, true );
	}
	SetStopTime( 0.7f );
	g_pKTDXApp->GetDGManager()->ClearScreen( 1 );

	CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;
	pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RevengeImpactTick", 
		pDamageData->impactPoint,
		200, 200, 2, 20 );

	if( pSeq != NULL )
	{
		pSeq->SetLandPosition( m_FrameDataNow.unitCondition.landPosition.y );
	}
}
//{{ kimhc // 2011-05-25 // SetOption, TitleOption에만 적용 되는 option 모든 itemOption에 적용 되도록 수정

float CX2GUUser::CalculateHpUpPercentBySocketOption( const vector<D3DXVECTOR2>& vecHpUpPercentBySocketOption )
{
	float fHpPercentToBeUp = 0.0f;
	int iRandomSeed = 0;
	BOOST_TEST_FOREACH( const D3DXVECTOR2&, val, vecHpUpPercentBySocketOption )
	{
		if ( GetRandomFloat( CKTDXRandomNumbers::SRO_ADD_MANA_ON_ATTACK + iRandomSeed++ ) < val.x )
			fHpPercentToBeUp += val.y;
	}

	return fHpPercentToBeUp;
}

float CX2GUUser::CalculateMpUpBySocketOption( const vector<D3DXVECTOR2>& vecMpUpBySocketOption )
{
	float fMpUp = 0.0f;
	int iRandomSeed = 0;
	BOOST_TEST_FOREACH( const D3DXVECTOR2&, val, vecMpUpBySocketOption )
	{
		if ( GetRandomFloat( CKTDXRandomNumbers::SRO_ADD_MANA_ON_ATTACK + iRandomSeed++ ) < val.x )
			fMpUp += val.y;
	}

	return fMpUp;
}

#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
float CX2GUUser::CalculateMpUpAttackedBySocketOption( vector<D3DXVECTOR4>& vecMpUpAttackedBySocketOption )
{
	float fMpUp = 0.0f;
	int iRandomSeed = 0;
	bool bCooltimeCheck = false; //쿨타임 체크가 필요한 option인지 체크. 필요한 option인 경우 쿨타임이 지났는지도 체크.

	BOOST_TEST_FOREACH( D3DXVECTOR4&, val, vecMpUpAttackedBySocketOption )
	{
		bCooltimeCheck = false;

		if( val.z > 0.0f )
		{
			bCooltimeCheck = true;
			
			if( val.w <= 0.0f )
			{
				bCooltimeCheck = false;
				val.w = val.z;
			}
		}


		if ( false == bCooltimeCheck && GetRandomFloat( CKTDXRandomNumbers::SRO_ADD_MANA_ON_ATTACK + iRandomSeed++ ) < val.x )
			fMpUp += val.y;
	}

	return fMpUp;
}
#endif //ADJUST_SECRET_ITEM_OPTION

//}} kimhc // 2011-05-25 // SetOption, TitleOption에만 적용 되는 option 모든 itemOption에 적용 되도록 수정

void CX2GUUser::ProcessAttackResult()
{
	if ( CX2DamageManager::AT_SPECIAL != m_DamageData.attackType )
	{
		// 공격시 mp up 기능
		//float fPercentMPUp = 0.0f;
		

		//{{ kimhc // 2011-05-25 // SetOption, TitleOption에만 적용 되는 option 모든 itemOption에 적용 되도록 수정

		// 공격시 증가 할 HP Percent
		float fHPPercentToBeUp = CalculateHpUpPercentBySocketOption( m_SocketData.m_vecHpUpByAttack );
		float fHPUp = GetMaxHp() * fHPPercentToBeUp;

		if( 0.0f < fHPUp )
		{
			UpNowHp( fHPUp );

			std::wstringstream strStream;
			strStream << L"HP+ " << (int)fHPUp;
			D3DXVECTOR3 pos = GetPos();
			pos.y += 50.0f;
			if( NULL != g_pData->GetPicCharGreen() )
				g_pData->GetPicCharGreen()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );
		}

		float fMPUp = CalculateMpUpBySocketOption( m_SocketData.m_vecMpUpByAttack );

		// 공격시 증가할 MP 양이 있으면
		if( 0.0f < fMPUp )
		{
			UpNowMp( fMPUp );

			std::wstringstream strStream;
			strStream << L"MP+ " << (int)fMPUp;
			D3DXVECTOR3 pos = GetPos();
			pos.y += 50.0f;
			if( NULL != g_pData->GetPicCharBlue() )
				g_pData->GetPicCharBlue()->DrawText( strStream.str().c_str(), pos, GetDirVector(), CKTDGPicChar::AT_CENTER );
		}

		//}} kimhc // 2011-05-25 // SetOption, TitleOption에만 적용 되는 option 모든 itemOption에 적용 되도록 수정		

//{{ kimhc // 2010.4.28 // 비밀던전 작업(엘더 무기 효과)
#if defined( SERV_SECRET_HELL ) || defined( SERV_SKILL_NOTE )	// 기술의 노트 때 추가된 함수를 사용함
		ProcessSocketEffectEx( CX2SocketItem::SIEE_ATTACK_SPEED_UP, this  );
#endif //#if defined( SERV_SECRET_HELL ) || defined( SERV_SKILL_NOTE )
//}} kimhc // 2010.4.28 // 비밀던전 작업(엘더 무기 효과)
	}
	
}


void CX2GUUser::AttackResult()
{
#if defined( _SERVICE_ )
	ELSWORD_VIRTUALIZER_START
#endif

	KTDXPROFILE();
	if( m_DamageData.reActResult == CX2DamageManager::RT_NO_DAMAGE || m_DamageData.reActResult == CX2DamageManager::RT_SENSOR )
		return;

	CX2GameUnit*	pDefenderUnit = NULL;
	if( null != m_DamageData.optrDefenderGameUnit )
	{
		pDefenderUnit		= m_DamageData.optrDefenderGameUnit.GetObservable();

#ifdef SERV_PET_SYSTEM
		SetGameUnitAttackedByMe( pDefenderUnit );
#endif
	}

	D3DXVECTOR3 dirUnitToAttacker = D3DXVECTOR3(0,0,0);
	if( pDefenderUnit != NULL )
	{
		dirUnitToAttacker = pDefenderUnit->GetPos() - GetPos();
#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
        dirUnitToAttacker.y = 0.f;
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION
	}


	if( D3DXVec3Dot( &GetDirVector(), &dirUnitToAttacker ) >= 0 )
		m_FrameDataNow.unitCondition.bAttackerFront = true;
	else
		m_FrameDataNow.unitCondition.bAttackerFront = false;

	if( m_FrameDataNow.syncData.bIsRight == false )
	{
		m_FrameDataNow.unitCondition.bAttackerFront = !m_FrameDataNow.unitCondition.bAttackerFront;			
	}

	m_FrameDataFuture.unitCondition.bAttackerFront = m_FrameDataNow.unitCondition.bAttackerFront;


	bool bCheckRevenge = false;

	m_DamageLightTime = 0.2f;


	if( IsMyUnit() == true )
	{
		if( m_bUpMPThisFrame == false 
#ifdef ADD_DAMAGE_TYPE_BUFF
		&& CX2DamageManager::DT_BUFF != m_DamageData.damageType 
#endif //ADD_DAMAGE_TYPE_BUFF
		)
		{
			int		redAdv						= 0;
			int		blueAdv						= 0;
			float	fIncreaseMpRate				= 1.0f;		// 피*타격시 마나 + 증가치(1.0은 증가가 없는 비율)
			float	fIncreaseSoulRate			= 1.0f;		// 피*타격시 각성 + 증가치

#ifdef ELSWORD_WAY_OF_SWORD
			if( CX2Unit::UT_ELSWORD == GetUnit()->GetType() )
			{
				float fWSPGain = 0.f;
				fWSPGain = g_pData->GetDamageManager()->CalcWayOfSwordPoint(m_DamageData.m_WayofSwordType, m_DamageData.damage.GetAllDamage(), GetWayOfSwordState() );
				SetWayOfSwordPoint( GetWayOfSwordPoint() + fWSPGain );

				fIncreaseMpRate *= g_pData->GetDamageManager()->CalcVigorMpUpOnAttack(m_DamageData.m_WayofSwordType, GetWayOfSwordState() );
			}
#ifdef NEW_CHARACTER_EL // 검의 길
			else if( CX2Unit::UT_ELESIS == GetUnit()->GetType() )
			{
				float fWSPGain = 0.f;
				fWSPGain = g_pData->GetDamageManager()->CalcWayOfSwordPoint(m_DamageData.m_WayofSwordType, m_DamageData.damage.GetAllDamage(), GetWayOfSwordState() );
				SetWayOfSwordPoint( GetWayOfSwordPoint() + fWSPGain );

				fIncreaseMpRate *= g_pData->GetDamageManager()->CalcVigorMpUpOnAttack_Elesis(m_DamageData.m_WayofSwordType, GetWayOfSwordState() );
			}
#endif // NEW_CHARACTER_EL

#endif ELSWORD_WAY_OF_SWORD

			//{{ kimhc // 2009-11-17 // 길드 스킬 중 정신집중, 집중된 마력, 격노, 분노해방
#ifdef	GUILD_SKILL
			const CX2Unit::UnitData* pUnitData = &GetUnit()->GetUnitData();

			// 집중된 마력
			const CX2SkillTree::SkillTemplet* pSkillTemplet = pUnitData->m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_GP_COMMON_CONCENTRATION_MAGICAL_POWER, pUnitData->m_byMemberShipGrade );

			if( NULL != pSkillTemplet )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				const int iSkillTempletLevel = max( 1, pUnitData->m_UserSkillTree.GetSkillLevel( pSkillTemplet->m_eID, true ) );	/// 스킬 레벨
	
				fIncreaseMpRate *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_ON_HIT_REL, iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
				fIncreaseMpRate *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_ON_HIT_REL );
	#endif // UPGRADE_SKILL_SYSTEM_2013
			}

			// 분노해방
			pSkillTemplet = pUnitData->m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_GP_COMMON_LIBERATION_OF_ANGER, pUnitData->m_byMemberShipGrade );

			if( NULL != pSkillTemplet )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				const int iSkillTempletLevel = max( 1, pUnitData->m_UserSkillTree.GetSkillLevel( pSkillTemplet->m_eID, true ) );	/// 스킬 레벨

				float fRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SOUL_GAIN_ON_HIT_REL, iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
				float fRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SOUL_GAIN_ON_HIT_REL );
	#endif // UPGRADE_SKILL_SYSTEM_2013
				
				fIncreaseSoulRate += CalculateIncreasingRate( fRate );
			}
#endif	GUILD_SKILL
			//}} kimhc // 2009-11-17 // 길드 스킬 중 정신집중, 집중된 마력, 격노, 분노해방

//{{ kimhc // 2010.11.3 // 레피 - 승화된 분노
#ifdef	NEW_SKILL_2010_11
			const CX2SkillTree::SkillTemplet* pSkillTempletSpritualizedFury 
				= pUnitData->m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_P_RRF_SPIRITUALIZED_FURY );

			if ( NULL != pSkillTempletSpritualizedFury )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				const int iSkillTempletLevel = max( 1, pUnitData->m_UserSkillTree.GetSkillLevel( pSkillTempletSpritualizedFury->m_eID, true ) );	/// 스킬 레벨

				float fRate = pSkillTempletSpritualizedFury->GetSkillAbilityValue( CX2SkillTree::SA_SOUL_GAIN_ON_HIT_REL, iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
				float fRate = pSkillTempletSpritualizedFury->GetSkillAbilityValue( CX2SkillTree::SA_SOUL_GAIN_ON_HIT_REL );
	#endif // UPGRADE_SKILL_SYSTEM_2013

				fIncreaseSoulRate += CalculateIncreasingRate( fRate );
			} // if
#endif	NEW_SKILL_2010_11
//}} kimhc // 2010.11.3 // 레피 - 승화된 분노

			if( g_pX2Room != NULL && g_pData->GetPVPRoom() != NULL )
			{
				if( g_pX2Room->GetRoomType() == CX2Room::RT_PVP )
				{
					if( g_pData->GetPVPRoom()->GetPVPGameType() == CX2PVPRoom::PGT_TEAM
						|| g_pData->GetPVPRoom()->GetPVPGameType() == CX2PVPRoom::PGT_TEAM_DEATH )
					{
						int redNum		= g_pX2Room->GetTeamNum( CX2Room::TN_RED, true );
						int blueNum		= g_pX2Room->GetTeamNum( CX2Room::TN_BLUE, true );
						if( redNum > blueNum )
						{
							blueAdv = redNum - blueNum;
						}
						else if( redNum < blueNum )
						{
							redAdv = blueNum - redNum;
						}
					}					
				}
			}


			//{{ dmlee 2008.04.11 캐시 아이템 착용시
			if( 0.f != m_CashItemAbility.m_fUpMPAtAttackOrDamage )
			{
				UpNowMp( m_CashItemAbility.m_fUpMPAtAttackOrDamage );
			}
			//}} dmlee 2008.04.11 캐시 아이템 착용시
			
			ProcessAttackResult();

			float fUpMPScaleBySkill = 1.f;
#ifdef NEW_SKILL_TREE
			if( CX2DamageManager::AT_SPECIAL != m_DamageData.attackType )
			{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
				int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_ESK_GET_MANA_UP, true );

				if( iSkillLevel > 0 )
				{
					const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_ESK_GET_MANA_UP );

					if( NULL != pSkillTemplet )
					{
						fUpMPScaleBySkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_ON_HIT_REL, iSkillLevel );
					}
				}
#else //UPGRADE_SKILL_SYSTEM_2013
				int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_GET_MANA_UP );

				if( iSkillLevel > 0 )
				{
					const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_GET_MANA_UP, iSkillLevel );

					if( NULL != pSkillTemplet )
					{
						fUpMPScaleBySkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_ON_HIT_REL );
					}
				}
#endif //UPGRADE_SKILL_SYSTEM_2013
			}
#endif NEW_SKILL_TREE

#ifdef BALANCE_GRAND_ARCHER_20121213
			if( CX2DamageManager::AT_SPECIAL != m_DamageData.attackType )
			{
				int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_LGA_COMMUNE_OF_NATURE, true );
				if( iSkillLevel > 0 )
				{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
					const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_LGA_COMMUNE_OF_NATURE );
					if( NULL != pSkillTemplet )
					{
						fUpMPScaleBySkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_ON_HIT_REL, iSkillLevel );
					}
	#else // UPGRADE_SKILL_SYSTEM_2013
					const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_LGA_COMMUNE_OF_NATURE, iSkillLevel );
					if( NULL != pSkillTemplet )
					{
						fUpMPScaleBySkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_ON_HIT_REL );
					}
	#endif // UPGRADE_SKILL_SYSTEM_2013
				}
			}
#endif //BALANCE_GRAND_ARCHER_20121213

#ifdef CHUNG_SECOND_CLASS_CHANGE
			if( CX2DamageManager::AT_SPECIAL != m_DamageData.attackType )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				/// 진동 사격에 MP 회수율 추가
				int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_LGA_VIBRATION_SHOOTING, true );

				if( iSkillLevel > 0 )
				{
					const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_LGA_VIBRATION_SHOOTING );
					if( NULL != pSkillTemplet )
					{
						fUpMPScaleBySkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_ON_HIT_REL, iSkillLevel );
					}
				}

				/// 신진대사 촉진 강화
				iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CIP_ADVANCED_METABOLISM_BOOST, true );

				if( iSkillLevel > 0 )
				{
					const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_CIP_ADVANCED_METABOLISM_BOOST );
					if( NULL != pSkillTemplet )
					{
						fUpMPScaleBySkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_ON_HIT_REL, iSkillLevel );
					}
				}
	#else // UPGRADE_SKILL_SYSTEM_2013
				int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CIP_ADVANCED_METABOLISM_BOOST );

				if( iSkillLevel > 0 )
				{
					const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_CIP_ADVANCED_METABOLISM_BOOST, iSkillLevel );
					if( NULL != pSkillTemplet )
					{
						fUpMPScaleBySkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_GAIN_ON_HIT_REL );
					}
				}
	#endif // UPGRADE_SKILL_SYSTEM_2013
			}

			
#endif CHUNG_SECOND_CLASS_CHANGE

		#ifdef SERV_9TH_NEW_CHARACTER // 김태환
			/// 애드일 땐, 타격시 DP 수치 올려 주자
			if ( NULL != GetUnit() && CX2Unit::UT_ADD == GetUnit()->GetType() )
			{
				if ( false == GetUpDPByAttackThisFrame() )	/// 프레임당 한번만 DP 회복 처리
				{
					UpNowDPValueByHit( m_DamageData );
					SetUpDPByAttackThisFrame( true );
				}
			}
		#endif //SERV_9TH_NEW_CHARACTER

			if( GetTeam() == CX2Room::TN_RED )
			{
				UpNowMpPerHitOthers( m_DamageData.fHitAddMP, redAdv, fUpMPScaleBySkill * fIncreaseMpRate );				
				
#ifdef DUNGEON_ITEM

	#ifdef SERV_CHUNG_TACTICAL_TROOPER		/// 택티컬 필드 추가
				if( GetHyperModeCount() < 3 && m_DamageData.m_fHpPercentUp <= 0.f && m_DamageData.m_fMpPercentUp <= 0.f &&
					m_DamageData.m_fIncreaseMP <= 0.f )
	#else  SERV_CHUNG_TACTICAL_TROOPER
				if( GetHyperModeCount() < 3 && m_DamageData.m_fHpPercentUp <= 0.f && m_DamageData.m_fMpPercentUp <= 0.f )
	#endif SERV_CHUNG_TACTICAL_TROOPER
#else
				if( GetHyperModeCount() < 3 )
#endif
				{
					//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업
		#ifdef SERV_ADD_LUNATIC_PSYKER // 김태환
					/// 버프 적용 구조로 변경
					UpNowSoul( ( (1.0f * (1.0f + GetHyperChargeSpeed() ) ) + (2.0f * redAdv) ) * fIncreaseSoulRate );
		#else // SERV_ADD_LUNATIC_PSYKER
					UpNowSoul( ( (1.0f * (1.0f + CX2SocketItem::GetFinalHyperGageChargeSpeedPercent( GetSocketData().m_fHyperModeChargeRate, GetUnitLevel() ) ) ) + (2.0f * redAdv) ) * fIncreaseSoulRate );
		#endif // SERV_ADD_LUNATIC_PSYKER
					//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업
				}
			}
			else if( GetTeam() == CX2Room::TN_BLUE )
			{
				UpNowMpPerHitOthers( m_DamageData.fHitAddMP, blueAdv, fUpMPScaleBySkill * fIncreaseMpRate );				
				
#ifdef DUNGEON_ITEM

	#ifdef SERV_CHUNG_TACTICAL_TROOPER		/// 택티컬 필드 추가
				if( GetHyperModeCount() < 3 && m_DamageData.m_fHpPercentUp <= 0.f && m_DamageData.m_fMpPercentUp <= 0.f &&
					m_DamageData.m_fIncreaseMP <= 0.f )
	#else  SERV_CHUNG_TACTICAL_TROOPER
				if( GetHyperModeCount() < 3 && m_DamageData.m_fHpPercentUp <= 0.f && m_DamageData.m_fMpPercentUp <= 0.f )
	#endif SERV_CHUNG_TACTICAL_TROOPER

#else
				if( GetHyperModeCount() < 3 )
#endif
				{
					//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업
		#ifdef SERV_ADD_LUNATIC_PSYKER // 김태환
					/// 버프 적용 구조로 변경
					UpNowSoul( ( (1.0f * (1.0f + GetHyperChargeSpeed() ) ) + (2.0f * blueAdv) ) * fIncreaseSoulRate );
		#else // SERV_ADD_LUNATIC_PSYKER
					UpNowSoul( ( (1.0f * (1.0f + CX2SocketItem::GetFinalHyperGageChargeSpeedPercent( GetSocketData().m_fHyperModeChargeRate, GetUnitLevel() ) ) ) + (2.0f * blueAdv) ) * fIncreaseSoulRate );
		#endif // SERV_ADD_LUNATIC_PSYKER
					//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업
				}
			}
			else
			{
				UpNowMpPerHitOthers( m_DamageData.fHitAddMP, 0, fUpMPScaleBySkill * fIncreaseMpRate );				

#ifdef DUNGEON_ITEM

	#ifdef SERV_CHUNG_TACTICAL_TROOPER		/// 택티컬 필드 추가
				if( GetHyperModeCount() < 3 && m_DamageData.m_fHpPercentUp <= 0.f && m_DamageData.m_fMpPercentUp <= 0.f &&
					m_DamageData.m_fIncreaseMP <= 0.f )
	#else  SERV_CHUNG_TACTICAL_TROOPER
				if( GetHyperModeCount() < 3 && m_DamageData.m_fHpPercentUp <= 0.f && m_DamageData.m_fMpPercentUp <= 0.f )
	#endif SERV_CHUNG_TACTICAL_TROOPER
#else
                if( GetHyperModeCount() < 3 )
#endif
				{
					//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업
		#ifdef SERV_ADD_LUNATIC_PSYKER // 김태환
					UpNowSoul( ( (1.0f * (1.0f + GetHyperChargeSpeed() ) ) ) * fIncreaseSoulRate );
		#else // SERV_ADD_LUNATIC_PSYKER
					UpNowSoul( ( (1.0f * (1.0f + CX2SocketItem::GetFinalHyperGageChargeSpeedPercent( GetSocketData().m_fHyperModeChargeRate, GetUnitLevel() ) ) ) ) * fIncreaseSoulRate );
		#endif // SERV_ADD_LUNATIC_PSYKER
					//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업
				}
			}
			m_bUpMPThisFrame = true;
		}

		SetStopTime( m_DamageData.fStopTimeAtt );
#ifdef NEW_SKILL_2010_11
		// oasis907 : 김상윤 [2010.11.1] // 룬 슬레이어 - 마법저항 수련
		if( m_DamageData.reActResult == CX2DamageManager::RT_REVENGE || 
			m_DamageData.reActResult == CX2DamageManager::RT_REFLECT )
#else
		if( m_DamageData.reActResult == CX2DamageManager::RT_REVENGE )
#endif NEW_SKILL_2010_11
		{
			m_PhysicParam.nowSpeed.x = 0.0f;
			m_PhysicParam.nowSpeed.y = 0.0f;

			bCheckRevenge = true;
		}

		if( m_DamageData.techPoint > 0 )
			g_pX2Game->AddTechPoint( m_DamageData.techPoint );

		SetNowForceDown( 0.f ); 


#ifdef ATTACK_DELAY_GAGE
//{{AFX
		AddAttackDelay( m_DamageData.fForceDownValue );
//}}AFX
#endif ATTACK_DELAY_GAGE


		if( m_DamageData.m_bDrain == true && pDefenderUnit != NULL )
		{
//			ModifyFinalDamageByGameUnitType( &m_DamageData );
			float fFinalDamage = pDefenderUnit->GetFinalDamage( &m_DamageData );
			UpNowHp( fFinalDamage );
		}
	}

#ifdef SERV_ARA_CHANGE_CLASS_SECOND // 김태환
	if ( 0.f < m_DamageData.fHitAddHPPer )		/// 공격 성공시, 체력 회복 설정
		UpNowHpPerHitOthers( m_DamageData.fHitAddHPPer );
#endif // SERV_ARA_CHANGE_CLASS_SECOND
#ifdef ADD_MEMO_1ST_CLASS //김창한
	if( 0.f < m_DamageData.fHitAddHPbyAttackPower ) /// 공격 성공시, 체력 회복 설정(공격자 물마공 평균에 비례)
		UpNowHpPerHitbyAttackPower( m_DamageData.fHitAddHPbyAttackPower );
#endif //ADD_MEMO_1ST_CLASS

#ifdef DUNGEON_ITEM

#ifdef SERV_CHUNG_TACTICAL_TROOPER		/// 택티컬 필드 추가
	if( m_DamageData.m_fHpPercentUp <= 0.f && m_DamageData.m_fMpPercentUp <= 0.f && bCheckRevenge == false &&
		m_DamageData.m_fIncreaseMP <= 0.f )	
#else  SERV_CHUNG_TACTICAL_TROOPER
	if( m_DamageData.m_fHpPercentUp <= 0.f && m_DamageData.m_fMpPercentUp <= 0.f && bCheckRevenge == false )	
#endif SERV_CHUNG_TACTICAL_TROOPER
#else
	if ( bCheckRevenge == false )
#endif	
	{

		if( NULL != m_pComboManager )
		{
			SetCurrentDamage( pDefenderUnit->GetFinalDamage( &m_DamageData ) );
			m_pComboManager->AddCombo();
		}

		DoDelegateProcessInAttackResult( m_DamageData );

#ifdef SERV_PET_SYSTEM
		CX2PET *pPet = g_pData->GetPetManager()->GetPet( GetUnitUID() );
		if( pPet != NULL )
		{ 
			pPet->AttackResult( m_DamageData.fHitAddMP );
		}
#endif
	}

	if( IsFocusUnit() == true )
	{

		switch( m_DamageData.m_eCameraShakeType )
		{
		case CKTDGCamera::DECT_UP:
			{
				// fix!! not yet!!

			} break;
		case CKTDGCamera::DECT_DOWN:
			{
				// fix!! not yet!!

			} break;
		case CKTDGCamera::DECT_UP_DOWN:
			{
				UpDownCrashCamera( m_DamageData.fCameraCrashGap, m_DamageData.fCameraCrashTime );

			} break;
		case CKTDGCamera::DECT_UP_DOWN_NO_RESET:
			{
				UpDownCrashCameraNoReset( m_DamageData.fCameraCrashGap, m_DamageData.fCameraCrashTime );
			} break;


		case CKTDGCamera::DECT_LEFT:
			{
				// fix!! not yet!!

			} break;

		case CKTDGCamera::DECT_RIGHT:
			{
				// fix!! not yet!!

			} break;

		case CKTDGCamera::DECT_LEFT_RIGHT:
			{
				ShakeLeftRight( m_DamageData.fCameraCrashGap, m_DamageData.fCameraCrashTime, 0.05f );
			} break;
		case CKTDGCamera::DECT_LEFT_RIGHT_NO_RESET:
			{
				LeftRightCrashCameraNoReset( m_DamageData.fCameraCrashGap, m_DamageData.fCameraCrashTime );
			} break;


		case CKTDGCamera::DECT_RANDOM:
			{
				// fix!! not yet!!
			} break;

		default:
			break;
		}



#ifdef CLEAR_SCREEN_ON_HIT
	#ifdef VERTICAL_SYNC_OPTION
		if ( false == g_pMain->GetGameOption().GetFlashEffect() )
		{
			g_pKTDXApp->GetDGManager()->ClearScreen( m_DamageData.clearScreen );
			g_pKTDXApp->GetDGManager()->SetClearScreenColor( m_DamageData.clearScreenColor );
		}
	#else
		g_pKTDXApp->GetDGManager()->ClearScreen( m_DamageData.clearScreen );
		g_pKTDXApp->GetDGManager()->SetClearScreenColor( m_DamageData.clearScreenColor );
	#endif
#endif // CLEAR_SCREEN_ON_HIT
	}




	switch( m_DamageData.reActType )
	{
	case CX2DamageManager::RT_CREATE_DAMAGE_EFFECT:
		{
			if( NULL != g_pX2Game &&
				NULL != g_pX2Game->GetDamageEffect() )
			{
				// fix!! damage effect이름과 powerrate를 입력 받을 수 있게
				g_pX2Game->GetDamageEffect()->CreateInstance( this, m_DamageData.m_wstrCreateDamageEffectName.c_str(),
					GetPowerRate(), m_DamageData.impactPoint, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );
			}
		} break;

	case CX2DamageManager::RT_CREATE_EFFECT_SET:
		{

			if( NULL != g_pX2Game )
			{
				CX2GameUnit* pTraceUnit = NULL;
				if( true == m_DamageData.m_bCreateEffectSetTraceUnit )
				{
					pTraceUnit = m_DamageData.optrDefenderGameUnit.GetObservable();
				}

#ifdef TRACE_UNIT_DIE_DELETE_EFFECTSET
				CX2EffectSet::Handle hEffectSet = g_pX2Game->GetEffectSet()->PlayEffectSet( m_DamageData.m_wstrCreateEffectSetName.c_str(), this, pTraceUnit, false, GetPowerRate() );
				if ( CX2EffectSet::EffectSetInstance* pInstance = g_pX2Game->GetEffectSet()->GetEffectSetInstance( hEffectSet ) )
				{
					pInstance->m_bTraceUnitDieDeleteEffectSet = m_DamageData.m_bTraceUnitDieDeleteEffectSet;
					pInstance->m_bCreateEffectSetTraceUnit = m_DamageData.m_bCreateEffectSetTraceUnit;
				}
#else //TRACE_UNIT_DIE_DELETE_EFFECTSET
				g_pX2Game->GetEffectSet()->PlayEffectSet( m_DamageData.m_wstrCreateEffectSetName.c_str(), this, pTraceUnit, false, GetPowerRate() );
#endif //TRACE_UNIT_DIE_DELETE_EFFECTSET
			}

		} break;

	default:
#ifdef SERV_ARME_DIMENSION_WITCH
		{			
			if( g_pX2Game != NULL && g_pX2Game->GetDamageEffect() != NULL &&
				( GetHitCreateDamageEffectRate() > 0.f && GetRandomFloat() <= GetHitCreateDamageEffectRate() ) || 
				( m_DamageData.m_fCreateDamageEffectRate > 0.f && GetRandomFloat() <= m_DamageData.m_fCreateDamageEffectRate ) )
			{
				g_pX2Game->GetDamageEffect()->CreateInstance( this, m_DamageData.m_wstrCreateDamageEffectName.c_str(),
					GetHitCreateDamageEffectPowerRate(), 
					m_DamageData.impactPoint, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );
			}						
		}		
#endif
		break;
	}

	if( NULL != g_pX2Game &&
		NULL != g_pX2Game->GetMajorParticle() )
	{
		switch( m_DamageData.reActResult )
		{
		case CX2DamageManager::RT_DUMMY_DAMAGE:
			break;

		default:
			{
				for( UINT i=0; i<m_DamageData.m_vecHitParticleName.size(); i++ )
				{
					CKTDGParticleSystem::CParticleEventSequence* pSeq = 
						g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  m_DamageData.m_vecHitParticleName[i].c_str(), m_DamageData.impactPoint );
					if( NULL != pSeq )
					{
						pSeq->SetLandPosition( GetLandPosition().y );
					}
				}
			} break;
		}
	}

	if ( CX2DamageManager::RT_DUMMY_DAMAGE != m_DamageData.reActResult && IsMyUnit() )
		SetHitCount( GetHitCount() + 1 );

	AttackResultPlayEffect();

#ifdef PVP_ZOOM_CAMERA
	SetSubZoomCameraTimer();
#endif

#if defined( _SERVICE_ ) 
	ELSWORD_VIRTUALIZER_END
#endif

	if( NULL != g_pX2Game && true == g_pX2Game->IsHost() )
	{
		if( m_fSummonNpcCoolTime <= 0.f )
		{
			for(UINT i=0; i<m_vecSummonNpcSocket.size(); ++i)
			{
				CX2GUUser::SummonNpcSocket tSummonNpc = m_vecSummonNpcSocket[i];
				if( GetRandomFloat(i) <= tSummonNpc.m_fSummonRate )
				{
					m_fSummonNpcCoolTime = tSummonNpc.m_fSummonNpcCoolTime;
					g_pX2Game->CreateNPCReq( tSummonNpc.m_iNpcId, GetUnitLevel(), true, GetPos(), 
						GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
					break;
				}
			}
		}	
	}

#ifdef SERV_NEW_DEFENCE_DUNGEON // 적용날짜: 2013-04-14
	/// 일반 공격 타격시 이펙트 셋 생성하는 함수 검사
	PlayEffectSetNormalAttackByBuff( m_DamageData.attackType );
#endif // SERV_NEW_DEFENCE_DUNGEON

}

/** @function : AttackResultPlayEffect
	@brief : 데미지 데이터의 reActResult 타입에 따라 다른 이펙트를 보여주는 함수\n
	각 캐릭터 클래스의 AttackResult를 공통으로 묶어서 이곳으로 옮김
	@param : void
	@return : void
*/
/*virtual*/ void CX2GUUser::AttackResultPlayEffect()
{
	// 기존의 각 캐릭터의 AttackResult에 있었을 때는 VIRTUALIZER를 해주었으나
	// 데미지와 관련된 부분이 아니기 때문에 할 필요 없음

	// ASSERT 처리는 하지만, Release에서 체크는 안함( 상위 함수의 NULL 처리에서 pDefenderUnit이 NULL이면 AttackResult()가 호출될 수 없음 )
	CX2GameUnit *pDefender = m_DamageData.optrDefenderGameUnit.GetObservable();
	ASSERT( NULL != pDefender );
	if ( NULL == pDefender )
		return;
	switch ( m_DamageData.reActResult )
	{
	case CX2DamageManager::RT_REVENGE:
		{
#ifdef X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
			if( g_pMain->GetGameOption().GetOptionList().m_eEffect == CX2GameOption::OL_HIGH ||	IsMyUnit() == true || pDefender->IsMyUnit() == true )
#endif//X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
            {
			    PlayRevengeReactTypeParticle( m_DamageData.impactPoint );
            }

			g_pX2Game->GetWorld()->SetWorldColor( 0xff000000 );
			g_pX2Game->GetWorld()->FadeWorldColor( g_pX2Game->GetWorld()->GetOriginColor(), 1.0f );

			AttackResultStateChange( USI_DAMAGE_REVENGE );
		} break;

	case CX2DamageManager::RT_DUMMY_DAMAGE:
	case CX2DamageManager::RT_GRAPPLE:
	case CX2DamageManager::RT_THROW:
#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE	  // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
	case CX2DamageManager::RT_FLIP_DIFF_DIR :
	case CX2DamageManager::RT_FLIP_DIFF_DIR_DUMMY_DAMAGE :
#endif // SERV_ELESIS_SECOND_CLASS_CHANGE // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
		break;

	case CX2DamageManager::RT_SMALL_DAMAGE:
//{{ kimhc // 2011.1.8 // 청 1차 전직
#ifdef	CHUNG_FIRST_CLASS_CHANGE
	case CX2DamageManager::RT_FLIP_SAME_DIR:
#endif	CHUNG_FIRST_CLASS_CHANGE
//}} kimhc // 2011.1.8 // 청 1차 전직
		{
#ifdef X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
			if( g_pMain->GetGameOption().GetOptionList().m_eEffect == CX2GameOption::OL_HIGH ||	IsMyUnit() == true || pDefender->IsMyUnit() == true )
#endif//X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
			{
				PlaySmallDamageReactTypeParticle( m_DamageData.impactPoint );
				PlayEffectSetImpactPointByBuff();
			}
		} break;

#ifdef GRAPPLING_TEST
	case CX2DamageManager::RT_GRAPPLE:
		break;

	case CX2DamageManager::RT_THROW:
		{
			ResetGrapplingState();
		} break;
#endif GRAPPLING_TEST

	default:
		{
#ifdef X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
			if( g_pMain->GetGameOption().GetOptionList().m_eEffect == CX2GameOption::OL_HIGH ||	IsMyUnit() == true || pDefender->IsMyUnit() == true )
#endif//X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
			{
				PlayEtcReactTypeParticle( m_DamageData.impactPoint );
				PlayEffectSetImpactPointByBuff();
			}
		} break;
	}
}

#ifdef UPGRADE_RAVEN
void CX2GUUser::AttackResultByType( CX2DamageManager::DamageData &pDamageData )
{
	return;
}
#endif

/** @function : PlayRevengeReactTypeParticle
@brief : 반격에 당한 경우 보여주는 파티클
@param : vImpactPoint_( 파티클 출력 위치의 레퍼런스)
@return : void
*/
void CX2GUUser::PlayRevengeReactTypeParticle( const D3DXVECTOR3& vImpactPoint_ )
{
	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();

	CKTDGParticleSystem::CParticleEventSequence* pSeqRevengeImpactSlashCW	= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_REVENGE_IMPACT_SLASH_CW ) );
	PlaySequenceByTriggerCount( pSeqRevengeImpactSlashCW,	m_DamageData.impactPoint, 50,50, 3 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqRevengeImpactSlashCCW	= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_REVENGE_IMPACT_SLASH_CCW ) );
	PlaySequenceByTriggerCount( pSeqRevengeImpactSlashCCW,	m_DamageData.impactPoint, 50,50, 3 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqRevengeImpact			= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_REVENGE_IMPACT ) );
	PlaySequenceByTriggerCount( pSeqRevengeImpact,			m_DamageData.impactPoint, 50,50, 1 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqRevengeImpactTick		= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_REVENGE_IMPACT_TICK ) );
	PlaySequenceByTriggerCount( pSeqRevengeImpactTick,		m_DamageData.impactPoint, 200, 200, 20 );

	if( pSeqRevengeImpactTick != NULL )
		pSeqRevengeImpactTick->SetLandPosition( m_FrameDataNow.unitCondition.landPosition.y );

}

/** @function : PlaySmallDamageReactTypeParticle
@brief : 스몰공격에 당한 경우 보여주는 파티클
@param : vImpactPoint_( 파티클 출력 위치의 레퍼런스)
@return : void
*/
void CX2GUUser::PlaySmallDamageReactTypeParticle( const D3DXVECTOR3& vImpactPoint_ )
{
	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();

	CKTDGParticleSystem::CParticleEventSequence* pSeqDamageImpact		= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT ) );
	PlaySequenceByTriggerCount( pSeqDamageImpact,		m_DamageData.impactPoint, 100,200, 10 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqDamageImpactCore	= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_CORE )  );
	PlaySequenceByTriggerCount( pSeqDamageImpactCore,	m_DamageData.impactPoint, 100,200, 10 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqDamageImpactSlash	= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_SLASH )  );
	PlaySequenceByTriggerCount( pSeqDamageImpactSlash,	m_DamageData.impactPoint, 50,50, 2 );
}

/** @function : PlayEtcReactTypeParticle
@brief : 반격, 스몰, 그외에 파티클을 보여주지 않는 경우를 제외한 경우에 보여주는 파티클
@param : vImpactPoint_( 파티클 출력 위치의 레퍼런스)
@return : void
*/
void CX2GUUser::PlayEtcReactTypeParticle( const D3DXVECTOR3& vImpactPoint_ )
{
	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();

	CKTDGParticleSystem::CParticleEventSequence* pSeqDamageImpactRed		= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_RED ) );	
	PlaySequenceByTriggerCount( pSeqDamageImpactRed, 			m_DamageData.impactPoint, 100,200, 10 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqDamageImpactRingRed	= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_RING_RED ) );
	PlaySequenceByTriggerCount( pSeqDamageImpactRingRed, 		m_DamageData.impactPoint, 100,200, 1 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqDamageImpactCoreRed	= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_CORE_RED ) );
	PlaySequenceByTriggerCount( pSeqDamageImpactCoreRed, 		m_DamageData.impactPoint, 100,100, 1 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqDamageImpactSlashRed	= pMajorParticleSystem->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_SLASH_RED ) );
	PlaySequenceByTriggerCount( pSeqDamageImpactSlashRed,		m_DamageData.impactPoint, 50,50, 1 );
}

#ifdef ATTACK_DELAY_GAGE
//{{AFX
void CX2GUUser::AddAttackDelay( float fDelay )
{
	m_fLastAttackPassTime = 0.0f;
	if( m_bAddAttackDelayThisState == false && g_pX2Game->GetGameType() == CX2Game::GT_PVP )
	{
		GetGageData()->AddAttackDelay( fDelay );
		m_bAddAttackDelayThisState = true;
	}
}
//}}AFX
#endif ATTACK_DELAY_GAGE


void CX2GUUser::AddForceDownDelay( float fDelay )
{	
#ifdef BALANCE_PATCH_20110303
	if( g_pX2Game->GetGameType() == CX2Game::GT_PVP )
	{
		if( m_bAddForceDownGageThisState == false )
		{
			m_fMaxDownForce = fDelay;
			m_bAddForceDownGageThisState = true;
		}
		else
		{
			m_fMaxDownForce = max(m_fMaxDownForce, fDelay);
		}
	}	
#else //BALANCE_PATCH_20110303
	m_fLastDamagePassTime = 0.0f;
	if( m_bAddForceDownGageThisState == false && g_pX2Game->GetGameType() == CX2Game::GT_PVP )
	{
		GetGageData()->AddForceDownGage( fDelay );
		m_bAddForceDownGageThisState = true;
	}
#endif //BALANCE_PATCH_20110303
}

void CX2GUUser::AttackResultStateChange( int damageRevenge )
{
	if( IsMyUnit() == false )
		return;

	StateChange( damageRevenge, true );
}

void CX2GUUser::Win()
{
	if( IsMyUnit() == true )
	{
		g_pX2Game->GetMajorParticle()->CreateSequence( NULL,  L"GameWin", 0,0,0, 1000, 1000, 1, 1 );
		g_pKTDXApp->GetDeviceManager()->PlaySound( L"Win.ogg", false, false );
	}
}

void CX2GUUser::Lose()
{
#ifdef GATE_DUNGEON
	if( NULL != g_pX2Game && CX2Game::GT_DUNGEON == g_pX2Game->GetGameType() )
	{
		CX2DungeonGame* pDungeonGame = static_cast<CX2DungeonGame*>(g_pX2Game);
		if( NULL != pDungeonGame &&
			NULL != pDungeonGame->GetDungeon &&
			NULL != pDungeonGame->GetDungeon->GetDungeonData &&
			pDungeonGame->GetDungeon()->GetDungeonData()->m_bShowClearText == false )
			return;
	}
#endif

	if( IsMyUnit() == true )
	{		
		switch( g_pX2Room->GetRoomType() )
		{
		case CX2Room::RT_PVP:
			{
				g_pX2Game->GetMajorParticle()->CreateSequence( NULL,  L"GameLose", 0,0,0, 1000, 1000, 1, 1 );
				g_pKTDXApp->GetDeviceManager()->PlaySound( L"Lose.ogg", false, false );

			} break;

		case CX2Room::RT_DUNGEON:
		case CX2Room::RT_TRAININGCENTER:
			{
				g_pX2Game->GetMajorParticle()->CreateSequence( NULL,  L"GameFail", 0,0,0, 1000, 1000, 1, 1 );
				g_pKTDXApp->GetDeviceManager()->PlaySound( L"Lose.ogg", false, false );

			} break;
		}
	}
}


void CX2GUUser::Draw()
{
	if( IsMyUnit() == true )
	{
		g_pX2Game->GetMajorParticle()->CreateSequence( NULL,  L"GameDraw", 0,0,0, 1000, 1000, 1, 1 );
		//g_pKTDXApp->GetDeviceManager()->PlaySound( L"Win.ogg" );
	}
}

D3DXVECTOR3 CX2GUUser::GetHeadBonePos() const
{
	D3DXVECTOR3 tempPos;
	GetFramePos( &tempPos, m_pFrame_Bip01_Head );
	tempPos.y += 70.0f;

	return tempPos; 
}

//{{ kimhc // 2011.1.17 // 지정한 Bone의 메트릭스 값을 Trace 함 (chung 코드 참고)
/** @function : GetCombineMatrixFromBoneName
	@brief : 본 이름에 해당하는 CombineMatrix값을 얻어옴
	@param : const wstring& wstrBoneName
	@return : const D3DXMATRIX*
*/
/*virtual*/ const D3DXMATRIX*	CX2GUUser::GetCombineMatrixFromBoneName( const wstring& wstrBoneName ) const
{
	if ( true == wstrBoneName.empty() )
	{
		return NULL;
	} // if

#ifdef EFFECT_TOOL
	if( NULL != m_pXSkinAnim_EffectTool )
	{
		CKTDXDeviceXSkinMesh::MultiAnimFrame* pMultiAnimFrame = m_pXSkinAnim_EffectTool->GetCloneFrame( wstrBoneName.c_str() );
		if ( NULL != pMultiAnimFrame )
		{
			return &(pMultiAnimFrame->combineMatrix);	
		} // if
	}
#endif //EFFECT_TOOL

	CKTDXDeviceXSkinMesh::MultiAnimFrame* pMultiAnimFrame = m_pXSkinAnim->GetCloneFrame( wstrBoneName.c_str() );
	if ( NULL == pMultiAnimFrame )
	{
		return NULL;
	} // if

	return &(pMultiAnimFrame->combineMatrix);	
}
//}} kimhc // 2011.1.17 // 지정한 Bone의 메트릭스 값을 Trace 함 (chung 코드 참고)

//{{ robobeg : 2008-10-21
//void CX2GUUser::SetShow( bool bShow )
/*virtual*/
void CX2GUUser::NotifyShowObjectChanged()
//}} robobeg : 2008-10-21
{
	//{{ robobeg : 2008-10-21
	//CX2GameUnit::SetShow( bShow );

	bool bShow = GetShowObject();

	CX2GameUnit::NotifyShowObjectChanged();

	//}} robobeg : 2008-10-21

	if( m_pUnitShadow != NULL )
		m_pUnitShadow->SetShowObject( bShow );


	//{{ kimhc // 2010.6.16 // 손에 붙는 무기이펙트 뿐만이 아니라 무기에 붙는 이펙트 까지 이곳에서 SetShow 해줌
#ifdef	ENCHANT_BUG_TEST
	SetShowEnchantWeaponParticle( bShow );
#else	ENCHANT_BUG_TEST
	SetShowEnchantedWeaponEffectAtHand( bShow );
#endif	ENCHANT_BUG_TEST
	//}} kimhc // 2010.6.16 // 손에 붙는 무기이펙트 뿐만이 아니라 무기에 붙는 이펙트 까지 이곳에서 SetShow 해줌
	


	CKTDGParticleSystem::CParticleEventSequence* pSeqHeadMarker    = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqHeadMarker );
//#ifdef TITLE_SYSTEM
	CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem		   = g_pData->GetUIMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
//#else
//	CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem		   = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
//#endif TITLE_SYSTEM


#ifdef  X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
	CKTDGParticleSystem::CParticleEventSequence* pSeqHoldCenter   = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hHoldEffCenter );
	CKTDGParticleSystem::CParticleEventSequence* pSeqHoldCircle   = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hHoldEffCircle );
#else   X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
	CKTDGParticleSystem::CParticleEventSequence* pSeqHoldCenter   = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHoldEffCenter );
	CKTDGParticleSystem::CParticleEventSequence* pSeqHoldCircle   = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHoldEffCircle );
#endif  X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX


	if( pSeqHeadMarker != NULL )
		pSeqHeadMarker->SetShowObject( bShow );

	if( pSeqEmblem != NULL )
		pSeqEmblem->SetShowObject( bShow );

	if( pSeqHoldCenter != NULL )
		pSeqHoldCenter->SetShowObject( bShow );
	if( pSeqHoldCircle != NULL )
		pSeqHoldCircle->SetShowObject( bShow );

	if( false == bShow )
		DisableAfterImage( true );

	BOOST_TEST_FOREACH( CX2EqipPtr, pEqip, m_ViewEqipList )
	{
		if ( pEqip != NULL )
			pEqip->NotifyShowObjectChanged();

	}//BOOST_TEST_FOREACH()


#ifdef SERV_PET_SYSTEM
	if( g_pData != NULL && g_pData->GetPetManager() != NULL )
	{
		g_pData->GetPetManager()->NotifyShowObjectChanged( GetUnitUID(), bShow );
	}
#endif

}
//CX2GUUser::SetShowObject()


// CX2GUUser 가 KTDGManager 에 등록, 삭제될 때 장착 부품들도 같이 등록, 삭제하기 위해 사용됨
/*virtual*/
void CX2GUUser::NotifyDGManagerChanged( CKTDGManager& refInManager_ )
{
	if ( IsRecursivelyManagedByDGManager() )
	{
		BOOST_TEST_FOREACH( CX2EqipPtr, pEqip, m_ViewEqipList )
		{
			if ( pEqip != NULL )
				refInManager_.AddObjectChain( pEqip.get() );
		}//BOOST_TEST_FOREACH()
	}
	else
	{
		BOOST_TEST_FOREACH( CX2EqipPtr, pEqip, m_ViewEqipList )
		{
			if ( pEqip != NULL )
				refInManager_.RemoveObjectChain( pEqip.get() );
		}//BOOST_TEST_FOREACH()
	}//if.. else..
}//CX2GUUser::NotifyDGManagerChanged()
//}} robobeg : 2008-10-17




bool CX2GUUser::IsMyUnit() const
{
	if( NULL != g_pX2Game && 
		g_pX2Game->GetMyUnit() == this )
		return true;
	else
		return false;
}

bool CX2GUUser::IsLocalUnit() const
{
	return IsMyUnit();
}

bool CX2GUUser::IsFocusUnit() const
{
	if( g_pX2Game->GetFocusUnit() == this )
		return true;
	else
		return false;
}

const CX2GUUser::SyncData& CX2GUUser::GetSyncData( bool bFuture ) const
{
	KTDXPROFILE();
	if( bFuture == true )
	{
		if( IsMyUnit() == true )
		{
			return m_FrameDataFuture.syncData;
		}
		else
		{
			if( m_ReceiveSyncDataList.empty() == true )
			{
				return m_FrameDataNow.syncData;
			}
			else
			{
				return m_ReceiveSyncDataList.back();
			}
		}
	}
	else
	{
		return m_FrameDataNow.syncData;
	}
}

const CX2GUUser::FrameData& CX2GUUser::GetFrameData( bool bFuture ) const
{
	KTDXPROFILE();
	if( bFuture == true )
	{
		if( IsMyUnit() == true )
		{
			return m_FrameDataFuture;
		}
		else
		{
			return m_FrameDataNow;
		}
	}
	else
	{
		return m_FrameDataNow;
	}
}

void CX2GUUser::ClearRecieveSyncData()
{
	m_SendSyncDataList.resize(0);
	m_ReceiveSyncDataList.resize(0);
//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
    m_LastSendSyncDataList.resize(0);
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
}

void CX2GUUser::DyingStart()
{
	if( m_bDyingStart  == true )
		return;

#ifdef RIDING_SYSTEM
	if ( true == GetRidingOn() && NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimPtr() )
	{
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_DyingState );
		m_ptrRidingPet->GetXSkinAnimPtr()->SetPlaySpeed( 0.5f );
		m_bPassDash = false;
	}
#endif //RIDING_SYSTEM

	CX2GameUnit::DyingStart();

	g_pX2Game->SetEnableAllKeyProcess( true );


	if( CX2Main::XS_TRAINING_GAME != g_pMain->GetNowStateID() )
	{
		if( IsMyUnit() == true )
		{
			//서버로 유닛 사망 데이터를 보낸다

			KEGS_USER_UNIT_DIE_REQ kPacket;

			//Init
			kPacket.m_KillerNPCUID = -1;
			kPacket.m_KillerUserUnitUID = -1;

#ifdef SERV_ADD_TITLE_CONDITION
			kPacket.m_ucDieReason = m_ucDieReason;
#endif

			if( GetAttackedByUserUnit() == true )
			{
                CX2GameUnit* pAttackerGameUnit = GetGameUnitWhoAttackedMe();
				if ( pAttackerGameUnit != NULL
#ifdef  X2OPTIMIZE_UNITTYPE_BUG_FIX
                    && pAttackerGameUnit->GetGameUnitType() == CX2GameUnit::GUT_USER
#endif  X2OPTIMIZE_UNITTYPE_BUG_FIX
                    )
				{
					
					kPacket.m_KillerUserUnitUID = pAttackerGameUnit->GetUnitUID();
					pAttackerGameUnit->DoProcessWhenKillEnemy( this );
				}
                else
                {
				    kPacket.m_KillerUserUnitUID = -1;
                }
			}
			else
			{
				// PVP 게임에서 유저의 소환 몬스터에 의해 유저가 죽은 경우, User가 죽인 것으로 처리해줘야 한다.
				if( NULL != g_pX2Game )
				{
#ifdef  X2OPTIMIZE_UNITTYPE_BUG_FIX
                    CX2GameUnit* pAttacker = GetGameUnitWhoAttackedMe();
                    CX2GUNPC* pNPC = ( pAttacker != NULL && pAttacker->GetGameUnitType() == CX2GameUnit::GUT_NPC )
                        ? static_cast<CX2GUNPC*>( pAttacker ) : NULL;
#else   X2OPTIMIZE_UNITTYPE_BUG_FIX
					CX2GUNPC* pNPC = static_cast<CX2GUNPC*>( GetGameUnitWhoAttackedMe() );
#endif  X2OPTIMIZE_UNITTYPE_BUG_FIX

#ifdef SERV_PVP_NEW_SYSTEM
					if( NULL != pNPC && g_pX2Room->IsNpcSlot( pNPC->GetUnitUID() ) == true )
					{
						kPacket.m_KillerNPCUID = -1;
						kPacket.m_KillerUserUnitUID = pNPC->GetUnitUID();
					}
					else
					{
						if( NULL != pNPC &&
							NULL != pNPC->GetNPCAI() )
						{
							switch( pNPC->GetNPCAI()->GetAIType() )
							{
							case CX2NPCAI::NAT_ALLY:
								{
									CX2AllyNPCAI* pNPCAI = (CX2AllyNPCAI*) pNPC->GetNPCAI();
									kPacket.m_KillerUserUnitUID = pNPCAI->GetAllyUnitUID();
								} break;
							}
							kPacket.m_KillerNPCUID = static_cast<int>( pNPC->GetUnitUID() );
						}
						else
							kPacket.m_KillerNPCUID = -1;
						
					}
#else
					if( NULL != pNPC &&
						NULL != pNPC->GetNPCAI() )
					{
						switch( pNPC->GetNPCAI()->GetAIType() )
						{
						case CX2NPCAI::NAT_ALLY:
							{
								CX2AllyNPCAI* pNPCAI = (CX2AllyNPCAI*) pNPC->GetNPCAI();
								kPacket.m_KillerUserUnitUID = pNPCAI->GetAllyUnitUID();
							} break;
						}
					}
#endif				
				}				
			}


			kPacket.m_MaxDamageKillerUserUnitUID = GetGameUnitUIDMaxDamage();

			g_pData->GetServerProtocol()->SendPacket( EGS_USER_UNIT_DIE_REQ, kPacket );
			g_pMain->AddServerPacket( EGS_USER_UNIT_DIE_ACK );

#ifdef EVE_ELECTRA
			if( IsMyUnit() == true )
			{
				if ( m_hSeqWhiteOut != INVALID_PARTICLE_SEQUENCE_HANDLE )
				{
					g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqWhiteOut );
					g_pX2Game->GetMajorParticle()->CreateSequenceHandle( NULL,  L"WhiteOutExtraDamageEnd", D3DXVECTOR3(0,0,0) );
				}
			}
			m_bWhiteOut = false;
#endif EVE_ELECTRA
		}

		//{{ kimhc // 2009-12-28 // 길드스킬 3라인 
#ifdef	GUILD_SKILL_PART_2
		// 끝없는 체력, 죽으면 이펙트 삭제 및 스킬 데이타 초기화
		if ( m_GuildSkillData.m_InfiniteStrength.m_hSeqEffect != INVALID_PARTICLE_SEQUENCE_HANDLE )
				g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_GuildSkillData.m_InfiniteStrength.m_hSeqEffect );
			m_GuildSkillData.m_InfiniteStrength.Init();
#endif	GUILD_SKILL_PART_2
		//}} kimhc // 2009-12-28 // 길드스킬 3라인

		//{{ kimhc // 2010.6.15 // 서바이벌 모드 혹은 데스매치 플레이 중 킬을 한 유저의 컴퓨터에서만 부활한 상대방 속성인챈트가 보이지 않는 오류
#ifdef	ENCHANT_BUG_TEST
		SetShowEnchantWeaponParticle( false );
#endif	ENCHANT_BUG_TEST
		//}} kimhc // 2010.6.15 // 서바이벌 모드 혹은 데스매치 플레이 중 킬을 한 유저의 컴퓨터에서만 부활한 상대방 속성인챈트가 보이지 않는 오류

#ifdef SERV_PET_SYSTEM
		++m_iDieCount;
#endif

		//{{ kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트
#ifdef	SERV_TOONILAND_CHANNELING_EVENT
		SetShowTooniLandEventEffectSet( false );
#endif	SERV_TOONILAND_CHANNELING_EVENT
		//}} kimhc // 2011-08-08 // 투니 랜드 채널링 이벤트
	}
#ifdef SERV_RENA_NIGHT_WATCHER
	ClearStartOfDelayedFiringData();		/// 사망시 지연의 신호탄 적용 정보 삭제
#endif SERV_RENA_NIGHT_WATCHER
}

void CX2GUUser::CommonStateStartFuture()
{
	KTDXPROFILE();

	int index = 0;
	// fix!! 죽고 스테이지 넘어가는 경우에 wait상태에서 현재 HP가 0이 될 수 있다, 다른 방법으로 해킹을 막자
	//if( m_FrameDataFuture.syncData.nowState == m_CommonState.m_Wait && GetGageManager()->GetNowHp() <= 0.0f )
	//	g_pKTDXApp->SetFindHacking( true );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    ClearAnimEventTimerOneshotFuture();
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_EventTimeStampFuture.clear();
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

	m_FrameDataFuture.unitCondition.fStateTimeBack	= 0.0f;
	m_FrameDataFuture.unitCondition.fStateTime		= 0.0f;

	m_FrameDataFuture.stateParam.bLandConnect		= true;
	m_FrameDataFuture.stateParam.bCanPushUnit		= true;
	m_FrameDataFuture.stateParam.bCanPassUnit		= false;
    
#ifdef ATTACK_DELAY_GAGE
//{{AFX
	m_bAddAttackDelayThisState						= false;
//}}AFX
#endif ATTACK_DELAY_GAGE
	if( -9999.f != m_fMaxDownForce )
		m_bAddForceDownGageThisState				= false;

	m_FrameDataFuture.unitCondition.bHit			= false;


	ZeroMemory( m_FrameDataFuture.stateParam.bEventFlagList, sizeof(bool) * EVENT_FLAG_LIST_NUM );


	wstring animName;
	LUA_GET_VALUE( m_LuaManager, "ANIM_NAME", animName, L"" );

#ifdef SERV_9TH_NEW_CHARACTER // 김태환
	SetCustomAnimName( m_FutureStateData, animName );		/// 특정 상태일 때, 애니메이션을 바꾸는 함수
#endif //SERV_9TH_NEW_CHARACTER

#ifdef RIDING_SYSTEM
	wstring ridingAnimName;
	LUA_GET_VALUE( m_LuaManager, "RIDING_ANIM_NAME", ridingAnimName, L"" );

	if ( true == GetRidingOn() && false == ridingAnimName.empty() )
		animName = ridingAnimName;
#endif //RIDING_SYSTEM
#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( true == animName.empty() )
	{
		int iRandomPercent = GetRandomIntFuture();
		ParseAnimNameFromList( animName, iRandomPercent );
	}
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

	CKTDGXSkinAnim::XSKIN_ANIM_PLAYTYPE playType;
	LUA_GET_VALUE_ENUM ( m_LuaManager, "PLAY_TYPE", playType, CKTDGXSkinAnim::XSKIN_ANIM_PLAYTYPE, CKTDGXSkinAnim::XAP_ONE_WAIT );
	bool bTransition = true;
	LUA_GET_VALUE( m_LuaManager, "TRANSITION", bTransition, true );
	float fStartTime = 0.0f;
	LUA_GET_VALUE( m_LuaManager, "ANIM_START_TIME", fStartTime, 0.0f );
	
	bool bAnimationChanged = false;

	if( m_FrameDataFuture.unitCondition.bTransitionChange == false || bTransition == false || m_FrameDataFuture.syncData.bDirectChange == true )
		bAnimationChanged = m_pXSkinAnimFuture->ChangeAnim( animName.c_str(), false, fStartTime );
	else
		bAnimationChanged = m_pXSkinAnimFuture->ChangeAnim( animName.c_str(), true, fStartTime );

	if ( true == bAnimationChanged )
		m_pXSkinAnimFuture->Play( playType );
// 	else
// 	{
// 		ASSERT(!"NOT GOOD");
// 	}


#ifdef	ADD_ANIM_SPEED_FUTURE
	LUA_GET_VALUE( m_LuaManager, "ANIM_SPEED", m_fAnimSpeedFuture, 1.f );
#else	ADD_ANIM_SPEED_FUTURE
	LUA_GET_VALUE( m_LuaManager, "ANIM_SPEED", m_fAnimSpeed, 1.f );
#endif // ADD_ANIM_SPEED_FUTURE
	
	// 아이템의 애니메이션 속도 증가 옵션에 영향을 받지 않는 상태인지
	bool bApplyAnimSpeedByItemAbility = true;
	LUA_GET_VALUE( m_LuaManager, "APPLY_ANIM_SPEED_BY_ITEM_ABILITY",	bApplyAnimSpeedByItemAbility,	true );

#ifdef	ADD_ANIM_SPEED_FUTURE

#ifdef CHUNG_FIRST_CLASS_CHANGE
	if ( true == bApplyAnimSpeedByItemAbility )
	{
		m_fAnimSpeedFuture += GetAddAnimSpeedFactor();
	} // if
#endif

	ResetAnimSpeed( m_fAnimSpeedFuture, bApplyAnimSpeedByItemAbility, true );

#else	ADD_ANIM_SPEED_FUTURE
	
#ifdef CHUNG_FIRST_CLASS_CHANGE
	if ( true == bApplyAnimSpeedByItemAbility )
	{
		m_fAnimSpeed += GetAddAnimSpeedFactor();
	} // if
#endif

	ResetAnimSpeed( m_fAnimSpeed, bApplyAnimSpeedByItemAbility, true );
#endif // ADD_ANIM_SPEED_FUTURE

	LUA_GET_VALUE( m_LuaManager, "LAND_CONNECT",	m_FrameDataFuture.stateParam.bLandConnect,	true );
	bool bCanPushUnit = true;
	LUA_GET_VALUE( m_LuaManager, "CAN_PUSH_UNIT",	bCanPushUnit,	true );
	m_FrameDataFuture.stateParam.bCanPushUnit = bCanPushUnit;
	bool bCanPassUnit = false;
	LUA_GET_VALUE( m_LuaManager, "CAN_PASS_UNIT",	bCanPassUnit,	false );
	m_FrameDataFuture.stateParam.bCanPassUnit = bCanPassUnit;

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    LUA_GET_VALUE( m_LuaManager, "APPLY_ANIM_MOVE", m_bFutureApplyAnimMove, true );
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	LUA_GET_VALUE( m_LuaManager, "APPLY_ANIM_MOVE", m_FrameDataFuture.stateParam.bApplyAnimMove, true );
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

#ifdef RAVEN_SECOND_CLASS_CHANGE	
	index = 0;
	m_vecCanPushUnit.clear();
	while( m_LuaManager.BeginTable( "CAN_PUSH_UNIT_TIME", index ) == true )
	{
		TIME_PUSHPASS canPushUnitTime;

		LUA_GET_VALUE( m_LuaManager, 1, canPushUnitTime.fTime , 0.0f );
		LUA_GET_VALUE( m_LuaManager, 2, canPushUnitTime.bCan, true );

		m_vecCanPushUnit.push_back(canPushUnitTime);
		index++;
		m_LuaManager.EndTable();
	}

	index = 0;
	m_vecCanPassUnit.clear();
	while( m_LuaManager.BeginTable( "CAN_PASS_UNIT_TIME", index ) == true )
	{
		TIME_PUSHPASS canPassUnitTime;

		LUA_GET_VALUE( m_LuaManager, 1, canPassUnitTime.fTime, 0.0f );
		LUA_GET_VALUE( m_LuaManager, 2, canPassUnitTime.bCan, false );

		m_vecCanPassUnit.push_back(canPassUnitTime);
		index++;
		m_LuaManager.EndTable();
	}

#endif



	D3DXVECTOR3 speed;
	if( m_LuaManager.GetValue( "SPEED_X", speed.x ) == true )
		m_PhysicParam.nowSpeed.x = speed.x;
	if( m_LuaManager.GetValue( "SPEED_Y", speed.y ) == true )
		m_PhysicParam.nowSpeed.y = speed.y;
	
	index = 0;
	m_vecSpeedFactor.clear();
	while( m_LuaManager.BeginTable( "SPEED_TIME", index ) == true )
	{
		TIME_SPEED timeSpeed;
		
		LUA_GET_VALUE( m_LuaManager, 1, timeSpeed.vSpeed.x, 0.0f );		/// X축 속도
		LUA_GET_VALUE( m_LuaManager, 2, timeSpeed.vSpeed.y, 0.0f );		/// Y축 속도
		LUA_GET_VALUE( m_LuaManager, 3, timeSpeed.vSpeed.z, -1.0f );	/// 적용될 애니메이션 타임
		LUA_GET_VALUE( m_LuaManager, 4, timeSpeed.iFlag, 0 );			/// m_PhysicParam.nowSpeed, 1이면 +=, 2이면 = 연산을 수행함, 3이면 패시브 스피드 값 변경

		m_vecSpeedFactor.push_back(timeSpeed);
		index++;
		m_LuaManager.EndTable();
	}


	LUA_GET_VALUE( m_LuaManager, "PASSIVE_SPEED_X", m_PhysicParam.passiveSpeed.x, -1.0f );
	LUA_GET_VALUE( m_LuaManager, "PASSIVE_SPEED_Y", m_PhysicParam.passiveSpeed.y, -1.0f );



	LUA_GET_VALUE( m_LuaManager, "DISABLE_GRAVITY_TIME_START", m_vDisableGravityInScriptTime.x, 0.f );
	LUA_GET_VALUE( m_LuaManager, "DISABLE_GRAVITY_TIME_END", m_vDisableGravityInScriptTime.y, 0.f );
	ASSERT( m_vDisableGravityInScriptTime.x <= m_vDisableGravityInScriptTime.y );

#ifdef  AISHA_SECOND_CLASS_CHANGE
	LUA_GET_VALUE( m_LuaManager, "IGNORE_LINE_TIME_START", m_vFutureIgnoreLineTime.x, 0.f );
	LUA_GET_VALUE( m_LuaManager, "IGNORE_LINE_TIME_END", m_vFutureIgnoreLineTime.y, 0.f );
	ASSERT( m_vFutureIgnoreLineTime.x <= m_vFutureIgnoreLineTime.y );
#endif  AISHA_SECOND_CLASS_CHANGE
	


	bool bIsRight;
	if( m_LuaManager.GetValue( "RIGHT", bIsRight ) == true )
		m_FrameDataFuture.syncData.bIsRight = bIsRight;

#ifdef SERV_ARA_CHANGE_CLASS_SECOND // 김태환

	/// 해당 스테이트에서만 정면을 보고, 스테이트가 끝나면 원래 방향으로 돌아봄
	LUA_GET_VALUE( m_LuaManager, "RIGHT_AT_THIS_STATE", m_bRightAtThisState, false );

	/// 방향이 뒤를 보고 있을때만 해당 기능을 적용 시킨다. StataEndFuture에서 방향을 원래대로 돌려준다.
	if ( m_FrameDataFuture.syncData.bIsRight == false && true == m_bRightAtThisState )
		m_FrameDataFuture.syncData.bIsRight = true;
	else
		m_bRightAtThisState = false;

#endif // SERV_ARA_CHANGE_CLASS_SECOND

	index = 0;
	m_StopAllList.clear();
	while( m_LuaManager.BeginTable( "STOP_ALL_UNIT", index ) == true )
	{
		D3DXVECTOR3 stopTime;
		LUA_GET_VALUE( m_LuaManager, 1, stopTime.x, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 2, stopTime.y, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 3, stopTime.z, -1.0f );
		if( stopTime.x != -1.0f )
		{
			if( stopTime.x <= g_pKTDXApp->GetElapsedTime() )
			{
				switch ( g_pX2Game->GetGameType() )
				{
				case CX2Game::GT_DUNGEON:
				case CX2Game::GT_BATTLE_FIELD:
					g_pX2Game->StopAllUnit( stopTime.y / 2.0f, &m_FrameDataFuture.syncData.position, 800.0f, this, stopTime.z );
					g_pX2Game->StopAllUnit( stopTime.y, &m_FrameDataFuture.syncData.position, 700.0f, this, stopTime.z );
					break;

				case CX2Game::GT_PVP:
					g_pX2Game->StopAllUnit( stopTime.y / 2.0f, &m_FrameDataFuture.syncData.position, 2000.0f, this, stopTime.z );
					g_pX2Game->StopAllUnit( stopTime.y, &m_FrameDataFuture.syncData.position, 1300.0f, this, stopTime.z );
					break;

				default:
					ASSERT( !L"wrong path" );
					break;
				}
			}
			else
				m_StopAllList.push_back( stopTime );
		}

		index++;
		m_LuaManager.EndTable();
	}

	index = 0;
	m_Stop2AllList.clear();
	while( m_LuaManager.BeginTable( "STOP2_ALL_UNIT", index ) == true )
	{
		D3DXVECTOR3 stopTime;
		LUA_GET_VALUE( m_LuaManager, 1, stopTime.x, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 2, stopTime.y, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 3, stopTime.z, -1.0f );
		if( stopTime.x != -1.0f )
		{
			if( stopTime.x <= g_pKTDXApp->GetElapsedTime() )
			{
				if( CX2Main::XS_DUNGEON_GAME == g_pMain->GetNowStateID() )
				{
					g_pX2Game->Stop2AllUnit( stopTime.y / 2.0f, &m_FrameDataFuture.syncData.position,800.0f, this, stopTime.z );
					g_pX2Game->Stop2AllUnit( stopTime.y, &m_FrameDataFuture.syncData.position, 700.0f, this, stopTime.z );
				}
				else
				{
					g_pX2Game->Stop2AllUnit( stopTime.y / 2.0f, &m_FrameDataFuture.syncData.position, 2000.0f, this, stopTime.z );
					g_pX2Game->Stop2AllUnit( stopTime.y, &m_FrameDataFuture.syncData.position, 1300.0f, this, stopTime.z );
				}
				//if( stopTime.z > 0.0f )
				//	SetStopTime( stopTime.z );
				//else
				//	SetStopTime( stopTime.y );
			}
			else
				m_Stop2AllList.push_back( stopTime );
		}
		index++;
		m_LuaManager.EndTable();
	}
	index = 0;
	m_StopMyList.clear();
	while( m_LuaManager.BeginTable( "STOP_MY_UNIT", index ) == true )
	{
		D3DXVECTOR2 stopTime;
		LUA_GET_VALUE( m_LuaManager, 1, stopTime.x, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 2, stopTime.y, -1.0f );
		if( stopTime.x != -1.0f )
		{
			if( stopTime.x <= g_pKTDXApp->GetElapsedTime() )
				SetStopTime( stopTime.y );
			else
				m_StopMyList.push_back( stopTime );
		}

		index++;
		m_LuaManager.EndTable();
	}

	index = 0;
	m_Stop2MyList.clear();
	while( m_LuaManager.BeginTable( "STOP2_MY_UNIT", index ) == true )
	{
		D3DXVECTOR2 stopTime;
		LUA_GET_VALUE( m_LuaManager, 1, stopTime.x, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 2, stopTime.y, -1.0f );
		if( stopTime.x != -1.0f )
		{
			if( stopTime.x <= g_pKTDXApp->GetElapsedTime() )
				SetStopTime( stopTime.y );
			else
				m_Stop2MyList.push_back( stopTime );
		}

		index++;
		m_LuaManager.EndTable();
	}

#ifdef ELSWORD_SHEATH_KNIGHT
	index = 0;
	while( m_LuaManager.BeginTable( "EVENT_PROCESS_TIME", index ) == true )
	{
		if( index >= 10 )
		{
			m_LuaManager.EndTable();
			break;
		}
		float fDummy = 0.f;
		LUA_GET_VALUE( m_LuaManager, 1, m_fEventTime[index].keyInputStart, 0.f );
		LUA_GET_VALUE( m_LuaManager, 2, m_fEventTime[index].keyInputEnd, 9999.f );
		LUA_GET_VALUE( m_LuaManager, 3, m_fEventTime[index].stateChange, 9999.f );
		index++;
		m_LuaManager.EndTable();
	}
	for( int i = index; i < 10; ++i )
	{
		m_fEventTime[i].keyInputStart = 0.f;
		m_fEventTime[i].keyInputEnd = 9999.f;
		m_fEventTime[i].stateChange = 9999.f; 
	}
	
	LUA_GET_VALUE(	m_LuaManager, "SKILL_CANCEL_AFTER",					m_fSkillCancelAfter,			9999.f );
	LUA_GET_VALUE(	m_LuaManager, "BWALK_CANCEL_AFTER",					m_fBWalkCancelAfter,			9999.f );
	LUA_GET_VALUE(	m_LuaManager, "WALK_CANCEL_AFTER",					m_fWalkCancelAfter,				9999.f );
	LUA_GET_VALUE(	m_LuaManager, "DASH_CANCEL_AFTER",					m_fDashCancelAfter,				9999.f );
	LUA_GET_VALUE(	m_LuaManager, "ATTACK_CANCEL_AFTER",				m_fAttackCancelAfter,			m_fWalkCancelAfter );
	LUA_GET_VALUE(	m_LuaManager, "ATTACK_CANCEL_AFTER_EX",				m_fAttackCancelAfterEx,			9999.f );

#endif ELSWORD_SHEATH_KNIGHT

#ifdef SERV_RAVEN_VETERAN_COMMANDER
	LUA_GET_VALUE(	m_LuaManager, "SKILL_CANCEL_AFTER_FLY",				m_fSkillCancelAfterFly,			9999.f );		/// 공중용 스킬 캔슬
#endif SERV_RAVEN_VETERAN_COMMANDER

#ifdef LINKED_LINEMAP_JUMP_USER_TEST
	LUA_GET_VALUE( m_LuaManager, "LINK_JUMP_TIME", m_fLinkJumpTime, 1.f );
	LUA_GET_VALUE( m_LuaManager, "LINK_JUMP_ACCEL_X", m_vLinkJumpAcceleration.x, 0.f );
	LUA_GET_VALUE( m_LuaManager, "LINK_JUMP_ACCEL_Y", m_vLinkJumpAcceleration.y, -3000.f );
	LUA_GET_VALUE( m_LuaManager, "LINK_JUMP_ACCEL_Z", m_vLinkJumpAcceleration.z, 0.f );

	if( CX2GameUnit::GUSI_NONE != m_CommonState.m_LinkJumpState &&
		m_FrameDataFuture.syncData.nowState == m_CommonState.m_LinkJumpState )
	{
		LinkJumpStart();
	}
#endif LINKED_LINEMAP_JUMP_USER_TEST

}

void CX2GUUser::CommonStateStart()
{
	KTDXPROFILE();

#ifdef UNIT_SLASH_TRACE_MANAGER_TEST
	if( NULL != m_pUnitSlashTraceManager )
	{
		m_pUnitSlashTraceManager->OnStateStart();
	}
#endif UNIT_SLASH_TRACE_MANAGER_TEST


#ifdef RENA_SIEGE_MODE_ANGLE_TEST
	m_bEnableLookAtIK_Spine = false;
#endif RENA_SIEGE_MODE_ANGLE_TEST
	m_bRotateBone = false;



//#ifdef LINEMAP_FAST_WIND_TEST
//	m_bEnableUpsideWind = true;
//	m_bWaitInTheAir = false;
//	m_fTimeInTheAir	= 0.f;
//#endif LINEMAP_FAST_WIND_TEST

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    ClearAnimEventTimerOneshotNow();
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_EventTimeStampNow.clear();
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

	m_HitUnitList.clear();

	LoadImmunityAtThisStateFromScript( m_LuaManager );

	m_FrameDataNow.unitCondition.fStateTimeBack	= 0.0f;
	m_FrameDataNow.unitCondition.fStateTime		= 0.0f;

	m_FrameDataNow.stateParam.bCanPushUnit		= true;
	m_FrameDataNow.stateParam.bCanPassUnit		= false;

	bool bCanPushUnit = true;
	LUA_GET_VALUE( m_LuaManager, "CAN_PUSH_UNIT",	bCanPushUnit,	true );
	m_FrameDataNow.stateParam.bCanPushUnit = bCanPushUnit;
	bool bCanPassUnit = false;
	LUA_GET_VALUE( m_LuaManager, "CAN_PASS_UNIT",	bCanPassUnit,	false );
	m_FrameDataNow.stateParam.bCanPassUnit = bCanPassUnit;
#ifdef SKILL_BALANCE_PATCH
#ifndef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_bCanPassUnit = bCanPassUnit;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#endif

//#ifdef  X2OPTIMIZE_USER_PASS_PUSH_UNIT_TIME_BUG_FIX
#ifdef RAVEN_SECOND_CLASS_CHANGE	
    {
	    int index = 0;
	    m_vecCanPushUnitNow.clear();
	    while( m_LuaManager.BeginTable( "CAN_PUSH_UNIT_TIME", index ) == true )
	    {
		    TIME_PUSHPASS canPushUnitTime;

		    LUA_GET_VALUE( m_LuaManager, 1, canPushUnitTime.fTime , 0.0f );
		    LUA_GET_VALUE( m_LuaManager, 2, canPushUnitTime.bCan, true );

		    m_vecCanPushUnitNow.push_back(canPushUnitTime);
		    index++;
		    m_LuaManager.EndTable();
	    }

	    index = 0;
	    m_vecCanPassUnitNow.clear();
	    while( m_LuaManager.BeginTable( "CAN_PASS_UNIT_TIME", index ) == true )
	    {
		    TIME_PUSHPASS canPassUnitTime;

		    LUA_GET_VALUE( m_LuaManager, 1, canPassUnitTime.fTime, 0.0f );
		    LUA_GET_VALUE( m_LuaManager, 2, canPassUnitTime.bCan, false );

		    m_vecCanPassUnitNow.push_back(canPassUnitTime);
		    index++;
		    m_LuaManager.EndTable();
	    }
    }
#endif
//#endif  X2OPTIMIZE_USER_PASS_PUSH_UNIT_TIME_BUG_FIX

#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	LUA_GET_VALUE( m_LuaManager, "APPLY_ANIM_MOVE", m_FrameDataNow.stateParam.bApplyAnimMove, true );
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

#ifdef SKILLSTRING_IN_SKILLTEMPLET
	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( GetNowStateSkillID() );
	if( pSkillTemplet != NULL )
	{
		g_pX2Game->SetStateString( pSkillTemplet->m_wstrName );
#ifdef ADD_DAMAGE_LOG
		if( true == IsMyUnit() )
		{
			g_pChatBox->AddChatLog( pSkillTemplet->m_wstrName.c_str(), KEGS_CHAT_REQ::CPT_SYSTEM);
		}
#endif // ADD_DAMAGE_LOG
	}
#else //SKILLSTRING_IN_SKILLTEMPLET
	int stateStrID;
	if( m_LuaManager.GetValue( "STATE_STRING",	stateStrID ) == true )
	{
		g_pX2Game->SetStateString( GET_STRING(stateStrID) );
#ifdef ADD_DAMAGE_LOG
		if( true == IsMyUnit() )
		{
			g_pChatBox->AddChatLog( GET_STRING(stateStrID), KEGS_CHAT_REQ::CPT_SYSTEM);
		}
#endif // ADD_DAMAGE_LOG
	}
#endif //SKILLSTRING_IN_SKILLTEMPLET

	LUA_GET_VALUE( m_LuaManager, "IS_ATTACK_STATE",			m_FrameDataNow.stateParam.bAttackState,			false );


	//{{ dmlee 2008.12.13 이브 소환 필살기 사용하면 tech point 주기 위해서
	if( true == IsMyUnit() )
	{
		int iTechPoint = 0;
		LUA_GET_VALUE( m_LuaManager, "TECH_POINT",				iTechPoint,				0	 );
		if( iTechPoint > 0 )
		{
			g_pX2Game->AddTechPoint( iTechPoint );
		}
	}
	//}} dmlee 2008.12.13 이브 소환 필살기 사용하면 tech point 주기 위해서


//#ifdef HEAD_INVERSE_KINEMATICS_TEST
//	LUA_GET_VALUE( m_LuaManager, "HEAD_IK",			m_bEnableHeadIK,			false );
//#endif HEAD_INVERSE_KINEMATICS_TEST
//


	bool bSuperArmor = false;
	LUA_GET_VALUE( m_LuaManager, "SUPER_ARMOR",			bSuperArmor,			false );
	m_FrameDataNow.stateParam.bSuperArmor			= bSuperArmor;
	
	bool bSuperArmorNotRed = true;
	LUA_GET_VALUE( m_LuaManager, "SUPER_ARMOR_NOT_RED", bSuperArmorNotRed,		true );
	m_FrameDataNow.stateParam.bSuperArmorNotRed		= bSuperArmorNotRed;

	m_bStateSuperArmor = bSuperArmor;

#ifdef SUPER_ARMOR_TIME
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    std::vector<D3DXVECTOR2>& vecSuperArmorTime = m_vecNowSuperArmorTime;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    std::vector<D3DXVECTOR2>& vecSuperArmorTime = m_FrameDataNow.stateParam.m_vecSuperArmorTime;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    vecSuperArmorTime.clear();

	int indexTimeTable = 0;
	while( m_LuaManager.BeginTable( "SUPER_ARMOR_TIME", indexTimeTable ) == true )
	{
		D3DXVECTOR2 superArmorTime;
		LUA_GET_VALUE( m_LuaManager, 1, superArmorTime.x, 0.f );
		LUA_GET_VALUE( m_LuaManager, 2, superArmorTime.y, 0.f );
		vecSuperArmorTime.push_back(superArmorTime);

		indexTimeTable++;
		m_LuaManager.EndTable();
	}
#endif

	if( bSuperArmor == true )
	{
		if( (m_bSuperArmorByItem == true && m_fSuperArmorByItem > 0.f) ||  //아이템에 의한 슈퍼아머 일 때
			(m_bSocketSuperArmor == true && m_fSocketSuperArmor > 0.f) || // 소켓에 의한 슈퍼 아머 일 때
			false == bSuperArmorNotRed ) //스크립트에서 지정한 슈퍼아머 외각라인 설정이 있을 때
		{
			m_FrameDataNow.stateParam.bSuperArmorNotRed = false; //외각 라인 빨간색으로 변경
		}
		else
		{
			m_FrameDataNow.stateParam.bSuperArmorNotRed = true;
		}
	}
	else
	{
		if( (m_bSuperArmorByItem == true && m_fSuperArmorByItem > 0.f) || (m_bSocketSuperArmor == true && m_fSocketSuperArmor > 0.f) )
		{
			m_FrameDataNow.stateParam.bSuperArmor = true;
			m_FrameDataNow.stateParam.bSuperArmorNotRed = false;
		}
		else
		{
			m_fSocketSuperArmor = 0.f;
			m_bSocketSuperArmor = false;
			m_fSuperArmorByItem = 0.f;
			m_bSuperArmorByItem = false;
		}
	}

	ZeroMemory( m_FrameDataNow.stateParam.bEventFlagList, sizeof(bool) * EVENT_FLAG_LIST_NUM );

	m_FrameDataNow.unitCondition.bHit				= false;






	wstring animName;
	LUA_GET_VALUE( m_LuaManager, "ANIM_NAME", animName, L"" );

#ifdef SERV_9TH_NEW_CHARACTER // 김태환
	SetCustomAnimName( m_NowStateData, animName );		/// 특정 상태일 때, 애니메이션을 바꾸는 함수
#endif //SERV_9TH_NEW_CHARACTER

#ifdef RIDING_SYSTEM
	wstring ridingAnimName;
	LUA_GET_VALUE( m_LuaManager, "RIDING_ANIM_NAME", ridingAnimName, L"" );

	if ( true == GetRidingOn() && false == ridingAnimName.empty() )
		animName = ridingAnimName;
#endif //RIDING_SYSTEM
#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( true == animName.empty() )
	{
		int iRandomPercent = GetRandomInt();
		ParseAnimNameFromList( animName, iRandomPercent );
	}
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

	CKTDGXSkinAnim::XSKIN_ANIM_PLAYTYPE playType;
	LUA_GET_VALUE_ENUM ( m_LuaManager, "PLAY_TYPE", playType, CKTDGXSkinAnim::XSKIN_ANIM_PLAYTYPE, CKTDGXSkinAnim::XAP_ONE_WAIT );

	bool bTransition = true;
	LUA_GET_VALUE( m_LuaManager, "TRANSITION", bTransition, true );
	float fStartTime = 0.0f;
	LUA_GET_VALUE( m_LuaManager, "ANIM_START_TIME", fStartTime, 0.0f );

	if( m_FrameDataNow.unitCondition.bTransitionChange == false || bTransition == false || m_FrameDataNow.syncData.bDirectChange == true )
		m_pXSkinAnim->ChangeAnim( animName.c_str(), false, fStartTime );
	else
		m_pXSkinAnim->ChangeAnim( animName.c_str(), true, fStartTime );
	m_pXSkinAnim->Play( playType );

	LUA_GET_VALUE( m_LuaManager, "ANIM_SPEED", m_fAnimSpeed, 1.f );


	// 아이템의 애니메이션 속도 증가 옵션에 영향을 받지 않는 상태인지 체크
	bool bApplyAnimSpeedByItemAbility = true;
	LUA_GET_VALUE( m_LuaManager, "APPLY_ANIM_SPEED_BY_ITEM_ABILITY",	bApplyAnimSpeedByItemAbility,	true );

#ifdef CHUNG_FIRST_CLASS_CHANGE
	// 슈팅 가디언 난전의 기술(패시브)에 의해 애니메이션 속도 증가
	if ( true == bApplyAnimSpeedByItemAbility )
	{
		m_fAnimSpeed += GetAddAnimSpeedFactor();
	} // if
#endif

	ResetAnimSpeed( m_fAnimSpeed, bApplyAnimSpeedByItemAbility, false );

//{{ kimhc // 2011.1.21 // 청 1차 전직
#ifdef	CHUNG_FIRST_CLASS_CHANGE
	// 스테이트 별 HittedType 지정, CommonStateStartFuture에서는 파싱 안함
	LUA_GET_VALUE_ENUM( m_LuaManager, "HITTED_TYPE_AT_STATE", m_eHittedTypeAtState, CX2DamageManager::HITTED_TYPE, CX2DamageManager::HTD_NO_SOUND );	
#endif	CHUNG_FIRST_CLASS_CHANGE
//}} kimhc // 2011.1.21 // 청 1차 전직

#ifdef DELETE_EFFECTSET_ON_CUSTOM_STATE
	bool bCustomStateDeleteEffectSet = false;
	LUA_GET_VALUE( m_LuaManager, "CUSTOM_STATE_DELETE_EFFECT_SET",	bCustomStateDeleteEffectSet,	false );
	if(bCustomStateDeleteEffectSet)
	{
		DeleteEffectSetOnCustomState();
	}
#endif DELETE_EFFECTSET_ON_CUSTOM_STATE

	
#ifdef ADD_MEMO_1ST_CLASS
	m_bApplyMemo = false;
	CX2SkillTree::SKILL_MEMO_ID eMemoID = CX2SkillTree::SMI_NONE;
	LUA_GET_VALUE_ENUM( m_LuaManager, "APPLY_MEMO", eMemoID,	CX2SkillTree::SKILL_MEMO_ID,	CX2SkillTree::SMI_NONE );
	if( CX2SkillTree::SMI_NONE != eMemoID )
	{
		m_bApplyMemo = GetEqippedSkillMemo( eMemoID );
	}
	// 현재스테이트에서 발생하는 effectset list를 담는다.
	LoadEffectSetFromScript( m_LuaManager, m_bApplyMemo );
#else //ADD_MEMO_1ST_CLASS
	// 현재스테이트에서 발생하는 effectset list를 담는다.
	LoadEffectSetFromScript( m_LuaManager );
#endif //ADD_MEMO_1ST_CLASS

	m_vecEffectSetToDeleteOnDamageReact.resize(0);
	m_vecEffectSetToDeleteOnStateEnd.resize(0);	





	if( m_LuaManager.BeginTable( "INVINCIBLE" ) == true )
	{
		float fInvin = -1.0f;
		LUA_GET_VALUE( m_LuaManager, 1,	fInvin,	-1.0f );
		m_FrameDataNow.stateParam.invincibleTime.m_fX = fInvin;
		fInvin = -1.0f;
		LUA_GET_VALUE( m_LuaManager, 2,	fInvin,	-1.0f );
		m_FrameDataNow.stateParam.invincibleTime.m_fY = fInvin;

		if( m_FrameDataNow.stateParam.invincibleTime.m_fX <= 0.0f && m_FrameDataNow.stateParam.invincibleTime.m_fY > 0.0f )
			m_FrameDataNow.stateParam.bInvincible = true;
		else
			m_FrameDataNow.stateParam.bInvincible = false;

		m_LuaManager.EndTable();
	}
	else
	{
		m_FrameDataNow.stateParam.invincibleTime.m_fX	= -1.0f;
		m_FrameDataNow.stateParam.invincibleTime.m_fY	= -1.0f;
		m_FrameDataNow.stateParam.bInvincible		= false;
	}

	if( m_fForceInvincibleTime > 0.0f )
		m_FrameDataNow.stateParam.bInvincible = true;


#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    m_mapNowAddSlashTrace.clear();
    LUA_GET_VALUE( m_LuaManager, "SLASH_TRACE_TIP_WIDE",	m_fNowSlashTraceTipWide,	4.0f );	
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_FrameDataNow.stateParam.m_mapAddSlashTrace.clear();
	LUA_GET_VALUE( m_LuaManager, "SLASH_TRACE_TIP_WIDE",	m_FrameDataNow.stateParam.fSlashTraceTipWide,	4.0f );	
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

#ifdef UNIT_SLASH_TRACE_MANAGER_TEST
	if( NULL != m_pUnitSlashTraceManager )
	{
		m_pUnitSlashTraceManager->SetSlashTraceTipWidth( 
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            m_fNowSlashTraceTipWide
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            m_FrameDataNow.stateParam.fSlashTraceTipWide
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            );
	}
#endif UNIT_SLASH_TRACE_MANAGER_TEST

	
	if( m_LuaManager.BeginTable( "SLASH_TRACE" ) == true )
	{
		D3DXVECTOR3 vSlashTraceTime;

		LUA_GET_VALUE( m_LuaManager, 1,	vSlashTraceTime.x,	-1.0f );
		LUA_GET_VALUE( m_LuaManager, 2,	vSlashTraceTime.y,	-1.0f );
		LUA_GET_VALUE( m_LuaManager, 3, vSlashTraceTime.z,  0.f );			// slash trace type
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        m_mapNowAddSlashTrace[ 0 ] = vSlashTraceTime;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_FrameDataNow.stateParam.m_mapAddSlashTrace[ 0 ] = vSlashTraceTime;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

		m_LuaManager.EndTable();
	}


	int iTableIndex = 0; 
	while( true == m_LuaManager.BeginTable( "SLASH_TRACE", iTableIndex ) )
	{
		int iWeaponIndex = 0;
		D3DXVECTOR3 vSlashTraceTime;

		LUA_GET_VALUE( m_LuaManager, 1,	vSlashTraceTime.x,	-1.0f );
		LUA_GET_VALUE( m_LuaManager, 2,	vSlashTraceTime.y,	-1.0f );
		LUA_GET_VALUE( m_LuaManager, 3, iWeaponIndex, 0 );
		LUA_GET_VALUE( m_LuaManager, 4, vSlashTraceTime.z, 0.f );			// slash trace type
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        m_mapNowAddSlashTrace[ iWeaponIndex ] = vSlashTraceTime;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_FrameDataNow.stateParam.m_mapAddSlashTrace[ iWeaponIndex ] = vSlashTraceTime;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

		m_LuaManager.EndTable(); // SLASH_TRACE%d
		iTableIndex++;
	}

	DoUnitSlashTraceInCommonStateStart();

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    D3DXVECTOR2& v2AfterImage = m_v2NowAfterImageTime;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    D3DXVECTOR2& v2AfterImage = m_FrameDataNow.stateParam.afterImage;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_LuaManager.BeginTable( "AFTER_IMAGE" ) == true )
	{

		LUA_GET_VALUE( m_LuaManager, 1,	v2AfterImage.x,	-1.0f );
		LUA_GET_VALUE( m_LuaManager, 2,	v2AfterImage.y,	-1.0f );

		m_LuaManager.EndTable();
	}
	else
	{
		v2AfterImage.x	= -1.0f;
		v2AfterImage.y	= -1.0f;
		DisableAfterImage();
	}

	if( IsFocusUnit() == true && m_FrameDataNow.stateParam.bResetCamera == true )
	{
		m_FrameDataNow.stateParam.hitCamera = 0;
		if( g_pX2Game->GetX2Camera()->GetCameraState() != CX2Camera::CS_NORMAL )
		{
			g_pX2Game->GetX2Camera()->NomalDirectCamera( this, g_pMain->GetGameOption().GetCameraDistance() );
		}

		int camera0Rate = 100;
		int camera1Rate = 100;
		int camera2Rate = 100;
		int ran = rand()%100 + 1;

		//09.02.18.hoons : 이브 아키텍쳐의 lose 상태일때만 다이렉트 카메라를 꺼주기 위해
		//                 추후에 코드정리 필요.
		//if( GetUnit()->GetClass() == CX2Unit::UC_EVE_ARCHITECTURE && GetGameUnitState() == CX2GUEve::ENSI_LOSE )
		//{
		//	camera0Rate = 100;
		//	camera1Rate = 0;
		//	camera2Rate = 0;
		//}
		//else
		//{
		LUA_GET_VALUE( m_LuaManager, "NORMAL_CAMERA0_RATE", camera0Rate, 0 );
		LUA_GET_VALUE( m_LuaManager, "NORMAL_CAMERA1_RATE", camera1Rate, 0 );
		LUA_GET_VALUE( m_LuaManager, "NORMAL_CAMERA2_RATE", camera2Rate, 0 );
		//}
		// hoons.
		if( ran < camera0Rate )
		{
			m_FrameDataNow.stateParam.normalCamera = 0;
		}
		else if( ran < (camera0Rate + camera1Rate) )
		{
			m_FrameDataNow.stateParam.normalCamera = 1;
		}
		else if( ran < (camera0Rate + camera1Rate + camera2Rate) )
		{
			m_FrameDataNow.stateParam.normalCamera = 2;
		}
		else
			m_FrameDataNow.stateParam.normalCamera = 0;

		ran = rand()%100 + 1;
		LUA_GET_VALUE( m_LuaManager, "HIT_CAMERA0_RATE", camera0Rate, 0 );
		LUA_GET_VALUE( m_LuaManager, "HIT_CAMERA1_RATE", camera1Rate, 0 );
		LUA_GET_VALUE( m_LuaManager, "HIT_CAMERA2_RATE", camera2Rate, 0 );
		if( ran < camera0Rate )
		{
			m_FrameDataNow.stateParam.hitCamera = 0;
		}
		else if( ran < (camera0Rate + camera1Rate) )
		{
			m_FrameDataNow.stateParam.hitCamera = 1;
		}
		else if( ran < (camera0Rate + camera1Rate + camera2Rate) )
		{
			m_FrameDataNow.stateParam.hitCamera = 2;
		}
		else
			m_FrameDataNow.stateParam.hitCamera = m_FrameDataNow.stateParam.normalCamera;
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    LUA_GET_VALUE( m_LuaManager, "FALL_DOWN", m_bNowFallDown, true );
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	LUA_GET_VALUE( m_LuaManager, "FALL_DOWN", m_FrameDataNow.stateParam.bFallDown, true );
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE


	m_DamageData.SimpleInit();
	m_DamageData.attackerType		= CX2DamageManager::AT_UNIT;
	m_DamageData.optrAttackerGameUnit		= this;
#ifndef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_DamageData.pAttackerEffect		= NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

#ifdef ADD_MEMO_1ST_CLASS
	if( true == m_bApplyMemo )
	{
		if( false == SetDamageData( "DAMAGE_DATA_MEMO", m_bApplyMemo ) )
		{
			SetDamageData( "DAMAGE_DATA" );
		}
	}
	else
#endif //ADD_MEMO_1ST_CLASS
	SetDamageData( "DAMAGE_DATA" );


#ifndef DELETE_OVERlAP_DECREASE_FORCE_DOWN_MELEE		/// 중복 적용중인 포스 다운 감소 구문 삭제
	if( m_DamageData.attackType != CX2DamageManager::AT_SPECIAL )
	{
		// 패시브 스킬에 따라 강제다운 수치 조정
		if( 1.f != m_SkillRelatedData.GetForceDownValueRateOfMeleeAttack() )
		{
			m_DamageData.fForceDownValue *= m_SkillRelatedData.GetForceDownValueRateOfMeleeAttack();//+= CalulateIncreaseingRate( m_SkillRelatedData.m_fForceDownValueRateOfMeleeAttack );
		}
	}
#endif DELETE_OVERlAP_DECREASE_FORCE_DOWN_MELEE
	
	// 개발자 테스트용
#ifndef _SERVICE_
	if( NULL != g_pData->GetMyUser() && 
		g_pData->GetMyUser()->GetAuthLevel() >= CX2User::XUAL_OPERATOR && 
		true == this->IsMyUnit() && 
		true == g_pX2Game->IsHost() )
	{
		if( 0.f != m_fDevAddDamage )
		{
			m_DamageData.damage.fPhysic		+= m_fDevAddDamage;
			m_DamageData.damage.fMagic		+= m_fDevAddDamage;
		}
	}
#endif


	m_FrameDataNow.stateParam.bResetCamera			= true;

	if( m_LuaManager.BeginTable( "REVENGE" ) == true )
	{
		float fReven = -1.0f;
		LUA_GET_VALUE( m_LuaManager, 1, fReven,	-1.0f );
		m_FrameDataNow.stateParam.fRevengeStartTime = fReven;
		fReven = -1.0f;
		LUA_GET_VALUE( m_LuaManager, 2, fReven,		-1.0f );
		m_FrameDataNow.stateParam.fRevengeEndTime = fReven;

		m_LuaManager.EndTable();
	}
	else
	{
		m_FrameDataNow.stateParam.fRevengeStartTime	= -1.0f;
		m_FrameDataNow.stateParam.fRevengeEndTime	= -1.0f;
	}

	// 마법반사
	if( m_LuaManager.BeginTable( "REFLEX_MAGIC" ) == true )
	{
		float fReflex = -1.0f;
		LUA_GET_VALUE( m_LuaManager, 1, fReflex,	-1.0f );
		m_FrameDataNow.stateParam.fReflexMagicStartTime = fReflex;
		fReflex= -1.0f;
		LUA_GET_VALUE( m_LuaManager, 2, fReflex,		-1.0f );
		m_FrameDataNow.stateParam.fReflexMagicEndTime = fReflex;

		m_LuaManager.EndTable();
	}
	else
	{
		m_FrameDataNow.stateParam.fReflexMagicStartTime	= -1.0f;
		m_FrameDataNow.stateParam.fReflexMagicEndTime	= -1.0f;
	}

	int index = 0;
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    m_vecAttackTime.resize( 0 );
    m_vecAttackTime.reserve( m_LuaManager.GetNumIndexedTables( "ATTACK_TIME" ) );
	while( m_LuaManager.BeginTable( "ATTACK_TIME", index ) == true )
	{
        m_vecAttackTime.resize( m_vecAttackTime.size() + 1 );
        KAttackTimeProjSeqName& kNode = m_vecAttackTime.back();

		LUA_GET_VALUE( m_LuaManager, 1, kNode.m_v2AttackTime.x, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 2, kNode.m_v2AttackTime.y, -1.0f );
        kNode.m_wstrProjSeqName.resize( 0 );
		m_LuaManager.GetValue( 3, kNode.m_wstrProjSeqName );
		index++;
		m_LuaManager.EndTable();
	}
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_AttackTimeList.clear();
	m_AttackProjSeqName.clear();
	while( m_LuaManager.BeginTable( "ATTACK_TIME", index ) == true )
	{
		D3DXVECTOR2 attackTime;
		wstring projSeqName;
		LUA_GET_VALUE( m_LuaManager, 1, attackTime.x, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 2, attackTime.y, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 3, projSeqName, L"" );
		m_AttackProjSeqName.push_back( projSeqName );
		m_AttackTimeList.push_back( attackTime );

		index++;
		m_LuaManager.EndTable();
	}
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	
	StopTime_StateStart();

	index = 0;
	m_vecSoundPlayData.resize(0);
	while( m_LuaManager.BeginTable( "SOUND_PLAY", index ) == true )
	{
		CX2GameUnit::SoundPlayData sndPlayData;

		LUA_GET_VALUE( m_LuaManager, 1, sndPlayData.m_SoundPlayTime,	-1.0f	);
		LUA_GET_VALUE( m_LuaManager, 2, sndPlayData.m_SoundPlayName,	L""		);
		LUA_GET_VALUE( m_LuaManager, 3, sndPlayData.m_SoundPlayRate,	100		);
		LUA_GET_VALUE( m_LuaManager, 4, sndPlayData.m_bOnlyIfMyUnit,	false	);

		m_vecSoundPlayData.push_back( sndPlayData );

		index++;
		m_LuaManager.EndTable();
	}

#ifdef ARA_CHARACTER_BASE
	int iSoundRate0 = 100;
	int iSoundRate1 = 100;
	int iSoundRate2 = 100;
	int iRand = rand()%100 + 1;
	
	LUA_GET_VALUE( m_LuaManager, "SOUND_SET0_RATE", iSoundRate0, 0 );
	LUA_GET_VALUE( m_LuaManager, "SOUND_SET1_RATE", iSoundRate1, 0 );
	LUA_GET_VALUE( m_LuaManager, "SOUND_SET2_RATE", iSoundRate2, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    USHORT  usShoundSet = 0;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    USHORT&  usShoundSet = m_FrameDataNow.stateParam.m_usSoundSet;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( iRand < iSoundRate0 )
	{
		usShoundSet = 0;
	}
	else if( iRand < ( iSoundRate0 + iSoundRate1 ) )
	{
		usShoundSet = 1;
	}
	else if( iRand < ( iSoundRate0 + iSoundRate1 + iSoundRate2 ) )
	{
		usShoundSet = 2;
	}
	else
		usShoundSet = 0;

	if ( m_LuaManager.BeginTable( "SOUND_SET", usShoundSet ) == true )
	{
		m_vecSoundPlayData.resize(0);

		bool bUseHyperSound = false;
		bool bUseBerserkSound = false;
		LUA_GET_VALUE( m_LuaManager, "USE_HYPER_SOUND", bUseHyperSound, false );
		LUA_GET_VALUE( m_LuaManager, "USE_BERSERK_SOUND", bUseBerserkSound, false );
		
		const char* pszState = "NORMAL";
		if ( 0.f < GetRemainHyperModeTime() && true == bUseHyperSound )
			pszState = "HYPER";

		if ( true == IsFullHyperMode() && 0.f < GetRemainHyperModeTime() && true == bUseBerserkSound )
			pszState = "BERSERK";
		
		if( m_LuaManager.BeginTable( pszState ) == true )
		{
			index = 0;
			while( m_LuaManager.BeginTable( "SOUND_PLAY", index ) == true )
			{
				CX2GameUnit::SoundPlayData sndPlayData;

				LUA_GET_VALUE( m_LuaManager, 1, sndPlayData.m_SoundPlayTime,	-1.0f	);
				LUA_GET_VALUE( m_LuaManager, 2, sndPlayData.m_SoundPlayName,	L""		);
				LUA_GET_VALUE( m_LuaManager, 3, sndPlayData.m_SoundPlayRate,	100		);
				LUA_GET_VALUE( m_LuaManager, 4, sndPlayData.m_bOnlyIfMyUnit,	false	);

				m_vecSoundPlayData.push_back( sndPlayData );

				index++;
				m_LuaManager.EndTable();	// SOUND_PLAY#
			}
		    m_LuaManager.EndTable();	// 이름없는 Table
		}
		m_LuaManager.EndTable();	// SOUND_SET
	}

#endif


	//// 장비교체시 어택박스 재설정되는 현상 예외처리
	//SetEnableAttackBox( L"Rfoot", false );
	//SetEnableAttackBox( L"Lfoot", false );
	//SetEnableAttackBox( L"Lhand2", false );
	if( m_LuaManager.BeginTable( "ENABLE_ATTACK_BOX" ) == true )
	{
		int index = 1;
		wstring wname;
		while( m_LuaManager.GetValue( index, wname ) == true )
		{
			SetEnableAttackBox( wname.c_str(), true );

			index++;
		}

		m_LuaManager.EndTable();
	}

	if( m_LuaManager.BeginTable( "DISABLE_ATTACK_BOX" ) == true )
	{
		int index = 1;
		wstring wname;
		while( m_LuaManager.GetValue( index, wname ) == true )
		{
			SetEnableAttackBox( wname.c_str(), false );

			index++;
		}

		m_LuaManager.EndTable();
	}

	if( m_FrameDataFuture.syncData.nowState == GUSI_DIE )
	{ 
		if( CX2Main::XS_TRAINING_GAME == g_pMain->GetNowStateID() )
		{
			CX2StateTrainingGame* pState = (CX2StateTrainingGame*) g_pMain->GetNowState();
			pState->Handler_EGS_END_TC_GAME_REQ( false );
		}
		else
		{
			//if ( g_pX2Game != NULL && g_pX2Game->GetGameEnd() == false )
			g_pData->GetServerProtocol()->SendID( EGS_USER_UNIT_DIE_COMPLETE_REQ );

			// FieldFix: landPostion, dirDegree, lastTouchLineIndex 만 필요한데 이렇게 대입하는 것은 정말 안좋은듯...
			m_FrameDataDead = m_FrameDataNow;

			if( CX2Main::XS_DUNGEON_GAME == g_pMain->GetNowStateID() )
			{
				CX2DungeonGame* pDungeonGame = static_cast<CX2DungeonGame*>(g_pX2Game);
				if( NULL != pDungeonGame &&
					NULL != pDungeonGame->GetDungeon() &&
					NULL != pDungeonGame->GetDungeon()->GetNowStage() )
				{
					m_DeadStageIndex	= pDungeonGame->GetDungeon()->GetNowStageIndex();
					m_DeadSubStageIndex = pDungeonGame->GetDungeon()->GetNowStage()->GetNowSubStageIndex();
				}
			}
		}
	}

#ifdef NO_DETONATION
	if( m_bNowStateDamageReact == true && GetNoDetonation() == true )
	{
		SetNoDetonation(true);
	}
	else
	{
		SetNoDetonation(false);
	}	
	m_bNowStateDamageReact = false;
#endif

	if( IsMyUnit() == true && m_pComboGuide != NULL )
	{
		wstring comboId, comboCommand;
		comboId = L"";
		comboCommand = L"";
		if( m_LuaManager.BeginTable( "COMBO_GUIDE" ) == true )
		{		
			LUA_GET_VALUE( m_LuaManager, 1,	comboId,		L"" );
			LUA_GET_VALUE( m_LuaManager, 2,	comboCommand,	L"" );	

			m_LuaManager.EndTable();
		}

		if(comboId == L"")
		{
			m_pComboGuide->ShowComboCommand(L"", L"", false);
		}
		else
		{
			m_pComboGuide->ShowComboCommand(comboId, comboCommand);
		}
	}	

#ifdef NEW_HENIR_TEST

#ifndef ADD_HENIR_BUFF		/// 버프로 변경되면서 쓰이지 않게 된 구문
	if(m_fTimeHenirBuff_Fire > 0.f && m_DamageData.attackType != CX2DamageManager::AT_SPECIAL)
	{
		g_pData->GetDamageManager()->SetExtraDamageData( &m_DamageData, true, CX2DamageManager::EDT_FIRE, 100.f, 5.f, 100.f, 0.f, 0, true );
	}

	if(m_fTimeHenirBuff_Water > 0.f && m_DamageData.attackType != CX2DamageManager::AT_SPECIAL)
	{
		g_pData->GetDamageManager()->SetExtraDamageData( &m_DamageData, true, CX2DamageManager::EDT_COLD, 100.f, 5.f, 100.f, 0.f, 0, true );
	}
#endif ADD_HENIR_BUFF

#endif NEW_HENIR_TEST

#ifdef ELSWORD_SHEATH_KNIGHT
	index = 0;
	while( m_LuaManager.BeginTable( "EVENT_PROCESS_TIME", index ) == true )
	{
		if( index >= 10 )
		{
			m_LuaManager.EndTable();
			break;
		}
		float fDummy = 0.f;
		LUA_GET_VALUE( m_LuaManager, 1, fDummy, 0.f );
		LUA_GET_VALUE( m_LuaManager, 2, fDummy, 9999.f );
		LUA_GET_VALUE( m_LuaManager, 3, m_fEventTime[index].stateChange, 9999.f );
		index++;
		m_LuaManager.EndTable();
	}

	LUA_GET_VALUE(	m_LuaManager, "SKILL_CANCEL_AFTER",					m_fSkillCancelAfter,			9999.f );
	LUA_GET_VALUE(	m_LuaManager, "BWALK_CANCEL_AFTER",					m_fBWalkCancelAfter,			9999.f );
	LUA_GET_VALUE(	m_LuaManager, "WALK_CANCEL_AFTER",					m_fWalkCancelAfter,				9999.f );
	LUA_GET_VALUE(	m_LuaManager, "DASH_CANCEL_AFTER",					m_fDashCancelAfter,				9999.f );
	LUA_GET_VALUE(	m_LuaManager, "ATTACK_CANCEL_AFTER",				m_fAttackCancelAfter,			m_fWalkCancelAfter );
	LUA_GET_VALUE(	m_LuaManager, "ATTACK_CANCEL_AFTER_EX",				m_fAttackCancelAfterEx,			9999.f );

#endif ELSWORD_SHEATH_KNIGHT

#ifdef SERV_RAVEN_VETERAN_COMMANDER
	LUA_GET_VALUE(	m_LuaManager, "SKILL_CANCEL_AFTER_FLY",				m_fSkillCancelAfterFly,			9999.f );		/// 공중용 스킬 캔슬
#endif SERV_RAVEN_VETERAN_COMMANDER

#ifdef SERV_EVE_BATTLE_SERAPH
	LUA_GET_VALUE( m_LuaManager, "IS_NOCHANGE_SPECTRO",		m_FrameDataNow.stateParam.bNoChangSpectro,		false );
#endif

	LUA_GET_VALUE(	m_LuaManager, "DAMAGE_DATA_CHANGE_TIME",			m_fCommonDamageChangeTime,		-1.f );

	LUA_GET_VALUE(	m_LuaManager, "CHANGE_WORLD_COLOR",					m_bChangeWorldColor,		false );
	LUA_GET_VALUE(	m_LuaManager, "SHOW_SKILL_CUT_IN_TIME",				m_fShowSkillCutInTime,		-1.f );

	DoCustomFunctionByBuffInCommonStateStart();
	ApplyDrainHpBuff();

#ifdef ADD_ARA_MEMO	// 적용날짜: 2013-03-22
	/// 메모 효과 변경으로 인하여 사용되지 않지만, 추후 스킬 개편시 사용 예정
	/*SetDamageReducePercent( 0 );		/// 스테이트가 시작될 때, 데미지 감소치를 0으로 초기화 시켜준다.*/
#endif // ADD_ARA_MEMO

#ifdef FIX_FORCE_DOWN_AND_DETONATION_BUG
	ForceDownAndDetonationProcess();
#endif //FIX_FORCE_DOWN_AND_DETONATION_BUG

#ifdef INSERT_BUFF_FACTOR_BY_SCPRIPT_STATE
	#ifdef ADD_MEMO_1ST_CLASS //김창한
		ParsingBuffFactorID( m_LuaManager, m_bApplyMemo );
	#else //ADD_MEMO_1ST_CLASS
		ParsingBuffFactorID( m_LuaManager );
	#endif //ADD_MEMO_1ST_CLASS
#endif // INSERT_BUFF_FACTOR_BY_SCPRIPT_STATE

}


void CX2GUUser::CommonFrameMoveFuture()
{
	KTDXPROFILE();
	
//#ifndef SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//	++m_dwFrameMoveCountFuture;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    m_ElapsedTimeNotBusyState.OnFrameMove( m_fElapsedTime );
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_ElapsedTimeNotBusyState.OnFrameMove();
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

#ifdef TEST_GROUP_GRAP

	if ( m_iGrapShakeCount > 0 )
	{
		if ( m_InputData.pureLeft == true && m_InputData.pureRight == false && m_bGrapEscapeKeyLeftCheck == false )
		{
			m_bGrapEscapeKeyLeftCheck = true;
			m_bGrapEscapeKeyRightCheck	= false;
			m_iGrapShakeCount--;
			m_InputData.Init();
		}
		else if ( m_InputData.pureRight == true && m_InputData.pureLeft == false && m_bGrapEscapeKeyRightCheck == false )
		{
			m_bGrapEscapeKeyRightCheck	= true;
			m_bGrapEscapeKeyLeftCheck	= false;
			m_iGrapShakeCount--;
			m_InputData.Init();
		}
	}
	else
	{
		m_bGrapEscapeKeyLeftCheck = false;
		m_bGrapEscapeKeyRightCheck = false;
	}
#endif TEST_GROUP_GRAP

	float fNowAnimTime = m_pXSkinAnimFuture->GetNowAnimationTime();

#ifdef RIDING_SYSTEM
	if ( true == GetRidingOn() && NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() )
		fNowAnimTime = m_ptrRidingPet->GetXSkinAnimFuturePtr()->GetNowAnimationTime();
#endif //RIDING_SYSTEM

#ifdef RAVEN_SECOND_CLASS_CHANGE
	// 스크립트 상에서 canPassUnit, canPushUnit을 시간대별로 지정해 줄수 있도록 한다.
	if( m_pXSkinAnimFuture != NULL && m_vecCanPushUnit.size() > 0)
	{		
		for(UINT i=0; i<m_vecCanPushUnit.size(); ++i)
		{
			TIME_PUSHPASS canPushUnitTime = m_vecCanPushUnit[i];

			if( canPushUnitTime.fTime <= fNowAnimTime )
			{				
				m_FrameDataFuture.stateParam.bCanPushUnit = canPushUnitTime.bCan;
				m_vecCanPushUnit.erase(m_vecCanPushUnit.begin() + i);
				--i;
			}
		}
	}
	if( m_pXSkinAnimFuture != NULL && m_vecCanPassUnit.size() > 0)
	{		
		for(UINT i=0; i<m_vecCanPassUnit.size(); ++i)
		{
			TIME_PUSHPASS canPassUnitTime = m_vecCanPassUnit[i];

			if( canPassUnitTime.fTime <= fNowAnimTime )
			{				
				m_FrameDataFuture.stateParam.bCanPassUnit = canPassUnitTime.bCan;
				m_vecCanPassUnit.erase(m_vecCanPassUnit.begin() + i);
				--i;
			}
		}
	}
#endif

	// 스크립트 상에서 특정 시간에 특정스피드를 지정해 줄수 있도록한다.
	if( m_pXSkinAnimFuture != NULL && m_vecSpeedFactor.size() > 0)
	{
		for(UINT i=0; i<m_vecSpeedFactor.size(); ++i)
		{
			TIME_SPEED timeSpeed = m_vecSpeedFactor[i];

			if( timeSpeed.iFlag > 0 && timeSpeed.vSpeed.z >= 0.f && timeSpeed.vSpeed.z <= fNowAnimTime )
			{
				switch(timeSpeed.iFlag)
				{
				case 1:
					m_PhysicParam.nowSpeed.x += timeSpeed.vSpeed.x;
					m_PhysicParam.nowSpeed.y += timeSpeed.vSpeed.y;
					break;
				case 2:
					m_PhysicParam.nowSpeed.x = timeSpeed.vSpeed.x;
					m_PhysicParam.nowSpeed.y = timeSpeed.vSpeed.y;
					break;
#ifdef ARA_CHANGE_CLASS_FIRST
				case 3:
					m_PhysicParam.passiveSpeed.x = timeSpeed.vSpeed.x;
					m_PhysicParam.passiveSpeed.y = timeSpeed.vSpeed.y;
					break;
#endif
				default:
					break;
				}				

				m_vecSpeedFactor.erase(m_vecSpeedFactor.begin() + i);
				--i;
			}
		}
	}

#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	map<float,bool>::iterator iter;
	for( iter = m_EventTimeStampFuture.begin(); iter != m_EventTimeStampFuture.end(); iter++ )
	{
		iter->second = true;
	}
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_FrameDataFuture.unitCondition.fStateTimeBack	= m_FrameDataFuture.unitCondition.fStateTime;
	m_FrameDataFuture.unitCondition.fStateTime		+= m_fElapsedTime;



	if( m_pXSkinAnimFuture->GetNowAnimationTime() >= m_vDisableGravityInScriptTime.x &&
		m_pXSkinAnimFuture->GetNowAnimationTime() < m_vDisableGravityInScriptTime.y )
	{
		m_bDisableGravityInScript = true;
	}
	else
	{
		m_bDisableGravityInScript = false;
	}

	m_fLastDamagePassTime += m_fElapsedTime;
	if( m_fLastDamagePassTime >= 2.0f )
	{
		AddForceDownGage( -10.0f * m_fElapsedTime );
	}


	if( m_fCanNotAttackTime > 0.0f )
	{
		m_fCanNotAttackTime -= m_fElapsedTime;
		if( m_fCanNotAttackTime < 0.0f )
			m_fCanNotAttackTime = 0.0f;
	}
	if( m_fCanNotJumpTime > 0.0f )
	{
		m_fCanNotJumpTime -= m_fElapsedTime;
		if( m_fCanNotJumpTime < 0.0f )
			m_fCanNotJumpTime = 0.0f;
	}
	if( m_fCanNotInputTime > 0.0f )
	{
		m_fCanNotInputTime -= m_fElapsedTime;
		if( m_fCanNotInputTime < 0.0f )
			m_fCanNotInputTime = 0.0f;
	}

	if( m_fCanNotInputTimeZXArrow > 0.0f )
	{
		m_fCanNotInputTimeZXArrow -= m_fElapsedTime;
		if( m_fCanNotInputTimeZXArrow < 0.0f )
			m_fCanNotInputTimeZXArrow = 0.0f;
	}




#ifdef REVERSE_GRAVITY_TEST
	m_fReverseGravitySpeedDeltaY = 0.f;
	if( true == g_pX2Game->IsInReverseGravityRegion( 
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        m_fElapsedTime,
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        GetPos(true ), m_fReverseGravitySpeedDeltaY, m_vReverseGravityRotateSpeedDelta, GetTeam() ) )
	{
		m_fCanNotInputTime = 0.1f;
		m_InputData.Init();
	}
#endif REVERSE_GRAVITY_TEST


#ifdef USER_HOLD
	if(GetHold() == true)
	{
		m_FrameDataFuture.syncData.position = m_vHold;
	}
#endif	

#ifdef TEST_GROUP_GRAP
	if (GetGrap() == true)
	{
		m_FrameDataFuture.syncData.position = m_vGrap;
	}
#endif TEST_GROUP_GRAP

#ifdef RIDING_SYSTEM
	if ( true == GetRidingOn() && GetNowStateID() != USI_RIDING_DIE )
		m_pXSkinAnimFuture->GetMatrix().Move( GetSaddlePos() );
	else
		m_pXSkinAnimFuture->GetMatrix().Move( m_FrameDataFuture.syncData.position );
#else //RIDING_SYSTEM
	m_pXSkinAnimFuture->GetMatrix().Move( m_FrameDataFuture.syncData.position );
#endif //RIDING_SYSTEM 탈 것 위치 적용


#ifdef GRAPPLING_TEST
	CX2GameUnit* pGrappler = GetUnitGrapplingMe( false );
	if( NULL != pGrappler )
	{
		m_pXSkinAnimFuture->GetMatrix().RotateDegree( pGrappler->GetUnitCondition( false ).m_GrapplingState.GetGrapplingRotation() );
	}
	else
#endif GRAPPLING_TEST
	{
#ifdef REVERSE_GRAVITY_TEST // oasis907 : 김상윤 [2011.6.29] 
		if(m_fReverseGravitySpeedDeltaY == 0.f)
#ifdef RIDING_SYSTEM
		{
			if ( true == GetRidingOn() && GetNowStateID() != USI_RIDING_DIE )
				m_pXSkinAnimFuture->GetMatrix().RotateDegree( GetSaddleDegree() );
			else
				m_pXSkinAnimFuture->GetMatrix().RotateDegree( m_FrameDataNow.unitCondition.dirDegree );
		}
#else //RIDING_SYSTEM
			m_pXSkinAnimFuture->GetMatrix().RotateDegree( m_FrameDataNow.unitCondition.dirDegree );
#endif //RIDING_SYSTEM 탈 것 회전 값 적용
#else
		m_pXSkinAnimFuture->GetMatrix().RotateDegree( m_FrameDataFuture.unitCondition.dirDegree );
#endif REVERSE_GRAVITY_TEST
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    bool    bXSkinAnimFutureOnFrameMoveCalled = false;
    bool    bRidingPetXSkinAnimFutureOnFrameMoveCalled = false;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_FrameDataFuture.syncData.bFrameStop == false )
	{
#ifdef RIDING_SYSTEM
		if( m_StopAdvanceTimeFuture == false )
		{
			m_pXSkinAnimFuture->OnFrameMove( m_fTime, m_fElapsedTime );
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            bXSkinAnimFutureOnFrameMoveCalled = true;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			if ( true == GetRidingOn() && NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() )
            {
				m_ptrRidingPet->GetXSkinAnimFuturePtr()->OnFrameMove( m_fTime, m_fElapsedTime );
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                bRidingPetXSkinAnimFutureOnFrameMoveCalled = true;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            }
		}
#else //RIDING_SYSTEM
		if( m_StopAdvanceTimeFuture == false )
        {
			m_pXSkinAnimFuture->OnFrameMove( m_fTime, m_fElapsedTime );
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            bXSkinAnimFutureOnFrameMoveCalled = true;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        }
#endif //RIDING_SYSTEM

		GetGageData()->OnFrameMove( m_fTime, m_fElapsedTime );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( bXSkinAnimFutureOnFrameMoveCalled == false )
        m_pXSkinAnimFuture->UpdateBeforeAnimationTime();
    if ( bRidingPetXSkinAnimFutureOnFrameMoveCalled == false && NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() )
        m_ptrRidingPet->GetXSkinAnimFuturePtr()->UpdateBeforeAnimationTime();
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE


//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
    m_FrameDataFuture.syncData.dwFrameMoveCount		= g_pX2Game->GetFrameUDPPack().GetFrameMoveCount();
//#else   SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//	m_FrameDataFuture.syncData.dwFrameMoveCount		= GetFrameMoveCountFuture();
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	m_FrameDataFuture.syncData.fNowHP				= GetNowHp();
	m_FrameDataFuture.syncData.fNowMP				= GetNowMp();

	m_FrameDataFuture.syncData.ucHitCount			= GetHitCount();
	m_FrameDataFuture.syncData.ucHittedCount		= GetHittedCount();
	m_FrameDataFuture.syncData.ucNumOfDeBuff		= GetNumOfDeBuff();

	CommonFrameMoveFuture_ExtraDamage();


	while( FlushSoul( 100.0f ) == true )
	{
		SetHyperModeCount( GetHyperModeCount() + 1 );
		if ( GetHyperModeCount() > 3 )
		{
			SetHyperModeCount( 3 );
		}
		else
		{
			g_pKTDXApp->GetDeviceManager()->PlaySound( L"Dama.ogg", false, false );
		}
	}
	if( NULL != g_pData && NULL != g_pData->GetPlayGuide() )
	{
		if( GetHyperModeCount() >= 1 )
		{	//각성구슬 1개 이상 일 때 각성 가이드 출력
			if( NULL != g_pMain && NULL != g_pMain->GetKeyPad() )
			{
				g_pData->GetPlayGuide()->SetPlayGuide(CX2PlayGuide::PGT_HYPER_MODE, true, g_pMain->GetKeyPad()->GetKeyString( GAMEACTION_AWAKE ));
			}
		}
		else
		{
			g_pData->GetPlayGuide()->SetPlayGuide(CX2PlayGuide::PGT_HYPER_MODE, false);
		}
	}

	if( m_FrameDataFuture.syncData.bFrameStop == false )
	{





#ifdef LINKED_LINEMAP_JUMP_USER_TEST
		if( CX2GameUnit::GUSI_NONE != m_CommonState.m_LinkJumpState &&
			m_FrameDataFuture.syncData.nowState == m_CommonState.m_LinkJumpState )
		{
			LinkJumpPhysicProcess( m_fTime, m_fElapsedTime );
		}
		else
		{
			m_fElapsedTimeAfterLastLinkJump += m_fElapsedTime;

#ifdef GRAPPLING_TEST
			if( true == IsGrappled( false) )
			{
				GrappledPhysicProcess( true );
			}
			else
#endif GRAPPLING_TEST
			{
				PhysicProcess();
			}

		}
#else LINKED_LINEMAP_JUMP_USER_TEST
		//{{AFX
#ifdef GRAPPLING_TEST
		if( true == IsGrappled( false) )
		{
			GrappledPhysicProcess( true );
		}
		else
#endif GRAPPLING_TEST
		{
			PhysicProcess();
		}
		//}}AFX
#endif LINKED_LINEMAP_JUMP_USER_TEST





		if( m_PhysicParam.passiveSpeed.x != -1.0f )
			m_PhysicParam.nowSpeed.x = m_PhysicParam.passiveSpeed.x;
		if( m_PhysicParam.passiveSpeed.y != -1.0f )
			m_PhysicParam.nowSpeed.y = m_PhysicParam.passiveSpeed.y;

		if( NULL != m_pComboManager )
		{
			m_pComboManager->SetMyUnit( IsMyUnit(), this );
			m_pComboManager->OnFrameMove( m_fTime, m_fElapsedTime );
		}
	}

	CommonFrameMoveFuture_TimedEvent();


	if( true == g_pMain->GetGameOption().GetOptionList().m_bPlayGuide && 
		NULL != g_pX2Game &&
		this == g_pX2Game->GetMyUnit() )
	{
		m_fElaspedTimeLastGuideMessage += m_fElapsedTime;

		if( m_pComboGuide != NULL )
		{
			D3DXVECTOR3 vPos = GetPos();
			vPos.x -= 50.f;
			vPos.y -= 30.f;
			D3DXVECTOR2 vPosGuide = g_pKTDXApp->GetProj3DPos(vPos);
			vPosGuide.x /= g_pKTDXApp->GetResolutionScaleX();
			vPosGuide.y /= g_pKTDXApp->GetResolutionScaleY();
			
			m_pComboGuide->SetPos( vPosGuide );
			m_pComboGuide->SetShow( true );
		}
	}
	else
	{
		if( m_pComboGuide != NULL )
		{
			m_pComboGuide->SetShow( false );
		}
	}



	// 이번 프레임의 event process 처리를 위한 준비

#ifdef NEW_SKILL_TREE
	m_bSpecialAttackEventProcessedAtThisFrame = false;
#endif NEW_SKILL_TREE

	m_FrameDataFuture.syncData.nowAction = UAI_NONE;
}




void CX2GUUser::CommonFrameMoveFuture_ExtraDamage()
{
#if defined( _SERVICE_ ) 
	ELSWORD_VIRTUALIZER_START
#endif

	//특수데미지 체크
	if( m_ExtraDamagePack.m_Poison.m_fTime > 0.0f && GetNowHp() > 0.0f )
	{
		float fBeforeHP = GetNowHp();
		UpNowHp( -1.0f * m_ExtraDamagePack.m_Poison.m_DamagePerSec * m_fElapsedTime );

		if( fBeforeHP > 0.0f && GetNowHp() < 1.0f )
			SetNowHp( 1.0f );
	}

	if( m_ExtraDamagePack.m_Fire.m_fTime > 0.0f && GetNowHp() > 0.0f )
	{
		float fBeforeHP = GetNowHp();
		UpNowHp( -1.0f * m_ExtraDamagePack.m_Fire.m_DamagePerSec * m_fElapsedTime );

		if( fBeforeHP > 0.0f && GetNowHp() < 1.0f )
			SetNowHp( 1.0f );

		if ( IsMyUnit() )
			CX2GageManager::GetInstance()->CrashMyStateGageUI( D3DXVECTOR2( -7, -7 ), D3DXVECTOR2( 7, 7 ), D3DXCOLOR( 1, 0, 0, 1) );
	}

	if( m_ExtraDamagePack.m_Lightning.m_fTime > 0.0f && GetNowHp() > 0.0f )
	{
		float fBeforeHP = GetNowHp();
		UpNowHp( -1.0f * m_ExtraDamagePack.m_Lightning.m_DamagePerSec * m_fElapsedTime );

		if( fBeforeHP > 0.0f && GetNowHp() < 1.0f )
			SetNowHp( 1.0f );

		if ( IsMyUnit() )
			CX2GageManager::GetInstance()->CrashMyStateGageUI( D3DXVECTOR2( -7, -7 ), D3DXVECTOR2( 7, 7 ), D3DXCOLOR( 1, 0, 0, 1) );
	}
	if( m_ExtraDamagePack.m_Cold.m_fTime > 0.0f && GetNowHp() > 0.0f )
	{
		float fBeforeHP = GetNowHp();
		UpNowHp( -1.0f * m_ExtraDamagePack.m_Cold.m_DamagePerSec * m_fElapsedTime );

		if( fBeforeHP > 0.0f && GetNowHp() < 1.0f )
			SetNowHp( 1.0f );

		if ( IsMyUnit() )
			CX2GageManager::GetInstance()->CrashMyStateGageUI( D3DXVECTOR2( -7, -7 ), D3DXVECTOR2( 7, 7 ), D3DXCOLOR( 0, 0, 1, 1) );
	}


	if( m_ExtraDamagePack.m_Curse.m_fTime > 0.0f && GetNowHp() > 0.0f )
	{
		FlushMp( m_ExtraDamagePack.m_Curse.m_DamagePerSec * m_fElapsedTime );
	}

	if( m_ExtraDamagePack.m_Frozen.m_fTime > 0.0f && GetNowHp() > 0.0f )
	{
		float fBeforeHP = GetNowHp();
		UpNowHp( -1.0f * m_ExtraDamagePack.m_Fire.m_DamagePerSec * m_fElapsedTime );

		if( fBeforeHP > 0.0f && GetNowHp() < 1.0f )
			SetNowHp( 1.0f );

		if ( IsMyUnit() )
			CX2GageManager::GetInstance()->CrashMyStateGageUI( D3DXVECTOR2( -7, -7 ), D3DXVECTOR2( 7, 7 ), D3DXCOLOR( 0, 0, 1, 1) );
	}

#if defined( _SERVICE_ ) 
	ELSWORD_VIRTUALIZER_END
#endif

}

void CX2GUUser::CommonFrameMoveFuture_TimedEvent()
{
	for( int i = 0; i < (int)m_StopAllList.size(); i++ )
	{
		D3DXVECTOR3 stopTime = m_StopAllList[i];
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        if( m_pXSkinAnimFuture->EventTimerOneshot( stopTime.x ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		if( m_pXSkinAnimFuture->EventTimer( stopTime.x ) == true && EventCheck( stopTime.x, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		{
			switch ( g_pX2Game->GetGameType() )
			{
			case CX2Game::GT_DUNGEON:
			case CX2Game::GT_BATTLE_FIELD:
				g_pX2Game->StopAllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 800.0f, this, stopTime.z );
				g_pX2Game->StopAllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 700.0f, this, stopTime.z );
				break;

			case CX2Game::GT_PVP:
				g_pX2Game->StopAllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 2000.0f, this, stopTime.z );
				g_pX2Game->StopAllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 1300.0f, this, stopTime.z );
				break;

			default:
				ASSERT( !L"wrong path" );
				break;
			}
		}
	}
	for( int i = 0; i < (int)m_Stop2AllList.size(); i++ )
	{
		D3DXVECTOR3 stopTime = m_Stop2AllList[i];
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        if( m_pXSkinAnimFuture->EventTimerOneshot( stopTime.x ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		if( m_pXSkinAnimFuture->EventTimer( stopTime.x ) == true && EventCheck( stopTime.x, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		{
			switch ( g_pX2Game->GetGameType() )
			{
			case CX2Game::GT_DUNGEON:
			case CX2Game::GT_BATTLE_FIELD:
				g_pX2Game->Stop2AllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 800.0f, this, stopTime.z );
				g_pX2Game->Stop2AllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 700.0f, this, stopTime.z );
				break;

			case CX2Game::GT_PVP:
				g_pX2Game->Stop2AllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 2000.0f, this, stopTime.z );
				g_pX2Game->Stop2AllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 1300.0f, this, stopTime.z );
				break;

			default:
				ASSERT( !L"wrong path" );
				break;
			}
		}
	}
	for( int i = 0; i < (int)m_StopMyList.size(); i++ )
	{
		D3DXVECTOR2 stopTime = m_StopMyList[i];
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        if( m_pXSkinAnimFuture->EventTimerOneshot( stopTime.x ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		if( m_pXSkinAnimFuture->EventTimer( stopTime.x ) == true && EventCheck( stopTime.x, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		{
			SetStopTime( stopTime.y );
		}
	}
	for( int i = 0; i < (int)m_Stop2MyList.size(); i++ )
	{
		D3DXVECTOR2 stopTime = m_Stop2MyList[i];
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        if( m_pXSkinAnimFuture->EventTimerOneshot( stopTime.x ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		if( m_pXSkinAnimFuture->EventTimer( stopTime.x ) == true && EventCheck( stopTime.x, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		{
			SetStop2Time( stopTime.y );
		}
	}
}


void CX2GUUser::CommonFrameMove()
{
//#ifndef SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//	++m_dwFrameMoveCountNow;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

	KTDXPROFILE();

#ifdef RIDING_SYSTEM
	if ( GetNowStateID() == USI_RIDING_WAIT && m_ePlayedEmotion == CX2Unit::ET_NONE  )
    {
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        m_ElapsedTimeRidingWaitHabit.OnFrameMove( m_fElapsedTime );
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_ElapsedTimeRidingWaitHabit.OnFrameMove();
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    }
#endif //RIDING_SYSTEM

	DoDelegateProcessInCommonFrameMove();

#ifdef DIALOG_SHOW_TOGGLE
	if( m_hSeqHeadMarker != INVALID_PARTICLE_SEQUENCE_HANDLE)
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeqHeadMarker    = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqHeadMarker );
		if( pSeqHeadMarker != NULL )
		{
			if( g_pKTDXApp->GetDGManager()->GetDialogManager()->GetHideDialog() == true )
				pSeqHeadMarker->SetShowObject(false);
			else
				pSeqHeadMarker->SetShowObject(true);
		}
	}


	if( m_hSeqEmblem != INVALID_PARTICLE_SEQUENCE_HANDLE)
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem		   = g_pData->GetUIMajorParticle()->GetInstanceSequence( m_hSeqEmblem );

		if( pSeqEmblem != NULL )
		{
#ifdef	FIXED_EMBLEM_HIDE_WHEN_DIE
			bool bIsEmblemShow = true;			// 칭호를 숨겨야 하는가?
			//
			if ( true == g_pKTDXApp->GetDGManager()->GetDialogManager()->GetHideDialog() ) // 스크린샷 모드 인가?
			{
				bIsEmblemShow = false;			 
			}
			else if ( CX2GameUnit::GUSI_DIE == GetGameUnitState () ) // 유닛의 State 가 죽은 상태라면..
			{
				bIsEmblemShow = false;
			}
			pSeqEmblem->SetShowObject( bIsEmblemShow );		

#else	// FIXED_EMBLEM_HIDE_WHEN_DIE
			if( g_pKTDXApp->GetDGManager()->GetDialogManager()->GetHideDialog() == true )
				pSeqEmblem->SetShowObject(false);
			else
				pSeqEmblem->SetShowObject(true);
#endif  // FIXED_EMBLEM_HIDE_WHEN_DIE
		}
	}
	

	
	
#endif

#ifdef NEW_SKILL_TREE

	GetUnit()->AccessUnitData().m_UserSkillTree.OnFrameMove( m_fTime, m_fElapsedTime );

	if( m_SkillRelatedData.m_fSkillCoolTimeLeft_SI_P_COMMON_SOFTBODY > 0.f )
	{
		m_SkillRelatedData.m_fSkillCoolTimeLeft_SI_P_COMMON_SOFTBODY -= m_fElapsedTime;
		if( m_SkillRelatedData.m_fSkillCoolTimeLeft_SI_P_COMMON_SOFTBODY < 0.f )
			m_SkillRelatedData.m_fSkillCoolTimeLeft_SI_P_COMMON_SOFTBODY = 0.f;
	}

#ifdef DUNGEON_ITEM
	if( m_fSuperArmorByItem > 0.f )
	{
		m_fSuperArmorByItem -= m_fElapsedTime;
		if( m_fSuperArmorByItem <= 0.f )
		{
			m_bSuperArmorByItem = false;
			m_fSuperArmorByItem = 0.f;
		}
	}	
#endif


#ifdef SKILL_CASH_10_TEST
	// Drain Particle
	if( m_hSeqDrainParticle != INVALID_PARTICLE_SEQUENCE_HANDLE &&
		null != m_optrLastAttackUnit && 
		CX2GameUnit::GUT_USER == m_optrLastAttackUnit->GetGameUnitType() )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqDrainParticle );
		if( NULL != pSeq )
		{					
			D3DXVECTOR3 pos = m_optrLastAttackUnit->GetWeaponBonePos( 0, L"TRACE_START0", 0 );
			pos.y += 60.0f;
			pSeq->SetBlackHolePosition( pos );
			if( pSeq->GetTime() > 1.5f )
			{
				pSeq->SetGravity( CMinMax<D3DXVECTOR3>(D3DXVECTOR3(0.0f, 0.0f, 0.0f), D3DXVECTOR3(0.0f, 0.0f, 0.0f)) );
				pSeq->SetUseLand( false );
			}
		}
		else
		{
			m_hSeqDrainParticle = INVALID_PARTICLE_SEQUENCE_HANDLE;
		}
	}
#endif

#endif NEW_SKILL_TREE

#ifdef SERV_PET_SYSTEM
	if( m_petCheer.m_fTime > 0.f )
	{
		if( GetNowHp() <= 0.f )
			m_petCheer.m_fTime = 0.f;

		m_petCheer.m_fTime -= m_fElapsedTime;
			
		if( m_petCheer.m_fTime <= 0.f && m_petCheer.m_fChangeHp > 0.f )
		{
			m_petCheer.m_fTime = 0.f;

			SetMaxHp( GetMaxHp() / m_petCheer.m_fChangeHp );
			
			if( GetNowHp() > GetMaxHp() )
			{
				SetNowHp( GetMaxHp() );			
			}
			
			m_petCheer.Init();
		}
		else if( m_petCheer.m_fTime > 0.f && m_petCheer.m_fChargeHp > 0.f )
		{
			SetNowHp( GetNowHp() + (GetMaxHp() * m_petCheer.m_fChargeHp * m_fElapsedTime) );
			if( GetNowHp() > GetMaxHp() )
			{
				SetNowHp( GetMaxHp() );			
			}
		}
	}
#endif
	
	if( m_pXSkinAnimFuture != NULL )
	{
#ifdef RIDING_SYSTEM
		if ( true == GetRidingOn() && NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimPtr() )
			CommonFrameMove_EffectSet( m_ptrRidingPet->GetXSkinAnimPtr()->GetNowAnimationTime() );
		else
			CommonFrameMove_EffectSet( m_pXSkinAnim->GetNowAnimationTime() );
#else //RIDING_SYSTEM
		CommonFrameMove_EffectSet( m_pXSkinAnim->GetNowAnimationTime() );
#endif //RIDING_SYSTEM 이펙트 시간 탈 것으로 적용하기
	}




#ifdef EQUIP_STRIP_TEST
	//{{AFX
	if( m_fTimeLeftToClearOutSuccessiveHit > 0.f )
	{
		m_fTimeLeftToClearOutSuccessiveHit -= m_fElapsedTime;
		if( m_fTimeLeftToClearOutSuccessiveHit <= 0.f )
		{
			m_fTimeLeftToClearOutSuccessiveHit = 0.f;
			m_iSuccessiveHitCount = 0;
		}
	}
	//}}AFX
#endif EQUIP_STRIP_TEST

	if( m_FrameDataFuture.syncData.nowState == GUSI_DIE )
	{
		return;
	}

	NoStateChangeActionFrameMove();

#ifdef UNIT_EMOTION
	EmotionFrameMove();
#endif

#ifdef DUNGEON_ITEM
	bool bSuperArmor = m_bSocketSuperArmor || m_bSuperArmorByItem;
	if( m_fSocketSuperArmor <= 0.f )
		m_bSocketSuperArmor = false;
	if( m_fSuperArmorByItem <= 0.f )
		m_bSuperArmorByItem = false;	

	if( m_bSocketSuperArmor == false && m_bSuperArmorByItem == false )
	{
		if( m_bStateSuperArmor == false )
			m_FrameDataNow.stateParam.bSuperArmor = false;
	}
	else
	{
		if( m_bStateSuperArmor == false )
			m_FrameDataNow.stateParam.bSuperArmor = true;
	}

#else
	if(m_fSocketSuperArmor <= 0.f)
	{
		if(m_bSocketSuperArmor == true && IsSuperArmor() )
			m_FrameDataNow.stateParam.bSuperArmor = false;
		m_bSocketSuperArmor = false;			
	}
#endif

#ifdef SUPER_ARMOR_TIME
	float fAnimTime = -1.f;
	if( m_pXSkinAnim != NULL )
		fAnimTime = m_pXSkinAnim->GetNowAnimationTime();

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    const std::vector<D3DXVECTOR2>& vecSuperArmorTime = m_vecNowSuperArmorTime;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    const std::vector<D3DXVECTOR2>& vecSuperArmorTime = m_FrameDataNow.stateParam.m_vecSuperArmorTime;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	for(UINT iSuperArmorTime=0; iSuperArmorTime < vecSuperArmorTime.size(); ++iSuperArmorTime)
	{
		const D3DXVECTOR2& superArmorTime = vecSuperArmorTime[iSuperArmorTime];				
		if( fAnimTime >= superArmorTime.x && fAnimTime <= superArmorTime.y )
		{
			m_FrameDataNow.stateParam.bSuperArmor = true;
			break;
		}
	}
#endif
	//#ifdef HEAVY_LOG_TEST
	//	const CKTDXCollision::CollisionDataListSet& subatkList = GetSubAttackListSet();
	//	if( subatkList.size() > 0 )
	//	{
	//		std::set<const CKTDXCollision::CollisionDataList*>::const_iterator it = subatkList.begin();
	//		const CKTDXCollision::CollisionDataList* pColList = *it;
	//		if( pColList->size() == 0 )
	//		{
	//			ASSERT( !"impossible" );
	//		}
	//	}
	//#endif HEAVY_LOG_TEST

//#ifdef  X2OPTIMIZE_USER_PASS_PUSH_UNIT_TIME_BUG_FIX
    {
        float   fNowAnimTime = fAnimTime;
#ifdef RIDING_SYSTEM
	        if ( true == GetRidingOn() && NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimPtr() )
		        fNowAnimTime = m_ptrRidingPet->GetXSkinAnimPtr()->GetNowAnimationTime();
#endif //RIDING_SYSTEM


#ifdef RAVEN_SECOND_CLASS_CHANGE
	    // 스크립트 상에서 canPassUnit, canPushUnit을 시간대별로 지정해 줄수 있도록 한다.
	    if( m_pXSkinAnim != NULL && m_vecCanPushUnitNow.size() > 0)
	    {		
		    for(UINT i=0; i<m_vecCanPushUnitNow.size(); ++i)
		    {
			    TIME_PUSHPASS canPushUnitTime = m_vecCanPushUnitNow[i];

			    if( canPushUnitTime.fTime <= fNowAnimTime )
			    {				
				    m_FrameDataNow.stateParam.bCanPushUnit = canPushUnitTime.bCan;
				    m_vecCanPushUnitNow.erase(m_vecCanPushUnitNow.begin() + i);
				    --i;
			    }
		    }
	    }
	    if( m_pXSkinAnim != NULL && m_vecCanPassUnitNow.size() > 0)
	    {		
		    for(UINT i=0; i<m_vecCanPassUnitNow.size(); ++i)
		    {
			    TIME_PUSHPASS canPassUnitTime = m_vecCanPassUnitNow[i];

			    if( canPassUnitTime.fTime <= fNowAnimTime )
			    {				
				    m_FrameDataNow.stateParam.bCanPassUnit = canPassUnitTime.bCan;
				    m_vecCanPassUnitNow.erase(m_vecCanPassUnitNow.begin() + i);
				    --i;
			    }
		    }
	    }
#endif
    }
//#endif  X2OPTIMIZE_USER_PASS_PUSH_UNIT_TIME_BUG_FIX



//#ifdef LINEMAP_FAST_WIND_TEST
//	if( true == m_bEnableUpsideWind )
//	{
//		if( true == m_bWaitInTheAir )
//		{
//			if( m_fTimeInTheAir > 0.f )
//			{
//				m_fTimeInTheAir -= m_fElapsedTime;
//			}
//			else if( m_fTimeInTheAir < 0.f )
//			{
//				m_fTimeInTheAir = 0.f;
//			}
//		}
//	}
//#endif LINEMAP_FAST_WIND_TEST



	m_bUpMPThisFrame = false;

	m_FrameDataNow.unitCondition.fStateTimeBack	= m_FrameDataNow.unitCondition.fStateTime;
	m_FrameDataNow.unitCondition.fStateTime		+= m_fElapsedTime;

#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	map<float,bool>::iterator iter;
	for( iter = m_EventTimeStampNow.begin(); iter != m_EventTimeStampNow.end(); iter++ )
	{
		iter->second = true;
	}
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

	KTDXPROFILE_BEGIN( "ANIM" );



#ifdef GRAPPLING_TEST
	if( true == IsGrappled( false ) )
	{
		GrappledPhysicProcess( false );
	}
#endif GRAPPLING_TEST


#ifdef USER_HOLD
	if(GetHold() == true)
	{
		m_FrameDataNow.syncData.position = m_vHold;
	}
#endif

#ifdef TEST_GROUP_GRAP
	if ( GetGrap() == true )
	{
		m_FrameDataNow.syncData.position = m_vGrap;
	}
#endif TEST_GROUP_GRAP

#ifdef RIDING_SYSTEM
	if ( true == GetRidingOn() && GetNowStateID() != USI_RIDING_DIE )
		m_pXSkinAnim->GetMatrix().Move( GetSaddlePos() );
	else
		m_pXSkinAnim->GetMatrix().Move( m_FrameDataNow.syncData.position );
#else //RIDING_SYSTEM
	m_pXSkinAnim->GetMatrix().Move( m_FrameDataNow.syncData.position );
#endif //RIDING_SYSTEM 탈 것 위치 적용하기


#ifdef GRAPPLING_TEST
	CX2GameUnit* pGrappler = GetUnitGrapplingMe( false );
	if( NULL != pGrappler )
	{
		m_pXSkinAnim->GetMatrix().RotateDegree( pGrappler->GetUnitCondition( false ).m_GrapplingState.GetGrapplingRotation() );
	}
	else
#endif GRAPPLING_TEST
	{
#ifdef REVERSE_GRAVITY_TEST  // oasis907 : 김상윤 [2011.6.29] 
		if(m_fReverseGravitySpeedDeltaY == 0.f)
#ifdef RIDING_SYSTEM
			if ( true == GetRidingOn() && GetNowStateID() != USI_RIDING_DIE )
				m_pXSkinAnim->GetMatrix().RotateDegree( GetSaddleDegree() );
			else
#endif //RIDING_SYSTEM 탈 것 회전값 적용하기
				m_pXSkinAnim->GetMatrix().RotateDegree( m_FrameDataNow.unitCondition.dirDegree );
#else
		m_pXSkinAnim->GetMatrix().RotateDegree( m_FrameDataNow.unitCondition.dirDegree );
#endif REVERSE_GRAVITY_TEST
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    bool    bXSkinAnimOnFrameMoveCalled = false;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_FrameDataNow.syncData.bFrameStop == false )
	{
		if( m_bPopAgain == false )
		{
			m_pXSkinAnim->OnFrameMove( m_fTime, m_fElapsedTime 
#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                * m_AdvanceTimeCount 
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                );
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            bXSkinAnimOnFrameMoveCalled = true;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

//#ifdef HEAD_INVERSE_KINEMATICS_TEST
//
//			if( g_pMain->GetGameOption().GetOptionList().m_UnitDetail == CX2GameOption::OL_HIGH )
//			{
//				HeadIKFrameMove( m_fTime, m_fElapsedTime );
//			}
//
//#endif HEAD_INVERSE_KINEMATICS_TEST


#ifdef RENA_SIEGE_MODE_ANGLE_TEST
			if( true == m_bEnableLookAtIK_Spine )
			{
				
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame = m_pXSkinAnim->GetCloneFrame( L"Bip01_Spine1" );
				LookAtIKFrameMove( pFrame, D3DXVECTOR3( 0, 0, -1 ), m_fLookAtIKAngle_Spine );
			}
#endif RENA_SIEGE_MODE_ANGLE_TEST

			if( m_bRotateBone == true )
			{
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame = m_pXSkinAnim->GetCloneFrame( L"Bip01_Spine1" );
				RotateBone( pFrame, D3DXVECTOR3( 0, 0, -1 ), m_fRotateBoneDegree );				
			}


			for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
			{
				CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];
				if ( pCX2Eqip == NULL )
					continue;

				//{{ robobeg : 2008-10-17
				//pCX2Eqip->OnFrameMove( m_fTime, m_fElapsedTime * m_AdvanceTimeCount, m_pXSkinAnim->GetRenderParam() );
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				pCX2Eqip->SetRenderParam( m_fTime, m_fElapsedTime , m_pXSkinAnim->GetRenderParam() );
				pCX2Eqip->OnFrameMove( m_fTime, m_fElapsedTime );
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				pCX2Eqip->SetRenderParam( m_fTime, m_fElapsedTime 
                    * m_AdvanceTimeCount, 
                    m_pXSkinAnim->GetRenderParam() );
				pCX2Eqip->OnFrameMove( m_fTime, m_fElapsedTime * m_AdvanceTimeCount );
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				//}} robobeg : 2008-10-17


				if ( pCX2Eqip->GetItem() != NULL && 
                    pCX2Eqip->GetItem()->GetItemTemplet() != NULL 
                    )
				{
					CX2Unit::EQIP_POSITION Epos = pCX2Eqip->GetItem()->GetItemTemplet()->GetEqipPosition();
					bool bFashion = pCX2Eqip->GetItem()->GetItemTemplet()->GetFashion();
					if( bFashion == true )
					{
						CX2Item* pTempItem = GetUnit()->GetInventory().GetEquippingItemByEquipPos( pCX2Eqip->GetItem()->GetItemTemplet()->GetEqipPosition(), false );

						//{{ kimhc // 실시간 엘소드 중 실시간 내구도 감소
#ifdef	REAL_TIME_ELSWORD
						if( pTempItem != NULL && pCX2Eqip->GetEnchantLevel() != pTempItem->GetItemData().m_EnchantLevel && 
							( ( pTempItem->GetItemData().m_PeriodType == CX2Item::PT_ENDURANCE && pTempItem->GetItemData().m_Endurance > 0) ||
								pTempItem->GetItemData().m_PeriodType == CX2Item::PT_INFINITY ) )
						{
							pCX2Eqip->ChangeEnchantLevel( pTempItem->GetItemData().m_EnchantLevel );
						}


						if( pCX2Eqip->GetEnchantLevel() != 0 )
						{
							if ( pTempItem == NULL || 
								( pTempItem != NULL && 
									pTempItem->GetItemData().m_PeriodType == CX2Item::PT_ENDURANCE && pTempItem->GetItemData().m_Endurance <= 0 ) )
								pCX2Eqip->ChangeEnchantLevel( 0 );
						}
#else	REAL_TIME_ELSWORD
						if( pTempItem != NULL && pCX2Eqip->GetEnchantLevel() != pTempItem->GetItemData().m_EnchantLevel )
						{
							pCX2Eqip->ChangeEnchantLevel( pTempItem->GetItemData().m_EnchantLevel );
						}
						if( pCX2Eqip->GetEnchantLevel() != 0 && pTempItem == NULL )
						{
							pCX2Eqip->ChangeEnchantLevel( 0 );
						}
#endif	REAL_TIME_ELSWORD
						//}} kimhc // 실시간 엘소드 중 실시간 내구도 감소
					}
				}
			}

#ifdef SHOOTING_TEST
//{{AFX

			if( NULL != g_pData->GetMyUser() &&
				g_pData->GetMyUser()->GetAuthLevel() >= CX2User::XUAL_OPERATOR &&
				g_pMain->GetShootingLevel() > 0 )
			{
				const int MAGIC_RANGE = g_pMain->GetShootingLevel();
				const float MAGIC_DEGREE = 3.f + (float) MAGIC_RANGE;

				const float MAGIC_GUN_FIRE_COOL_TIME = 0.1f;
				if( true == m_InputData.pureD && 
					m_TimerGunFireCooling.elapsed() > MAGIC_GUN_FIRE_COOL_TIME &&
					GetNowHp() > 0.f )
				{
					m_TimerGunFireCooling.restart();

					float fSinDegree = sinf( (float) g_pKTDXApp->GetTime() * 4.f ) * (10.f + 6.f * (float) MAGIC_RANGE);
					float fRandomDegree = 0.f;
					float fRandomX = 0.f, fRandomY = 0.f, fRandomZ = 0.f;
					for( int i=0; i<MAGIC_RANGE; i++ )
					{
						fRandomDegree = (float) (rand() % 10 ) / 10.f;
						fRandomDegree += (float) i * MAGIC_DEGREE;

						fRandomX = (float) ( rand() % 50 );
						fRandomY = (float) ( rand() % 10 );
						fRandomZ = (float) ( rand() % 50 ) / 10.f;

						g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*)this, L"MACHINE_GUN_STRAIGHT", GetPowerRate(), 
							GetBonePos( L"Bip01_Spine1" ) + D3DXVECTOR3( fRandomX, fRandomY, fRandomZ ),
							GetRotateDegree() + D3DXVECTOR3(0, 0, fRandomDegree + fSinDegree),
							GetRotateDegree() + D3DXVECTOR3(0, 0, fRandomDegree + fSinDegree), GetLandPosition().y );

						g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*)this, L"MACHINE_GUN_STRAIGHT", GetPowerRate(), 
							GetBonePos( L"Bip01_Spine1" ) + D3DXVECTOR3( -fRandomX, -fRandomY, -fRandomZ ),
							GetRotateDegree() + D3DXVECTOR3(0, 0, -fRandomDegree + fSinDegree), 
							GetRotateDegree() + D3DXVECTOR3(0, 0, -fRandomDegree + fSinDegree), GetLandPosition().y );
					}
				}


				const float MAGIC_GRENADE_FIRE_COOL_TIME = 1.f;
				if( true == m_InputData.pureD && 
					m_TimerGunFireCooling.elapsed() > MAGIC_GRENADE_FIRE_COOL_TIME &&
					GetNowHp() > 0.f )
				{
					m_TimerGunFireCooling.restart();
					float fRandomDegree = 0.f;

					g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*)this, L"CANNONFORT_PARASITE_LASER", GetPowerRate(), 
						GetBonePos( L"Bip01_Spine1" ) + D3DXVECTOR3( 0.f, (float)(rand() % 70 - 35 ), 0.f ),
						GetRotateDegree() + D3DXVECTOR3(0, 0, fRandomDegree), GetRotateDegree() + D3DXVECTOR3(0, 0, fRandomDegree), GetLandPosition().y );

				}
			}
//}}AFX

#endif SHOOTING_TEST

		}		
	}	
	KTDXPROFILE_END();
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( bXSkinAnimOnFrameMoveCalled == false )
    {
        m_pXSkinAnim->UpdateBeforeAnimationTime();
    }
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE






	CKTDGParticleSystem::CParticleEventSequence* pSeq_Poison		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqPoisonBody );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Fire1 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqFireBody1 );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Fire2 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqFireBody2 );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Curse 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCurseBody );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_SlowRight 	= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqSlowBodyRight );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_SlowLeft  	= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqSlowBodyLeft  );

	CKTDGParticleSystem::CParticleEventSequence* pSeq_Cold_Head		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCold_Head );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Cold1L  		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCold1  );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Cold2L  		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCold2  );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Cold1R  		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCold1_Right  );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Cold2R  		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCold2_Right  );

	CKTDGParticleSystem::CParticleEventSequence* pSeq_Pepper1 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqPepperBody1  );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Pepper2 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqPepperBody2  );

	CKTDGParticleSystem::CParticleEventSequence* pSeq_Stun 			= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqStun  );





	CKTDGParticleSystem::CParticleEventSequence* pSeq_Enchant_Stun				= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Stun  );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Enchant_Stun_Second		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Stun_Second  );

	/// Old Blaze
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Enchant_Blaze_Second		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Blaze_Second  );
	/// Old Blaze
	
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Enchant_Frozen_Second		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Frozen_Second  );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Enchant_Poison_Second		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Poison_Second  );

	CKTDGParticleSystem::CParticleEventSequence* pSeq_Enchant_Exclamation		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Exclamation  );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Enchant_Exclamation2		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Exclamation2  );
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Enchant_Exclamation3		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Exclamation3  );

#ifdef SERV_RENA_NIGHT_WATCHER
	/// EDT 이모티콘
	CKTDGParticleSystem::CParticleEventSequence* pSeq_Enchant_ArrowOfExplosion  = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_ArrowOfExplosion );

	/// 중첩수 이모티콘
	CKTDGParticleSystem::CParticleEventSequence* pSeq_StartOfDelayedFiringOverlap  = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hStartOfDelayedFiringOverlap );
#endif SERV_RENA_NIGHT_WATCHER

	D3DXVECTOR3 poisonBodyEffPos = GetPos();
	poisonBodyEffPos.y += 100.0f;
	if( pSeq_Poison != NULL )
		pSeq_Poison->SetPosition( poisonBodyEffPos );
	if( pSeq_Curse != NULL )
		pSeq_Curse->SetPosition( poisonBodyEffPos );

	D3DXVECTOR3 vEmoticonPos = GetPos() + D3DXVECTOR3( 0, 250.f, 0 ) - 40.f * GetZVector();

#ifdef SERV_RENA_NIGHT_WATCHER
	D3DXVECTOR3 vOverlapEmoticonPos = GetPos() + D3DXVECTOR3( 0, 310.f, 0 ) - 40.f * GetZVector();	/// 중첩된 EDT 횟수 표시 이모티콘 위치

	vOverlapEmoticonPos += 50.f * m_FrameDataNow.unitCondition.dirVector;
#endif SERV_RENA_NIGHT_WATCHER

	if( pSeq_Cold_Head != NULL )
		pSeq_Cold_Head->SetPosition( vEmoticonPos );



	if( pSeq_Enchant_Stun != NULL )
		pSeq_Enchant_Stun->SetPosition( vEmoticonPos );

	if( pSeq_Enchant_Exclamation != NULL )
	{
#ifdef MODIFY_OVERLAP_EDT_EMOTICON
		pSeq_Enchant_Exclamation->SetPosition( vOverlapEmoticonPos );
#else
		D3DXVECTOR3 vExclamationPos = vEmoticonPos;
		vExclamationPos.y += 75;
		pSeq_Enchant_Exclamation->SetPosition( vExclamationPos );
#endif //MODIFY_OVERLAP_EDT_EMOTICON
	}

	if( pSeq_Enchant_Exclamation2 != NULL )
	{
#ifdef MODIFY_OVERLAP_EDT_EMOTICON
		pSeq_Enchant_Exclamation2->SetPosition( vOverlapEmoticonPos );
#else
		D3DXVECTOR3 vExclamationPos = vEmoticonPos;
		vExclamationPos.y += 75;
		pSeq_Enchant_Exclamation2->SetPosition( vExclamationPos );
#endif //MODIFY_OVERLAP_EDT_EMOTICON
	}

	if( pSeq_Enchant_Exclamation3 != NULL )
	{
#ifdef MODIFY_OVERLAP_EDT_EMOTICON
		pSeq_Enchant_Exclamation3->SetPosition( vOverlapEmoticonPos );
#else
		D3DXVECTOR3 vExclamationPos = vEmoticonPos;
		vExclamationPos.y += 75;
		pSeq_Enchant_Exclamation3->SetPosition( vExclamationPos );
#endif //MODIFY_OVERLAP_EDT_EMOTICON
	}

	if ( m_ExtraDamagePack.m_EnchantBlaze.m_Accumulation >= 2 ||
		m_ExtraDamagePack.m_EnchantPoison.m_Accumulation >= 2 ||
		m_ExtraDamagePack.m_EnchantFrozen.m_Accumulation >= 2 )
	{
		if( m_hSeqEnchant_Exclamation3 == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
#ifdef MODIFY_OVERLAP_EDT_EMOTICON
			m_hSeqEnchant_Exclamation3 = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Overlap_EDT_Emoticon_3", 0,0,0 );
#else
			m_hSeqEnchant_Exclamation3 = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Enchant_Exclamation_Emoticon3", 0,0,0 );
#endif //MODIFY_OVERLAP_EDT_EMOTICON
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
            pSeq_Enchant_Exclamation3		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Exclamation3  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }

		if( pSeq_Enchant_Exclamation3 != NULL )
		{
			pSeq_Enchant_Exclamation3->SetEmitRate( 20, 20 );
		}


		if ( pSeq_Enchant_Exclamation != NULL )
		{
			pSeq_Enchant_Exclamation->ClearAllParticle();
			pSeq_Enchant_Exclamation->SetEmitRate( 0, 0 );
		}

		if ( pSeq_Enchant_Exclamation2 != NULL )
		{
			pSeq_Enchant_Exclamation2->ClearAllParticle();
			pSeq_Enchant_Exclamation2->SetEmitRate( 0, 0 );
		}

	}
	else if ( m_ExtraDamagePack.m_EnchantBlaze.m_Accumulation >= 1 ||
		m_ExtraDamagePack.m_EnchantPoison.m_Accumulation >= 1 ||
		m_ExtraDamagePack.m_EnchantFrozen.m_Accumulation >= 1 )
	{
		if( m_hSeqEnchant_Exclamation2 == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
#ifdef MODIFY_OVERLAP_EDT_EMOTICON
			m_hSeqEnchant_Exclamation2 = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Overlap_EDT_Emoticon_2", 0,0,0 );
#else
			m_hSeqEnchant_Exclamation2 = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Enchant_Exclamation_Emoticon2", 0,0,0 );
#endif //MODIFY_OVERLAP_EDT_EMOTICON
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Enchant_Exclamation2		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Exclamation2  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }

		if( pSeq_Enchant_Exclamation2 != NULL )
		{
			pSeq_Enchant_Exclamation2->SetEmitRate( 20, 20 );
		}

		if( pSeq_Enchant_Exclamation3 != NULL )
		{
			pSeq_Enchant_Exclamation3->ClearAllParticle();
			pSeq_Enchant_Exclamation3->SetEmitRate( 0, 0 );
		}

		if ( pSeq_Enchant_Exclamation != NULL )
		{
			pSeq_Enchant_Exclamation->ClearAllParticle();
			pSeq_Enchant_Exclamation->SetEmitRate( 0, 0 );
		}

	}
	else if ( m_ExtraDamagePack.m_EnchantBlaze.m_fTime > 0 ||
		m_ExtraDamagePack.m_EnchantPoison.m_fTime > 0 ||
		m_ExtraDamagePack.m_EnchantFrozen.m_fTime > 0  )
	{
		if( m_hSeqEnchant_Exclamation == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
#ifdef MODIFY_OVERLAP_EDT_EMOTICON
			m_hSeqEnchant_Exclamation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( static_cast<CKTDGObject*>(this),  L"Overlap_EDT_Emoticon_1", 0,0,0 );
#else
			m_hSeqEnchant_Exclamation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Enchant_Exclamation_Emoticon", 0,0,0 );
#endif //MODIFY_OVERLAP_EDT_EMOTICON
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Enchant_Exclamation		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Exclamation  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }

		if ( pSeq_Enchant_Exclamation != NULL )
		{
			pSeq_Enchant_Exclamation->SetEmitRate( 20, 20 );
		}

		if ( pSeq_Enchant_Exclamation2 != NULL )
		{
			pSeq_Enchant_Exclamation2->ClearAllParticle();
			pSeq_Enchant_Exclamation2->SetEmitRate( 0, 0 );
		}

		if( pSeq_Enchant_Exclamation3 != NULL )
		{
			pSeq_Enchant_Exclamation3->ClearAllParticle();
			pSeq_Enchant_Exclamation3->SetEmitRate( 0, 0 );
		}
	}
	else
	{

		if ( pSeq_Enchant_Exclamation != NULL )
		{
			pSeq_Enchant_Exclamation->ClearAllParticle();
			pSeq_Enchant_Exclamation->SetEmitRate( 0, 0 );
		}

		if ( pSeq_Enchant_Exclamation2 != NULL )
		{
			pSeq_Enchant_Exclamation2->ClearAllParticle();
			pSeq_Enchant_Exclamation2->SetEmitRate( 0, 0 );
		}

		if( pSeq_Enchant_Exclamation3 != NULL )
		{
			pSeq_Enchant_Exclamation3->ClearAllParticle();
			pSeq_Enchant_Exclamation3->SetEmitRate( 0, 0 );
		}
	}

	if( NULL != pSeq_Enchant_Blaze_Second )
		pSeq_Enchant_Blaze_Second->SetPosition( vEmoticonPos );

	if( pSeq_Enchant_Frozen_Second != NULL )
		pSeq_Enchant_Frozen_Second->SetPosition( vEmoticonPos );

	if( pSeq_Enchant_Poison_Second != NULL )
		pSeq_Enchant_Poison_Second->SetPosition( vEmoticonPos );

	if( pSeq_Enchant_Stun_Second != NULL )
		pSeq_Enchant_Stun_Second->SetPosition( vEmoticonPos );


	if( pSeq_Stun != NULL )
		pSeq_Stun->SetPosition( vEmoticonPos );

	/// mauntain : 김태환 [2012.05.21] 레나 2차 전직 나이트 와쳐 - 지연의 신호탄
#ifdef SERV_RENA_NIGHT_WATCHER
	if( NULL != pSeq_Enchant_ArrowOfExplosion )		/// EDT 이모티콘
	{
		pSeq_Enchant_ArrowOfExplosion->SetPosition( vEmoticonPos );

		if( false == pSeq_Enchant_ArrowOfExplosion->GetShowObject() )
			pSeq_Enchant_ArrowOfExplosion->SetShowObject( true );
	}

	if( NULL != pSeq_StartOfDelayedFiringOverlap )	/// 중첩 이모티콘
	{
		pSeq_StartOfDelayedFiringOverlap->SetPosition( vOverlapEmoticonPos );

		if( false == pSeq_StartOfDelayedFiringOverlap->GetShowObject() )
			pSeq_StartOfDelayedFiringOverlap->SetShowObject( true );
	}
#endif SERV_RENA_NIGHT_WATCHER


	D3DXVECTOR3 fireBodyEffPos1 = GetPos();
	fireBodyEffPos1.y += 120.0f;
	fireBodyEffPos1.x += 30.0f;
	if( pSeq_Fire1 != NULL )
		pSeq_Fire1->SetPosition( fireBodyEffPos1 );
	D3DXVECTOR3 fireBodyEffPos2 = GetPos();
	fireBodyEffPos2.y += 80.0f;
	fireBodyEffPos2.x -= 20.0f;
	if( pSeq_Fire2 != NULL )
		pSeq_Fire2->SetPosition( fireBodyEffPos2 );

	if( pSeq_Pepper1 != NULL )
		pSeq_Pepper1->SetPosition( fireBodyEffPos1 );
	if( pSeq_Pepper2 != NULL )
		pSeq_Pepper2->SetPosition( fireBodyEffPos2 );

	D3DXVECTOR3 lFoot;
	GetFramePos( &lFoot, m_pFrame_Bip01_L_Foot );
	D3DXVECTOR3 rFoot;
	GetFramePos( &rFoot, m_pFrame_Bip01_R_Foot );

	if( pSeq_SlowRight != NULL )
	{
		pSeq_SlowRight->SetPosition( rFoot );
	}
	if( pSeq_SlowLeft != NULL )
	{
		pSeq_SlowLeft->SetPosition( lFoot );
	}

	if( pSeq_Cold1L != NULL )
	{
		pSeq_Cold1L->SetPosition( lFoot );
	}
	if( pSeq_Cold2L != NULL )
	{
		pSeq_Cold2L->SetPosition( lFoot );
	}
	if( pSeq_Cold1R != NULL )
	{
		pSeq_Cold1R->SetPosition( rFoot );
	}
	if( pSeq_Cold2R != NULL )
	{
		pSeq_Cold2R->SetPosition( rFoot );
	}

	
	
	CommonFrameMove_Particle();

#ifdef SKILL_30_TEST
	CommonFrameMoveStateAbnormality();
#endif SKILL_30_TEST

	if( m_vecFreezePtr.empty() == false || m_vecStunPtr.empty() == false )
	{
		if ( this == g_pX2Game->GetMyUnit() )
			g_pX2Game->SetEnableAllKeyProcess( false );

		if( (m_vecStunPtr.empty() == false && GetNowStateID() != GetDamageGroggyStateID()) 
#ifdef FIX_FORCE_DOWN_AND_DETONATION_BUG
			&& (false == m_pGageData->GetActivateDetonation() && false == m_pGageData->GetActivateForceDown()) 
#endif // FIX_FORCE_DOWN_AND_DETONATION_BUG
			)
		{

#ifdef NOT_CANCEL_BBT_STUN_BY_HIT		/// 스턴이 걸리면 처음엔 무조건 그로기 스테이트로 변경시킨다.
			if( true == m_bChangeGroggyState )
			{
#ifdef RIDING_SYSTEM
				/// 탈것에 탑승시에는 탈것의 스테이트로 전환
				if ( true == GetRidingOn() )
					StateChange( USI_RIDING_DAMAGE_FRONT );
				else
#endif // RIDING_SYSTEM
					StateChange( GetDamageGroggyStateID() );

				m_bChangeGroggyState = false;
			}
			else
#endif NOT_CANCEL_BBT_STUN_BY_HIT
			{
				switch ( GetNowStateID() )
				{
#ifdef NOT_CANCEL_BBT_STUN_BY_HIT		/// 스턴 상태에서도 피격 모션 취할 수 있도록 추가
				case USI_DAMAGE_SMALL_FRONT:
				case USI_DAMAGE_SMALL_BACK:
				case USI_DAMAGE_BIG_FRONT:
				case USI_DAMAGE_BIG_BACK:
				case USI_DAMAGE_STANDUP_FRONT:
				case USI_DAMAGE_STANDUP_BACK:
				case USI_DAMAGE_AIR_SMALL:	
				case USI_DAMAGE_AIR_DOWN:
				case USI_DAMAGE_AIR_DOWN_LANDING:
				case USI_DAMAGE_AIR_FALL:
				case USI_DAMAGE_AIR_UP:
				case USI_DAMAGE_AIR_FLY_FRONT:
				case USI_DAMAGE_AIR_FLY_BACK:
#endif NOT_CANCEL_BBT_STUN_BY_HIT
				case USI_DAMAGE_DOWN_FRONT:
				case USI_DAMAGE_DOWN_BACK:
				case USI_DAMAGE_AIR_DOWN_INVINCIBLE:
#ifdef RIDING_SYSTEM
				case USI_RIDING_DAMAGE_FRONT:
				case USI_RIDING_DAMAGE_BACK:
#endif //RIDING_SYSTEM
					break;

				default:
					{
#ifdef RIDING_SYSTEM
						/// 탈것에 탑승시에는 탈것의 스테이트로 전환
						if ( true == GetRidingOn() )
							StateChange( USI_RIDING_DAMAGE_FRONT );
						else
#endif // RIDING_SYSTEM
							StateChange( GetDamageGroggyStateID() );
					}
					break;
				}		
			}
		}
	}
	else
	{
		if ( this == g_pX2Game->GetMyUnit() )
			g_pX2Game->SetEnableAllKeyProcess( true );
	}

	// fix!! 이 부분 전체 framemove에서 안돌고 event로 처리되도록 수정하기

	if ( m_delegateProcessReturnFromScaleChange )
		m_delegateProcessReturnFromScaleChange();

	float fAnimSpeedRate = 1.f;
	float fRunJumpSpeedRate = 1.0f;
	//bool bCheckEnchantFrozen = false;

#ifdef SERV_SKILL_NOTE
	fAnimSpeedRate *= m_PhysicParam.GetAnimSpeed();
#endif

	if( m_ExtraDamagePack.m_EnchantPoison.m_fTime > 0.0f && GetNowHp() > 0.0f )
	{
		float fBeforeHP = GetNowHp();

		if ( m_ExtraDamagePack.m_EnchantPoison.m_fElapsedTimeToEffectDamage >= 1.0f )
		{
			m_ExtraDamagePack.m_EnchantPoison.m_fElapsedTimeToEffectDamage = 0;

			float fPrevNow = GetNowHp();	// 속성 포이즌으로 사망 가능(김상윤)

	#ifdef FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE // 김태환
			/// 죽을 때 발동되는 스킬 검사 및 처리
			if ( false == ProcessSkillAtDie( m_ExtraDamagePack.m_EnchantPoison.m_DamagePerSec ) )
				UpNowHp(-m_ExtraDamagePack.m_EnchantPoison.m_DamagePerSec);
	#else //FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE
			UpNowHp(-m_ExtraDamagePack.m_EnchantPoison.m_DamagePerSec);
	#endif //FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE

			D3DXVECTOR3 numPos;
			GetFramePos( &numPos, m_pFrame_Bip01_Head );
			numPos.y += 70.0f;
			if( NULL != g_pData->GetPicChar() )
			{
#ifdef ALWAYS_SCREEN_SHOT_TEST
				if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() == false )
				{
					g_pData->GetPicChar()->DrawText( static_cast<int>( fPrevNow - GetNowHp() ), numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );
				}
#else 
				g_pData->GetPicChar()->DrawText( static_cast<int>( fPrevNow - GetNowHp() ), numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );
#endif ALWAYS_SCREEN_SHOT_TEST
			}
		}
	}

	if( m_ExtraDamagePack.m_Poison.m_fTime > 0.0f || m_ExtraDamagePack.m_EnchantPoison.m_fTime > 0.0f )
	{
		if( m_hSeqPoisonBody == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqPoisonBody = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"UnitPoison", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Poison		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqPoisonBody );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }

		if( pSeq_Poison != NULL )
			pSeq_Poison->SetEmitRate( 10,20 );

		m_ExtraDamagePack.m_Poison.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_Poison.m_fTime < 0.0f )
			m_ExtraDamagePack.m_Poison.m_fTime = 0.0f;

		if ( m_ExtraDamagePack.m_EnchantPoison.m_fTime > 0.0f )
		{
			if( m_hSeqEnchant_Poison_Second == INVALID_PARTICLE_SEQUENCE_HANDLE )
            {
				m_hSeqEnchant_Poison_Second = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Enchant_Poison_Emoticon_Second", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                    pSeq_Enchant_Poison_Second		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Poison_Second  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
            }

			if ( pSeq_Enchant_Poison_Second != NULL )
			{
				pSeq_Enchant_Poison_Second->SetEmitRate( 20, 40 );
			}



			const CX2EnchantItem::EnchantData* pEnchantData = NULL;
			if ( g_pX2Game->GetGameType() == CX2Game::GT_PVP )
			{
				pEnchantData = g_pData->GetEnchantItem()->GetEnchantData( CX2DamageManager::EDT_ENCHANT_POISON );
			}
			else
			{
				pEnchantData = g_pData->GetEnchantItem()->GetNPCEnchantData( CX2DamageManager::EDT_ENCHANT_POISON );
			}


			if ( pEnchantData != NULL )
			{
				if ( m_ExtraDamagePack.m_EnchantPoison.m_Accumulation == 0 )
				{
					float fApplySlowFact = ( 1.0f - ((float)pEnchantData->m_FirstSlowPercent / 100.0f) );

					float fAlpha = 1.0f - fApplySlowFact;

					float fResist = GetEnchantResist( CX2EnchantItem::ET_NATURE );
					fAlpha = fAlpha * fResist / CX2EnchantItem::EAR_MAX_VALUE;

#ifdef ENCHANT_BALANCE_101014
					// oasis907 : 김상윤 [2010.10.5] // 속성 포이즌 이동속도 -> 속도 디버프로 변경
					if ( fAnimSpeedRate > fApplySlowFact + fAlpha )
						fAnimSpeedRate = fApplySlowFact + fAlpha;
#else
					if ( fRunJumpSpeedRate > fApplySlowFact + fAlpha )
						fRunJumpSpeedRate = fApplySlowFact + fAlpha;
#endif ENCHANT_BALANCE_101014

				}
				else if ( m_ExtraDamagePack.m_EnchantPoison.m_Accumulation == 1 )
				{
					float fApplySlowFact = ( 1.0f - ((float)pEnchantData->m_SecondSlowPercent / 100.0f) );

					float fAlpha = 1.0f - fApplySlowFact;

					float fResist = GetEnchantResist( CX2EnchantItem::ET_NATURE );
					fAlpha = fAlpha * fResist / CX2EnchantItem::EAR_MAX_VALUE;

#ifdef ENCHANT_BALANCE_101014
					if ( fAnimSpeedRate > fApplySlowFact + fAlpha )
						fAnimSpeedRate = fApplySlowFact + fAlpha;
#else
					if ( fRunJumpSpeedRate > fApplySlowFact + fAlpha )
						fRunJumpSpeedRate = fApplySlowFact + fAlpha;
#endif ENCHANT_BALANCE_101014


				}
				else if ( m_ExtraDamagePack.m_EnchantPoison.m_Accumulation >= 2 )
				{
					float fApplySlowFact = ( 1.0f - ((float)pEnchantData->m_ThirdSlowPercent / 100.0f) );

					float fAlpha = 1.0f - fApplySlowFact;

					float fResist = GetEnchantResist( CX2EnchantItem::ET_NATURE );
					fAlpha = fAlpha * fResist / CX2EnchantItem::EAR_MAX_VALUE;

#ifdef ENCHANT_BALANCE_101014
					if ( fAnimSpeedRate > fApplySlowFact + fAlpha )
						fAnimSpeedRate = fApplySlowFact + fAlpha;
#else
					if ( fRunJumpSpeedRate > fApplySlowFact + fAlpha )
						fRunJumpSpeedRate = fApplySlowFact + fAlpha;
#endif ENCHANT_BALANCE_101014
				}
#ifdef ENCHANT_BALANCE_101014
				if( fAnimSpeedRate >= 1.f )
				{
					fAnimSpeedRate = 1.f;
				}
#endif ENCHANT_BALANCE_101014
			}
		}
		else
		{
			if( pSeq_Enchant_Poison_Second != NULL )
			{
				pSeq_Enchant_Poison_Second->ClearAllParticle( );
				pSeq_Enchant_Poison_Second->SetEmitRate( 0 ,0 );
			}
		}


		m_ExtraDamagePack.m_EnchantPoison.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_EnchantPoison.m_fTime < 0.0f )
			m_ExtraDamagePack.m_EnchantPoison.m_fTime = 0.0f;


		m_ExtraDamagePack.m_EnchantPoison.m_fElapsedTimeToEffectDamage += m_fElapsedTime;
	}
	else
	{
		if( pSeq_Poison != NULL )
			pSeq_Poison->SetEmitRate( 0,0 );



		if( pSeq_Enchant_Poison_Second != NULL )
		{
			pSeq_Enchant_Poison_Second->ClearAllParticle( );
			pSeq_Enchant_Poison_Second->SetEmitRate( 0 ,0 );
		}
	}

	if( m_ExtraDamagePack.m_EnchantShock.m_fTime > 0.0f )
	{
		if ( this == g_pX2Game->GetMyUnit() )
			g_pX2Game->SetEnableAllKeyProcess( false );


		if ( m_ExtraDamagePack.m_EnchantShock.m_Accumulation >= 1 )
		{
			if ( pSeq_Enchant_Stun != NULL )
			{
				pSeq_Enchant_Stun->ClearAllParticle();
				pSeq_Enchant_Stun->SetEmitRate( 0, 0 );
			}

			if( m_hSeqEnchant_Stun_Second == INVALID_PARTICLE_SEQUENCE_HANDLE )
            {
				m_hSeqEnchant_Stun_Second = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Enchant_Stun_Emoticon_Second", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                    pSeq_Enchant_Stun_Second		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Stun_Second  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
            }

			if ( pSeq_Enchant_Stun_Second != NULL )
			{
				pSeq_Enchant_Stun_Second->SetEmitRate( 20, 40 );
			}
		}
		else
		{
			if ( pSeq_Enchant_Stun_Second != NULL )
			{
				pSeq_Enchant_Stun_Second->ClearAllParticle();
				pSeq_Enchant_Stun_Second->SetEmitRate( 0, 0 );
			}

			if( m_hSeqEnchant_Stun == INVALID_PARTICLE_SEQUENCE_HANDLE )
            {
				m_hSeqEnchant_Stun = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Enchant_Stun_Emoticon", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                    pSeq_Enchant_Stun				= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Stun  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
            }

			if ( pSeq_Enchant_Stun != NULL )
			{
				pSeq_Enchant_Stun->SetEmitRate( 20, 40 );
			}
		}


		m_ExtraDamagePack.m_EnchantShock.m_Accumulation = 1;

		m_FrameDataNow.stateParam.bSuperArmor = true;
		m_FrameDataNow.stateParam.bSuperArmorNotRed = true;
		m_fSocketSuperArmor = 0.f;
		m_bSocketSuperArmor = false;

		m_ExtraDamagePack.m_EnchantShock.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_EnchantShock.m_fTime <= 0.0f )
		{
			m_ExtraDamagePack.m_EnchantShock.m_fTime = 0.0f;
			if ( m_ExtraDamagePack.m_EnchantShock.m_Accumulation == 1 )
			{
				if ( this == g_pX2Game->GetMyUnit() )
					g_pX2Game->SetEnableAllKeyProcess( true );

				if ( GetNowHp() > 0.f )
				{
					if ( m_bReserveForceDownForShock == true )
#ifdef RIDING_SYSTEM
						if ( true == GetRidingOn() )
							StateChange( USI_RIDING_DAMAGE_BACK, true );
						else
							StateChange( USI_DAMAGE_SMALL_BACK, true );
#else //RIDING_SYSTEM
						StateChange( USI_DAMAGE_SMALL_BACK );
#endif //RIDING_SYSTEM 데미지 State 변경
					else
					{
#ifdef ELSWORD_WAY_OF_SWORD
						if( m_ExtraDamagePack.m_EnchantShock.m_bCured == true )
						{
							m_ExtraDamagePack.m_EnchantShock.m_bCured = false;
							m_bReserveForceDownForShock = false;

#ifdef RIDING_SYSTEM
							if ( true == GetRidingOn() )
								StateChange( USI_RIDING_DAMAGE_FRONT, true );
							else
								StateChange( USI_DAMAGE_SMALL_FRONT, true );
#else //RIDING_SYSTEM
							StateChange( USI_DAMAGE_SMALL_FRONT, true );
#endif //RIDING_SYSTEM 데미지 State 변경
						}
						else
						{
							m_bReserveForceDownForShock = false;
#ifdef RIDING_SYSTEM
							if ( true == GetRidingOn() )
								StateChange( USI_RIDING_DAMAGE_FRONT, true );
							else
								StateChange( USI_DAMAGE_DOWN_FRONT, true );
#else //RIDING_SYSTEM
							StateChange( USI_DAMAGE_DOWN_FRONT, true );
#endif //RIDING_SYSTEM 데미지 State 변경
						}
#else
						m_bReserveForceDownForShock = false;
						StateChange( USI_DAMAGE_DOWN_FRONT, true );
#endif ELSWORD_WAY_OF_SWORD
					}

					g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"Smoke_Stone_Property01", GetPos() );
					g_pX2Game->GetMinorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Stone_Property01", GetPos(), D3DXVECTOR3(0,0,0), D3DXVECTOR3(0,0,0) );

#ifdef CUSTOM_DELETE_EFFECT_ON_DAMAGE_REACT
						DeleteEffectSetOnDamageReact();

						// 지정한 스테이트에서 이펙트셋 지우는 기능, 피격 시 수행 하도록 처리
						if( true == m_bIsCustomStateDeleteEffectOnDamageReact )
							DeleteEffectSetOnCustomState();
#endif // CUSTOM_DELETE_EFFECT_ON_DAMAGE_REACT
				}



				m_ExtraDamagePack.m_EnchantShock.m_Accumulation = 0;
			}
		}
	}
	else
	{
		m_bReserveForceDownForShock = false;

		if ( pSeq_Enchant_Stun != NULL)
		{
			pSeq_Enchant_Stun->ClearAllParticle();
			pSeq_Enchant_Stun->SetEmitRate(0, 0 );
		}

		if ( pSeq_Enchant_Stun_Second != NULL )
		{
			pSeq_Enchant_Stun_Second->ClearAllParticle();
			pSeq_Enchant_Stun_Second->SetEmitRate( 0, 0 );
		}
	}

	if ( m_ExtraDamagePack.m_EnchantPoison.m_fTime <= 0.0f )
	{
		m_ExtraDamagePack.m_EnchantPoison.m_fElapsedTimeToEffectDamage = 0.0f;
		m_ExtraDamagePack.m_EnchantPoison.m_Accumulation = 0;
	}

	/// 구 방식 블레이즈 ------------------------------------------------------------------------------------------------------
	if( m_ExtraDamagePack.m_EnchantBlaze.m_fTime > 0.0f && GetNowHp() > 0.0f )
	{
		float fBeforeHP = GetNowHp();
		//m_GageManager.GetHPGage()->fNow -= m_ExtraDamagePack.m_Fire.m_DamagePerSec * m_fElapsedTime;
		if ( m_ExtraDamagePack.m_EnchantBlaze.m_fElapsedTimeToEffectDamage >= 1.0f )
		{
			m_ExtraDamagePack.m_EnchantBlaze.m_fElapsedTimeToEffectDamage = 0;

#ifdef ENCHANT_BALANCE_101014 // oasis907 : 김상윤 [2010.10.5] // 속성 블레이즈로 사망 가능
			float fPrevNow = GetNowHp();

	#ifdef FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE // 김태환
			/// 죽을 때 발동되는 스킬 검사 및 처리
			if ( false == ProcessSkillAtDie( m_ExtraDamagePack.m_EnchantBlaze.m_DamagePerSec ) )
				SetNowHp( fPrevNow - m_ExtraDamagePack.m_EnchantBlaze.m_DamagePerSec ); 
	#else //FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE
			SetNowHp( fPrevNow - m_ExtraDamagePack.m_EnchantBlaze.m_DamagePerSec ); 
	#endif //FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE

#else
#ifdef REFACTORING_BY_TOOL_TEAM
			UpHPIfAlive( -m_ExtraDamagePack.m_EnchantBlaze.m_DamagePerSec, 1.f ); 
#else REFACTORING_BY_TOOL_TEAM
			float fPrevNow = m_GageManager.GetHPGage()->fNow;
			m_GageManager.GetHPGage()->fNow -= m_ExtraDamagePack.m_EnchantBlaze.m_DamagePerSec;
			if( fBeforeHP > 0.0f && m_GageManager.GetHPGage()->fNow < 1.0f )
			{
				m_GageManager.GetHPGage()->fNow = 1.0f;
			}

#endif REFACTORING_BY_TOOL_TEAM
#endif ENCHANT_BALANCE_101014

			//m_GageManager.CrashMyStateGageBar( D3DXVECTOR2( -7, -7 ), D3DXVECTOR2( 7, 7 ), D3DXCOLOR( 1, 0, 0, 1) );

			D3DXVECTOR3 numPos;
			GetFramePos( &numPos, m_pFrame_Bip01_Head );
			numPos.y += 70.0f;
			if( NULL != g_pData->GetPicChar() )
			{
#ifdef REFACTORING_BY_TOOL_TEAM
				g_pData->GetPicChar()->DrawText( (int)( -m_ExtraDamagePack.m_EnchantBlaze.m_DamagePerSec ), numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );
#else REFACTORING_BY_TOOL_TEAM
#ifdef ALWAYS_SCREEN_SHOT_TEST
				if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() ==  false )
				{
					g_pData->GetPicChar()->DrawText( (int)( fPrevNow - GetNowHp() ), numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );
				}
#else 
				g_pData->GetPicChar()->DrawText( (int)( fPrevNow - GetNowHp() ), numPos, GetDirVector(), CKTDGPicChar::AT_CENTER );
#endif ALWAYS_SCREEN_SHOT_TEST
#endif REFACTORING_BY_TOOL_TEAM
			}
		}
	}

	if( m_ExtraDamagePack.m_Fire.m_fTime > 0.0f || m_ExtraDamagePack.m_EnchantBlaze.m_fTime > 0.0f )
	{
		if( m_hSeqFireBody1 == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqFireBody1 = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"SwordFireTip", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Fire1 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqFireBody1 );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }
		if( m_hSeqFireBody2 == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqFireBody2 = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"SwordFireTip", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Fire2 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqFireBody2 );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }

		if( pSeq_Fire1 != NULL )
			pSeq_Fire1->SetEmitRate( 20,40 );
		if( pSeq_Fire2 != NULL )
			pSeq_Fire2->SetEmitRate( 20,40 );


		m_ExtraDamagePack.m_Fire.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_Fire.m_fTime < 0.0f )
			m_ExtraDamagePack.m_Fire.m_fTime = 0.0f;

		m_ExtraDamagePack.m_EnchantBlaze.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_EnchantBlaze.m_fTime < 0.0f )
			m_ExtraDamagePack.m_EnchantBlaze.m_fTime = 0.0f;

		m_ExtraDamagePack.m_EnchantBlaze.m_fElapsedTimeToEffectDamage += m_fElapsedTime;

		if ( m_ExtraDamagePack.m_EnchantBlaze.m_fTime > 0.0f )
		{
			if( m_hSeqEnchant_Blaze_Second == INVALID_PARTICLE_SEQUENCE_HANDLE )
            {
				m_hSeqEnchant_Blaze_Second = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Enchant_Blaze_Emoticon_Second", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                     pSeq_Enchant_Blaze_Second		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Blaze_Second  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
            }

			if ( pSeq_Enchant_Blaze_Second != NULL )
			{
				pSeq_Enchant_Blaze_Second->SetEmitRate( 20, 40 );
			}

		}
		else
		{
			if ( pSeq_Enchant_Blaze_Second != NULL )
			{
				pSeq_Enchant_Blaze_Second->ClearAllParticle();
				pSeq_Enchant_Blaze_Second->SetEmitRate( 0, 0 );
			}
		}
	}
	else
	{
		if( pSeq_Fire1 != NULL )
			pSeq_Fire1->SetEmitRate( 0,0 );
		if( pSeq_Fire2 != NULL )
			pSeq_Fire2->SetEmitRate( 0,0 );



		if ( pSeq_Enchant_Blaze_Second != NULL )
		{
			pSeq_Enchant_Blaze_Second->ClearAllParticle();
			pSeq_Enchant_Blaze_Second->SetEmitRate( 0, 0 );
		}


	}
	if ( m_ExtraDamagePack.m_EnchantBlaze.m_fTime <= 0.0f )
	{
		m_ExtraDamagePack.m_EnchantBlaze.m_fElapsedTimeToEffectDamage = 0.0f;
		m_ExtraDamagePack.m_EnchantBlaze.m_Accumulation = 0;
	}
	/// ----------------------------------------------------------------------------------------------------------------------


	if( m_ExtraDamagePack.m_Curse.m_fTime > 0.0f )
	{
		if( m_hSeqCurseBody == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqCurseBody = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"UnitCurse", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Curse 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCurseBody );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }

		if( pSeq_Curse != NULL )
			pSeq_Curse->SetEmitRate( 10,20 );

		m_ExtraDamagePack.m_Curse.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_Curse.m_fTime < 0.0f )
			m_ExtraDamagePack.m_Curse.m_fTime = 0.0f;
	}
	else
	{
		if( pSeq_Curse != NULL )
			pSeq_Curse->SetEmitRate( 0,0 );
	}
	if( m_ExtraDamagePack.m_Slow.m_fTime > 0.0f )
	{
		if( m_hSeqSlowBodyRight == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqSlowBodyRight = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"UnitSlow", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_SlowRight 	= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqSlowBodyRight );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }
		if( m_hSeqSlowBodyLeft == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqSlowBodyLeft = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"UnitSlow", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_SlowLeft  	= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqSlowBodyLeft  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }

		if( pSeq_SlowRight != NULL )
			pSeq_SlowRight->SetEmitRate( 5,10 );
		if( pSeq_SlowLeft != NULL )
			pSeq_SlowLeft->SetEmitRate( 5,10 );

		m_ExtraDamagePack.m_Slow.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_Slow.m_fTime < 0.0f )
			m_ExtraDamagePack.m_Slow.m_fTime = 0.0f;
	}
	else
	{
		if( pSeq_SlowRight != NULL )
			pSeq_SlowRight->SetEmitRate( 0,0 );
		if( pSeq_SlowLeft != NULL )
			pSeq_SlowLeft->SetEmitRate( 0,0 );
	}


	if( m_ExtraDamagePack.m_Cold.m_fTime > 0.0f || 
		m_ExtraDamagePack.m_EnchantFrozen.m_fTime > 0.0f )
	{
		if ( m_ExtraDamagePack.m_Cold.m_fTime > 0.0f )
		{
#ifdef NEW_EXTRA_DAMAGE
			if(m_ExtraDamagePack.m_Cold.m_iLevel < 0)
#endif
			{
				//감소율 = 0.2
				if ( fAnimSpeedRate > 0.8f )
					fAnimSpeedRate = 0.8f;
			}
#ifdef NEW_EXTRA_DAMAGE
			else
			{
				//감소율 = 0.2 + ( 0.0025 * EDT레벨 )
				float fAnimSpeedReduceRate = 0.2f + ( 0.0025f * (float)m_ExtraDamagePack.m_Cold.m_iLevel );
				if( fAnimSpeedRate > 1.f - fAnimSpeedReduceRate)
				{
					fAnimSpeedRate = 1.f - fAnimSpeedReduceRate;
				}
				if( fAnimSpeedRate >= 1.f )
				{
					fAnimSpeedRate = 1.f;
				}
			}
#endif

			if( false == m_bColdSlowApplied )
			{
				m_bColdSlowApplied = true;	
			}
		}
		else
		{
			if( true == m_bColdSlowApplied )
			{
				m_bColdSlowApplied = false;
			}
		}

		if ( m_ExtraDamagePack.m_EnchantFrozen.m_fTime > 0.f )
		{
			m_bFrozenSlowApplied = true;

			if( m_hSeqEnchant_Frozen_Second == INVALID_PARTICLE_SEQUENCE_HANDLE )
            {
				m_hSeqEnchant_Frozen_Second = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Enchant_Frozen_Emoticon_Second", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                    pSeq_Enchant_Frozen_Second		= g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchant_Frozen_Second  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
            }


			if ( pSeq_Enchant_Frozen_Second != NULL )
			{
				pSeq_Enchant_Frozen_Second->SetEmitRate( 20, 40 );
			}


			const CX2EnchantItem::EnchantData* pEnchantData = NULL;
			if ( g_pX2Game->GetGameType() == CX2Game::GT_PVP )
			{
				pEnchantData = g_pData->GetEnchantItem()->GetEnchantData( CX2DamageManager::EDT_ENCHANT_FROZEN );
			}
			else
			{
				pEnchantData = g_pData->GetEnchantItem()->GetNPCEnchantData( CX2DamageManager::EDT_ENCHANT_FROZEN );
			}


			if ( pEnchantData != NULL )
			{
				if ( m_ExtraDamagePack.m_EnchantFrozen.m_Accumulation == 0 )
				{
					float fApplySlowFact = ( 1.0f - ((float)pEnchantData->m_FirstSlowPercent / 100.0f) );

					float fAlpha = 1.0f - fApplySlowFact;

					float fResist = GetEnchantResist( CX2EnchantItem::ET_WATER );
					fAlpha = fAlpha * fResist / CX2EnchantItem::EAR_MAX_VALUE;



					if ( fRunJumpSpeedRate > fApplySlowFact + fAlpha )
						fRunJumpSpeedRate = fApplySlowFact + fAlpha;


				}
				else if ( m_ExtraDamagePack.m_EnchantFrozen.m_Accumulation == 1 )
				{
					float fApplySlowFact = ( 1.0f - ((float)pEnchantData->m_SecondSlowPercent / 100.0f) );

					float fAlpha = 1.0f - fApplySlowFact;

					float fResist = GetEnchantResist( CX2EnchantItem::ET_WATER );
					fAlpha = fAlpha * fResist / CX2EnchantItem::EAR_MAX_VALUE;



					if ( fRunJumpSpeedRate > fApplySlowFact + fAlpha )
						fRunJumpSpeedRate = fApplySlowFact + fAlpha;


				}
				else if ( m_ExtraDamagePack.m_EnchantFrozen.m_Accumulation >= 2 )
				{
					float fApplySlowFact = ( 1.0f - ((float)pEnchantData->m_ThirdSlowPercent / 100.0f) );

					float fAlpha = 1.0f - fApplySlowFact;

					float fResist = GetEnchantResist( CX2EnchantItem::ET_WATER );
					fAlpha = fAlpha * fResist / CX2EnchantItem::EAR_MAX_VALUE;



					if ( fRunJumpSpeedRate > fApplySlowFact + fAlpha )
						fRunJumpSpeedRate = fApplySlowFact + fAlpha;
				}
			}
		}
		else
		{

			if( pSeq_Enchant_Frozen_Second != NULL )
			{
				pSeq_Enchant_Frozen_Second->ClearAllParticle();
				pSeq_Enchant_Frozen_Second->SetEmitRate( 0, 0 );
			}
		}

		if( m_hSeqCold1 == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqCold1 = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Ice_Status_Error01", 0, 0, 0 );	
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Cold1L  		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCold1  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }
		if( m_hSeqCold2 == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqCold2 = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Ice_Status_Error02", 0, 0, 0 );	
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Cold2L  		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCold2  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }
		if( m_hSeqCold1_Right == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqCold1_Right = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Ice_Status_Error01", 0, 0, 0 );	
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Cold1R  		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCold1_Right  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }
		if( m_hSeqCold2_Right == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqCold2_Right = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Ice_Status_Error02", 0, 0, 0 );	
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Cold2R  		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCold2_Right  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }



		if( pSeq_Cold1L != NULL )
		{
			pSeq_Cold1L->SetEmitRate( 20,30 );
		}
		if( pSeq_Cold2L != NULL )
		{
			pSeq_Cold2L->SetEmitRate( 10,20 );
		}
		if( pSeq_Cold1R != NULL )
		{
			pSeq_Cold1R->SetEmitRate( 20,30 );
		}
		if( pSeq_Cold2R != NULL )
		{
			pSeq_Cold2R->SetEmitRate( 10,20 );
		}
		//if( pSeq_Cold_Head != NULL )
		//	pSeq_Cold_Head->SetEmitRate( 10, 20 );



		if ( m_ExtraDamagePack.m_Cold.m_fTime > 0.0f )
		{
			if( m_hSeqCold_Head == INVALID_PARTICLE_SEQUENCE_HANDLE )
            {
				m_hSeqCold_Head = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"UnitCold", 0, 0, 0 );	
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                    pSeq_Cold_Head		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqCold_Head );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
            }

			if( pSeq_Cold_Head != NULL )
				pSeq_Cold_Head->SetEmitRate( 10,20 );
		}
		else
		{
			if( pSeq_Cold_Head != NULL )
			{
				pSeq_Cold_Head->ClearAllParticle();
				pSeq_Cold_Head->SetEmitRate( 0,0 );
			}
		}


		m_ExtraDamagePack.m_Cold.m_fTime -= m_fElapsedTime;

		if( m_ExtraDamagePack.m_Cold.m_fTime < 0.0f )
			m_ExtraDamagePack.m_Cold.m_fTime = 0.0f;

		m_ExtraDamagePack.m_EnchantFrozen.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_EnchantFrozen.m_fTime < 0.0f )
			m_ExtraDamagePack.m_EnchantFrozen.m_fTime = 0.0f;

	}
	else
	{
		if( true == m_bColdSlowApplied )
		{
			m_bColdSlowApplied = false;
		}

		if ( m_bFrozenSlowApplied == true )
		{
			m_bFrozenSlowApplied = false;

		}


		if( pSeq_Cold1L != NULL )
			pSeq_Cold1L->SetEmitRate( 0,0 );
		if( pSeq_Cold2L != NULL )
			pSeq_Cold2L->SetEmitRate( 0,0 );
		if( pSeq_Cold1R != NULL )
			pSeq_Cold1R->SetEmitRate( 0,0 );
		if( pSeq_Cold2R != NULL )
			pSeq_Cold2R->SetEmitRate( 0,0 );
		if( pSeq_Cold_Head != NULL )
		{
			pSeq_Cold_Head->ClearAllParticle();
			pSeq_Cold_Head->SetEmitRate( 0, 0 );
		}

		if( pSeq_Enchant_Frozen_Second != NULL )
		{
			pSeq_Enchant_Frozen_Second->ClearAllParticle();
			pSeq_Enchant_Frozen_Second->SetEmitRate( 0, 0 );
		}
	}

	if( m_ExtraDamagePack.m_Aging.m_fTime > 0.f )
	{
		fAnimSpeedRate *= m_ExtraDamagePack.m_Aging.m_fAnimSpeedRate;
		fRunJumpSpeedRate *= m_ExtraDamagePack.m_Aging.m_fRunJumpRate;
	}


	if ( m_ExtraDamagePack.m_EnchantFrozen.m_fTime <= 0.0f )
	{
		m_ExtraDamagePack.m_EnchantFrozen.m_fElapsedTimeToEffectDamage = 0.0f;
		m_ExtraDamagePack.m_EnchantFrozen.m_Accumulation = 0;
	}

	if( m_fGroggyTime > 0.f )
	{
		if( m_hSeqStun == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqStun = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"UnitStun", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Stun 			= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqStun  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }

		if( NULL != pSeq_Stun )
			pSeq_Stun->SetEmitRate( 10, 20 );
	}
	else
	{
		if( NULL != pSeq_Stun )
		{
			pSeq_Stun->ClearAllParticle();
			pSeq_Stun->SetEmitRate( 0, 0 );
		}
	}




	if( m_fPepperRunTime > 0.f )
	{
		if( m_hSeqPepperBody1 == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqPepperBody1 = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"SwordFireTip", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Pepper1 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqPepperBody1  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }
		if( m_hSeqPepperBody2 == INVALID_PARTICLE_SEQUENCE_HANDLE )
        {
			m_hSeqPepperBody2 = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"SwordFireTip", 0,0,0 );
#ifdef  X2OPTIMIZE_GAMEOPTION_BUGFIX
                pSeq_Pepper2 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hSeqPepperBody2  );
#endif  X2OPTIMIZE_GAMEOPTION_BUGFIX
        }

		if( NULL != pSeq_Pepper1 )
			pSeq_Pepper1->SetEmitRate( 30, 40 );

		if( NULL != pSeq_Pepper2 )
			pSeq_Pepper2->SetEmitRate( 30, 40 );
	}
	else
	{
		if( NULL != pSeq_Pepper1 )
			pSeq_Pepper1->SetEmitRate( 0, 0 );

		if( NULL != pSeq_Pepper2 )
			pSeq_Pepper2->SetEmitRate( 0, 0 );
	}




	if( m_ExtraDamagePack.m_Lightning.m_fTime > 0.0f )
	{
		//근거리 아군도 닳는다
		D3DXVECTOR3 pos = GetPos();   		
		for( int i = 0; i < g_pX2Game->GetUnitNum(); i++ )
		{
			CX2GameUnit* pUnit = g_pX2Game->GetUnit( i );
			if( pUnit != NULL
				&& pUnit != this
				&& pUnit->IsLocalUnit() == true
				&& pUnit->GetTeam() == GetTeam()
				&& pUnit->GetInvincible() == false
				&& pUnit->GetNowHp() > 0.0f
				&& GetDistance( pos, pUnit->GetPos() ) < 200.0f )
			{


#ifdef REFACTORING_BY_TOOL_TEAM
				UpNowHp( -m_ExtraDamagePack.m_Lightning.m_DamagePerSec * m_fElapsedTime, 1.f );
#else REFACTORING_BY_TOOL_TEAM

				float fBeforeHP = pUnit->GetNowHp();
				//pUnit->GetGageManager()->GetHPGage()->fNow -= m_ExtraDamagePack.m_Lightning.m_DamagePerSec * m_fElapsedTime;
				float fNowHp = pUnit->GetNowHp() - m_ExtraDamagePack.m_Lightning.m_DamagePerSec * m_fElapsedTime;
				SetNowHp( fNowHp );
				if( fBeforeHP > 0.0f && pUnit->GetNowHp() < 1.0f )
				{
					pUnit->SetNowHp( 1.f ); 
				}



#ifdef DAMAGE_HISTORY
				*m_fDamageHistory += (m_ExtraDamagePack.m_Lightning.m_DamagePerSec * m_fElapsedTime);				
#endif


#endif REFACTORING_BY_TOOL_TEAM







			}
		}

		m_ExtraDamagePack.m_Lightning.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_Lightning.m_fTime < 0.0f )
			m_ExtraDamagePack.m_Lightning.m_fTime = 0.0f;
	}

	// mauntain : 김태환 [2012.05.21] 레나 2차 전직 나이트 와쳐 - 폭발의 화살 EDT Emoticon 갱신
#ifdef SERV_RENA_NIGHT_WATCHER
	if ( false == GetStartOfDelayedFiringData().empty() )	//자신에게 박힌 폭발의 화살이 있다면, 이모티콘 유지
	{
		if ( pSeq_Enchant_ArrowOfExplosion != NULL )
		{
			pSeq_Enchant_ArrowOfExplosion->SetEmitRate( 20, 40 );
		}

		if ( pSeq_StartOfDelayedFiringOverlap != NULL )
		{
			pSeq_StartOfDelayedFiringOverlap->SetEmitRate( 20, 40 );
		}
	}
	else
	{
		if( pSeq_Enchant_ArrowOfExplosion != NULL )
		{
			pSeq_Enchant_ArrowOfExplosion->ClearAllParticle();
			pSeq_Enchant_ArrowOfExplosion->SetEmitRate( 0, 0 );
		}

		if( pSeq_StartOfDelayedFiringOverlap != NULL )
		{
			pSeq_StartOfDelayedFiringOverlap->ClearAllParticle();
			pSeq_StartOfDelayedFiringOverlap->SetEmitRate( 0, 0 );
		}
	}

	CommonFrameMoveStateAbnormalityStartOfDelayedFiring();
#endif SERV_RENA_NIGHT_WATCHER

#ifdef RENA_SECOND_CLASS_CHANGE
	if( m_ExtraDamagePack.m_StigmaDebuff.m_fTime > 0.f )
	{
		fRunJumpSpeedRate *= m_ExtraDamagePack.m_StigmaDebuff.m_fRunJumpRate;
	}
#endif RENA_SECOND_CLASS_CHANGE


	// 이동속도 변화 적용
	if( false == IsSamef( m_fRunJumpSpeedRate, fRunJumpSpeedRate ) )
		m_fRunJumpSpeedRate = fRunJumpSpeedRate;

	if( g_pX2Game != NULL && g_pX2Game->GetLineMap() != NULL )
	{
		const CKTDGLineMap::LineData* pLineData = g_pX2Game->GetLineMap()->GetLineData( m_FrameDataNow.syncData.lastTouchLineIndex );
		if( pLineData != NULL && pLineData->m_bUnderWater == true && GetPos().y <= pLineData->m_fWaterHeight)
		{
			ChangeUnderWater(true);
			//m_bUnderWaterHead = true;
		}
		else if( pLineData != NULL && pLineData->m_bForceChangeColor == true )
		{
			m_bForceChagneColor = true;			
		}
		else
		{
			ChangeUnderWater(false);
			//m_bUnderWaterHead = false;
			m_bForceChagneColor = false;			
		}

		if( pLineData != NULL && pLineData->m_bUnderWater == true && GetHeadBonePos().y <= pLineData->m_fWaterHeight )
		{			
			float fMinY = min( pLineData->startPos.y, pLineData->endPos.y );			
			float fColorRate = (pLineData->m_fWaterHeight - GetPos().y/*GetHeadBonePos().y*/) / (pLineData->m_fWaterHeight - fMinY); 
			m_cLineUnitColor = D3DXCOLOR( pLineData->m_cLineColor.r * fColorRate, pLineData->m_cLineColor.g * fColorRate, pLineData->m_cLineColor.b * fColorRate, 0.f );

			fAnimSpeedRate *= pLineData->m_fAnimSpeed;
			m_fOxygenGage += pLineData->m_fVarianceOxyen * m_fElapsedTime;
			if( m_fOxygenGage < 0.f )
				m_fOxygenGage = 0.f;
			else if( m_fOxygenGage > MAGIC_OXYGEN_GAGE )
				m_fOxygenGage = MAGIC_OXYGEN_GAGE;

			if( m_fOxygenGage <= 0.f )
			{
#ifdef REFACTORING_BY_TOOL_TEAM
				UpNowHp( -GetMaxHp() * 0.05f * m_fElapsedTime );
				if( GetNowHp() <= 0.f )
				{
					// 익사
#ifdef SERV_ADD_TITLE_CONDITION
					m_ucDieReason = KEGS_USER_UNIT_DIE_REQ::UUDR_LACK_OF_OXYGEN;
#endif
				}
#else REFACTORING_BY_TOOL_TEAM
				float fNowHP = GetNowHp() - GetMaxHp() * 0.05f * m_fElapsedTime;
				if( fNowHP <= 0.f )
				{
					// 익사
					fNowHP = 0.f;
#ifdef SERV_ADD_TITLE_CONDITION
					m_ucDieReason = KEGS_USER_UNIT_DIE_REQ::UUDR_LACK_OF_OXYGEN;
#endif
				}
				SetNowHp( fNowHP );
#endif REFACTORING_BY_TOOL_TEAM
			}
		}
		else
		{			
			m_cLineUnitColor = D3DXCOLOR( 0.f, 0.f, 0.f, 0.f );

			if( m_fOxygenGage < MAGIC_OXYGEN_GAGE )
			{
				m_fOxygenGage += 40 * m_fElapsedTime;
				if( m_fOxygenGage > MAGIC_OXYGEN_GAGE )
					m_fOxygenGage = MAGIC_OXYGEN_GAGE;
			}
		}

		if( m_bForceChagneColor == true )
		{
			m_cLineUnitColor = D3DXCOLOR( pLineData->m_cLineColor.r, pLineData->m_cLineColor.g, pLineData->m_cLineColor.b, 0.f );
		}
	}

	//{{ JHKang / 강정훈 / 2011/01/25 / 애니메이션 속도 조절 비율값
#ifdef SEASON3_MONSTER_2010_12
	fAnimSpeedRate *= m_fAnimSpeedRateByNpc;
#endif SEASON3_MONSTER_2010_12
	//}} JHKang / 강정훈 / 2011/01/25 / 애니메이션 속도 조절 비율값

	// 애니메이션 속도 변화 적용
	if( m_fAnimSpeedRate != fAnimSpeedRate )
	{
		m_fAnimSpeedRate = fAnimSpeedRate;
#ifdef	ADD_ANIM_SPEED_FUTURE
		ResetAnimSpeed( m_fAnimSpeedFuture, true, true );
#else	ADD_ANIM_SPEED_FUTURE
		ResetAnimSpeed( m_fAnimSpeed, true, true );
#endif // ADD_ANIM_SPEED_FUTURE
		ResetAnimSpeed( m_fAnimSpeed, true, false );
	}

	/*
	//애드온 스탯 적용
	AccessStat().AccessAddOnTime().m_fAtkPhysic = AccessStat().AccessAddOnTime().m_fAtkPhysic - m_fElapsedTime;
	if( AccessStat().AccessAddOnTime().m_fAtkPhysic <= 0.0f )
	{
		AccessStat().AccessAddOnTime().m_fAtkPhysic = 0.0f;
		AccessStat().AccessAddOnStat().m_fAtkPhysic = 0.0f;
		if( NULL != pSeq_AtkPhysic )
		{
			pSeq_AtkPhysic->ClearAllParticle();
			pSeq_AtkPhysic->SetEmitRate( CMinMax<float>(0,0) );
		}
	}
	AccessStat().AccessAddOnTime().m_fAtkMagic = AccessStat().AccessAddOnTime().m_fAtkMagic - m_fElapsedTime;
	if( AccessStat().AccessAddOnTime().m_fAtkMagic <= 0.0f )
	{
		AccessStat().AccessAddOnTime().m_fAtkMagic = 0.0f;
		AccessStat().AccessAddOnStat().m_fAtkMagic = 0.0f;
		if( NULL != pSeq_AtkMagic )
		{
			pSeq_AtkMagic->ClearAllParticle();
			pSeq_AtkMagic->SetEmitRate( CMinMax<float>(0,0) );
		}
	}


	AccessStat().AccessAddOnTime().m_fDefPhysic = AccessStat().AccessAddOnTime().m_fDefPhysic - m_fElapsedTime;
	if( AccessStat().AccessAddOnTime().m_fDefPhysic <= 0.0f )
	{
		AccessStat().AccessAddOnTime().m_fDefPhysic = 0.0f;
		AccessStat().AccessAddOnStat().m_fDefPhysic = 0.0f;
		if( NULL != pSeq_DefPhysic )
		{
			pSeq_DefPhysic->ClearAllParticle();
			pSeq_DefPhysic->SetEmitRate( CMinMax<float>(0,0) );
		}
	}
	AccessStat().AccessAddOnTime().m_fDefMagic = AccessStat().AccessAddOnTime().m_fDefMagic - m_fElapsedTime;
	if( AccessStat().AccessAddOnTime().m_fDefMagic <= 0.0f )
	{
		AccessStat().AccessAddOnTime().m_fDefMagic = 0.0f;
		AccessStat().AccessAddOnStat().m_fDefMagic = 0.0f;
	}
	*/

	CommonFrameMove_Invincible();


	KTDXPROFILE_BEGIN( "LAND_CHECK" );
	m_FrameDataNow.unitCondition.landPosition = g_pX2Game->GetWorld()->GetLineMap()->GetLandPosition( m_FrameDataNow.syncData.position, 
		LINE_RADIUS, 
		&m_FrameDataNow.syncData.lastTouchLineIndex );


	if( fabs( m_FrameDataNow.syncData.position.y - m_FrameDataNow.unitCondition.landPosition.y ) < LINE_RADIUS )
		m_FrameDataNow.unitCondition.bFootOnLine = true;
	else
		m_FrameDataNow.unitCondition.bFootOnLine = false;

#ifdef WORLD_TRIGGER
	if( m_fTriggerTime < 0.5f )
		m_fTriggerTime += m_fElapsedTime;

	if( g_pX2Game != NULL && 
		g_pX2Game->GetWorld() != NULL && 
		g_pX2Game->GetLineMap() != NULL &&
		IsMyUnit() == true &&
		m_fTriggerTime >= 0.5f )
		//m_FrameDataNow.unitCondition.bFootOnLine == true )
	{
		const CKTDGLineMap::LineData* pLineData = g_pX2Game->GetLineMap()->GetLineData( m_FrameDataNow.syncData.lastTouchLineIndex );
		ASSERT( NULL != pLineData );
		if ( NULL != pLineData )
		{
			if( pLineData->m_bFootOnLine == false || (pLineData->m_bFootOnLine == true && m_FrameDataNow.unitCondition.bFootOnLine == true) )
			{
				m_fTriggerTime = 0.f;		
#ifdef SERV_WORLD_TRIGGER_RELOCATION			
				g_pX2Game->Handler_EGS_WORLD_TRIGGER_RELOCATION_REQ( pLineData->m_iTriggerId );		
#else	//SERV_WORLD_TRIGGER_RELOCATION
				g_pX2Game->GetWorld()->ActiveTrigger( pLineData->m_iTriggerId );
#endif	//SERV_WORLD_TRIGGER_RELOCATION
			}
		}
	}
#endif

	KTDXPROFILE_END();

	KTDXPROFILE_BEGIN( "RE_ATTACK" );
	if( m_DamageData.bReAttack == true )
	{
		for( CX2DamageManager::HitUnitVector::iterator iter = m_DamageData.hitUnitList.begin(); 
            iter != m_DamageData.hitUnitList.end(); )
		{
			CX2DamageManager::HitUnit* pHitUnit = &(*iter);
			pHitUnit->fRemainGap -= m_fElapsedTime;
			if( pHitUnit->fRemainGap <= 0.0f )
			{
#ifdef  X2OPTIMIZE_STL_CONTAINER_USAGE
                iter = EraseUnorderlyUsingSwap( m_DamageData.hitUnitList, iter );
#else   X2OPTIMIZE_STL_CONTAINER_USAGE
				iter = m_DamageData.hitUnitList.erase( iter );
#endif  X2OPTIMIZE_STL_CONTAINER_USAGE
			}
            else
            {
                ++iter;
            }
		}
	}
	KTDXPROFILE_END();

	KTDXPROFILE_BEGIN( "MATRIX_AND_GAGE" );
	m_DamageLightTime -= m_fElapsedTime;
	if( m_DamageLightTime < 0.0f )
		m_DamageLightTime = 0.0f;

#ifdef USER_HOLD
	if(GetHold() == true)
	{
		m_FrameDataNow.syncData.position = m_vHold;
	}
#endif

#ifdef TEST_GROUP_GRAP
	if (GetGrap() == true)
	{
		m_FrameDataNow.syncData.position = m_vGrap;
	}
#endif TEST_GROUP_GRAP
	
	GetMatrix().Move( m_FrameDataNow.syncData.position );

#ifdef GRAPPLING_TEST
	CX2GameUnit* pGrappler2 = GetUnitGrapplingMe( false );
	if( NULL != pGrappler2 )
	{
		GetMatrix().RotateDegree( pGrappler2->GetUnitCondition( false ).m_GrapplingState.GetGrapplingRotation() );
	}
	else
#endif GRAPPLING_TEST
	{
#ifdef REVERSE_GRAVITY_TEST  // oasis907 : 김상윤 [2011.6.29] 
		if(m_fReverseGravitySpeedDeltaY == 0.f)
		{
#ifdef RIDING_SYSTEM
			if ( true == GetRidingOn() && GetNowStateID() != USI_RIDING_DIE )
				GetMatrix().RotateDegree( GetSaddleDegree() );
			else
#endif //RIDING_SYSTEM 탈 것 회전 값 적용하기
				GetMatrix().RotateDegree( m_FrameDataNow.unitCondition.dirDegree );
		}

#else
		GetMatrix().RotateDegree( m_FrameDataNow.unitCondition.dirDegree );
#endif REVERSE_GRAVITY_TEST

		
	}


	
	KTDXPROFILE_END();
// #ifdef FIXED_EMBLEM_HIDE_WHEN_DIE 캐릭터 그림자 뿌려주는 부분, 
// m_pUnitShadow 의 SetShowObject 를 false 로 두면 사라짐
	KTDXPROFILE_BEGIN( "ETC_FRAME_MOVE" );
#ifdef X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
	if( g_pMain->GetGameOption().GetOptionList().m_eEffect == CX2GameOption::OL_HIGH )
#else//X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
	if( g_pMain->GetGameOption().GetOptionList().m_bEffect == true )
#endif//X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
	{
		if( m_pUnitShadow != NULL 
#ifdef EVE_CLOAKING_ADJUST
			&& m_bAbsoluteInvisibility == false
#endif EVE_CLOAKING_ADJUST
			)
		{
			m_pUnitShadow->SetShowObject( true );
			m_pUnitShadow->UpdatePosition( m_FrameDataNow.syncData.position, m_FrameDataNow.unitCondition.landPosition, m_FrameDataNow.unitCondition.dirDegree );
		}

		if( m_pAfterImage != NULL )
			m_pAfterImage->OnFrameMove( m_fTime, m_fElapsedTime );
	}
	else
	{
		if( m_pUnitShadow != NULL )
		{
			m_pUnitShadow->SetShowObject( false );
		}
	}
	KTDXPROFILE_END();




	KTDXPROFILE_BEGIN( "SET_COMPONENT_POS" );
	if( IsMyUnit() == false )
	{
		SetNowHp( m_FrameDataNow.syncData.fNowHP );
		SetNowMp( m_FrameDataNow.syncData.fNowMP );

//#ifndef SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//		SetFrameMoveCountNow( m_FrameDataNow.syncData.dwFrameMoveCount );
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

		SetHitCount( m_FrameDataNow.syncData.ucHitCount );
		SetHittedCount( m_FrameDataNow.syncData.ucHittedCount );		
		SetNumOfDeBuff( m_FrameDataNow.syncData.ucNumOfDeBuff );
	}

	D3DXVECTOR3 markerPos, vHeadPos, vTempPos;
	GetFramePos( &vHeadPos, m_pFrame_Bip01_Head );
	markerPos = GetPos();
	markerPos.y = vHeadPos.y;

	markerPos.y += 70.0f;
	vTempPos = markerPos;

	D3DXVECTOR3 vSize = D3DXVECTOR3(0.6f, 0.6f, 0.6f);
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CKTDGParticleSystem::CParticle* pPart_Emblem_200 = g_pData->GetUIMajorParticle()->ValidateParticleHandle( m_hPart_Emblem_200 ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if( CKTDGParticleSystem::CParticle* pPart_Emblem_200 = m_pPart_Emblem_200 )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	{
		// 이브 투명화 상태일 때는 팀표시 마크를 안보이게
		if( true == GetAbsoluteInvisibility() )
		{
			pPart_Emblem_200->SetPos( D3DXVECTOR3( 0.f, -999999.f, 0.f ) );
		}
		else
		{
			pPart_Emblem_200->SetPos( vTempPos + D3DXVECTOR3( 0, 20, 0 ) );        
		}
		markerPos.y += 60.f;

		vSize = D3DXVECTOR3(0.36f, 0.36f, 0.36f);
	}

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CKTDGParticleSystem::CParticle* pHeadMarkerParticle = g_pX2Game->GetMajorParticle()->ValidateParticleHandle( m_hHeadMarkerParticle ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CKTDGParticleSystem::CParticle* pHeadMarkerParticle = m_pHeadMarkerParticle )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	{
//#ifdef TITLE_SYSTEM        
		pHeadMarkerParticle->SetSize( vSize );
//#endif
		pHeadMarkerParticle->SetPos( markerPos );


		// 이브 투명화 상태일 때는 팀표시 마크를 안보이게
		if( true == GetAbsoluteInvisibility() )
		{
			pHeadMarkerParticle->SetPos( D3DXVECTOR3( 0.f, -999999.f, 0.f ) );
		}
	}

	markerPos.y += 100.0f;

	CKTDGParticleSystem::CParticleEventSequence* pSeqHeadMaker = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqHeadMarker );
	if( NULL != pSeqHeadMaker )
	{
		pSeqHeadMaker->SetPosition( markerPos );
	}

	CKTDGParticleSystem::CParticleEventSequence* pSeqQuestion = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hQuestionMark );
	if( NULL != pSeqQuestion )
	{
		pSeqQuestion->SetPosition( markerPos );
	}

	CKTDGParticleSystem::CParticleEventSequence* pSeqExclamationMark = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hExclamationMark );
	if( NULL != pSeqExclamationMark )
	{
		pSeqExclamationMark->SetPosition( markerPos );
	}

	KTDXPROFILE_END();

	if( m_FrameDataNow.stateParam.bInvincible == true || IsSuperArmor() )
		m_FlyCount = 0;


	KTDXPROFILE_BEGIN( "HYPER" );

	if( GetNowHp() <= 0.0f )
	{
		if( pSeq_Cold_Head != NULL )
		{
			pSeq_Cold_Head->ClearAllParticle();
			pSeq_Cold_Head->SetEmitRate( 0,0 );
		}

		if( NULL !=	pSeq_Stun )
		{
			pSeq_Stun->ClearAllParticle();
			pSeq_Stun->SetEmitRate( 0, 0 );
		}


		if ( pSeq_Enchant_Stun != NULL )
		{
			pSeq_Enchant_Stun->ClearAllParticle();
			pSeq_Enchant_Stun->SetEmitRate( 0, 0 );
		}

		if ( pSeq_Enchant_Exclamation != NULL )
		{
			pSeq_Enchant_Exclamation->ClearAllParticle();
			pSeq_Enchant_Exclamation->SetEmitRate( 0, 0 );
		}

		if ( pSeq_Enchant_Exclamation2 != NULL )
		{
			pSeq_Enchant_Exclamation2->ClearAllParticle();
			pSeq_Enchant_Exclamation2->SetEmitRate( 0, 0 );
		}

		if ( pSeq_Enchant_Exclamation3 != NULL )
		{
			pSeq_Enchant_Exclamation3->ClearAllParticle();
			pSeq_Enchant_Exclamation3->SetEmitRate( 0, 0 );
		}

		if ( pSeq_Enchant_Frozen_Second != NULL )
		{
			pSeq_Enchant_Frozen_Second->ClearAllParticle();
			pSeq_Enchant_Frozen_Second->SetEmitRate( 0, 0 );
		}

		if ( pSeq_Enchant_Blaze_Second != NULL )
		{
			pSeq_Enchant_Blaze_Second->ClearAllParticle();
			pSeq_Enchant_Blaze_Second->SetEmitRate( 0, 0 );
		}

		if ( pSeq_Enchant_Poison_Second != NULL )
		{
			pSeq_Enchant_Poison_Second->ClearAllParticle();
			pSeq_Enchant_Poison_Second->SetEmitRate( 0, 0 );
		}

		if ( pSeq_Enchant_Stun_Second != NULL )
		{
			pSeq_Enchant_Stun_Second->ClearAllParticle();
			pSeq_Enchant_Stun_Second->SetEmitRate( 0, 0 );
		}

		//{{ kimhc // 2010.6.15 // 서바이벌 모드 혹은 데스매치 플레이 중 킬을 한 유저의 컴퓨터에서만 부활한 상대방 속성인챈트가 보이지 않는 오류
#ifndef ENCHANT_BUG_TEST
		//{{AFX
		// 2008.10.28 죽었을 때 무기 인챈트 효과 제거 - 김태완
		// 2008.11.03 코드 위치 정확한 곳으로 이동 : HP가 0 아래가 되었을때 이펙트 삭제
		for( UINT i=0; i<m_vecpWeapon.size(); i++ )
		{
			Weapon* pWeapon = m_vecpWeapon[i];
			if( pWeapon != NULL )
			{
				pWeapon->SetEnchantParticleShow(false);
			}
		}

		SetShowEnchantedWeaponEffectAtHand( false );
		//}}AFX
#endif ENCHANT_BUG_TEST
//}} kimhc // 2010.6.15 //



		//2008.11.03 죽었을 때 상태이상 파티클 제거 - 김태완
		// 이 부분은 나중에 function 하나 만들어서 코드정리를 좀 해줘야겠다

		m_ExtraDamagePack.Init();	// 하는 김에 상태이상 자체도 초기화

		if ( pSeq_Poison != NULL )
		{
			//pSeq_Poison->ClearAllParticle();
			pSeq_Poison->SetEmitRate( 0, 0 );
		}
		if ( pSeq_Fire1 != NULL )
		{
			//pSeq_Fire1->ClearAllParticle();
			pSeq_Fire1->SetEmitRate( 0, 0 );
		}
		if ( pSeq_Fire2 != NULL )
		{
			//pSeq_Fire2->ClearAllParticle();
			pSeq_Fire2->SetEmitRate( 0, 0 );
		}
		if ( pSeq_Curse != NULL )
		{
			//pSeq_Curse->ClearAllParticle();
			pSeq_Curse->SetEmitRate( 0, 0 );
		}
		if ( pSeq_SlowLeft != NULL )
		{
			//pSeq_SlowLeft->ClearAllParticle();
			pSeq_SlowLeft->SetEmitRate( 0, 0 );
		}
		if ( pSeq_SlowRight != NULL )
		{
			//pSeq_SlowRight->ClearAllParticle();
			pSeq_SlowRight->SetEmitRate( 0, 0 );
		}
		if ( pSeq_Cold1L != NULL )
		{
			//pSeq_Cold1L->ClearAllParticle();
			pSeq_Cold1L->SetEmitRate( 0, 0 );
		}
		if ( pSeq_Cold2L != NULL )
		{
			//pSeq_Cold2L->ClearAllParticle();
			pSeq_Cold2L->SetEmitRate( 0, 0 );
		}
		if ( pSeq_Cold1R != NULL )
		{ 
			//pSeq_Cold1R->ClearAllParticle();
			pSeq_Cold1R->SetEmitRate( 0, 0 );
		}
		if ( pSeq_Cold2R != NULL )
		{
			//pSeq_Cold2R->ClearAllParticle();
			pSeq_Cold2R->SetEmitRate( 0, 0 );
		}
		if ( pSeq_Pepper1 != NULL )
		{
			//pSeq_Pepper1->ClearAllParticle();
			pSeq_Pepper1->SetEmitRate( 0, 0 );
		}
		if ( pSeq_Pepper2 != NULL )
		{
			//pSeq_Pepper2->ClearAllParticle();
			pSeq_Pepper2->SetEmitRate( 0, 0 );
		}
		// mauntain : 김태환 [2012.05.21] 레나 2차 전직 나이트 와쳐 - 지연의 신호탄
#ifdef SERV_RENA_NIGHT_WATCHER
		if ( pSeq_Enchant_ArrowOfExplosion != NULL )
		{
			pSeq_Enchant_ArrowOfExplosion->ClearAllParticle();
			pSeq_Enchant_ArrowOfExplosion->SetEmitRate( 0, 0 );
		}

		if ( pSeq_StartOfDelayedFiringOverlap != NULL )
		{
			pSeq_StartOfDelayedFiringOverlap->ClearAllParticle();
			pSeq_StartOfDelayedFiringOverlap->SetEmitRate( 0, 0 );
		}
#endif SERV_RENA_NIGHT_WATCHER

	}
	KTDXPROFILE_END();



	for( UINT i=0; i<m_vecpWeapon.size(); ++i )
	{
		Weapon* pWeapon = m_vecpWeapon[i];
		pWeapon->CommonFrameMoveForUser( m_fTime, m_fElapsedTime );
	}
//#ifndef NOT_USE_DICE_ROLL
//	if( NULL != m_pDiceRoll )
//	{
//		m_pDiceRoll->OnFrameMove( m_fTime, m_fElapsedTime );
//	}
//#endif //NOT_USE_DICE_ROLL



	CommonFrameMove_TimedEvent();

	if( NULL != GetUnit() )
	{
		ProcessEnchantedWeaponEffectAtHand( GetUnit()->GetType() );
	}

#ifdef NEW_HENIR_TEST

#ifndef ADD_HENIR_BUFF		/// 버프로 변경되면서 쓰이지 않게 된 구문
	if(m_fTimeHenirBuff_Fire > 0.f)
	{
		m_fTimeHenirBuff_Fire -= m_fElapsedTime;
		if(m_fTimeHenirBuff_Fire <= 0.f)
		{
			m_fTimeHenirBuff_Fire = 0.f;
			SetEnableWeaponRenderEffect(false);
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13782), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );

		}
	}


	if(m_fTimeHenirBuff_Water > 0.f)
	{
		m_fTimeHenirBuff_Water -= m_fElapsedTime;
		if(m_fTimeHenirBuff_Water <= 0.f)
		{
			m_fTimeHenirBuff_Water = 0.f;
			SetEnableWeaponRenderEffect(false);
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13782), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );

		}
	}


	if(m_fTimeHenirBuff_Light > 0.f)
	{
		m_fTimeHenirBuff_Light -= m_fElapsedTime;
		if(m_fTimeHenirBuff_Light <= 0.f)
		{
			m_fTimeHenirBuff_Light = 0.f;
			SetEnableWeaponRenderEffect(false);
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13782), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );

		}
	}


	if(m_fTimeHenirBuff_Nature > 0.f)
	{
		m_fTimeHenirBuff_Nature -= m_fElapsedTime;
		if(m_fTimeHenirBuff_Nature <= 0.f)
		{
			m_fTimeHenirBuff_Nature = 0.f;
			if( INVALID_EFFECTSET_HANDLE != m_hHenirBuff_Nature )
			{
				g_pX2Game->GetEffectSet()->StopEffectSet( m_hHenirBuff_Nature );
				m_hHenirBuff_Nature = INVALID_EFFECTSET_HANDLE;
			}
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13782), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );

		}
	}


	if(m_fTimeHenirBuff_Wind > 0.f)
	{
		m_fTimeHenirBuff_Wind -= m_fElapsedTime;
		if(m_fTimeHenirBuff_Wind <= 0.f)
		{
			m_fTimeHenirBuff_Wind = 0.f;

			SetAnimSpeedFactor( 1.f,	0.f, CX2GameUnit::SFI_SPEED_7, CX2GameUnit::SFST_UPDATE);
			SetVecMoveSpeedFactor( 1.f,	0.f, CX2GameUnit::SFI_SPEED_7, CX2GameUnit::SFST_UPDATE);
			SetVecJumpSpeedFactor( 1.f,	0.f, CX2GameUnit::SFI_SPEED_7, CX2GameUnit::SFST_UPDATE);

			if( INVALID_EFFECTSET_HANDLE != m_hHenirBuff_Wind )
			{
				g_pX2Game->GetEffectSet()->StopEffectSet( m_hHenirBuff_Wind );
				m_hHenirBuff_Wind = INVALID_EFFECTSET_HANDLE;
			}
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13782), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );

		}
	}
#endif ADD_HENIR_BUFF

#endif NEW_HENIR_TEST

#ifdef SPECIAL_USE_ITEM
	if(m_fSpecialItemBuff_Wind > 0.f)
	{
		m_fSpecialItemBuff_Wind -= m_fElapsedTime;
		if(m_fSpecialItemBuff_Wind <= 0.f)
		{
			StopSpecialItemBuffWind();
		}
	}
#endif

	if( m_fSummonNpcCoolTime > 0.f )
	{
		m_fSummonNpcCoolTime -= m_fElapsedTime;
		if( m_fSummonNpcCoolTime < 0.f )
			m_fSummonNpcCoolTime = 0.f;
	}

#ifdef BUFF_TEMPLET_SYSTEM
	if( GetNowHp() > 0.f )							//체력이 남아있을 때 실행
		//10초당 HP 회복 소켓
		SetHPChangeRatePerSecond( m_fElapsedTime );

	if( GetNowMp() < GetMaxMp() )					//엠피가 최대치가 아닐 때 실행
		//엠피 회복량 중가 소켓
		SetMPChangeRateValue( m_fElapsedTime );
#endif BUFF_TEMPLET_SYSTEM

#ifdef SUMMON_MONSTER_CARD_SYSTEM			// mauntain : 김태환 [2012.06.26] 몬스터 카드 소환 기능 - 해당 유저의 몬스터 소환 정보	
	if( -1 != GetSummonMonsterCardData().GetSummonMonsterUID() )
	{
		float fSummonMonsterTime = GetSummonMonsterCardData().GetSummonMonsterTime();
		if( fSummonMonsterTime > 0.f)
			fSummonMonsterTime -= m_fElapsedTime;

		if( 0.f >=  fSummonMonsterTime )		//유지시간 종료시
		{
			CX2GUNPC* pNPC = g_pX2Game->GetNPCUnitByUID( GetSummonMonsterCardData().GetSummonMonsterUID() );
#ifdef NO_COPY_CARD_MONSTER_DATA_SHASHA // 카드 몬스터로 제작된 하멜 비던 샤샤에 대한 예외 처리, 13-09-06 kimjh, 나중에 NPC Type 을 추가하거나 인자를 추가하여 변경할 것!
			if( NULL != pNPC )
			{	
				pNPC->StateChange( pNPC->GetSummmonEndState() );			//소환 해제 State로 강제 전환
#ifdef EVENT_MONSTER_CARD_SUMMON_ENEMY
				//삭제될 타이밍에 4마리 소환 몬카면 동시에 삭제 시켜준다.
				std::vector<int> temp = AccessSummonMonsterCardData().GetSummonMonsterUIDVec();
				if( !temp.empty() )
				{
					for( int i = 0; i < temp.size(); ++i )
					{
						CX2GUNPC* pNPC = g_pX2Game->GetNPCUnitByUID( temp[i] );
						if( NULL != pNPC )
							pNPC->StateChange( pNPC->GetSummmonEndState() );
					}
					AccessSummonMonsterCardData().ClearSummonMonsterUIDInVec();
				}		
#endif EVENT_MONSTER_CARD_SUMMON_ENEMY

				if ( false == pNPC->IsUnitID( CX2UnitManager::NUI_SHASHA_STAGE0 ) &&
					false == pNPC->IsUnitID( CX2UnitManager::NUI_SHASHA_STAGE1 ) &&
					false == pNPC->IsUnitID( CX2UnitManager::NUI_SHASHA_STAGE2 ) )
					AccessSummonMonsterCardData().init();									//소환 정보 초기화
			}
#else // NO_COPY_CARD_MONSTER_DATA_SHASHA
			if( NULL != pNPC )
				pNPC->StateChange( pNPC->GetSummmonEndState() );			//소환 해제 State로 강제 전환
#ifdef EVENT_MONSTER_CARD_SUMMON_ENEMY
				//삭제될 타이밍에 4마리 소환 몬카면 동시에 삭제 시켜준다.
				std::vector<int> temp = AccessSummonMonsterCardData()->GetSummonMonsterUIDVec();
				if( !temp.empty() )
				{
					for( int i = 0; i < temp.size(); ++i )
					{
						CX2GUNPC* pNPC = g_pX2Game->GetNPCUnitByUID( temp[i] );
						if( NULL != pNPC )
							pNPC->StateChange( pNPC->GetSummmonEndState() );
					}
					AccessSummonMonsterCardData()->ClearSummonMonsterUIDInVec();
				}		
#endif EVENT_MONSTER_CARD_SUMMON_ENEMY
			
			AccessSummonMonsterCardData().init();									//소환 정보 초기화
#endif // NO_COPY_CARD_MONSTER_DATA_SHASHA // 카드 몬스터로 제작된 하멜 비던 샤샤에 대한 예외 처리, 13-09-06 kimjh, 나중에 NPC Type 을 추가하거나 인자를 추가하여 변경할 것!			
		}
		else
			AccessSummonMonsterCardData().SetSummonMonsterTime( fSummonMonsterTime );
	}
#endif SUMMON_MONSTER_CARD_SYSTEM

	if( true == m_bChangeWorldColor )
		ChangeWorldColorByHyperMode();

	if( false == IsSamef( -1.f, m_fShowSkillCutInTime ) )
		ShowActiveSkillCutInAndLightByScript( m_fShowSkillCutInTime, false );

	DoCustomFunctionByBuffInCommonFrameMove();

	DamageDataChangeProcess();
}



void CX2GUUser::CommonFrameMove_Invincible()
{
	KTDXPROFILE_BEGIN( "INVINCIBLE" );
	if( m_FrameDataNow.stateParam.invincibleTime.m_fX != -1.0f
		&& m_FrameDataNow.stateParam.invincibleTime.m_fY != -1.0f )
	{
		if( m_FrameDataNow.stateParam.invincibleTime.m_fX <= m_pXSkinAnim->GetNowAnimationTime()
			&& m_FrameDataNow.stateParam.invincibleTime.m_fY > m_pXSkinAnim->GetNowAnimationTime() )
			m_FrameDataNow.stateParam.bInvincible = true;
		else
			m_FrameDataNow.stateParam.bInvincible = false;
	}
	else if( m_fForceInvincibleTime <= 0.0f )	// FieldFix: else를 쓰는 것은 잘못 된것이지 않나?? m_FrameDataNow.stateParam.invincibleTime
	{
		m_FrameDataNow.stateParam.bInvincible = false;
	}

	if( m_fShowInvincibleTime > 0.0f )
	{
		m_fShowInvincibleSwapTime -= m_fElapsedTime;
		if( m_fShowInvincibleSwapTime <= 0.0f )
		{
			m_fShowInvincibleSwapTime	= 0.05f;
			m_bShowInvincibleWhite		= !m_bShowInvincibleWhite;
		}

	}
	if( m_FrameDataNow.syncData.bFrameStop == false )
	{
		m_fShowInvincibleTime -= m_fElapsedTime;
		if( m_fShowInvincibleTime <= 0.0f )
			m_fShowInvincibleTime = 0.0f;		

		m_fForceInvincibleTime -= m_fElapsedTime;
		if( m_fForceInvincibleTime <= 0.0f )
			m_fForceInvincibleTime = 0.0f;
	}

	if( m_fForceInvincibleTime > 0.0f )
	{
		m_FrameDataNow.stateParam.bInvincible = true;
	}
	KTDXPROFILE_END();
}

void CX2GUUser::CommonFrameMove_TimedEvent()
{
	KTDXPROFILE();

    {
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        const D3DXVECTOR2& v2AfterImage = m_v2NowAfterImageTime;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        const D3DXVECTOR2& v2AfterImage = m_FrameDataNow.stateParam.afterImage;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	    if( v2AfterImage.x != -1.0f
		    && v2AfterImage.y != -1.0f )
	    {
		    if( v2AfterImage.x <= m_pXSkinAnim->GetNowAnimationTime()
			    && v2AfterImage.y > m_pXSkinAnim->GetNowAnimationTime() )
			    EnableAfterImage();
		    else
			    DisableAfterImage();
	    }
    }

	//공격 체크
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    for( int i = 0; i < (int)m_vecAttackTime.size(); i++ )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	for( int i = 0; i < (int)m_AttackTimeList.size(); i++ )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        D3DXVECTOR2 attackTime = m_vecAttackTime[i].m_v2AttackTime;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		D3DXVECTOR2 attackTime = m_AttackTimeList[i];
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		if( m_pXSkinAnim->GetNowAnimationTime() > attackTime.x && m_pXSkinAnim->GetNowAnimationTime() < attackTime.y )
		{
			if( g_pData->GetDamageManager()->DamageCheck( &m_DamageData ) == true )
			{
				if( m_FrameDataNow.unitCondition.bHit == false && GetShowSmallGageAndName() )
				{
					D3DXVECTOR2 projPos = g_pKTDXApp->GetProj3DPos( m_DamageData.impactPoint );
					projPos.y -= 50.0f;
					projPos.x += 50.0f;

		//{{ kimhc // 2010.12.21 // 2010-12-23 New Character CHUNG
	#ifdef	NEW_CHARACTER_CHUNG
					CKTDGParticleSystem::CParticleEventSequence* pParticle = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                        m_vecAttackTime[i].m_wstrProjSeqName.c_str(),
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                        m_AttackProjSeqName[i].c_str(), 
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                        projPos.x, projPos.y, 0.0f,	100, 100, -1, 1 );
					if ( NULL != pParticle && false == m_FrameDataNow.syncData.bIsRight )
					{
						D3DXVECTOR3 vAddRotateRel = pParticle->GetAddRotateRel();
						// Z축 회전만 반대로 시킴
						vAddRotateRel.z *= -1.0f;
						pParticle->SetAddRotateRel( vAddRotateRel );						
					}
	#else	NEW_CHARACTER_CHUNG
					g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                        m_vecAttackTime[i].m_wstrProjSeqName.c_str()
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                        m_AttackProjSeqName[i].c_str(), 
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                        projPos.x, projPos.y, 0.0f,	100, 100, -1, 1 );
	#endif	NEW_CHARACTER_CHUNG
		//}} kimhc // 2010.12.21 //  2010-12-23 New Character CHUNG
					
				}
				m_FrameDataNow.unitCondition.bHit = true;
				m_FrameDataFuture.unitCondition.bHit = m_FrameDataNow.unitCondition.bHit;
			}
		}
	}

	if( IsMyUnit() == false )
	{
		for( int i = 0; i < (int)m_StopAllList.size(); i++ )
		{
			D3DXVECTOR3 stopTime = m_StopAllList[i];
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            if( m_pXSkinAnim->EventTimerOneshot( stopTime.x ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			if( m_pXSkinAnim->EventTimer( stopTime.x ) == true && EventCheck( stopTime.x, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			{
				switch ( g_pX2Game->GetGameType() )
				{
				case CX2Game::GT_DUNGEON:
				case CX2Game::GT_BATTLE_FIELD:
					{
						g_pX2Game->StopAllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 800.0f, this, stopTime.z );
						g_pX2Game->StopAllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 700.0f, this, stopTime.z );
					} break;

				case CX2Game::GT_PVP:
					{
						g_pX2Game->StopAllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 2000.0f, this, stopTime.z );
						g_pX2Game->StopAllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 1300.0f, this, stopTime.z );
					} break;

				default:
					ASSERT( !L"wrong path" );
					break;
				}
			}
		}
		for( int i = 0; i < (int)m_Stop2AllList.size(); i++ )
		{
			D3DXVECTOR3 stopTime = m_Stop2AllList[i];
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            if( m_pXSkinAnim->EventTimerOneshot( stopTime.x ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			if( m_pXSkinAnim->EventTimer( stopTime.x ) == true && EventCheck( stopTime.x, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			{
				switch ( g_pX2Game->GetGameType() )
				{
				case CX2Game::GT_DUNGEON:
				case CX2Game::GT_BATTLE_FIELD:
					{
						g_pX2Game->Stop2AllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 800.0f, this, stopTime.z );
						g_pX2Game->Stop2AllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 700.0f, this, stopTime.z );
					} break;

				case CX2Game::GT_PVP:
					{
						g_pX2Game->Stop2AllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 2000.0f, this, stopTime.z );
						g_pX2Game->Stop2AllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 1300.0f, this, stopTime.z );
					} break;

				default:
					ASSERT( !L"wrong path" );
					break;
				}
			}
		}
	}
	for( int i = 0; i < (int)m_StopOtherList.size(); i++ )
	{
		D3DXVECTOR2 stopTime = m_StopOtherList[i];
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        if( m_pXSkinAnim->EventTimerOneshot( stopTime.x ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		if( m_pXSkinAnim->EventTimer( stopTime.x ) == true && EventCheck( stopTime.x, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		{
			switch ( g_pX2Game->GetGameType() )
			{
			case CX2Game::GT_DUNGEON:
			case CX2Game::GT_BATTLE_FIELD:
				{
					g_pX2Game->StopOtherUnit( this, stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 800.0f );
					g_pX2Game->StopOtherUnit( this, stopTime.y, &m_FrameDataNow.syncData.position, 700.0f );
				} break;

			case CX2Game::GT_PVP:
				{
					g_pX2Game->StopOtherUnit( this, stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 2000.0f );
					g_pX2Game->StopOtherUnit( this, stopTime.y, &m_FrameDataNow.syncData.position, 1300.0f );
				} break;

			default:
				ASSERT( !L"wrong path" );
				break;
			}
		}
	}
	for( int i = 0; i < (int)m_Stop2OtherList.size(); i++ )
	{
		D3DXVECTOR2 stopTime = m_Stop2OtherList[i];
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        if( m_pXSkinAnim->EventTimerOneshot( stopTime.x ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		if( m_pXSkinAnim->EventTimer( stopTime.x ) == true && EventCheck( stopTime.x, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		{
			switch ( g_pX2Game->GetGameType() )
			{
			case CX2Game::GT_DUNGEON:
			case CX2Game::GT_BATTLE_FIELD:
				{
					g_pX2Game->Stop2OtherUnit( this, stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 800.0f );
					g_pX2Game->Stop2OtherUnit( this, stopTime.y, &m_FrameDataNow.syncData.position, 700.0f );
				} break;

			case CX2Game::GT_PVP:
				{
					g_pX2Game->Stop2OtherUnit( this, stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 2000.0f );
					g_pX2Game->Stop2OtherUnit( this, stopTime.y, &m_FrameDataNow.syncData.position, 1300.0f );
				} break;

			default:
				ASSERT( !L"wrong path" );
				break;
			}
		}
	}

#ifdef USE_DIFFERENT_SOUND_WHEN_IN_SPECIAL
	std::vector<SoundPlayData> vecSoundPlayData = m_vecSoundPlayData;	
	BOOST_TEST_FOREACH( CX2GameUnit::SoundPlayData&, soundData, vecSoundPlayData )
#else //USE_DIFFERENT_SOUND_WHEN_IN_SPECIAL
	BOOST_TEST_FOREACH( const CX2GameUnit::SoundPlayData&, soundData, m_vecSoundPlayData )
#endif //USE_DIFFERENT_SOUND_WHEN_IN_SPECIAL
	{
		float fTime = soundData.m_SoundPlayTime;
		int iRate	= soundData.m_SoundPlayRate;

#ifdef TEST_GROUP_GRAP // oasis907 : 김상윤 [2011.1.24] // 홀드 상태에서는 캐릭터 사운드 플레이 안하기
		if(GetGrap() == true)
			continue;
#endif TEST_GROUP_GRAP

#ifdef RIDING_SYSTEM
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        bool bSkinAnimEventTimer = m_pXSkinAnim->EventTimerOneshot( fTime );
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		bool bSkinAnimEventTimer = m_pXSkinAnim->EventTimer( fTime );
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

		if ( NULL != m_ptrRidingPet && true == GetRidingOn() && NULL != m_ptrRidingPet->GetXSkinAnimPtr() )
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            bSkinAnimEventTimer = m_ptrRidingPet->GetXSkinAnimPtr()->EventTimerOneshot( fTime );
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			bSkinAnimEventTimer = m_ptrRidingPet->GetXSkinAnimPtr()->EventTimer( fTime );
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        if( bSkinAnimEventTimer == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		if( bSkinAnimEventTimer == true && EventCheck( fTime, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#else //RIDING_SYSTEM
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        if( m_pXSkinAnim->EventTimerOneshot( fTime ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		if( m_pXSkinAnim->EventTimer( fTime ) == true && EventCheck( fTime, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#endif //RIDING_SYSTEM
		{
			if( rand()%100 < iRate )
			{
#ifdef USE_DIFFERENT_SOUND_WHEN_IN_SPECIAL
				if( NULL != g_pData && NULL != g_pData->GetUnitManager())
				{
					std::map<std::wstring, CX2UnitManager::UseSpecialSoundData> mapDifferentSound = g_pData->GetUnitManager()->m_mapDifferentSoundMappingData;
					std::map<std::wstring, CX2UnitManager::UseSpecialSoundData>::iterator itMappingSound = mapDifferentSound.find(soundData.m_SoundPlayName);
					
					if( itMappingSound != mapDifferentSound.end())
					{
						// 파일이 있으면 치환하자. 임시로. 
						bool bNowChangeSound = false;

						switch(itMappingSound->second.iUseSpecialSoundType)
						{
						case CX2UnitManager::USE_SPECIAL_SOUND_TYPE::USST_BASIC: // 아무 조건 없으면 무조건 변경
							bNowChangeSound = true;
							break;

						case CX2UnitManager::USE_SPECIAL_SOUND_TYPE::USST_BERSERK: // 광폭화 모드
							// 각 캐릭터이고, 3각성이면
							if( NULL != GetUnit())
							{
								if( itMappingSound->second.iUseSpecialSoundSubType == GetUnit()->GetType() 
									&& GetHyperModeCountUsed() >= 3 ) // 3개 이상일 경우 광폭화로 설정
								{
									bNowChangeSound = true;
								}
							}
							break;

						default:
							bNowChangeSound = false;
							break;
						}

						if(bNowChangeSound)
							soundData.m_SoundPlayName = itMappingSound->second.wstrChangeSound;
					}
				}
#endif //USE_DIFFERENT_SOUND_WHEN_IN_SPECIAL

#ifdef FIX_USER_3D_SOUND_BUG
				// 내 유닛만 출력 해야 할 사운드라면
				if( true == soundData.m_bOnlyIfMyUnit )
				{
					// 현재 객체가 내 유닛 객체일 때만 출력
					if( true == IsMyUnit() )
					{
						// 3D 사운드 적용하지 않기.
						// (일부 던전 맵에서 시작 사운드가 나오지 않는 오류 수정을 위해)
						PlaySound( soundData.m_SoundPlayName.c_str(), false );
					}
				}
				else
				{
					// 3D 사운드 적용
					PlaySound( soundData.m_SoundPlayName.c_str() );
				}
#else
				if( soundData.m_bOnlyIfMyUnit == true && IsMyUnit() == true )
					PlaySound( soundData.m_SoundPlayName.c_str(), false );
				else if( soundData.m_bOnlyIfMyUnit == false )
					PlaySound( soundData.m_SoundPlayName.c_str(), false );
#endif // FIX_USER_3D_SOUND_BUG
			}
		}
	}

#ifdef INSERT_BUFF_FACTOR_BY_SCPRIPT_STATE
	CommonFrameMove_InsertBuffFactor();
#endif // INSERT_BUFF_FACTOR_BY_SCPRIPT_STATE
}



void CX2GUUser::CommonFrameMove_Particle()
{
	KTDXPROFILE();


	D3DXVECTOR3 hpAndMpUpPos = GetBonePos( L"Bip01_Spine" );
	if ( m_hSeqHPUp != INVALID_PARTICLE_SEQUENCE_HANDLE )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqHPUp );
		if( NULL != pSeq )
		{
			pSeq->SetPosition( hpAndMpUpPos );
		}
		else
		{
			m_hSeqHPUp = INVALID_PARTICLE_SEQUENCE_HANDLE;
		}
	}	
	
	if ( m_hSeqMPUp != INVALID_PARTICLE_SEQUENCE_HANDLE )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqMPUp );
		if( NULL != pSeq )
		{
			pSeq->SetPosition( hpAndMpUpPos );
		}
		else
		{
			m_hSeqMPUp = INVALID_PARTICLE_SEQUENCE_HANDLE;
		}
	}




	D3DXVECTOR3 MPHoldEffPos( 0, 0, 0);
	GetFramePos( &MPHoldEffPos, m_pFrame_Bip01 );
#ifdef  X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
	CKTDGParticleSystem::CParticleEventSequence* pSeqHoldEffCenter = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hHoldEffCenter );
	CKTDGParticleSystem::CParticleEventSequence* pSeqHoldEffCircle = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hHoldEffCircle );
#else   X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
	CKTDGParticleSystem::CParticleEventSequence* pSeqHoldEffCenter = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHoldEffCenter );
	CKTDGParticleSystem::CParticleEventSequence* pSeqHoldEffCircle = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHoldEffCircle );
#endif  X2OPTIMIZE_CONFUSE_DIFFERENT_PARTICLE_SYSTEMS_BUG_FIX
	if( NULL != pSeqHoldEffCenter )
		pSeqHoldEffCenter->SetPosition( MPHoldEffPos );
	if( NULL != pSeqHoldEffCircle )
		pSeqHoldEffCircle->SetPosition( MPHoldEffPos );

#ifdef HIT_PARTICLE_TRACE_UNIT
	D3DXVECTOR3 vEffectPos = GetPos();
	vEffectPos.y += 110.f;
	for( SeqHitParticleTraceUnitContainer::iterator lit = m_listSeqHitParticleTraceUnit.begin() ; lit != m_listSeqHitParticleTraceUnit.end(); )
	{
		CKTDGParticleSystem::CParticleEventSequenceHandle hParticle = *lit;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( hParticle );
		if( NULL != pSeq )
		{
			pSeq->SetPosition( vEffectPos );
			++lit;
		}
		else
		{
#ifdef  X2OPTIMIZE_STL_CONTAINER_USAGE
            lit = EraseUnorderlyUsingSwap( m_listSeqHitParticleTraceUnit, lit );
#else   X2OPTIMIZE_STL_CONTAINER_USAGE
			lit = m_listSeqHitParticleTraceUnit.erase(lit);
#endif  X2OPTIMIZE_STL_CONTAINER_USAGE
		}

	}
#endif HIT_PARTICLE_TRACE_UNIT

//#ifdef PVP_BOSS_COMBAT_TEST
//	
//	if( INVALID_EFFECTSET_HANDLE == m_hEffectSetBossMark )
//	{
//		if( NULL != g_pX2Room )
//		{
//			CX2Room::SlotData* pSlotData = g_pX2Room->GetSlotDataByUnitUID( GetUnitUID() );
//			if( NULL != pSlotData )
//			{
//				if( true == pSlotData->GetIsBoss() )
//				{
//					m_hEffectSetBossMark = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_BossHeadMark_Test", (CX2GameUnit*) this );
//				}
//			}
//		}
//	}
//
//#endif PVP_BOSS_COMBAT_TEST


}











// enchant frozen 이 아니에요~
/*virtual*/ void CX2GUUser::CommonFrameMoveStateAbnormalityFrozen()
{
	KTDXPROFILE();

	if( m_ExtraDamagePack.m_Frozen.m_fTime > 0.f )
	{
		if ( this == g_pX2Game->GetMyUnit() )
			g_pX2Game->SetEnableAllKeyProcess( false );

		m_FrameDataNow.stateParam.bSuperArmor = true;
		m_FrameDataNow.stateParam.bSuperArmorNotRed = true;

		m_ExtraDamagePack.m_Frozen.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_Frozen.m_fTime <= 0.0f )
		{
			m_ExtraDamagePack.m_Frozen.m_fTime = 0.0f;
			if ( this == g_pX2Game->GetMyUnit() )
			{
				g_pX2Game->SetEnableAllKeyProcess( true );
			}

			if( GetNowHp() > 0.f )
			{
#ifdef ELSWORD_WAY_OF_SWORD
				if( m_ExtraDamagePack.m_Frozen.m_bCured == true )
				{
					m_ExtraDamagePack.m_Frozen.m_bCured = false;
#ifdef RIDING_SYSTEM
					if ( true == GetRidingOn() )
						StateChange( USI_RIDING_DAMAGE_FRONT, true );
					else
						StateChange( USI_DAMAGE_SMALL_FRONT, true );
#else //RIDING_SYSTEM
					StateChange( USI_DAMAGE_SMALL_FRONT, true );
#endif //RIDING_SYSTEM 데미지 State 변경
				}
				else
				{
#ifdef RIDING_SYSTEM
					if ( true == GetRidingOn() )
						StateChange( USI_RIDING_DAMAGE_FRONT, true );
					else
						StateChange( USI_DAMAGE_DOWN_FRONT, true );
#else //RIDING_SYSTEM
					StateChange( USI_DAMAGE_DOWN_FRONT, true );
#endif //RIDING_SYSTEM 데미지 State 변경
				}
#else
				StateChange( USI_DAMAGE_DOWN_FRONT, true );
#endif ELSWORD_WAY_OF_SWORD
			}
		}
	}





	if( m_ExtraDamagePack.m_Frozen.m_fTime > 0.f )
	{
		if( INVALID_EFFECTSET_HANDLE == m_hEffSetStateAbnormalityFrozen )
		{
			m_hEffSetStateAbnormalityFrozen = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_State_Abnormality_Frozen", this ); /*, NULL, false, -1.f, m_ExtraDamagePack.m_Frozen.m_fTime );*/
		}

		//if( INVALID_EFFECTSET_HANDLE != m_hEffSetStateAbnormalityFrozen )
		//{
		//	CX2EffectSet::EffectSetInstance* pEffInst = g_pX2Game->GetEffectSet()->GetEffectSetInstance( m_hEffSetStateAbnormalityFrozen );
		//	if( NULL != pEffInst )
		//	{
		//		pEffInst->m_fLifeTime = m_ExtraDamagePack.m_Frozen.m_fTime;
		//	}
		//	
		//}
	}
	else
	{
		if( INVALID_EFFECTSET_HANDLE != m_hEffSetStateAbnormalityFrozen )
		{
			g_pX2Game->GetEffectSet()->StopEffectSet( m_hEffSetStateAbnormalityFrozen );
		}
	}
}


#ifdef EDT_WATER_HOLD_TEST
//{{ lucidash : 김상훈 [2010.1.4]
void CX2GUUser::CommonFrameMoveStateAbnormalityWaterHold()
{
	KTDXPROFILE();

	if( m_ExtraDamagePack.m_WaterHold.m_fTime > 0.f )
	{
		if ( this == g_pX2Game->GetMyUnit() )
			g_pX2Game->SetEnableAllKeyProcess( false );

		m_FrameDataNow.stateParam.bSuperArmor = true;
		m_FrameDataNow.stateParam.bSuperArmorNotRed = true;

		m_ExtraDamagePack.m_WaterHold.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_WaterHold.m_fTime <= 0.0f )
		{
			m_bDisableGravity = false;
			m_ExtraDamagePack.m_WaterHold.m_fTime = 0.0f;
			if ( this == g_pX2Game->GetMyUnit() )
			{
				g_pX2Game->SetEnableAllKeyProcess( true );
			}

			if( GetNowHp() > 0.f )
			{
				if ( IsOnSomethingFuture() == false )
					StateChange( USI_DAMAGE_AIR_FALL, true );
				else
#ifdef RIDING_SYSTEM
					if ( true == GetRidingOn() )
						StateChange( USI_RIDING_DAMAGE_FRONT, true );
					else
						StateChange( USI_DAMAGE_DOWN_FRONT, true );
#else //RIDING_SYSTEM
					StateChange( USI_DAMAGE_DOWN_FRONT, true );
#endif //RIDING_SYSTEM 데미지 State 변경
			}
		}
		else
		{

			if( GetNowHp() > 0.f )
			{
				m_bDisableGravity = true;
			}
			else
			{
				m_bDisableGravity = false;
			}


			 m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
			 m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );
		//if ( IsOnSomethingFuture() == true )
//			{
//				m_FrameDataFuture.syncData.position.y				= 	m_FrameDataFuture.unitCondition.landPosition.y + 50.f;
//				m_FrameDataNow.syncData.position.y				= 	m_FrameDataFuture.unitCondition.landPosition.y + 50.f;
//			}
			if ( m_pXSkinAnim->EventTimer( 0.1f ) == true )
				AnimStop();
		}
	}


	if( m_ExtraDamagePack.m_WaterHold.m_fTime > 0.f )
	{
		if( INVALID_PARTICLE_SEQUENCE_HANDLE == m_hSeqWaterHold1 )
		{
			m_hSeqWaterHold1 = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Pa_LAGUZ_SPAB_BigBouble", 0,0,0 );
		}

		if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_hSeqWaterHold1 )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWaterHold1 );
			//ASSERT( NULL != pSeq );
			if( NULL != pSeq )
			{

				pSeq->SetPosition( GetBonePos(L"Bip01_Spine") );
				pSeq->SetEmitRate( 20, 20 );
			}
			else
			{
				m_hSeqWaterHold1 = INVALID_PARTICLE_SEQUENCE_HANDLE;
			}
		}
	}
	else
	{
		if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_hSeqWaterHold1 )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWaterHold1 );
			//ASSERT( NULL != pSeq );
			if( NULL != pSeq )
			{
				pSeq->SetEmitRate( 0, 0 );
				pSeq->ClearAllParticle();
			}
			else
			{
				m_hSeqWaterHold1 = INVALID_PARTICLE_SEQUENCE_HANDLE;
			}
		}
	}

	if( m_ExtraDamagePack.m_WaterHold.m_fTime > 0.f )
	{
		if( INVALID_PARTICLE_SEQUENCE_HANDLE == m_hSeqWaterHold2 )
		{
			m_hSeqWaterHold2 = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Pa_LAGUZ_SPAB_SmallBouble", 0,0,0 );
		}

		if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_hSeqWaterHold2 )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWaterHold2 );
			//ASSERT( NULL != pSeq );
			if( NULL != pSeq )
			{
				pSeq->SetPosition( GetBonePos(L"Bip01_Spine") );
				pSeq->SetEmitRate( 20, 20 );
			}
			else
			{
				m_hSeqWaterHold2 = INVALID_PARTICLE_SEQUENCE_HANDLE;
			}
		}
	}
	else
	{
		if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_hSeqWaterHold2 )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWaterHold2 );
			//ASSERT( NULL != pSeq );
			if( NULL != pSeq )
			{
				pSeq->SetEmitRate( 0, 0 );
				pSeq->ClearAllParticle();
			}
			else
			{
				m_hSeqWaterHold2 = INVALID_PARTICLE_SEQUENCE_HANDLE;
			}
		}
	}
}
//}} lucidash : 김상훈 [2010.1.4]
#endif EDT_WATER_HOLD_TEST

#ifdef EVE_ELECTRA
void CX2GUUser::CommonFrameMoveStateAbnormalityFlashBang()
{
	KTDXPROFILE();

	if( m_ExtraDamagePack.m_FlashBang.m_fTime > 0.f )
	{
		m_ExtraDamagePack.m_FlashBang.m_fTime -= m_fElapsedTime;
		if( m_ExtraDamagePack.m_FlashBang.m_fTime < 0.0f )
		{
			m_ExtraDamagePack.m_FlashBang.m_fTime = 0.0f;

			if( IsMyUnit() == true )
			{
				g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqWhiteOut );
				g_pX2Game->GetMajorParticle()->CreateSequenceHandle( NULL,  L"WhiteOutExtraDamageEnd", D3DXVECTOR3(0,0,0) );
			}
			m_bWhiteOut = false;
		}
	}
}
#endif EVE_ELECTRA



//#ifdef HEAD_INVERSE_KINEMATICS_TEST
//void CX2GUUser::HeadIKFrameMove( double fTime, float fElapsedTime )
//{
//	KTDXPROFILE();
//
//	if( NULL == m_pFrame_Bip01_Head )
//		return;
//
//	if( m_pXSkinAnim == NULL )
//		return; 
//
//	bool bReturnToZeroAngle = false;
//	D3DXVECTOR3 vLocalRotationAxis(1, 0, 0);
//
//	const float MAGIC_DELAY_TIME = 1.f;
//	if( true == m_bEnableHeadIK &&
//		m_FrameDataNow.unitCondition.fStateTime > MAGIC_DELAY_TIME )
//	{
//		float fEnemyDistance = 0.f;
//		CX2GameUnit* pEnemyUnit = g_pX2Game->GetFrontNearestEnemyUnit( (CX2GameUnit*)this, fEnemyDistance );
//		
//		if( NULL != pEnemyUnit &&
//			fEnemyDistance < m_fHeadIKRadius )
//		{
//			const D3DXVECTOR3 LOCAL_HEAD_FORWARD( 0.f, 0.f, 1.f );
//			D3DXVECTOR3 vLookAt = pEnemyUnit->GetPos();
//			vLookAt.y += pEnemyUnit->GetUnitHeight(false) * 3.f / 4.f;
//
//			D3DXMATRIX matToLocal; 
//			if( NULL == D3DXMatrixInverse( &matToLocal, NULL, &m_pFrame_Bip01_Head->combineMatrix ) )
//				return;
//
//
//			D3DXVECTOR3 vLocalLookAt;
//			D3DXVec3TransformCoord( &vLocalLookAt, &vLookAt, &matToLocal );
//			D3DXVec3Normalize( &vLocalLookAt, &vLocalLookAt );
//
//
//			D3DXVec3Cross( &vLocalRotationAxis, &LOCAL_HEAD_FORWARD, &vLocalLookAt );
//			D3DXVec3Normalize( &vLocalRotationAxis, &vLocalRotationAxis );
//
//			float fLocalRotationAngle = acosf( D3DXVec3Dot( &LOCAL_HEAD_FORWARD, &vLocalLookAt ) );
//			if( fLocalRotationAngle < -m_fHeadIKAngleMax )
//			{
//				fLocalRotationAngle = -m_fHeadIKAngleMax;
//			}
//			else if( fLocalRotationAngle > m_fHeadIKAngleMax )
//			{
//				fLocalRotationAngle = m_fHeadIKAngleMax;
//			}
//
//			if( fLocalRotationAngle < m_fHeadIKAngle )
//			{
//				m_fHeadIKAngle -= fElapsedTime * m_fHeadIKAngleChangeRate;
//				if( m_fHeadIKAngle < fLocalRotationAngle )
//				{
//					m_fHeadIKAngle = fLocalRotationAngle;
//				}
//			}
//			else if( fLocalRotationAngle > m_fHeadIKAngle )
//			{
//				m_fHeadIKAngle += fElapsedTime * m_fHeadIKAngleChangeRate;
//				if( m_fHeadIKAngle > fLocalRotationAngle )
//				{
//					m_fHeadIKAngle = fLocalRotationAngle;
//				}
//			}
//		}
//		else
//		{
//			bReturnToZeroAngle = true;
//		}
//	}
//	else if( 0.f != m_fHeadIKAngle )
//	{
//		bReturnToZeroAngle = true;
//	}
//
//
//	if( true == bReturnToZeroAngle )
//	{
//		if( m_fHeadIKAngle > 0.f )
//		{
//			m_fHeadIKAngle -= fElapsedTime * m_fHeadIKAngleChangeRate;
//			if( m_fHeadIKAngle < 0.f )
//			{
//				m_fHeadIKAngle = 0.f;
//			}
//		}
//		else if( m_fHeadIKAngle < 0.f )
//		{
//			m_fHeadIKAngle += fElapsedTime * m_fHeadIKAngleChangeRate;
//			if( m_fHeadIKAngle > -0.f )
//			{
//				m_fHeadIKAngle = 0.f;
//			}
//		}
//	}
//
//
//	if( 0.f != m_fHeadIKAngle )
//	{
//		D3DXMATRIX matRotation;
//		D3DXMatrixRotationAxis( &matRotation, &vLocalRotationAxis, m_fHeadIKAngle );
//		m_pFrame_Bip01_Head->combineMatrix = matRotation * m_pFrame_Bip01_Head->combineMatrix;
//
//		if( NULL != m_pFrame_Bip01_Head->pFrameFirstChild &&
//			NULL != m_pMotion )
//		{
//			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameFirstChildClone = (CKTDXDeviceXSkinMesh::MultiAnimFrame*) m_pFrame_Bip01_Head->pFrameFirstChild;
//			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameFirstChildSrc = m_pMotion->GetFrame( pFrameFirstChildClone->m_iIndex );
//			if( NULL != pFrameFirstChildSrc )
//			{
//				m_pXSkinAnim->UpdateAnimationFrame_Public( pFrameFirstChildSrc, &m_pFrame_Bip01_Head->combineMatrix, pFrameFirstChildClone );
//			}
//		}
//	}
//}
//
//#endif HEAD_INVERSE_KINEMATICS_TEST



#ifdef RENA_SIEGE_MODE_ANGLE_TEST
// @fRotationAngle: degree 값입니다
void CX2GUUser::LookAtIKFrameMove( CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame, const D3DXVECTOR3& vRotationAxis, const float fRotationAngle )
{
	KTDXPROFILE();

	if( NULL == pFrame )
		return;

	if( NULL == m_pMotion )
		return; 

	if( m_pXSkinAnim == NULL )
		return; 

	if( 0.f == fRotationAngle )
		return; 


	D3DXMATRIX matRotation;
	D3DXMatrixRotationAxis( &matRotation, &vRotationAxis, D3DX_PI / 180.f * fRotationAngle );
	pFrame->combineMatrix = matRotation * pFrame->combineMatrix;

	CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameFirstChildClone = (CKTDXDeviceXSkinMesh::MultiAnimFrame*) pFrame->pFrameFirstChild;
	if( pFrameFirstChildClone != NULL )
	{
		CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameFirstChildSrc = m_pMotion->FindFrame(pFrameFirstChildClone->Name);
		if( NULL != pFrameFirstChildSrc )
		{
			m_pXSkinAnim->UpdateAnimationFrame_Public( pFrameFirstChildSrc, &pFrame->combineMatrix, pFrameFirstChildClone );
		}
	}
}
#endif RENA_SIEGE_MODE_ANGLE_TEST


float CX2GUUser::DoAimingTarget(float fDist, const D3DXVECTOR3& vCoefficient, bool &bIsTarget, D3DXVECTOR3 &vTargetPosition, D3DXVECTOR3 &vLandPos, bool bGap )
{
	bIsTarget = false;

	if( g_pX2Game == NULL )
		return 0.f;

	CX2GameUnit *pAimedUnit = NULL;
	float fMinDist = fDist * fDist;
	float fX = 0.f;
	float fY = 0.f;

	for(int i=0; i<g_pX2Game->GetUnitNum(); ++i)
	{
		// 조준할 놈을 선별한다.
		CX2GameUnit *pUnit = g_pX2Game->GetUnit(i);
		if( pUnit != NULL && g_pX2Game->IsValidUnit( pUnit ) == true &&
			pUnit->GetTeam() != GetTeam() && pUnit->GetNowHp() > 0.f )
		{			
			// npc라면 basic type 몬스터만 타겟팅할 수 있다.
			if( pUnit->GetGameUnitType() == CX2GameUnit::GUT_NPC )
			{
				CX2GUNPC *pNpc = (CX2GUNPC*)pUnit;
				if( pNpc->GetNPCTemplet().m_ClassType != CX2UnitManager::NCT_BASIC ||
					pNpc->GetInvincible() )
					continue;
			}

			D3DXVECTOR3 vTargetPos = pUnit->GetPos();
			D3DXVECTOR3 vMyPos = GetPos();
#ifdef ADJUST_SIEGE_SHELLING
			const CKTDXCollision::CollisionDataListSet& AttackListSet = pUnit->GetCollisionListSet();
#ifdef  X2OPTIMIZE_LOCKONDATA_COLLISION_CHECK_CRASH_BUG_FIX
			bool    bInit = false;
#else   X2OPTIMIZE_LOCKONDATA_COLLISION_CHECK_CRASH_BUG_FIX
			const CKTDXCollision::CollisionDataList* collisionDataList = *AttackListSet.begin();
			CKTDXCollision::CollisionData* collisionData = *collisionDataList->begin();
			vPos = collisionData->GetPointStart();
#endif  X2OPTIMIZE_LOCKONDATA_COLLISION_CHECK_CRASH_BUG_FIX

			BOOST_FOREACH( const CKTDXCollision::CollisionDataList* collisionDataList, AttackListSet )
			{
				BOOST_FOREACH( CKTDXCollision::CollisionData* collisionData, *collisionDataList )
				{
					D3DXVECTOR3 vCollPos = collisionData->GetPointStart();
#ifdef  X2OPTIMIZE_LOCKONDATA_COLLISION_CHECK_CRASH_BUG_FIX
					if ( bInit == false )
					{
						bInit = true;
						vTargetPos = vCollPos;
						continue;
					}
#endif  X2OPTIMIZE_LOCKONDATA_COLLISION_CHECK_CRASH_BUG_FIX

					float fDist = GetDistance( vMyPos, vCollPos );
					float fOldDist = GetDistance( vMyPos, vTargetPos );

					if ( fDist <= fOldDist )
						vTargetPos = vCollPos;
				}
			}

			if ( bInit == false )
			{
				vTargetPos = pUnit->GetPos();
			}
#endif //ADJUST_SIEGE_SHELLING

			D3DXVECTOR3 vDir = vTargetPos - vMyPos;
			float fDistTemp = D3DXVec3LengthSq( &vDir);
			if( fDistTemp > fMinDist)
				continue;

			float fDir = 0.1f;
			if( GetIsRight() == false )
				fDir = -0.1f;

			const CKTDGLineMap::LineData* pLineData =  g_pX2Game->GetWorld()->GetLineMap()->GetLineData( pUnit->GetLastTouchLineIndex() );
			if( pLineData == NULL )
				continue;

			D3DXVECTOR3 vLineDir = pLineData->dirVector;
			D3DXVECTOR3 vRight = vTargetPos - (vMyPos + (vLineDir * fDir));
			bool bFront = false;
			if( D3DXVec3LengthSq( &vRight ) < fDistTemp )
			{
				bFront = true;
			}
			if( bFront == false )
				continue;

			vDir = pUnit->GetLandPos() - GetLandPos();
			vDir.y = 0.f;
			float fFixDir = ( pUnit->GetHeadBonePos().y - vTargetPos.y ) / 2.f;
			float fTempY = pUnit->GetHeadBonePos().y - fFixDir;
			float fLocalX = D3DXVec3LengthSq( &vDir );
			float fLocalY = pow( fTempY - vMyPos.y, 2 );	// 허리꺽을 각도 계산을 위한 표적 값
			float fLocalPosY = pow( vTargetPos.y - vMyPos.y, 2 );	// 범위내에 들어오는지 판단하기 위한 값
			float fMaxLocalY = vCoefficient.x * fLocalX;
			float fMinLocalY = vCoefficient.y * fLocalX;

			if( bGap == true )
			{
				fMaxLocalY += 50.f;
				fMinLocalY -= 30.f;
			}

			if( fMaxLocalY < 0.f || fMinLocalY > 0.f )
				continue;
			
			// y축 사이각... 귀찮아 걍 내적쓰자.			
			D3DXVECTOR3 v1 = vTargetPos - vMyPos;
			D3DXVECTOR3 v2 = vLineDir * fDir;
			v1.y = v2.y = 0.f;
			D3DXVec3Normalize( &v1, &v1 );
			D3DXVec3Normalize( &v2, &v2 );
			
			float fDot = acos(D3DXVec3Dot( &v1, &v2));
			if( fDot < -1.f * vCoefficient.z || fDot > vCoefficient.z )
				continue;
			


			if(  fTempY - vMyPos.y < 0.f )
				fLocalY *= -1.f;
			
			float fSignedValue = 1.f;
			if( vTargetPos.y < vMyPos.y )
			{
				fSignedValue *= -1.f;
			}

			if( fSignedValue * fLocalPosY <= fMaxLocalY && fSignedValue * fLocalPosY >= fMinLocalY )
			{
				fMinDist = fDistTemp;
				pAimedUnit = pUnit;
				fX = fLocalX;
				fY = fLocalY;
#ifdef ADJUST_SIEGE_SHELLING
				vTargetPosition = vTargetPos;
#endif //ADJUST_SIEGE_SHELLING
			}			
		}
	}

	if( pAimedUnit == NULL )
	{
		bIsTarget = false;
		return 0.f;
	}
#ifndef ADJUST_SIEGE_SHELLING
	vTargetPosition = pAimedUnit->GetPos();
	vTargetPosition.y += (( pAimedUnit->GetHeadBonePos().y - vTargetPosition.y ) / 2.f);
#endif //ADJUST_SIEGE_SHELLING
	vLandPos = pAimedUnit->GetLandPos();
	bIsTarget = true;
	return atan( fY / fX );
}

void CX2GUUser::RotateBone( CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame, const D3DXVECTOR3& vRotationAxis, const float fRotationAngle )
{
	KTDXPROFILE();

	if( NULL == pFrame )
		return;

	if( NULL == m_pMotion )
		return; 

	if( m_pXSkinAnim == NULL )
		return; 

	if( 0.f == fRotationAngle )
		return; 


	D3DXMATRIX matRotation;
	D3DXMatrixRotationAxis( &matRotation, &vRotationAxis, D3DX_PI / 180.f * fRotationAngle );
	pFrame->combineMatrix = matRotation * pFrame->combineMatrix;

	CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameFirstChildClone = (CKTDXDeviceXSkinMesh::MultiAnimFrame*) pFrame->pFrameFirstChild;
	if( pFrameFirstChildClone != NULL )
	{
		CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameFirstChildSrc = m_pMotion->FindFrame(pFrameFirstChildClone->Name);
		if( NULL != pFrameFirstChildSrc )
		{
			m_pXSkinAnim->UpdateAnimationFrame_Public( pFrameFirstChildSrc, &pFrame->combineMatrix, pFrameFirstChildClone );
		}
	}
}



void CX2GUUser::CommonCameraMove()
{
	KTDXPROFILE();

	// dynamic camera 옵션이 켜져있을 때만 이 함수가 호출된다. 


	int iCameraIndex = m_FrameDataNow.stateParam.normalCamera;
	if( true == m_FrameDataNow.unitCondition.bHit )
	{
		iCameraIndex = m_FrameDataNow.stateParam.hitCamera;
	}


#ifdef CAMERA_SCRIPTING_TEST
	g_pX2Game->GetX2Camera()->GetLineScriptedCameraData().m_vFinalRelativeEyePosition = D3DXVECTOR3( 0, 0, 0 );
#endif CAMERA_SCRIPTING_TEST


	if( m_LuaManager.BeginTable( "CAMERA", iCameraIndex ) == true )
	{
#ifdef FIX_BATTLE_FIELD_DYNAMIC_CAMERA
		if( 0.f > fPreWorldNear )
		{ // 다이나믹 카메라 시작 되면 캐릭터가 사라지는 문제를 수정하기 위해 , Near값 10으로 보정
			fPreWorldNear = g_pKTDXApp->GetDGManager()->GetNear();
			if( fPreWorldNear >= 50.f )
			{
				g_pKTDXApp->GetDGManager()->SetNear(10);

				g_pKTDXApp->GetDGManager()->SetProjection( 
					g_pKTDXApp->GetDGManager()->GetNear(),
					g_pKTDXApp->GetDGManager()->GetFar(), true );
			}
			else
			{
				fPreWorldNear = -1.f;
			}
		}
#endif // FIX_BATTLE_FIELD_DYNAMIC_CAMERA

		std::vector< float > vecSubCameraTiming;
		if( m_LuaManager.BeginTable( "SUB_CAMERA_TIMING" ) == true )
		{
			float fSubCameraTiming = 0.f;
			for( int i=1; ; i++ )
			{
				if( true == m_LuaManager.GetValue( i, fSubCameraTiming ) )
				{
					vecSubCameraTiming.push_back( fSubCameraTiming );
				}
				else
				{
					break;
				}
			}
			m_LuaManager.EndTable(); // SUB_CAMERA_TIMING
		}

		if( true == vecSubCameraTiming.empty() )
		{
			g_pX2Game->GetX2Camera()->PlayLuaCamera( this, m_LuaManager, 1 );
		}
		else
		{
			bool bDone = false;
			for( int i=0; i<(int)vecSubCameraTiming.size(); i++ )
			{
				float fTiming = vecSubCameraTiming[i];

				if( m_pXSkinAnim->GetNowAnimationTime() < fTiming )
				{
					char tableName[64] = "";
					StringCchPrintfA( tableName, ARRAY_SIZE(tableName), "SUB_CAMERA%d", i );
					g_pX2Game->GetX2Camera()->PlayLuaCamera( this, m_LuaManager, tableName );
					bDone = true;
					break;
				}
			}

			if( false == bDone )
			{
				char tableName[64] = "";
				StringCchPrintfA( tableName, ARRAY_SIZE(tableName), "SUB_CAMERA%d", (int)vecSubCameraTiming.size() );
				g_pX2Game->GetX2Camera()->PlayLuaCamera( this, m_LuaManager, tableName );
			}
		}

		
		m_LuaManager.EndTable(); // CAMERA
	}
	else
	{
#ifdef FIX_BATTLE_FIELD_DYNAMIC_CAMERA
		if( 0.f < fPreWorldNear )
		{// 다이나믹 카메라에 의해 SetNear값을 10으로 보정 한 상태라면 원복
			g_pKTDXApp->GetDGManager()->SetNear(fPreWorldNear);
			fPreWorldNear = -1.f;

			g_pKTDXApp->GetDGManager()->SetProjection( 
				g_pKTDXApp->GetDGManager()->GetNear(),
				g_pKTDXApp->GetDGManager()->GetFar(), true );
		}
#endif // FIX_BATTLE_FIELD_DYNAMIC_CAMERA

		float eyeDistance = 0;

#ifdef DASH_CAMERA_ANGLE_TEST
		//{{AFX
		if ( CheckDashAngleChangeTime() == true )
		{
			if ( g_pX2Game->GetInputData()->pureRight == true || g_pX2Game->GetInputData()->pureLeft == true )
			{
				if ( m_fTimeToDashCameraChange >= DASH_CAMERA_FIRST_WAIT_TIME )
				{	
					m_fAngleDegree = GetDashCameraAngleDegree();
				}
			}
		}
		//}}AFX
#endif // DASH_CAMERA_ANGLE_TEST





		const CKTDGLineMap::CameraData* pCameraData = g_pX2Game->GetWorld()->GetLineMap()->GetCameraData( m_FrameDataFuture.syncData.lastTouchLineIndex );
		if( NULL != pCameraData )
		{
#ifdef CHECK_CAMERA_INFO
			m_bIsLineMapCamera = true;
#endif //CHECK_CAMERA_INFO
			switch( pCameraData->m_eType )
			{
			case CKTDGLineMap::LCT_ABSOULTE_POSITION:
				{
					g_pX2Game->GetX2Camera()->GameLineCamera( this, pCameraData->m_vEye, pCameraData->m_vLookAt, pCameraData->m_bFocusUnit, 0.4f );			
				} break;
			case CKTDGLineMap::LCT_RELATIE_POSITION:

				{
#ifdef CAMERA_SCRIPTING_TEST
					g_pX2Game->GetX2Camera()->GetLineScriptedCameraData().m_vFinalRelativeEyePosition = pCameraData->m_vRelativeEye;
					g_pX2Game->GetX2Camera()->GetLineScriptedCameraData().m_fSpeed = pCameraData->m_fCameraRepositionSpeed;
#endif CAMERA_SCRIPTING_TEST
					g_pX2Game->GetX2Camera()->NomalTrackingCamera( this, g_pMain->GetGameOption().GetCameraDistance(), 200, m_fAngleDegree, eyeDistance, 0.f, 0.3f );
				} break;

			default:
				{
					g_pX2Game->GetX2Camera()->NomalTrackingCamera( this, g_pMain->GetGameOption().GetCameraDistance(), 200, m_fAngleDegree, eyeDistance, 0.f, 0.3f );

				} break;
			}

		}
		else
		{
#ifdef CHECK_CAMERA_INFO
			m_bIsLineMapCamera = false;
#endif //CHECK_CAMERA_INFO
#ifdef SERV_CHUNG_TACTICAL_TROOPER
			if( m_GameCameraOffset.bEnable == true )
			{
				g_pX2Game->GetX2Camera()->NomalTrackingCamera( this, g_pMain->GetGameOption().GetCameraDistance() + m_GameCameraOffset.fCameraDistance,
					200.f + m_GameCameraOffset.fHeight,
					m_fAngleDegree + m_GameCameraOffset.fAngleDegree,				
					eyeDistance + m_GameCameraOffset.fEyeDistance,
					0.f + m_GameCameraOffset.fLookatDistance,
					0.3f + m_GameCameraOffset.fTrackingTime,
					0.0f + m_GameCameraOffset.fTrackingAtTime );

			}
			else
				g_pX2Game->GetX2Camera()->NomalTrackingCamera( this, g_pMain->GetGameOption().GetCameraDistance(), 200, m_fAngleDegree, eyeDistance, 0.f, 0.3f );
#else
			g_pX2Game->GetX2Camera()->NomalTrackingCamera( this, g_pMain->GetGameOption().GetCameraDistance(), 200, m_fAngleDegree, eyeDistance, 0.f, 0.3f );
#endif SERV_CHUNG_TACTICAL_TROOPER
		}
	}
}





#ifdef HEAD_ATTACHED_CAMERA_TEST 

	bool CX2GUUser::BoneAttachedCamera( const wstring& boneName, const D3DXVECTOR3& vEyeOffset /*= D3DXVECTOR3(0, 0, 0) */ )
	{
		if( true == boneName.empty() )
			return false;

		if( m_pXSkinAnim == NULL )
			return false;

		CKTDXDeviceXSkinMesh::MultiAnimFrame* pBone = m_pXSkinAnim->GetCloneFrame( boneName.c_str() );
		if( NULL == pBone )
			return false;

		return BoneAttachedCamera( pBone, vEyeOffset );
	}

	bool CX2GUUser::BoneAttachedCamera( const CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame, const D3DXVECTOR3& vEyeOffset /*= D3DXVECTOR3(0, 0, 0) */ )
	{
		if( NULL == pFrame )
			return false;

		D3DXVECTOR3 vEye( pFrame->combineMatrix._41, pFrame->combineMatrix._42, pFrame->combineMatrix._43 );

		const D3DXVECTOR3 LOCAL_BONE_FORWARD( 0, 0, 1 );
		D3DXMATRIX matRotation = pFrame->combineMatrix;
		matRotation._41 = 0.f;
		matRotation._42 = 0.f;
		matRotation._43 = 0.f;
		matRotation._44 = 1.f;

		D3DXVECTOR3 vLookVec;
		D3DXVec3TransformCoord( &vLookVec, &LOCAL_BONE_FORWARD, &matRotation );
		D3DXVec3Normalize( &vLookVec, &vLookVec );

		
		vEye += vLookVec * vEyeOffset.z;

		D3DXVECTOR3 vUpVec(0, 0, 0);
		if( 0.f != vEyeOffset.x ||
			0.f != vEyeOffset.y )
		{
			const D3DXVECTOR3 LOCAL_BONE_UP( 1, 0, 0 );
			D3DXVec3TransformCoord( &vUpVec, &LOCAL_BONE_UP, &matRotation );
			D3DXVec3Normalize( &vUpVec, &vUpVec );
		}

		if( 0.f != vEyeOffset.y )
		{
			vEye += vUpVec * vEyeOffset.y;
		}

		
		if( 0.f != vEyeOffset.x )
		{
			D3DXVECTOR3 vRightVec(0, 0, 0);
			D3DXVec3Cross( &vRightVec, &vUpVec, &vLookVec );

			vEye += vRightVec * vEyeOffset.x;
		}

		if( NULL != g_pX2Game )
		{
			g_pX2Game->GetX2Camera()->ManualDirectCamera( vEye, vEye + vLookVec );
		}

		return true;
	}
#endif HEAD_ATTACHED_CAMERA_TEST

/*virtual*/ void CX2GUUser::DetonationEventProcess()
{
#ifdef RIDING_SYSTEM
	if( true == GetRidingOn() )
		return;
#endif // RIDING_SYSTEM

#ifdef NO_DETONATION
	if( true == GetNoDetonation() )
		return;
#endif //NO_DETONATION

	if( m_OrgInputData.pureZ == true || m_OrgInputData.pureX == true )
	{
		GetGageData()->SetCanChargeMpForDetonation( true );
	}
}

void CX2GUUser::CommonEventProcess()
{
	const int iSecretSkillStateId = m_ComboAndSkillChainSystem.GetTriggerSecretSkillState( this );
	if ( 0 != iSecretSkillStateId )
		StateChange( iSecretSkillStateId );

	SpecialAttackEventProcess( CX2SkillTree::ASUT_ANYTIME );		// 아무때나 쓸 수 있는 필살기에 대한 키 이벤트 처리


#ifdef GRAPPLING_TEST
	GrappledEventProcess();
#endif GRAPPLING_TEST
	if( m_InputData.oneSpace == true &&
		 true == GetUnit()->GetUnitData().m_UserSkillTree.GetEnabledSkillSlotB())
	{
		ToggleSkillSlotAB();
	}



	if( true == m_bSteppedJumpLinemap )
	{
		m_bSteppedJumpLinemap = false;


		if( m_fPepperRunTime > 0.f )
		{
			StateChange( USI_PEPPER_RUN_JUMP_UP );
		}
		else
		{
#ifdef RIDING_SYSTEM
			/// 점프 라인맵 에서 탈것 탑승중이면 탈것 점프 모션으로 변경
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_JUMP_UP );
			else
				StateChange( USI_JUMP_UP );
#endif // RIDING_SYSTEM
		}

		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
		m_PhysicParam.nowSpeed.x += m_vAddJumpSpeed.x;
		m_PhysicParam.nowSpeed.y = m_vAddJumpSpeed.y;
	}

	DetonationEventProcess();

	if( m_FrameDataFuture.syncData.fNowHP <= 0.0f && true == IsOnSomethingFuture() )
	{
		if( m_FrameDataNow.unitCondition.bAttackerFront == true )
		{
#ifdef RIDING_SYSTEM
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_DIE );
			else
				 StateChange( USI_DIE_FRONT );
#else //RIDING_SYSTEM
			StateChange( USI_DIE_FRONT );
#endif //RIDING_SYSTEM
		}
		else
		{
#ifdef RIDING_SYSTEM
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_DIE );
			else
				StateChange( USI_DIE_BACK );
#else //RIDING_SYSTEM
			StateChange( USI_DIE_BACK );
#endif //RIDING_SYSTEM
		}
	}
#ifdef RIDING_SYSTEM	// 오현빈 // 죽은 상태에서 탈 것 탑승 모션으로 공중에 굳는 문제 수정
	else if( m_FrameDataFuture.syncData.fNowHP <= 0.0f && false == IsOnSomethingFuture() )
	{
		if ( true == GetRidingOn() )
		{
			StateChange( USI_JUMP_DOWN );
		}
	}
#endif // RIDING_SYSTEM
}

void CX2GUUser::CommonStateEndFuture()
{
	LUA_GET_VALUE( m_LuaManager, "TRANSITION", m_FrameDataFuture.unitCondition.bTransitionChange, true );

	bool bFlipDir = false;
	LUA_GET_VALUE( m_LuaManager, "FLIP_DIR_END", bFlipDir, false );
	if( bFlipDir == true )
	{
		m_FrameDataFuture.syncData.bIsRight			= !m_FrameDataFuture.syncData.bIsRight;
		m_FrameDataFuture.unitCondition.dirDegree.y	+= 180.0f;
	}

#ifdef SERV_ARA_CHANGE_CLASS_SECOND // 김태환

	/// 해당 스테이트에서만 정면을 보고, 스테이트가 끝나면 원래 방향으로 돌아봄
	if ( true == m_bRightAtThisState )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
		m_bRightAtThisState					= false;
	}

#endif // SERV_ARA_CHANGE_CLASS_SECOND

#ifdef LINKED_LINEMAP_JUMP_USER_TEST
	if( CX2GameUnit::GUSI_NONE != m_CommonState.m_LinkJumpState &&
		m_FrameDataFuture.syncData.nowState == m_CommonState.m_LinkJumpState )
	{
		LinkJumpEnd();
	}
#endif LINKED_LINEMAP_JUMP_USER_TEST

	//{{ kimhc // 2010.2.17 //
#ifdef	APPLY_MOTION_OFFSET
	m_bApplyMotionOffset = true;
#endif	APPLY_MOTION_OFFSET
	//}} kimhc // 2010.2.17 //

}


void CX2GUUser::CommonStateEnd()
{
	
#ifdef CRAYONPOP_EMOTION_WITH_MUSIC		// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨
	if ( false == m_bIsPlayAvatarEmotionSoundWithoutEmotion )
#endif // CRAYONPOP_EMOTION_WITH_MUSIC	// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨	
	{
		if( m_pAvatarEmotionSound != NULL )
		{
			m_pAvatarEmotionSound->Stop();
			SAFE_CLOSE( m_pAvatarEmotionSound );
		}
	}

	for( UINT i=0; i<m_vecpWeapon.size(); ++i )
	{
		m_vecpWeapon[i]->CommonStateEnd();
	}

	if( m_LuaManager.BeginTable( "ENABLE_ATTACK_BOX" ) == true )
	{
		int index = 1;
		wstring wname;
		while( m_LuaManager.GetValue( index, wname ) == true )
		{
			SetEnableAttackBox( wname.c_str(), false );

			index++;
		}

		m_LuaManager.EndTable();
	}

	if( m_LuaManager.BeginTable( "DISABLE_ATTACK_BOX" ) == true )
	{
		int index = 1;
		wstring wname;
		while( m_LuaManager.GetValue( index, wname ) == true )
		{
			SetEnableAttackBox( wname.c_str(), true );

			index++;
		}

		m_LuaManager.EndTable();
	}

	LUA_GET_VALUE( m_LuaManager, "TRANSITION", m_FrameDataNow.unitCondition.bTransitionChange, true );
#ifndef WORLD_TOOL
	if ( NULL != g_pX2Game->GetWorld() )
		g_pX2Game->GetWorld()->FadeWorldColor( g_pX2Game->GetWorld()->GetOriginColor(), 1.0f );
#endif

	int stateStrID;
	if( m_LuaManager.GetValue( "STATE_STRING",	stateStrID ) == true )
	{
		g_pX2Game->SetStateString( L"" );
	}
#ifdef SKILLSTRING_IN_SKILLTEMPLET
	g_pX2Game->SetStateString( L"" );
#endif //SKILLSTRING_IN_SKILLTEMPLET

	DeleteEffectSetOnStateEnd();

	//{{ kimhc // 2010.2.17 //
// #ifdef	APPLY_MOTION_OFFSET
// 	m_bApplyMotionOffset = true;
// #endif	APPLY_MOTION_OFFSET
	//}} kimhc // 2010.2.17 //


#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE	  // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
	// CUSTOM_STATE_DELETE_EFFECT_SET_ON_STATE_END 구문이 있을 때, 해당 State 가 끝나면 m_vecEffectSetToDeleteOnCustomState 내용을 모두 지운다.
	bool bCustomStateDeleteEffectSetOnStateEnd = false;
	LUA_GET_VALUE( m_LuaManager, "CUSTOM_STATE_DELETE_EFFECT_SET_ON_STATE_END",	bCustomStateDeleteEffectSetOnStateEnd,	false );
	if(bCustomStateDeleteEffectSetOnStateEnd)
	{
		DeleteEffectSetOnCustomState();
	}
#endif // SERV_ELESIS_SECOND_CLASS_CHANGE // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트

#ifdef SERV_ELSWORD_INFINITY_SWORD
	m_OldStateId = m_NowStateData.stateID;
#endif




	DoCustomFunctionByBuffInCommonStateEnd();
}



#ifdef GRAPPLING_TEST


	/*virtual*/ void CX2GUUser::GrappledEventProcess()
	{
		KTDXPROFILE();


		if( GetFutureStateID() != m_CommonState.m_GrappledFront &&
			GetFutureStateID() != m_CommonState.m_GrappledBack )
		{
			return;
		}


		const float MAGIC_TIME = 10.f;
		if( m_FrameDataFuture.unitCondition.fStateTime > MAGIC_TIME )
		{
			StateChange( m_CommonState.m_Thrown );
		}
		else if( NULL == GetUnitGrapplingMe( true ) )
		{
			StateChange( m_CommonState.m_Thrown );
		}
	}



	void CX2GUUser::GrappledPhysicProcess( bool bFuture )
	{

		KTDXPROFILE();

		CX2GameUnit* pGrappler = NULL;
		//if( true == IsMyUnit() )
		//{
		//	pGrappler = m_FrameDataFuture.unitCondition.m_GrapplingState.GetUnitGrapplingMe();
		//}

		if( NULL == pGrappler )
		{
			pGrappler = m_FrameDataNow.unitCondition.m_GrapplingState.GetUnitGrapplingMe();
		}
		
		if( NULL == pGrappler )
			return;


		CX2GUUser::FrameData* pFrameData = NULL;
		if( true == bFuture )
			pFrameData = &m_FrameDataFuture;
		else
			pFrameData = &m_FrameDataNow;



		pGrappler->CalcGrapplingPosition( false );

		if( true == IsMyUnit() )
		{
			m_FrameDataFuture.unitCondition.m_GrapplingState.m_vGrappledPosition = GetPos( true );
			m_FrameDataFuture.unitCondition.m_GrapplingState.m_vGrappledRotation = m_FrameDataFuture.unitCondition.dirDegree;
			m_FrameDataFuture.unitCondition.m_GrapplingState.CalcGrappledPosition();

			pFrameData->syncData.position = pGrappler->GetUnitCondition( false ).m_GrapplingState.GetGrapplingPosition();/* 
				+ GetPos( true ) - m_FrameDataFuture.unitCondition.m_GrapplingState.GetGrappledPosition();*/
		}
		else
		{
			m_FrameDataNow.unitCondition.m_GrapplingState.m_vGrappledPosition = GetPos( false );
			m_FrameDataNow.unitCondition.m_GrapplingState.m_vGrappledRotation = m_FrameDataNow.unitCondition.dirDegree;
			m_FrameDataNow.unitCondition.m_GrapplingState.CalcGrappledPosition();

			pFrameData->syncData.position = pGrappler->GetUnitCondition( false ).m_GrapplingState.GetGrapplingPosition(); /*
				+ GetPos( false ) - m_FrameDataNow.unitCondition.m_GrapplingState.GetGrappledPosition();*/
		}


		pFrameData->syncData.lastTouchLineIndex = pGrappler->GetLastTouchLineIndex( false );

		pFrameData->unitCondition.dirDegree = pGrappler->GetUnitCondition( false ).dirDegree;
		pFrameData->unitCondition.dirVector = pGrappler->GetUnitCondition( false ).dirVector;	

		pFrameData->syncData.bIsRight = pGrappler->GetIsRight();

		pFrameData->unitCondition.bFootOnLine = false;
		pFrameData->unitCondition.bFootOnUnit = false;

		pFrameData->unitCondition.landPosition = pGrappler->GetLandPos( false );

	}



#endif GRAPPLING_TEST





void CX2GUUser::PhysicProcess()
{
	KTDXPROFILE();



//#ifdef TRANSFORMER_TEST
//
//	if( true == GetTransformed() &&
//		NULL != GetTransformer() )
//	{
//		m_FrameDataFuture.syncData.position = GetTransformer()->GetPos();
//		m_FrameDataFuture.syncData.lastTouchLineIndex = GetTransformer()->GetLastTouchLineIndex();
//
//
//		m_FrameDataFuture.unitCondition.dirDegree = GetTransformer()->GetRotateDegree();
//		m_FrameDataFuture.unitCondition.dirVector = GetTransformer()->GetDirVector();
//
//		m_FrameDataFuture.syncData.bIsRight = GetTransformer()->GetIsRight();
//
//		m_FrameDataFuture.unitCondition.bFootOnLine = GetTransformer()->GetUnitCondition().bFootOnLine;
//		//m_FrameDataFuture.unitCondition.bFootOnUnit = false;
//		m_FrameDataFuture.unitCondition.landPosition = GetTransformer()->GetLandPos();
//
//		return; 
//	}
//
//#endif TRANSFORMER_TEST









	//물리 파라메터 계산//////////////////////////////////////////////////////////
	D3DXVECTOR3 position;
	D3DXVECTOR3 positionOrg;
	D3DXVECTOR3 angleDegree;

	//현재 정보 받아오기
	positionOrg = position = m_FrameDataFuture.syncData.position;
	angleDegree	= m_FrameDataFuture.unitCondition.dirDegree;
	

	if( g_pX2Game == NULL || g_pX2Game->GetWorld() == NULL )
	{
		ASSERT( !"user physic process world / linemap is NULL" );
		return;
	}


	CKTDGLineMap* pLineMap = g_pX2Game->GetWorld()->GetLineMap();
	if( NULL == pLineMap )
	{
		ASSERT( !"user physic process linemap is NULL" );
		return;
	}



	const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );

//{{ kimhc // 2010.7.7 // 몬스터가 생성한 라인맵
#ifdef	LINE_MAP_CREATED_BY_MONSTER

	// 몬스터가 생성한 라인맵인데 diable 한 경우라면
	if ( pLineData != NULL && pLineData->m_bTempLineMap == true && pLineData->bEnable == false )
	{
		D3DXVECTOR3 outPos( 0.0f, 0.0f, 0.0f );
		int iLineIndex = -1;
		// 바로 밑의 라인맵이 있는지 검색
#ifdef  X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
        pLineMap->GetDownNearestWithBound( positionOrg, FLT_MAX, &outPos, &iLineIndex );
#else   X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
		pLineMap->GetDownNearest( positionOrg, &outPos, &iLineIndex );
#endif  X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
		pLineData = pLineMap->GetLineData( iLineIndex );

		// 있으면 밑으로 내려감
		if ( pLineData != NULL )
		{
			m_FrameDataFuture.syncData.position.y	-= LINE_RADIUS * 1.5f;
			position	= m_FrameDataFuture.syncData.position;
			positionOrg = m_FrameDataFuture.syncData.position;
			angleDegree	= pLineData->dirDegree;

			m_FrameDataFuture.syncData.lastTouchLineIndex	= iLineIndex;
			m_FrameDataFuture.unitCondition.dirDegree		= pLineData->dirDegree;
			m_FrameDataFuture.unitCondition.bTempLineMap	= pLineData->m_bTempLineMap;	
		}
	}

#ifdef WORLD_TRIGGER
	bool bFindLine = false;
	if( pLineData == NULL || 
		( pLineData->bEnable == false && pLineData->m_bTempLineMap == false ) )
	{
		D3DXVECTOR3 outPos( 0.0f, 0.0f, 0.0f );
		int iLineIndex = -1;
		// 바로 밑의 라인맵이 있는지 검색
#ifdef  X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
        pLineMap->GetDownNearestWithBound( positionOrg, FLT_MAX, &outPos, &iLineIndex );
#else   X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
		pLineMap->GetDownNearest( positionOrg, &outPos, &iLineIndex );
#endif  X2OPTIMIZE_LINEMAP_OPTIMIZE_AND_BUG_FIX
		pLineData = pLineMap->GetLineData( iLineIndex );

		// 있으면 밑으로 내려감
		if ( pLineData != NULL )
		{
			m_FrameDataFuture.syncData.position.y	-= LINE_RADIUS * 1.5f;
			position	= m_FrameDataFuture.syncData.position;
			positionOrg = m_FrameDataFuture.syncData.position;
			angleDegree	= pLineData->dirDegree;

			m_FrameDataFuture.syncData.lastTouchLineIndex	= iLineIndex;
			m_FrameDataFuture.unitCondition.dirDegree		= pLineData->dirDegree;
			m_FrameDataFuture.unitCondition.bTempLineMap	= pLineData->m_bTempLineMap;	
			bFindLine = true;
		}		
	}
	if( pLineData == NULL || 
		( pLineData->bEnable == false && pLineData->m_bTempLineMap == false && bFindLine == false ) )
#else

	// line data가 없거나(위의 과정을 거쳤을 경우도 포함), 몬스터가 생성한 라인맵이 아닌데 disable한 경우
	if( pLineData == NULL || 
		( pLineData->bEnable == false && pLineData->m_bTempLineMap == false ) )
#endif
	{
		ErrorLog( XEM_ERROR121 );
		int lineIndex = pLineMap->GetNearestLine( positionOrg );

		if( lineIndex < 0 )
		{
			ErrorLog( XEM_ERROR122 );
		}
		pLineData = pLineMap->GetLineData( lineIndex );
		if( pLineData == NULL )
		{
			ErrorLog( XEM_ERROR123 );
			pLineData = pLineMap->GetAnyEnabledNormalLine();
			if( NULL == pLineData )
			{
				ErrorLogMsg( XEM_ERROR123, "line error" );
			}
		}

		if( NULL != pLineData )
		{
			positionOrg = position = m_FrameDataFuture.syncData.position = pLineData->startPos;
			m_FrameDataFuture.syncData.lastTouchLineIndex = lineIndex;
			angleDegree	= m_FrameDataFuture.unitCondition.dirDegree = pLineData->dirDegree;
			m_PhysicParam.nowSpeed.x = 0.0f;
			m_PhysicParam.nowSpeed.y = 0.0f;
		}
		else
		{
			//{{ dmlee 2008.11.8 
			// 뭔가 오류가 심각하다. 이런 상황이 생기면 안되는데. 
			// 여기에 탈출하기 메뉴를 하나 추가해버릴까? 일단은 안 뻗게 예외처리.
			ASSERT( !"user physic process linedata is NULL" );
			return;
			//}} dmlee 2008.11.8 
		}
	}
#else	LINE_MAP_CREATED_BY_MONSTER
	// line data가 없을 경우에 예외처리
	if( pLineData == NULL || pLineData->bEnable == false )
	{
		ErrorLog( XEM_ERROR121 );
		int lineIndex = pLineMap->GetNearestLine( positionOrg );
		if( lineIndex < 0 )
		{
			ErrorLog( XEM_ERROR122 );
		}
		pLineData = pLineMap->GetLineData( lineIndex );
		if( pLineData == NULL )
		{
			ErrorLog( XEM_ERROR123 );
			pLineData = pLineMap->GetAnyEnabledNormalLine();
			if( NULL == pLineData )
			{
				ErrorLogMsg( XEM_ERROR123, "line error" );
			}
		}

		if( NULL != pLineData )
		{
			positionOrg = position = m_FrameDataFuture.syncData.position = pLineData->startPos;
			m_FrameDataFuture.syncData.lastTouchLineIndex = lineIndex;
			angleDegree	= m_FrameDataFuture.unitCondition.dirDegree = pLineData->dirDegree;
			m_PhysicParam.nowSpeed.x = 0.0f;
			m_PhysicParam.nowSpeed.y = 0.0f;
		}
		else
		{
			//{{ dmlee 2008.11.8 
			// 뭔가 오류가 심각하다. 이런 상황이 생기면 안되는데. 
			// 여기에 탈출하기 메뉴를 하나 추가해버릴까? 일단은 안 뻗게 예외처리.
			ASSERT( !"user physic process linedata is NULL" );
			return;
			//}} dmlee 2008.11.8 
		}
	}
#endif	LINE_MAP_CREATED_BY_MONSTER
//}} kimhc // 2010.7.7 // 몬스터가 생성한 라인맵
	
	//X감쇄
	bool positive;
	if( m_PhysicParam.nowSpeed.x >= 0.0f )
		positive = true;
	else
		positive = false;
	if( positive == true )
	{
		m_PhysicParam.nowSpeed.x -= m_PhysicParam.fReloadAccel * m_fElapsedTime;
		if( m_PhysicParam.nowSpeed.x <= 0.0f )
			m_PhysicParam.nowSpeed.x = 0.0f;
	}
	else
	{
		m_PhysicParam.nowSpeed.x += m_PhysicParam.fReloadAccel * m_fElapsedTime;
		if( m_PhysicParam.nowSpeed.x > 0.0f )
			m_PhysicParam.nowSpeed.x = 0.0f;
	}

#ifdef REVERSE_GRAVITY_TEST

	if( 0.f != m_fReverseGravitySpeedDeltaY )
	{

		if( m_PhysicParam.nowSpeed.y > 300.f )
		{
			m_PhysicParam.nowSpeed.y -= m_PhysicParam.fGAccel * m_fElapsedTime;
			if( m_PhysicParam.nowSpeed.y <= m_PhysicParam.fMaxGSpeed )
				m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed;
		}
		else if( m_PhysicParam.nowSpeed.y < -50.f )
		{
			float fScale = m_PhysicParam.nowSpeed.y / -50.f;
			m_PhysicParam.nowSpeed.y += m_fReverseGravitySpeedDeltaY * fScale;
		}
		else
		{
			m_PhysicParam.nowSpeed.y += m_fReverseGravitySpeedDeltaY;
		}

		if( m_PhysicParam.nowSpeed.y < -4000.f )
			m_PhysicParam.nowSpeed.y = -4000.f;

		if( m_PhysicParam.nowSpeed.y > 4000.f )
			m_PhysicParam.nowSpeed.y = 4000.f;



		if( m_FrameDataFuture.unitCondition.bFootOnLine == true )
		{
			position.y += LINE_RADIUS * 1.5f;
		}

		//{{ oasis907 : 김상윤 [2011.6.29]
		if(m_vReverseGravityRotateSpeedDelta == D3DXVECTOR3(0.f, 0.f, 0.f))
		{
			m_vReverseGravityRotateSpeedDelta.x = 0.0f;
			m_vReverseGravityRotateSpeedDelta.y = (GetRandomFloat() * 4.f) - 2.f;
			m_vReverseGravityRotateSpeedDelta.z = 0.f;
			
#ifdef RIDING_SYSTEM
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_JUMP_DOWN );
			else
				StateChange( USI_JUMP_DOWN );
#else //RIDING_SYSTEM
			StateChange( USI_JUMP_DOWN );
#endif //RIDING_SYSTEM
		}
		m_PhysicParam.nowSpeed.x = 0.f;

		D3DXVECTOR3 vAnimRotateDegree = m_pXSkinAnimFuture->GetMatrix().GetRotateDegree();
		vAnimRotateDegree.x += m_vReverseGravityRotateSpeedDelta.x;
		vAnimRotateDegree.y += m_vReverseGravityRotateSpeedDelta.y;
		vAnimRotateDegree.z += m_vReverseGravityRotateSpeedDelta.z;

		m_pXSkinAnimFuture->GetMatrix().RotateDegree( vAnimRotateDegree );


		m_pXSkinAnim->GetMatrix().RotateDegree( vAnimRotateDegree );



		D3DXVECTOR3 vRotateDegree = GetMatrix().GetRotateDegree();
		GetMatrix().RotateDegree(vRotateDegree);
		//}} oasis907 : 김상윤 [2011.6.29] 
	}	
	else 
#endif REVERSE_GRAVITY_TEST
	{
#ifdef REVERSE_GRAVITY_TEST
		m_vReverseGravityRotateSpeedDelta = D3DXVECTOR3(0.f, 0.f, 0.f);
#endif REVERSE_GRAVITY_TEST

		//Y감쇄
		float fBuoyancy = 1.f;
		if( pLineData != NULL && pLineData->m_bUnderWater == true && GetPos().y <= pLineData->m_fWaterHeight )
		{
			fBuoyancy = pLineData->m_fBuoyancy;
		}

#ifdef WALL_JUMP_TEST

	#ifdef REMOVE_LAND_CONNECT_CONSTRAINTS
		if( m_bDisableGravity == false &&
			m_bDisableGravityInScript == false )
	#else REMOVE_LAND_CONNECT_CONSTRAINTS
		//{{AFX
		if( m_FrameDataFuture.stateParam.bLandConnect == false &&
			m_bDisableGravity == false &&
			m_bDisableGravityInScript == false )
			//}}AFX
	#endif REMOVE_LAND_CONNECT_CONSTRAINTS

#else WALL_JUMP_TEST
		//{{AFX
		if( m_FrameDataFuture.stateParam.bLandConnect == false )
			//}}AFX
#endif WALL_JUMP_TEST
		{
			// m_bDisableGravity 이게 이제 들어가는게 확정되면 요걸 써야할듯 음헤헤 m_bRidingMachine 요부분은 임시임 ~~
			if ( m_bRidingMachine == false  )
			{
				m_PhysicParam.nowSpeed.y -= m_PhysicParam.fGAccel * m_fElapsedTime * fBuoyancy;
				if( m_PhysicParam.nowSpeed.y <= m_PhysicParam.fMaxGSpeed * fBuoyancy )
					m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed * fBuoyancy;

				m_PhysicParam.nowSpeed.y -= m_PhysicParam.fDownAccel * m_fElapsedTime;
				if( m_PhysicParam.nowSpeed.y <= m_PhysicParam.fMaxGSpeed * fBuoyancy )
					m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed * fBuoyancy;
			}
		}
		else
		{
#ifdef WALL_JUMP_TEST
			if( m_bDisableGravity == false && m_bDisableGravityInScript == false )
#endif WALL_JUMP_TEST
			{
				if ( m_bRidingMachine == false )
				{
					m_PhysicParam.nowSpeed.y = 0.0f;
				}
			}
		}
	}



#ifdef VILLAGE_FLASH_MAN_DEV_ONLY

#ifdef _DEBUG
	if ( g_pData->GetMyUser()->GetAuthLevel() >= CX2User::XUAL_OPERATOR )
	{
		if( g_pKTDXApp->GetDIManager()->Getkeyboard()->GetPureKeyState(DIK_LSHIFT) == TRUE )
		{
			m_PhysicParam.nowSpeed.x *= 6.f;
		}
	}
#endif // _DEBUG

#endif VILLAGE_FLASH_MAN_DEV_ONLY

	//X이동
	m_FrameDataFuture.unitCondition.dirVector = pLineData->dirVector;

	float fSlowFactor = 1.0f;
	if( pLineData != NULL && pLineData->m_bUnderWater == true && GetPos().y <= pLineData->m_fWaterHeight )
	{
		fSlowFactor *= pLineData->m_fResistance;
	}

	if( false == IsOnSomethingFuture() )
	{
		D3DXVECTOR3 dirVec = m_FrameDataFuture.unitCondition.dirVector;
		dirVec.y = 0.0f;

		if( m_FrameDataFuture.syncData.bIsRight == true )
			position += dirVec * m_PhysicParam.nowSpeed.x * fSlowFactor * m_fElapsedTime;
		else
			position -= dirVec * m_PhysicParam.nowSpeed.x * fSlowFactor * m_fElapsedTime;
	}
	else
	{
		if( m_FrameDataFuture.syncData.bIsRight == true )
			position += m_FrameDataFuture.unitCondition.dirVector * m_PhysicParam.nowSpeed.x * fSlowFactor * m_fElapsedTime;
		else
			position -= m_FrameDataFuture.unitCondition.dirVector * m_PhysicParam.nowSpeed.x * fSlowFactor * m_fElapsedTime;
	}

	//라인 스피드 적용
	m_FrameDataFuture.unitCondition.dirVector = pLineData->dirVector;
	if( true == m_FrameDataFuture.unitCondition.bFootOnLine )
	{
		position += pLineData->dirVector * pLineData->m_fSpeed * m_fElapsedTime;
	}



//#ifdef LINEMAP_SLOW_WIND_TEST
//
//	if( false == IsOnSomethingFuture() )
//	{
//		if( NULL != pLineData &&
//			0.f != pLineData->m_fWindRange )
//		{
//			float fDist = m_FrameDataFuture.syncData.position.y - m_FrameDataFuture.unitCondition.landPosition.y;
//			if( fDist < 0.f )
//				fDist = -fDist;
//
//			if( fDist < pLineData->m_fWindRange )
//			{
//				D3DXVECTOR3 vWindSpeed = pLineData->dirVector;
//				if( 0.f != vWindSpeed.y )
//				{
//					vWindSpeed.y = 0.f;
//					D3DXVec3Normalize( &vWindSpeed, &vWindSpeed );
//				}
//				vWindSpeed *= pLineData->m_vWindSpeed.x;
//				vWindSpeed.y = pLineData->m_vWindSpeed.y;
//
//				position += vWindSpeed * m_fElapsedTime;
//			}
//		}
//	}
//
//#endif LINEMAP_SLOW_WIND_TEST




	//모션 이동
    if( 
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        m_bFutureApplyAnimMove == true
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	    m_FrameDataFuture.stateParam.bApplyAnimMove == true 
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		
		//{{ kimhc // 2010.2.17 //
#ifdef	APPLY_MOTION_OFFSET
		&& m_bApplyMotionOffset == true
#endif	APPLY_MOTION_OFFSET
	//}} kimhc // 2010.2.17 //
		)
	{

		D3DXVECTOR3 vTranslationX = GetDirVector() * m_pXSkinAnimFuture->GetMotionOffset().x;
		D3DXVECTOR3 vTranslationZ = GetZVector() * m_pXSkinAnimFuture->GetMotionOffset().z;
		vTranslationX.y = 0.f;
		vTranslationZ.y = 0.f;

		if( m_FrameDataFuture.syncData.bIsRight == true )
		{
			position += vTranslationX + vTranslationZ;
		}
		else
		{
			position -= vTranslationX + vTranslationZ;
		}
	}




//#ifdef STEP_ON_MONSTER_TEST
//	m_FrameDataFuture.unitCondition.bFootOnUnit = false;
//#endif STEP_ON_MONSTER_TEST

	//다른 캐릭터에 의해 밀림 혹은 막힘
	if( m_FrameDataFuture.stateParam.bCanPassUnit == false )
	{
#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
        D3DXVECTOR2 vMyUnitMinMaxY( m_FrameDataFuture.syncData.position.y, m_FrameDataFuture.syncData.position.y + GetUnitHeight( true ) );
        D3DXVECTOR2 vMyUnitMinMaxYCur( m_FrameDataFuture.syncData.position.y, m_FrameDataFuture.syncData.position.y + GetUnitHeight( true ));
#else   X2OPTIMIZE_NPC_NONHOST_SIMULATION
		D3DXVECTOR2 vMyUnitMinMaxY( GetPos(true).y, GetPos(true).y + GetUnitHeight( true ) );
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION


		const vector<CX2GameUnit*>& vecGameUnitList = g_pX2Game->GetUnitList();
		for( vector<CX2GameUnit*>::const_iterator cvItr = vecGameUnitList.begin();
            vecGameUnitList.end() != cvItr; ++cvItr )
		{
			CX2GameUnit* pGameUnit = *cvItr;
			if ( NULL != pGameUnit
//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
                && pGameUnit != this
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
                )
			{
				if ( ( ( pGameUnit->GetTeam() != GetTeam() && false == pGameUnit->GetStateparam( true ).bCanPassUnit) 
#ifdef ADD_CAN_PASS_ALLY_UNIT	//JHKang	
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                || ( pGameUnit->GetTeam() == GetTeam() && pGameUnit->GetGameUnitType() == GUT_NPC
                && static_cast<CX2GUNPC*>( pGameUnit )->CanPassAllyUnit() == false )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				|| ( pGameUnit->GetTeam() == GetTeam() && false == pGameUnit->GetStateparam( true ).bCanPassAllyUnit ) 
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#endif // ADD_CAN_PASS_ALLY_UNIT				
				) && ( pGameUnit->GetAllyTeam() == CX2Room::TN_NONE || pGameUnit->GetAllyTeam() != static_cast<CX2Room::TEAM_NUM>(GetTeam()) ) && // 대상의 아군팀이 설정되어있지 않거나, 대상이 아군팀이 아니면
					pGameUnit->GetGameUnitState() != GUSI_DIE &&
					!( g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD && false == pGameUnit->DidReceiveFirstSyncPacket() ) )  /// 배틀필드에서 싱크패킷을 한번도 못받은게 아니면
				{
					// 내가 밀릴 수 없고, 상대가 밀릴 수 있는 상태라면
					if ( !( false == m_FrameDataFuture.stateParam.bCanPushUnit &&
						pGameUnit->GetStateparam( true ).bCanPushUnit ) )
                    {
#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
                        vMyUnitMinMaxY.x = position.y;
                        vMyUnitMinMaxY.y = position.y + GetUnitHeight( true );
                        if ( pGameUnit->GetGameUnitType() == GUT_USER )
                        {
//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
                            int  iDirection = 0;
                            PhysicProcess_RetrieveRelativePosInfo( static_cast<CX2GUUser*>(pGameUnit), pGameUnit->GetUnitIndex(), iDirection );
                            if ( ProcessCanPushUnit( pGameUnit, vMyUnitMinMaxY, position, iDirection ) == false )
                            {
					            position = m_FrameDataFuture.syncData.position;
					            m_PhysicParam.nowSpeed.x = 0.0f;
                            }
//#else   X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//                            if ( ProcessCanPushUserUnit( static_cast<CX2GUUser*>(pGameUnit), vMyUnitMinMaxY, vMyUnitMinMaxYCur, position ) == false )
//                            {
//					            position = m_FrameDataFuture.syncData.position;
//					            m_PhysicParam.nowSpeed.x = 0.0f;
//                            }
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
                        }
                        else
                        {
                            CX2GUNPC* pNPC = static_cast<CX2GUNPC*>(pGameUnit);
                            int  iDirection = 0;
                            switch( pNPC->GetUserUnitRelativePos( GetUnitIndex() ) )
                            {
                            case 1:
                                iDirection = 2;
                                break;
                            case 2:
                                iDirection = 1;
                                break;
                            case 3:
                                iDirection = 4;
                                break;
                            case 4:
                                iDirection = 3;
                                break;
                            }
//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
                            if ( ProcessCanPushUnit( pGameUnit, vMyUnitMinMaxY, position, iDirection ) == false )
//#else   X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//                            if ( ProcessCanPushNPCUnit( static_cast<CX2GUNPC*>(pGameUnit), vMyUnitMinMaxY, position, iDirection ) == false )
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
                            {
					            position = m_FrameDataFuture.syncData.position;
					            m_PhysicParam.nowSpeed.x = 0.0f;
                            }
                        }
                        continue;
#else   X2OPTIMIZE_NPC_NONHOST_SIMULATION
						ProcessCanPushUnit( pGameUnit, vMyUnitMinMaxY, position );
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION
                    }

					/// 투과 방지
#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
                    if ( CheckPassUnit( pGameUnit, position ) == true )
                    {
					    position = m_FrameDataFuture.syncData.position;
					    m_PhysicParam.nowSpeed.x = 0.0f;
                    }
#else   X2OPTIMIZE_NPC_NONHOST_SIMULATION
                    ProcessCanPassUnit( pGameUnit, position );
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION
				}
				
#ifndef X2OPTIMIZE_NPC_NONHOST_SIMULATION
#ifdef ADD_CAN_PASS_ALLY_UNIT	//JHKang
				if ( pGameUnit->GetTeam() == GetTeam() &&
					( pGameUnit->GetAllyTeam() == CX2Room::TN_NONE || pGameUnit->GetAllyTeam() != static_cast<CX2Room::TEAM_NUM>(GetTeam()) ) && // 대상의 아군팀이 설정되어있지 않거나, 대상이 아군팀이 아니면
					pGameUnit->GetGameUnitState() != GUSI_DIE &&
					!( g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD && false == pGameUnit->DidReceiveFirstSyncPacket() ) &&	/// 배틀필드에서 싱크패킷을 한번도 못받은게 아니면
					false == pGameUnit->GetStateparam( true ).bCanPassAllyUnit )
				{
					// 내가 밀릴 수 없고, 상대가 밀릴 수 있는 상태라면
					if ( !( false == m_FrameDataFuture.stateParam.bCanPushUnit &&
						pGameUnit->GetStateparam( true ).bCanPushUnit ) )
						ProcessCanPushUnit( pGameUnit, vMyUnitMinMaxY, position );

					ProcessCanPassUnit( pGameUnit, position );
				}
#endif //ADD_CAN_PASS_ALLY_UNIT
#endif//X2OPTIMIZE_NPC_NONHOST_SIMULATION				
			}
		}
	}

	//Y이동
#ifdef RIDING_SYSTEM
	D3DXVECTOR3 vPos = ( true == GetRidingOn() && NULL != m_ptrRidingPet ) ? m_ptrRidingPet->GetPos() : m_FrameDataFuture.syncData.position;
#endif //RIDING_SYSTEM

	if( m_PhysicParam.nowSpeed.y > 0.f &&
#ifdef RIDING_SYSTEM
		false == pLineMap->CanPassUp( vPos )
#else //RIDING_SYSTEM
		false == pLineMap->CanPassUp( m_FrameDataFuture.syncData.position )
#endif //RIDING_SYSTEM
		)
	{
		position.y = m_FrameDataFuture.syncData.position.y;
		m_PhysicParam.nowSpeed.y = 0.f;
	}
	else
	{
		if( D3DXVECTOR3(0, 0, 0 ) == m_vDisplaceUnitPosition )
		{
			position.y += m_PhysicParam.nowSpeed.y * m_fElapsedTime;
		}
	}


	//// 외부요인에 의한 캐릭터 위치변화가 있다면
	//if( D3DXVECTOR3(0, 0, 0 ) != m_vFixedUnitPosition )
	//{
	//	m_PhysicParam.nowSpeed = D3DXVECTOR2( 0, 0 );
	//	m_PhysicParam.passiveSpeed = D3DXVECTOR2( -1, -1 );

	//	position = m_vFixedUnitPosition;
	//	ClearFixedUnitPosition();
	//	ClearDisplaceUnitPosition();
	//}
	//else 
	if( D3DXVECTOR3( 0, 0, 0 ) != m_vDisplaceUnitPosition )
	{
		if( true == GetShowObject() &&
			GetNowHp() > 0.f )
		{
#ifndef ARA_CHARACTER_BASE
			m_FrameDataFuture.stateParam.bCanPassUnit = true;
#endif

			ResetOnSomethingFuture();

			position += m_vDisplaceUnitPosition;

#ifdef SKILL_BALANCE_PATCH
			float fDistSq = D3DXVec3LengthSq( &m_vDisplaceUnitPosition );
			if(fDistSq <= 81.f)
			{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                m_FrameDataFuture.stateParam.bCanPassUnit = m_bFutureCanPassUnit;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				m_FrameDataFuture.stateParam.bCanPassUnit = m_bCanPassUnit;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			}
#endif
		}
		//ClearFixedUnitPosition();
		ClearDisplaceUnitPosition();
	}




	// 벽에 부딪혔는지 
#ifdef WALL_JUMP_TEST
	m_FrameDataFuture.unitCondition.bFootOnWall = false;
	bool bCanWallJump = false;
	if( true == pLineMap->CrossedWall( m_FrameDataFuture.syncData.position, position, bCanWallJump ) )
#else
	if( true == pLineMap->CrossedWall( m_FrameDataFuture.syncData.position, position ) )
#endif WALL_JUMP_TEST
	{
#ifdef WALL_JUMP_TEST
		if( false == IsOnSomethingFuture() &&
			true == bCanWallJump )
		{
			m_FrameDataFuture.unitCondition.bFootOnWall = true;
		}
#endif WALL_JUMP_TEST

		position.x = positionOrg.x;
		position.z = positionOrg.z;
	}




#ifdef LINEMAP_RECT_TEST
	// 사각형 영역과 충돌 처리
	KTDXPROFILE_BEGIN("physic_RECT_collision");
	D3DXVECTOR3 vNearestOutPosition(0, 0, 0);
	if( true == pLineMap->IsInAnyRect( position, &vNearestOutPosition ) )
	{
		if( true == pLineMap->IsInAnyRect( positionOrg ) )
		{
			position = vNearestOutPosition;
		}
		else
		{
			position.x = positionOrg.x;
			position.z = positionOrg.z;
		}

		if( m_PhysicParam.nowSpeed.y > 0.f )
			m_PhysicParam.nowSpeed.y = 0.f;
	}
	KTDXPROFILE_END();
#endif LINEMAP_RECT_TEST




#ifdef RESET_INVALID_UNIT_POSITION_TEST
	bool bMisplaced = false;		// 유닛의 위치가 이상하지 않은지
#endif RESET_INVALID_UNIT_POSITION_TEST



	//지면 계산////////////////////////////////////////////////////////////////////
	bool bTouch	= false;
	//m_FrameDataFuture.unitCondition.bFall	= false;
	int lastTouchLineIndex		= m_FrameDataFuture.syncData.lastTouchLineIndex;
	D3DXVECTOR3 landPosition	= m_FrameDataFuture.unitCondition.landPosition;

	if ( CX2Unit::UC_EVE_BATTLE_SERAPH == GetUnitClass() && CX2GUEve::ENSI_EBS_BOOST_DASH == m_NowStateData.stateID )
		bTouch = pLineMap->IsOnLine( position, 51.f, &landPosition, &lastTouchLineIndex );
// #ifdef RIDING_SYSTEM //JHKang
// 	else if ( GetRidingOn() )
// 		bTouch = pLineMap->IsOnLine( position, 51.f, &landPosition, &lastTouchLineIndex );
// #endif //RIDING_SYSTEM
	else
		bTouch = pLineMap->IsOnLine( position, LINE_RADIUS, &landPosition, &lastTouchLineIndex );


	if( bTouch == true ) //이동 위치가 선 위라면
	{
		if( m_PhysicParam.nowSpeed.y > 0.0f )
		{
			//상승 중이면 수평 위치만 선에 싱크한다.
			position.x = landPosition.x;
			position.z = landPosition.z;
		}
#ifdef AISHA_SECOND_CLASS_CHANGE
		else if( 0.f != m_vFutureIgnoreLineTime.y &&
			m_pXSkinAnimFuture->GetNowAnimationTime() >= m_vFutureIgnoreLineTime.x &&
			m_pXSkinAnimFuture->GetNowAnimationTime() < m_vFutureIgnoreLineTime.y )
		{
			position.x = landPosition.x;
			position.z = landPosition.z;
		}
#endif AISHA_SECOND_CLASS_CHANGE
		else
		{
			//하강이나 정지상태면 위치를 선에 싱크한다.
			position = landPosition;

			//땅을 밟았으므로 Y속도를 없앤다.
			m_PhysicParam.nowSpeed.y = 0.0f;
			m_PhysicParam.fDownAccel = 0.0f;
		}
	}
	else //이동 위치가 선 위가 아니라면
	{
		//지금 반드시 땅을 밟고 있어야 하는 상황이라면
#ifdef REMOVE_LAND_CONNECT_CONSTRAINTS
#else REMOVE_LAND_CONNECT_CONSTRAINTS
		if( m_FrameDataFuture.stateParam.bLandConnect == true
			&& pLineMap->IsOnLineConnect( position, &lastTouchLineIndex, LINE_RADIUS, &landPosition ) == true )

		{
			position = landPosition; //현재 위치를 땅에 싱크한다.

			//땅을 밟았으므로 Y속도를 없앤다.
			m_PhysicParam.nowSpeed.y = 0.0f;
			m_PhysicParam.fDownAccel = 0.0f;
		}
		else //점프나 하강등 땅을 밟지 않는것이 정상인 상황이라면
#endif REMOVE_LAND_CONNECT_CONSTRAINTS
		{
			const CKTDGLineMap::LineData* pDwnLineData = pLineMap->GetLineData( lastTouchLineIndex );
			bool bMeOnStart = false;
			bool bMeOnEnd = false;           

			if( pDwnLineData != NULL )
			{
				if( GetDistance(landPosition,pDwnLineData->startPos) < LINE_RADIUS && pDwnLineData->beforeLine == -2 )
					bMeOnStart = true;
				else if( GetDistance(landPosition,pDwnLineData->endPos) < LINE_RADIUS && pDwnLineData->nextLine == -2 )
					bMeOnEnd = true;

#ifdef MONSTER_ROAD
			//{{ kimhc // 2010.8.3 // WALL 타입의 라인맵 처리 변경
#ifdef	FIX_LINE_TYPE_WALL
			    if( pDwnLineData->lineType == CKTDGLineMap::LT_MONSTER_ROAD || pDwnLineData->lineType == CKTDGLineMap::LT_WALL )
#else	FIX_LINE_TYPE_WALL
			    if( pDwnLineData->lineType == CKTDGLineMap::LT_MONSTER_ROAD )
#endif	FIX_LINE_TYPE_WALL
			    //}} kimhc // 2010.8.3 // WALL 타입의 라인맵 처리 변경		
			    {
				    bMeOnStart = bMeOnEnd = false;
			    }
#endif
			}		

			if( bMeOnStart == true )
			{				
				if( position.y < landPosition.y )
					position.y = landPosition.y;

				//모션 데이타 때문에 -2 지점을 뚫고 나가는 현상문에 수정, 아직 테스트 못했음
				//position.x		= pDwnLineData->startPos.x;
				//position.z		= pDwnLineData->startPos.z;
				//landPosition.x	= pDwnLineData->startPos.x;
				//landPosition.z	= pDwnLineData->startPos.z;
				landPosition = pLineMap->GetLandPosition( position, LINE_RADIUS, &lastTouchLineIndex );
				position.x = landPosition.x;
				position.z = landPosition.z;
			}
			else if( bMeOnEnd == true )
			{
				if( position.y < landPosition.y )
					position.y = landPosition.y;

				//position.x		= pDwnLineData->endPos.x;
				//position.z		= pDwnLineData->endPos.z;
				//landPosition.x	= pDwnLineData->endPos.x;
				//landPosition.z	= pDwnLineData->endPos.z;
				landPosition = pLineMap->GetLandPosition( position, LINE_RADIUS, &lastTouchLineIndex );
				position.x = landPosition.x;
				position.z = landPosition.z;
			}
			else
			{
				bool bCanDown = pLineMap->CanDown( position, LINE_RADIUS, &landPosition, &lastTouchLineIndex, false, false, false );

				if( bCanDown == true ) //아래쪽에 발판이 있어서 내려갈 수가 있다면
				{
					//수직 위치를 아래쪽 선에 싱크한다.
					position.x = landPosition.x;
					position.z = landPosition.z;

					//if( m_PhysicParam.nowSpeed.y <= 0.0f )
					//{
					//	m_FrameDataFuture.unitCondition.bFall = true;
					//}

					if( position.y < landPosition.y )
						position.y = landPosition.y;
				}
				else //더이상 아래쪽에 발판이 없어 떨어질 상황이면
				{

#ifdef RESET_INVALID_UNIT_POSITION_TEST
					bMisplaced = true;
#endif RESET_INVALID_UNIT_POSITION_TEST

					//position = positionOrg;	//이번 프레임의 이동을 캔슬한다.
					position.x = positionOrg.x;
					position.z = positionOrg.z;
					if( position.y < landPosition.y )
						position.y = landPosition.y;	

#ifdef  X2OPTIMIZE_WALL_TRAP_BUG_FIX
                    if ( m_FrameDataFuture.unitCondition.bFootOnLine == true 
                        && m_PhysicParam.nowSpeed.y < 0.f )
                    {
			            m_PhysicParam.nowSpeed.y = 0.0f;
			            m_PhysicParam.fDownAccel = 0.0f;
                    }
#endif  X2OPTIMIZE_WALL_TRAP_BUG_FIX
				}
			}
		}
	}

#ifdef RESET_INVALID_UNIT_POSITION_TEST

	if( bMisplaced != m_bMisplaced )
	{
		m_bMisplaced = bMisplaced;
		if( true == bMisplaced )
		{
			m_TimerMisplaced.restart();
		}
	}

#endif RESET_INVALID_UNIT_POSITION_TEST

	if ( !m_vecNeverMovePtr.empty() && NULL != m_vecNeverMovePtr.back() )
#ifdef NEVER_MOVE_GRAVITY_APPLY
	{
		D3DXVECTOR3 vPos = m_vecNeverMovePtr.back()->GetPos();
		if( m_vecNeverMovePtr.back()->GetGravitiApply())
		{
			position.x = vPos.x;
			position.z = vPos.z;
		}
		else
			position = vPos;
	}
#else
		position = m_vecNeverMovePtr.back()->GetPos();
#endif //NEVER_MOVE_GRAVITY_APPLY

	if( true == m_bEntangled )
	{
		//position = positionOrg;
		position = m_vEntangledPosition;
	}

	if( lastTouchLineIndex < 0 || pLineMap->GetLineData( lastTouchLineIndex )->bEnable == false )
	{
		lastTouchLineIndex = pLineMap->GetNearestLine( position, &landPosition );
	}


	m_FrameDataFuture.syncData.lastTouchLineIndex	= lastTouchLineIndex;
	m_FrameDataFuture.unitCondition.landPosition	= landPosition;


	//라인정보를 가지고 온다
	pLineData = pLineMap->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );

	if( pLineData == NULL )
	{
		InitPosition( false, 0 );
		pLineData = pLineMap->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );
	}
	else if( pLineData->bEnable == false )
	{
		int lineIndex = pLineMap->GetNearestLine( positionOrg );
		if( lineIndex != -1 )
		{
			pLineData = pLineMap->GetLineData( lineIndex );
			positionOrg = position = m_FrameDataFuture.syncData.position = pLineData->startPos;
			m_FrameDataFuture.syncData.lastTouchLineIndex = lineIndex;
			angleDegree	= m_FrameDataFuture.unitCondition.dirDegree = pLineData->dirDegree;
		}
		else
		{
			InitPosition( false, 0 );
		}
		m_PhysicParam.nowSpeed.x = 0.0f;
		m_PhysicParam.nowSpeed.y = 0.0f;
	}



	//싱크를 맞출 발판이 정해졌다면 앵글 정보를 맞춘다.
	D3DXVECTOR3 dirDegree;
	INIT_VECTOR3( dirDegree, 0.0f, 0.0f, 0.0f );
	if( m_FrameDataFuture.syncData.bIsRight == true )
	{
		dirDegree.x = pLineData->dirDegree.x;
		dirDegree.y = pLineData->dirDegree.y;
		//angle.z = D3DXToRadian(lineData.dirDegree.z);
	}
	else
	{
		dirDegree.x = pLineData->dirDegree.x;
		dirDegree.y = pLineData->dirDegree.y + 180.0f;
		//angle.z = D3DXToRadian(-lineData.dirDegree.z);
	}


	






	//위치 업데이트////////////////////////////////////////////////////////////////
	m_FrameDataFuture.syncData.position			= position;
	m_FrameDataFuture.unitCondition.dirDegree	= dirDegree;

	const float MAGIC_LINE_TOUCH_BOUND = 1.f;
	if( fabs(m_FrameDataFuture.syncData.position.y-m_FrameDataFuture.unitCondition.landPosition.y) < MAGIC_LINE_TOUCH_BOUND && 
		m_PhysicParam.nowSpeed.y <= 0.f )
		m_FrameDataFuture.unitCondition.bFootOnLine = true;
	else
		m_FrameDataFuture.unitCondition.bFootOnLine = false;





	

	//PhysicProcess_FastUpwardWind(pLineMap);
	PhysicProcess_Jumping(pLineMap);
	PhysicProcess_Bungee(pLineMap);
	//PhysicProcess_Portal(pLineMap);

	if ( m_delegatePhysicProcessPortalByGameType )
		m_delegatePhysicProcessPortalByGameType( pLineMap );


}








//void CX2GUUser::PhysicProcess_FastUpwardWind( CKTDGLineMap* pLineMap )
//{
//#ifdef LINEMAP_FAST_WIND_TEST
//	if( true == m_bEnableUpsideWind )
//	{
//		if( GetNowHp() > 0.f )
//		{
//			const CKTDGLineMap::LineData* pLineData_Land = pLineMap->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );
//			if( NULL != pLineData_Land &&
//				0.f != pLineData_Land->m_fUpsideWindAccelaration )
//			{
//				float fDist = m_FrameDataFuture.syncData.position.y - m_FrameDataFuture.unitCondition.landPosition.y;
//				if( fDist < 0.f )
//					fDist = -fDist;
//
//				float fSlope = -pLineData_Land->m_fUpsideWindAccelaration / pLineData_Land->m_fUpsideWindRange;
//				float fUpSideAccel = pLineData_Land->m_fUpsideWindAccelaration + fSlope * fDist;
//
//				if( fUpSideAccel > 0.f )
//				{
//					if( true == m_FrameDataFuture.unitCondition.bFootOnLine )
//					{
//						ResetOnSomethingFuture();
//
//						m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
//					}
//
//					m_PhysicParam.nowSpeed.y += fUpSideAccel * m_fElapsedTime;
//				}
//			}
//		}
//	}
//
//#endif LINEMAP_FAST_WIND_TEST
//}


void CX2GUUser::PhysicProcess_Jumping( CKTDGLineMap* pLineMap )
{
	if( true == IsOnSomethingFuture()  )
	{
		const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );
		if( NULL != pLineData )
		{
	#ifdef ADD_LINEMAP_JUMPUP_DIRECTION
			if ( 0.f < pLineData->m_fKeyStopTime )
				SetCanNotInputTime_LUA( pLineData->m_fKeyStopTime );
	#endif //ADD_LINEMAP_JUMPUP_DIRECTION

			switch( pLineData->lineType )
			{
			case CKTDGLineMap::LT_JUMP_UP_REL:
				{
					if( USI_DAMAGE_DOWN_FRONT	!= (int) m_NowStateData.stateID &&
						USI_DAMAGE_DOWN_BACK	!= (int) m_NowStateData.stateID &&
						USI_DAMAGE_AIR_FALL			!= (int) m_NowStateData.stateID &&
						USI_DAMAGE_AIR_DOWN_LANDING	!= (int) m_NowStateData.stateID )
					{
						if( USI_JUMP_DOWN == (int) m_NowStateData.stateID &&
							true == m_InputData.pureDown &&
							true == pLineMap->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS, &m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
						{
							m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.1f;
						}
						else
						{
#ifdef ADD_LINEMAP_JUMPUP_DIRECTION
							if ( CKTDGLineMap::LDO_RIGHT == pLineData->m_eDirection )
							{
								if ( false == GetIsRight() )
									m_FrameDataFuture.syncData.bIsRight = true;
							}
							else if ( CKTDGLineMap::LDO_LEFT == pLineData->m_eDirection )
							{
								if ( true == GetIsRight() )
									m_FrameDataFuture.syncData.bIsRight = false;
							}

							if ( 0.f < pLineData->m_fKeyStopTime )
								SetCanNotInputTime_LUA( pLineData->m_fKeyStopTime );

							m_bSteppedJumpLinemap = true;
							PlaySound( L"HighJump.ogg" ); 
							m_vAddJumpSpeed = pLineData->m_vJumpSpeed;
#else
							m_bSteppedJumpLinemap = true;
							PlaySound( L"HighJump.ogg" ); 
							m_vAddJumpSpeed = pLineData->m_vJumpSpeed;
#endif
						}
					}
				} break;

			case CKTDGLineMap::LT_JUMP_UP_ABS:
				{
					if( USI_DAMAGE_DOWN_FRONT	!= (int) m_NowStateData.stateID &&
						USI_DAMAGE_DOWN_BACK	!= (int) m_NowStateData.stateID &&
						USI_DAMAGE_AIR_FALL			!= (int) m_NowStateData.stateID &&
						USI_DAMAGE_AIR_DOWN_LANDING	!= (int) m_NowStateData.stateID )
					{
						if( USI_JUMP_DOWN == (int) m_NowStateData.stateID &&
							true == m_InputData.pureDown &&
							true == pLineMap->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS, &m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
						{
							m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.1f;
						}
						else
						{
							m_bSteppedJumpLinemap = true;

							PlaySound( L"HighJump.ogg" ); 


							if( true == m_FrameDataFuture.syncData.bIsRight )
							{
								m_vAddJumpSpeed = pLineData->m_vJumpSpeed;
							}
							else
							{
								m_vAddJumpSpeed = pLineData->m_vJumpSpeed;
								m_vAddJumpSpeed.x = -m_vAddJumpSpeed.x;
							}
						}
					}
				} break;
			}
		}
	}
}
void CX2GUUser::PhysicProcess_Bungee( CKTDGLineMap* pLineMap )
{
	const float MAGIC_REBIRTH_WAIT_TIME = 2.f;

	if( false == m_bWaitingForRebirthAfterBungee &&
		true == m_FrameDataFuture.unitCondition.bFootOnLine )
	{
		const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );
		if( NULL != pLineData )
		{
			switch( pLineData->lineType )
			{
			case CKTDGLineMap::LT_BUNGEE:
				{
					m_bWaitingForRebirthAfterBungee = true;
					m_timerRebirthAfterBungee.restart();

					SetCanNotInputTime_ZXArrow( MAGIC_REBIRTH_WAIT_TIME );

				} break;
			}
		}
	}

	if( true == m_bWaitingForRebirthAfterBungee )
	{
		if( m_timerRebirthAfterBungee.elapsed() > MAGIC_REBIRTH_WAIT_TIME )
		{
			const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );
			if( NULL != pLineData )
			{
				switch( pLineData->lineType )
				{
				case CKTDGLineMap::LT_BUNGEE:
					{
						m_bWaitingForRebirthAfterBungee = false;

						ClearRecieveSyncData();
#ifdef RIDING_SYSTEM
						/// 번지 라인맵 에서 탈것 탑승중이면 탈것 피격 모션으로 변경
						if ( true == GetRidingOn() )
							StateChange( USI_RIDING_DAMAGE_FRONT, true );
						else
#endif // RIDING_SYSTEM
							StateChange( USI_DAMAGE_AIR_DOWN, true );

						// 번지 데미지 기존 10%에서 15%로 조정 (기획 이승만씨 요청사항)
#ifdef REFACTORING_BY_TOOL_TEAM
						UpNowHp( -GetMaxHp() * 0.15f, 1.f );
#else REFACTORING_BY_TOOL_TEAM
						float fNowHP = GetNowHp() - GetMaxHp() * 0.15f;
						if( fNowHP <= 0.f )
							fNowHP = 1.f;
						SetNowHp( fNowHP );
#endif REFACTORING_BY_TOOL_TEAM



						InitPosByLineData( pLineData->m_iTeleportLineIndex );

					} break;
				}
			}
		}
	}
}




void CX2GUUser::PhysicProcess_Portal( CKTDGLineMap* pLineMap )
{
#ifdef PORTAL_LINEMAP_TEST
	if( true == m_FrameDataFuture.unitCondition.bFootOnLine )
	{
		const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );
		if( NULL != pLineData )
		{
			switch( pLineData->lineType )
			{
#ifdef FIELD_BOSS_RAID
				//#note LT_POTAL 바로 위에 위치 해야 함. 의도적으로 break 누락 했음.
				// default 동작이 LT_NORMAL 에도 추가되어야 함
			case CKTDGLineMap::LT_NORMAL:
				{
					m_bEnterPortal = false;
					m_bLeavePortal = true;

					if( false == pLineData->m_bIsPortalWhenActiveRaid || // 포탈로 변경되는 라인맵이 아니거나
						false == CX2BossRaidManager::GetInstance()->IsActiveRaidPortal() )// 현재 변경되는 조건이 아니라면
						break;
				}
#endif // FIELD_BOSS_RAID
			case CKTDGLineMap::LT_POTAL:
				{
					if( true == m_bLeavePortal )
					{
						if( false == m_bEnterPortal )
						{
							m_bEnterPortal = true;
							m_timerInPortal.restart();

							CreateTeleportEffect( ( pLineData->startPos + pLineData->endPos ) * 0.5f, pLineData->dirDegree );
						}	
						else
						{
							if( m_timerInPortal.elapsed() > 0.7 )
							{
								m_bLeavePortal = false;
								m_timerInPortal.restart();

								SetCanNotInputTime_ZXArrow( 0.3f );

								ClearRecieveSyncData();
								InitPosByLineData( pLineData->m_iTeleportLineIndex );


								pLineData = pLineMap->GetLineData( pLineData->m_iTeleportLineIndex );
								if( NULL != pLineData )
								{
									CreateTeleportEffect( ( pLineData->startPos + pLineData->endPos ) * 0.5f, pLineData->dirDegree );
								}
								else
								{
									CreateTeleportEffect( GetPos(), GetRotateDegree() );
								}
							}
						}
					}
				} break;

			default:
				{
					// #NOTE default 동작이 LT_NORMAL 에도 추가되어야 함
					m_bEnterPortal = false;
					m_bLeavePortal = true;

				} break;
			}
		}
	}

#endif PORTAL_LINEMAP_TEST
}

void CX2GUUser::PhysicProcess_PortalInBattleField( CKTDGLineMap* pLineMap )
{
#ifdef PORTAL_LINEMAP_TEST
	if( true == m_FrameDataFuture.unitCondition.bFootOnLine )
	{
		const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );
		if( NULL != pLineData )
		{
			switch( pLineData->lineType )
			{
#ifdef FIELD_BOSS_RAID
				//#note LT_POTAL 바로 위에 위치 해야 함. 의도적으로 break 누락 했음.
				// default 동작이 LT_NORMAL 에도 추가되어야 함
			case CKTDGLineMap::LT_NORMAL:
				{
					m_bEnterPortal = false;
					m_bLeavePortal = true;

					if( false == pLineData->m_bIsPortalWhenActiveRaid || // 포탈로 변경되는 라인맵이 아니거나
						false == CX2BossRaidManager::GetInstance()->IsActiveRaidPortal() )// 현재 변경되는 조건이 아니라면
						break;
				}
#endif // FIELD_BOSS_RAID
			case CKTDGLineMap::LT_POTAL:
				{
					if( true == m_bLeavePortal )
					{
						if( false == m_bEnterPortal )
						{
							m_bEnterPortal = true;
							m_timerInPortal.restart();
						}	
						else
						{
							if( m_timerInPortal.elapsed() > 2.3f )
							{
								m_bLeavePortal = false;
								m_timerInPortal.restart();

								
								ClearRecieveSyncData();
								
								pLineData = pLineMap->GetLineData( pLineData->m_iTeleportLineIndex );
								if( NULL != pLineData )
								{
									CreateTeleportEffect( ( pLineData->startPos + pLineData->endPos ) * 0.5f, pLineData->dirDegree );
								}
								else
								{
									CreateTeleportEffect( GetPos(), GetRotateDegree() );
								}
							}
						}
					}
				} break;

			default:
				{
					m_bEnterPortal = false;
					m_bLeavePortal = true;

				} break;
			}
		}
	}

#endif PORTAL_LINEMAP_TEST
}

bool CX2GUUser::CommonSpecialAttackEventProcess( IN const CX2UserSkillTree& cUserSkillTree_, OUT const CX2UserSkillTree::SkillSlotData* & pSkillSlotDataPressed_, OUT int& iSkillSlotIndexPressed_ )
{
	//오현빈 // 2012-04-30 // 스킬슬롯 체인지 없이 확장 스킬 사용 할 수 있도록 수정 // iSkillSlotIndexPressed_값이 0~7의 값을 갖도록 수정
	// 현재 제너레이트 블랙홀의 타격을 받고 있는 상태라면
	if( true == IsThereEffectiveBlackHoleDamageEffect() )
	{
		return false;
	}

	// 지금 스페셜 어택이 사용중인 프레임이면
	if( true == m_bSpecialAttackEventProcessedAtThisFrame )
		return false;

#ifdef FIX_SKILL_SLOT_CHANGE_BUG 
	if( true == IsCanNotIntput() ) // 키 입력 불가 상태 검사 
		return false;
#endif // FIX_SKILL_SLOT_CHANGE_BUG

	const bool bSkillSlotB = false;

	if( true == m_InputData.oneA )
	{
		pSkillSlotDataPressed_ = cUserSkillTree_.GetSkillSlot( 0, bSkillSlotB );
		if( NULL != pSkillSlotDataPressed_ && 
			CX2SkillTree::SI_NONE != pSkillSlotDataPressed_->m_eID )
		{
			iSkillSlotIndexPressed_ = 0;
		}
		return true;
	}
	if( true == m_InputData.oneS )
	{
		pSkillSlotDataPressed_ = cUserSkillTree_.GetSkillSlot( 1, bSkillSlotB );
		if( NULL != pSkillSlotDataPressed_ && 
			CX2SkillTree::SI_NONE != pSkillSlotDataPressed_->m_eID )
		{
			iSkillSlotIndexPressed_ = 1;
		}
		return true;
	}
	if( true == m_InputData.oneD )
	{
		pSkillSlotDataPressed_ = cUserSkillTree_.GetSkillSlot( 2, bSkillSlotB );
		if( NULL != pSkillSlotDataPressed_ && 
			CX2SkillTree::SI_NONE != pSkillSlotDataPressed_->m_eID )
		{
			iSkillSlotIndexPressed_ = 2;
		}
		return true;
	}
	if( true == m_InputData.oneC )
	{
		pSkillSlotDataPressed_ = cUserSkillTree_.GetSkillSlot( 3, bSkillSlotB );
		if( NULL != pSkillSlotDataPressed_ && 
			CX2SkillTree::SI_NONE != pSkillSlotDataPressed_->m_eID )
		{
			iSkillSlotIndexPressed_ = 3;
		}
		return true;
	}
//{{오현빈 // 2012-04-30 // 스킬슬롯 체인지 없이 확장 스킬 사용 할 수 있도록 수정
	//스킬슬롯 확장 상태가 아니라면 확장 스킬 사용 할 수 없도록 수정
	if( NULL != g_pData && NULL != g_pData->GetUIManager() && NULL != g_pData->GetUIManager()->GetUISkillTree() &&
	    false == g_pData->GetUIManager()->GetUISkillTree()->IsExpandSkillSlot() )
		return true;

	if( true == m_InputData.oneQ )
	{
		pSkillSlotDataPressed_ = cUserSkillTree_.GetSkillSlot( 0, !bSkillSlotB );
		if( NULL != pSkillSlotDataPressed_ && 
			CX2SkillTree::SI_NONE != pSkillSlotDataPressed_->m_eID )
		{
			iSkillSlotIndexPressed_ = 4;
		}
		return true;
	}
	if( true == m_InputData.oneW )
	{
		pSkillSlotDataPressed_ = cUserSkillTree_.GetSkillSlot( 1, !bSkillSlotB );
		if( NULL != pSkillSlotDataPressed_ && 
			CX2SkillTree::SI_NONE != pSkillSlotDataPressed_->m_eID )
		{
			iSkillSlotIndexPressed_ = 5;
		}
		return true;
	}
	if( true == m_InputData.oneE )
	{
		pSkillSlotDataPressed_ = cUserSkillTree_.GetSkillSlot( 2, !bSkillSlotB );
		if( NULL != pSkillSlotDataPressed_ && 
			CX2SkillTree::SI_NONE != pSkillSlotDataPressed_->m_eID )
		{
			iSkillSlotIndexPressed_ = 6;
		}
		return true;
	}
	if( true == m_InputData.oneR )
	{
		pSkillSlotDataPressed_ = cUserSkillTree_.GetSkillSlot( 3, !bSkillSlotB );
		if( NULL != pSkillSlotDataPressed_ && 
			CX2SkillTree::SI_NONE != pSkillSlotDataPressed_->m_eID )
		{
			iSkillSlotIndexPressed_ = 7;
		}
		return true;
	}
//}}오현빈 // 2012-04-30 // 스킬슬롯 체인지 없이 확장 스킬 사용 할 수 있도록 수정
	return true;
}

/** @function : CX2GetActualMPConsume
	@brief : 사용한 스킬의 MP 소모량을 얻어옴
	@param : 사용한 스킬의 ID, 사용한 스킬의 레벨
	@return : 소모될 MP 수치
*/
/*virtual*/ float CX2GUUser::GetActualMPConsume( const CX2SkillTree::SKILL_ID eSkillID_, const int iSkillLevel_ ) const
{
#ifdef NEXON_QA_CHEAT_REQ
	if( NULL != g_pData->GetMyUser() && g_pData->GetMyUser()->GetAuthLevel() >= CX2User::XUAL_SPECIAL_USER )
		if( NULL != g_pX2Game->GetMyUnit() && true == g_pX2Game->GetMyUnit()->GetInvincibleAndNoMpConsume_Cheat() )
			return 0;
#endif //NEXON_QA_CHEAT_REQ

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( eSkillID_ );

	if( NULL == pSkillTemplet )
	{
		const float MAGIC_ERROR_MP_COST = 100.f;
		return MAGIC_ERROR_MP_COST;
	}
	else
	{
		if ( NULL == GetUnit()  )
			return 0.f;
	
		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
		const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
		return pSkillTemplet->GetSkillMPConsumptionValue( iSkillTempletLevel );
	}
#else // UPGRADE_SKILL_SYSTEM_2013
	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( eSkillID_, iSkillLevel_ );

	if( NULL == pSkillTemplet )
	{
		const float MAGIC_ERROR_MP_COST = 100.f;
		return MAGIC_ERROR_MP_COST;
	}
	else
		return pSkillTemplet->m_fMPConsumption;
#endif // UPGRADE_SKILL_SYSTEM_2013
}

/** @function : GetActualCoolTime
	@brief : 사용한 스킬의 쿨타임을 얻어옴
	@param : 사용한 스킬의 ID, 사용한 스킬의 레벨
	@return : 쿨타임 수치
*/
/*virtual*/ float CX2GUUser::GetActualCoolTime( IN const CX2SkillTree::SkillTemplet* pSkillTemplet_, IN int iSkillLevel ) const
{
	if( NULL == pSkillTemplet_ )
		return 0.f;

	const float fSkillCoolTime = pSkillTemplet_->GetSkillCoolTimeValue( iSkillLevel );

	return max( 0.f, fSkillCoolTime );
}

#ifdef ACTUAL_CB_CONSUME
/** @function : CX2GetActualCBConsume
	@brief : 사용한 스킬의 CB 소모량을 얻어옴
	@param : 사용한 스킬의 ID, 사용한 스킬의 레벨
	@return : 소모될 CB 수치
*/
/*virtual*/ USHORT CX2GUUser::GetActualCBConsume( CX2SkillTree::SKILL_ID eSkill_ID_, int iSkillLevel_ )
{
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( eSkill_ID_ );
#else // UPGRADE_SKILL_SYSTEM_2013
	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( eSkill_ID_, iSkillLevel_ );
#endif // UPGRADE_SKILL_SYSTEM_2013

	if( NULL == pSkillTemplet )
	{
		const USHORT MAGIC_ERROR_CB_COST = 1;
		return MAGIC_ERROR_CB_COST;
	}

	USHORT usCBConsume = pSkillTemplet->m_usCBConsumption;
	switch( eSkill_ID_ )
	{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_CDC_RUMBLE_SHOT:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_A_CSG_RUMBLE_SHOT:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
#ifdef ADDITIONAL_MEMO	// 해외팀 누락 디파인 추가
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_CHUNG_MEMO13 ) == true )
			{
				usCBConsume = 2;
			}
#endif ADDITIONAL_MEMO
		}
	default:
		break;
	}

	if( usCBConsume < 0 )
		usCBConsume = 0;

	return usCBConsume;
}
#endif //ACTUAL_CB_CONSUME

bool CX2GUUser::EventTimer( float fTime, bool bFuture )
{
	KTDXPROFILE();
	if( bFuture == true )
	{
		if( m_FrameDataFuture.unitCondition.fStateTimeBack < fTime
			&& m_FrameDataFuture.unitCondition.fStateTime >= fTime )
		{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            return  true;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			map<float,bool>::iterator iter;
			iter = m_EventTimeStampFuture.find( fTime );
			if( iter == m_EventTimeStampFuture.end() )
			{
				m_EventTimeStampFuture.insert( std::make_pair(fTime,false) );
				return true;
			}
			else
			{
				bool bFramePass = iter->second;

				if( bFramePass == false )
					return true;
				else
					return false;
			}
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		}
		else
			return false;
	}
	else
	{
		if( m_FrameDataNow.unitCondition.fStateTimeBack < fTime
			&& m_FrameDataNow.unitCondition.fStateTime >= fTime )
		{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
            return  true;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			map<float,bool>::iterator iter;
			iter = m_EventTimeStampNow.find( fTime );
			if( iter == m_EventTimeStampNow.end() )
			{
				m_EventTimeStampNow.insert( std::make_pair(fTime,false) );
				return true;
			}
			else
			{
				bool bFramePass = iter->second;

				if( bFramePass == false )
					return true;
				else
					return false;
			}
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		}
		else
			return false;
	}
}

#ifndef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
bool CX2GUUser::EventCheck( float fTime, bool bFuture )
{
	KTDXPROFILE();
	if( bFuture == true )
	{
		map<float,bool>::iterator iter;
		iter = m_EventTimeStampFuture.find( fTime );
		if( iter == m_EventTimeStampFuture.end() )
		{
			m_EventTimeStampFuture.insert( std::make_pair(fTime,false) );
			return true;
		}
		else
		{
			bool bFramePass = iter->second;

			if( bFramePass == false )
				return true;
			else
				return false;
		}
	}
	else
	{
		map<float,bool>::iterator iter;
		iter = m_EventTimeStampNow.find( fTime );
		if( iter == m_EventTimeStampNow.end() )
		{
			m_EventTimeStampNow.insert( std::make_pair(fTime,false) );
			return true;
		}
		else
		{
			bool bFramePass = iter->second;

			if( bFramePass == false )
				return true;
			else
				return false;
		}
	}
}
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

//#ifdef  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
void CX2GUUser::PushFrameData( bool bSendForce )
{
	KTDXPROFILE();
	
#ifdef MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT
	if( true == IsAvaliableActionDuringDamageReact(m_FrameDataFuture.syncData.nowAction ))
		bSendForce = true;
#endif // MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT

	m_SendSyncDataList.push_back( m_FrameDataFuture.syncData );
	if( bSendForce == true || (int)m_SendSyncDataList.size() >= m_FrameBufferNum )
	{
		//네트웍 샌드
		SendFrameData();
		m_SendSyncDataList.resize(0);
	}
}
//#else   SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
//void CX2GUUser::PushFrameData()
//{
//	KTDXPROFILE();
//
//	m_SendSyncDataList.push_back( m_FrameDataFuture.syncData );
//	if( (int)m_SendSyncDataList.size() >= m_FrameBufferNum )
//	{
//		//네트웍 샌드
//		SendFrameData();
//		m_SendSyncDataList.resize(0);
//	}
//}
//#endif  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND

//#ifdef  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
bool CX2GUUser::PopFrameData( bool bPopOnce, OUT bool& bFrameBufferPass )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
bool CX2GUUser::PopFrameData( bool bPopOnce )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
//#else   SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
//void CX2GUUser::PopFrameData()
//#endif  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
{
	KTDXPROFILE();
//#ifdef  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
    bool    bPopAgain = false;
//#endif  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND

	//리시브 리스트에 데이타가 남아 있다면
	if( (int)m_ReceiveSyncDataList.size() > 0 )
	{
		m_FrameDataNowBefore						= m_FrameDataNow;
		m_FrameDataNow.syncData						= m_ReceiveSyncDataList.front();

#ifdef USER_HOLD
		if(GetHold() == true)
		{
			m_FrameDataNow.syncData.position = m_vHold;
		}
#endif

#ifdef TEST_GROUP_GRAP
		if (GetGrap() == true )
		{
			m_FrameDataNow.syncData.position = m_vGrap;
		}
#endif TEST_GROUP_GRAP

		GetMatrix().Move( m_FrameDataNow.syncData.position );

		//로테이션 정보 업데이트
		const CKTDGLineMap::LineData* pLineData = NULL;
		if( g_pX2Game != NULL && g_pX2Game->GetWorld() != NULL && g_pX2Game->GetWorld()->GetLineMap() != NULL )
			pLineData = g_pX2Game->GetWorld()->GetLineMap()->GetLineData( m_FrameDataNow.syncData.lastTouchLineIndex );

		if ( pLineData != NULL )
		{
			m_FrameDataNow.unitCondition.dirVector		= pLineData->dirVector;
			m_FrameDataNow.unitCondition.dirDegree		= pLineData->dirDegree;
			m_FrameDataNow.unitCondition.dirDegree.z	= 0.0f;

			if( m_FrameDataNow.syncData.bIsRight == false )
			{
				m_FrameDataNow.unitCondition.dirDegree.y += 180.0f;
			}




#ifdef GRAPPLING_TEST
			CX2GameUnit* pGrappler = GetUnitGrapplingMe( false );
			if( NULL != pGrappler )
			{
				GetMatrix().RotateDegree( pGrappler->GetUnitCondition( false ).m_GrapplingState.GetGrapplingRotation() );
			}
			else
#endif GRAPPLING_TEST
			{
#ifdef REVERSE_GRAVITY_TEST
				if(m_fReverseGravitySpeedDeltaY == 0.f)
				{
#ifdef RIDING_SYSTEM
					if ( true == GetRidingOn() && GetNowStateID() != USI_RIDING_DIE )
						GetMatrix().RotateDegree( GetSaddleDegree() );
					else
#endif //RIDING_SYSTEM 탈 것 회전 값 적용
						GetMatrix().RotateDegree( m_FrameDataNow.unitCondition.dirDegree );
				}


					//GetMatrix().RotateDegree( m_FrameDataNow.unitCondition.dirDegree );
#else
				GetMatrix().RotateDegree( m_FrameDataNow.unitCondition.dirDegree );
#endif REVERSE_GRAVITY_TEST
				
			}
		}

#ifdef ACTIVE_KOG_GAME_PERFORMANCE_CHECK
	    //내 유닛이 아닐 경우에만 측정함.
	    if ( false == IsMyUnit() )
	    {
			//초기의 FrameMoveCount 영역이라면...
			if( m_dwLastRecvFrameMoveCount >= m_adwInitFrameMoveCount[0] && m_dwLastRecvFrameMoveCount <= m_adwInitFrameMoveCount[1] )
				m_dwLastRecvFrameMoveCount = 0;

		    if( m_dwLastRecvFrameMoveCount != 0 )
		    {
			    if( m_FrameDataNow.syncData.dwFrameMoveCount > m_dwLastRecvFrameMoveCount )
                {
        		    KOGGamePerformanceCheck::GetInstance()->GetUDPTransCheckMgr()->UpdateUserSyncPacketLossRate( m_FrameDataNow.syncData.dwFrameMoveCount - m_dwLastRecvFrameMoveCount, 1 );
                }
		    }

		    m_dwLastRecvFrameMoveCount = m_FrameDataNow.syncData.dwFrameMoveCount;
	    }
#endif//ACTIVE_KOG_GAME_PERFORMANCE_CHECK

		m_ReceiveSyncDataList.erase( m_ReceiveSyncDataList.begin() );
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        bFrameBufferPass = false;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_FrameDataNow.unitCondition.bFrameBufferPass = false;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

//#ifdef  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
        if( (int)m_ReceiveSyncDataList.size() > m_FrameBufferNum * 2 )
        {
			bPopAgain = true;
#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			m_AdvanceTimeCount = 1;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        }
        else
//#endif  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
		if( (int)m_ReceiveSyncDataList.size() > m_FrameBufferNum + m_AddFrameBuffer )
		{
//#ifdef  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
            if ( m_FrameDataNow.syncData.nowState == USI_WAIT
                && m_ReceiveSyncDataList.front().nowState == USI_WAIT 
                || bPopOnce == false )
                bPopAgain = true;
//#else   SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
//			m_bPopAgain = true;
//#endif  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			m_AdvanceTimeCount = 1;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			/*
			m_fFrameSkipTime += m_fElapsedTime;
			if( m_fFrameSkipTime > m_fElapsedTime * 2.0f )
			{
			m_FrameSkipNum++;
			if( m_FrameSkipNum > 10 )
			{
			m_AddFrameBuffer--;
			if( m_AddFrameBuffer < 0 )
			m_AddFrameBuffer = 0;
			m_FrameSkipNum = 0;
			}
			}
			*/
		}
		else
		{
//#ifndef  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
//			m_bPopAgain = false;
//#endif  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			m_AdvanceTimeCount = 1;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			//m_fFrameSkipTime = 0.0f;
		}

		//m_fFrameWaitTime = 0.0f;
	}
	else
	{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        bFrameBufferPass = true;
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_FrameDataNow.unitCondition.bFrameBufferPass = true;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		/*
		m_fFrameWaitTime += m_fElapsedTime;
		if( m_fFrameWaitTime > m_fElapsedTime * 2.0f )
		{
		m_FrameWaitNum++;
		if( m_FrameWaitNum > 10 )
		{
		m_AddFrameBuffer++;
		if( m_AddFrameBuffer > m_FrameBufferNum )
		m_AddFrameBuffer = m_FrameBufferNum;
		m_FrameWaitNum = 0;
		}
		}

		m_fFrameSkipTime = 0.0f;
		*/
	}
//#ifdef  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
    return  bPopAgain;
//#endif  SERV_OPTIMIZE_ROBUST_USER_NPC_PACKET_SEND
}



void CX2GUUser::SendFrameData()
{
	KTDXPROFILE();

	if( NULL == g_pX2Game )
		return;

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
    if ( m_SendSyncDataList.empty() == true && m_LastSendSyncDataList.empty() == true )
        return;

    if ( m_SendSyncDataList.empty() == false )
    {
        m_ReceiveSyncDataList.insert( m_ReceiveSyncDataList.end(), m_SendSyncDataList.begin(), m_SendSyncDataList.end() );
        _PostProcess_ReceiveFrameData();
    }

//#else   SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//	if( true == m_SendSyncDataList.empty() )
//		return;
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK


//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
	if ( g_pData->GetGameUDP()->GetNonRelayUIDs().empty() == false
		|| g_pData->GetGameUDP()->GetRelayUIDs().empty() == false )
    {
        if ( g_pX2Game->GetFrameUDPPack().GetUnitUID() == GetUnitUID() )
        {
            KDYNAMIC_UNIT_USER_SYNC kLastSync;
            KDYNAMIC_UNIT_USER_SYNC kXPT_UNIT_USER_SYNC;
            BYTE    bySerialized[sizeof(KDYNAMIC_UNIT_USER_SYNC)];
//#ifndef X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//            kLastSync.Reset();
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
		    KTDXPROFILE_BEGIN( "COPY" );
            unsigned uSize = m_LastSendSyncDataList.size() + m_SendSyncDataList.size();
            const SyncData* pSyncData = NULL;
            for( unsigned u = 0; u != uSize; ++u )
		    {
			    //첫번째 항목의 framemovecount만 저장
                if ( u < m_LastSendSyncDataList.size() )
                    pSyncData = &m_LastSendSyncDataList[u];
                else
                    pSyncData = &m_SendSyncDataList[u-m_LastSendSyncDataList.size()];
                kXPT_UNIT_USER_SYNC.Reset();
                kXPT_UNIT_USER_SYNC.m_ucNowState = pSyncData->nowState;
                kXPT_UNIT_USER_SYNC.m_ucNowAction			= pSyncData->nowAction;
                kXPT_UNIT_USER_SYNC.m_cStateChangeNum			= pSyncData->stateChangeNum;
//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
                kXPT_UNIT_USER_SYNC.m_fPosY = pSyncData->position.y;
                _EncodeUserSyncPos( kXPT_UNIT_USER_SYNC.m_usPosX, kXPT_UNIT_USER_SYNC.m_usPosZ, pSyncData->position, pSyncData->lastTouchLineIndex );
//#else   X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//                _EncodeUserSyncPos( kXPT_UNIT_USER_SYNC.m_usPosX, kXPT_UNIT_USER_SYNC.m_usPosY, kXPT_UNIT_USER_SYNC.m_usPosZ, pSyncData->position, pSyncData->lastTouchLineIndex );
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
                kXPT_UNIT_USER_SYNC.m_ucLastTouchLineIndex = pSyncData->lastTouchLineIndex;
				kXPT_UNIT_USER_SYNC.m_fNowHp = pSyncData->fNowHP;
				kXPT_UNIT_USER_SYNC.m_fNowMp = pSyncData->fNowMP;
			    kXPT_UNIT_USER_SYNC.m_cEncodedData = 0;
			    kXPT_UNIT_USER_SYNC.EncodeHyperModeCount( (char) pSyncData->m_HyperModeCount );
			    kXPT_UNIT_USER_SYNC.EncodeIsRight( pSyncData->bIsRight );
			    kXPT_UNIT_USER_SYNC.EncodeFrameStop( pSyncData->bFrameStop );
			    kXPT_UNIT_USER_SYNC.EncodeDirectChange( pSyncData->bDirectChange );
#ifdef SERV_9TH_NEW_CHARACTER // 김태환
				kXPT_UNIT_USER_SYNC.m_sEncodedDataFromCannonBallCountAndEtc = 0;
#else // SERV_9TH_NEW_CHARACTER
				kXPT_UNIT_USER_SYNC.m_cEncodedDataFromCannonBallCountAndEtc = 0;
#endif // SERV_9TH_NEW_CHARACTER
			    kXPT_UNIT_USER_SYNC.EncodeCannonBallCount( static_cast<int>( pSyncData->m_CannonBallCount ) );
			    kXPT_UNIT_USER_SYNC.m_usRandomTableIndex = pSyncData->m_usRandomTableIndex;
                kXPT_UNIT_USER_SYNC.m_ucHitCount = pSyncData->ucHitCount;
			    kXPT_UNIT_USER_SYNC.m_ucHittedCount = pSyncData->ucHittedCount;
                kXPT_UNIT_USER_SYNC.m_ucNumOfDeBuff = pSyncData->ucNumOfDeBuff;
//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
                kXPT_UNIT_USER_SYNC.m_dwRelativePos = pSyncData->m_dwRelativePos;
                BYTE* pByBuffer = &bySerialized[0];
                kXPT_UNIT_USER_SYNC.Serialize( pByBuffer, &kLastSync );
//#else   X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//                BYTE* pByBuffer = &bySerialized[0];
//                kXPT_UNIT_USER_SYNC.Serialize( pByBuffer, ( u == 0 ) ? NULL : &kLastSync );
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
                if ( false == g_pX2Game->GetFrameUDPPack().AddFrameUDPPack_IDPack( XPT_UNIT_USER_SYNC_PACK, &bySerialized[0], (WORD)( pByBuffer-&bySerialized[0] ), true ) )
                {
                    BYTE* pByBuffer = &bySerialized[0];
                    kXPT_UNIT_USER_SYNC.Serialize( pByBuffer, NULL );
                    g_pX2Game->GetFrameUDPPack().AddFrameUDPPack_IDPack( XPT_UNIT_USER_SYNC_PACK, &bySerialized[0], (WORD)( pByBuffer-&bySerialized[0] ), false );
                }
                kLastSync = kXPT_UNIT_USER_SYNC;
		    }
		    KTDXPROFILE_END();
        }
    }

	if( g_pMain->IsEnableUdpPacketOverlap() )
		m_LastSendSyncDataList.swap( m_SendSyncDataList );
	else
		m_LastSendSyncDataList.clear();

    m_SendSyncDataList.resize(0);


//#else   SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//
//    {
//
//		m_kXPT_UNIT_USER_SYNC_PACK.m_vecUserSyncList.resize(0);
//		m_kXPT_UNIT_USER_SYNC_PACK.m_iUnitUID = m_UnitUID;
//
//		KTDXPROFILE_BEGIN( "COPY" );
//		for( int i = 0; i < (int)m_SendSyncDataList.size(); i++ )
//		{
//			KXPT_UNIT_USER_SYNC kXPT_UNIT_USER_SYNC;
//
//#ifdef OPTIMIZED_P2P
//			SyncData* pSyncData = &m_SendSyncDataList[i];
//			kXPT_UNIT_USER_SYNC.m_ucNowState = pSyncData->nowState;
//
//			kXPT_UNIT_USER_SYNC.nowAction			= pSyncData->nowAction;
//
//
//            if( !g_pX2Game )
//            {
//                break;
//            }
//
//            if( !g_pX2Game->GetLineMap() )
//            {
//                break;
//            }
//
//            D3DXVECTOR3 v3LandStart = D3DXVECTOR3( pSyncData->position.x, pSyncData->position.y + LINE_RADIUS, pSyncData->position.z );
//            D3DXVECTOR3 v3LandEnd = D3DXVECTOR3( pSyncData->position.x, 0.f, pSyncData->position.z );
//            D3DXVECTOR3 v3ContactPoint1, v3ContactPoint2;
//            const CKTDGLineMap::LineData* pLineData = g_pX2Game->GetLineMap()->GetLineData( ( int )pSyncData->lastTouchLineIndex );
//            if( pLineData )
//            {
//                if( !g_pKTDXApp->GetCollision()->LineToLine( v3LandStart, v3LandEnd, pLineData->startPos, pLineData->endPos, LINE_RADIUS, v3ContactPoint1, v3ContactPoint2 ) )
//                {
//                    StateLog( L"위치 이상한듯" );
//                    kXPT_UNIT_USER_SYNC.m_usPosX = floatToHalf( 0.f );
//                }
//                else
//                {
//                    kXPT_UNIT_USER_SYNC.m_usPosX = floatToHalf( D3DXVec3Length( &( v3ContactPoint2 - pLineData->startPos ) ) );
//                }
//                kXPT_UNIT_USER_SYNC.m_usPosY = floatToHalf( pSyncData->position.y - pLineData->startPos.y );
//            }
//            else
//            {
//                StateLog( L"라인맵 포인터 이상" );
//                kXPT_UNIT_USER_SYNC.m_usPosX = floatToHalf( 0.f );
//                kXPT_UNIT_USER_SYNC.m_usPosY = floatToHalf( 0.f );
//            }
//            kXPT_UNIT_USER_SYNC.m_ucLastTouchLineIndex = pSyncData->lastTouchLineIndex;
//
//            kXPT_UNIT_USER_SYNC.EncodeEncodedData( pSyncData->bIsRight, pSyncData->bFrameStop, pSyncData->bDirectChange, ( int )pSyncData->stateChangeNum, ( int )pSyncData->m_HyperModeCount );
//
//#ifdef NEW_RANDOM_TABLE_TEST
//			kXPT_UNIT_USER_SYNC.m_usRandomTableIndex = pSyncData->m_usRandomTableIndex;
//#else NEW_RANDOM_TABLE_TEST
////{{AFX
//			kXPT_UNIT_USER_SYNC.m_RandSeed			= pSyncData->m_RandSeed;
//			kXPT_UNIT_USER_SYNC.m_RandSeed2			= pSyncData->m_RandSeed2;
////}}AFX
//#endif NEW_RANDOM_TABLE_TEST
//
//            // 일단은 for loop 안에서 이따위로 하자. 나중에 밖으로 빼줘 ㅠ.ㅠ
//            m_kXPT_UNIT_USER_SYNC_PACK.m_usNowHP = floatToHalf( pSyncData->fNowHP );
//            m_kXPT_UNIT_USER_SYNC_PACK.m_usNowMP = floatToHalf( pSyncData->fNowMP );
//
//#else OPTIMIZED_P2P
//
////{{AFX
//			SyncData* pSyncData						= &m_SendSyncDataList[i];
//			kXPT_UNIT_USER_SYNC.dwFrameMoveCount	= pSyncData->dwFrameMoveCount;
//			kXPT_UNIT_USER_SYNC.nowState			= pSyncData->nowState;
//			kXPT_UNIT_USER_SYNC.nowAction			= pSyncData->nowAction;
//			kXPT_UNIT_USER_SYNC.stateChangeNum		= pSyncData->stateChangeNum;
//			kXPT_UNIT_USER_SYNC.posX				= pSyncData->position.x;
//			kXPT_UNIT_USER_SYNC.posY				= pSyncData->position.y;
//			kXPT_UNIT_USER_SYNC.posZ				= pSyncData->position.z;
//			kXPT_UNIT_USER_SYNC.lastTouchLineIndex	= pSyncData->lastTouchLineIndex;
//
////{{ kimhc // 2010.12.7 // 던전, 대전 등에서 상대방 또는 파티원의 HP가 줄지 않는 현상 수정
//			// HP와 MP가 2바이트에서 4바이트로 늘어남, PosX,Y,Z를 2바이트 형식으로 줄이는 것을 고려해 봐야 할듯
//			kXPT_UNIT_USER_SYNC.fNowHP				= pSyncData->fNowHP;
//			kXPT_UNIT_USER_SYNC.fNowMP				= pSyncData->fNowMP;
////}} kimhc // 2010.12.7 // 던전, 대전 등에서 상대방 또는 파티원의 HP가 줄지 않는 현상 수정
//			
//			kXPT_UNIT_USER_SYNC.m_EncodedData = 0;
//			kXPT_UNIT_USER_SYNC.EncodeHyperModeCount( (char) pSyncData->m_HyperModeCount );
//			kXPT_UNIT_USER_SYNC.EncodeIsRight( pSyncData->bIsRight );
//			kXPT_UNIT_USER_SYNC.EncodeFrameStop( pSyncData->bFrameStop );
//			kXPT_UNIT_USER_SYNC.EncodeDirectChange( pSyncData->bDirectChange );
//
////{{ kimhc // 2010.12.13 // 2010-12-23 New Character CHUNG
//#ifdef	NEW_CHARACTER_CHUNG
//			kXPT_UNIT_USER_SYNC.m_EncodedDataFromCannonBallCountAndEtc = 0;
//			kXPT_UNIT_USER_SYNC.EncodeCannonBallCount( static_cast<int>( pSyncData->m_CannonBallCount ) );
//#endif	NEW_CHARACTER_CHUNG
////}} kimhc // 2010.12.13 //  2010-12-23 New Character CHUNG
//
//#ifdef NEW_RANDOM_TABLE_TEST
//			kXPT_UNIT_USER_SYNC.m_usRandomTableIndex = pSyncData->m_usRandomTableIndex;
//#else NEW_RANDOM_TABLE_TEST
//			kXPT_UNIT_USER_SYNC.m_RandSeed			= pSyncData->m_RandSeed;
//			kXPT_UNIT_USER_SYNC.m_RandSeed2			= pSyncData->m_RandSeed2;
//#endif NEW_RANDOM_TABLE_TEST
////}}AFX
//
//#endif // OPTIMIZED_P2P
//
//			kXPT_UNIT_USER_SYNC.ucHitCount		= pSyncData->ucHitCount;
//			kXPT_UNIT_USER_SYNC.ucHittedCount	= pSyncData->ucHittedCount;
//			kXPT_UNIT_USER_SYNC.ucNumOfDeBuff	= pSyncData->ucNumOfDeBuff;
//
//			m_kXPT_UNIT_USER_SYNC_PACK.m_vecUserSyncList.push_back( kXPT_UNIT_USER_SYNC );
//		}
//		KTDXPROFILE_END();
//
//
//		KTDXPROFILE_BEGIN( "SERIALIZE_BROADCAST" );
//		KSerBuffer buff;
//		Serialize( &buff, &m_kXPT_UNIT_USER_SYNC_PACK );
//		g_pData->GetGameUDP()->BroadCast( g_pX2Game->GetVecUserUIDforSyncPacket(), XPT_UNIT_USER_SYNC_PACK, (char*)buff.GetData(), buff.GetLength() );
//		KTDXPROFILE_END();
//
//		m_SendSyncDataList.resize(0);
//    }
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
}




//#ifdef SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK


void CX2GUUser::_PostProcess_ReceiveFrameData()
{
	if( m_bFirstDataReceive == false )
	{

		CKTDGParticleSystem::CParticleEventSequence* pSeqHeadMarker    = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqHeadMarker );
//#ifdef TITLE_SYSTEM
		CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem		   = g_pData->GetUIMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
//#else
//		CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem		   = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
//#endif TITLE_SYSTEM

		if( NULL != pSeqHeadMarker )
			pSeqHeadMarker->SetShowObject(true);

		if( NULL != pSeqEmblem )
			pSeqEmblem->SetShowObject( true );

		if ( false == IsMyUnit() )	/// 첫 패킷을 받은 유저가 내유닛이 아니고
		{
#ifdef FIX_OBSERVER_MODE_CRASH
			/// 나에게 걸린 버프/디버프가 있으면
			if ( NULL != g_pX2Game && NULL != g_pX2Game->GetMyUnit() && !g_pX2Game->GetMyUnit()->IsBuffTempletListEmpty() )
#else  FIX_OBSERVER_MODE_CRASH
			if ( !g_pX2Game->GetMyUnit()->IsBuffTempletListEmpty() )	/// 나에게 걸린 버프/디버프가 있으면
#endif FIX_OBSERVER_MODE_CRASH
				g_pX2Game->GetMyUnit()->SendBuffInfoNot( GetUnitUID() );	/// 방금 패킷을 받은 유저에게 버프/디버프 정보를 보낸다
		}
	    m_bFirstDataReceive = true;
	}

	m_bConnect			= true;
}

void CX2GUUser::ReceiveFrameData( DWORD dwFrameMoveCount, const KDYNAMIC_UNIT_USER_SYNC& kUserSync )
{
	KTDXPROFILE();

	//최초로 sync 데이터를 받을 때에는 모든 데이터가 왔는지 확인한다.
	if( kUserSync.m_usDataFieldFlag != KDYNAMIC_UNIT_USER_SYNC::eUnitUserSync_DataField_All )
    {
        return;
    }
    if ( dwFrameMoveCount <= m_FrameDataNow.syncData.dwFrameMoveCount )
    {
		return;
	}

	float fMaxHP = GetMaxHp();
	float fMaxMP = GetMaxMp();

	SyncData syncData;
	syncData.SetData( kUserSync, dwFrameMoveCount, fMaxHP, fMaxMP );
    if ( m_ReceiveSyncDataList.empty() == true )
    {
	    m_ReceiveSyncDataList.push_back( syncData );
    }
    else
    {
        if ( m_ReceiveSyncDataList.back().dwFrameMoveCount < syncData.dwFrameMoveCount )
            m_ReceiveSyncDataList.push_back( syncData );
        else
        {
            std::vector<SyncData>::iterator iter = std::lower_bound( m_ReceiveSyncDataList.begin(), m_ReceiveSyncDataList.end(), syncData.dwFrameMoveCount );
            if ( iter != m_ReceiveSyncDataList.end() && iter->dwFrameMoveCount == syncData.dwFrameMoveCount )
			{
#ifdef MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT // NonLocal Unit
				if( true == IsAvaliableActionDuringDamageReact( iter->nowAction ) )
				{
					syncData.nowAction = iter->nowAction;
				}
#endif // MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT
                *iter = syncData;
			}
            else
                m_ReceiveSyncDataList.insert( iter, syncData );
        }
    }

    _PostProcess_ReceiveFrameData();

}

//#else   SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//
//void CX2GUUser::ReceiveFrameData( KXPT_UNIT_USER_SYNC_PACK* pKXPT_UNIT_USER_SYNC_PACK )
//{
//	KTDXPROFILE();
//
//    if( !pKXPT_UNIT_USER_SYNC_PACK )
//    {
//        return;
//    }
//
//
//
//#ifdef OPTIMIZED_P2P
//    std::vector< KXPT_UNIT_USER_SYNC >::iterator vit;
//	for( vit = pKXPT_UNIT_USER_SYNC_PACK->m_vecUserSyncList.begin();
//         vit != pKXPT_UNIT_USER_SYNC_PACK->m_vecUserSyncList.end();
//         vit++ )
//	{
//		SyncData syncData;
//		syncData.SetData( *vit, pKXPT_UNIT_USER_SYNC_PACK->m_usNowHP, pKXPT_UNIT_USER_SYNC_PACK->m_usNowMP );
//		m_ReceiveSyncDataList.push_back( syncData );
//	}
//#else
//    for( int i = 0; i < (int)pKXPT_UNIT_USER_SYNC_PACK->m_vecUserSyncList.size(); i++ )
//	{
//        KXPT_UNIT_USER_SYNC* pKXPT_UNIT_USER_SYNC = &pKXPT_UNIT_USER_SYNC_PACK->m_vecUserSyncList[i];
//		SyncData syncData;
//		syncData.SetData( pKXPT_UNIT_USER_SYNC );
//		m_ReceiveSyncDataList.push_back( syncData );
//	}
//#endif // OPTIMIZED_P2P
//	
//// 	if ( !m_ReceiveSyncDataList.empty() )
//// 	{
//// 		auto SortFunc = []( const SyncData& lhs_, const SyncData& rhs_ ) {
//// 			return lhs_.dwFrameMoveCount < rhs_.dwFrameMoveCount;
//// 		};
//// 
//// 		sort( m_ReceiveSyncDataList.begin(), m_ReceiveSyncDataList.end(), SortFunc );
//// 	}
//	
//	if( m_bFirstDataReceive == false )
//	{
//
//		CKTDGParticleSystem::CParticleEventSequence* pSeqHeadMarker    = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqHeadMarker );
//#ifdef TITLE_SYSTEM
//		CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem		   = g_pData->GetUIMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
//#else
//		CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem		   = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
//#endif TITLE_SYSTEM
//
//		if( NULL != pSeqHeadMarker )
//			pSeqHeadMarker->SetShowObject(true);
//
//		if( NULL != pSeqEmblem )
//			pSeqEmblem->SetShowObject( true );
//
//// 		if ( !m_ReceiveSyncDataList.empty() )
//// 		{
//// 			SyncData& ReceiveSyncData = m_ReceiveSyncDataList.back();
//// 			SetFrameMoveCount( GetFrameMoveCount() + ReceiveSyncData.dwFrameMoveCount );
//// 			SetHitCount( GetHitCount() + ReceiveSyncData.ucHitCount );
//// 			SetHittedCount( GetHittedCount() + ReceiveSyncData.ucHittedCount );
//// 			SetNumOfDeBuff( GetNumOfDeBuff() + ReceiveSyncData.ucNumOfDeBuff );
//// 		}
//
//		if ( false == IsMyUnit() )	/// 첫 패킷을 받은 유저가 내유닛이 아니고
//		{
//#ifdef FIX_OBSERVER_MODE_CRASH
//			/// 나에게 걸린 버프/디버프가 있으면
//			if ( NULL != g_pX2Game && NULL != g_pX2Game->GetMyUnit() && !g_pX2Game->GetMyUnit()->IsBuffTempletListEmpty() )
//#else  FIX_OBSERVER_MODE_CRASH
//			if ( !g_pX2Game->GetMyUnit()->IsBuffTempletListEmpty() )	/// 나에게 걸린 버프/디버프가 있으면
//#endif FIX_OBSERVER_MODE_CRASH
//				g_pX2Game->GetMyUnit()->SendBuffInfoNot( GetUnitUID() );	/// 방금 패킷을 받은 유저에게 버프/디버프 정보를 보낸다
//		}
//	}
//
//	m_bFirstDataReceive = true;
//	m_bConnect			= true;
//
//}
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

#ifdef UNIT_SYNC_PACKET_DUNGEON_FOR_TEST
//void CX2GUUser::ReceiveFrameData( KXPT_UNIT_USER_SYNC_PACK_FOR_DUNGEON* pKXPT_UNIT_USER_SYNC_PACK )
//{
//	KTDXPROFILE();
//
//	for( int i = 0; i < (int)pKXPT_UNIT_USER_SYNC_PACK->m_vecUserSyncList.size(); i++ )
//	{
//		KXPT_UNIT_USER_SYNC_FOR_DUNGEON* pKXPT_UNIT_USER_SYNC = &pKXPT_UNIT_USER_SYNC_PACK->m_vecUserSyncList[i];
//		SyncData syncData;
//		syncData.SetData( pKXPT_UNIT_USER_SYNC );
//		m_ReceiveSyncDataList.push_back( syncData );
//	}
//
//	if( m_bFirstDataReceive == false )
//	{
//
//		CKTDGParticleSystem::CParticleEventSequence* pSeqHeadMarker    = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqHeadMarker );
//
//#ifdef TITLE_SYSTEM
//		CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem		   = g_pData->GetUIMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
//#else
//		CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem		   = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEmblem );
//#endif TITLE_SYSTEM
//
//
//
//		if( NULL != pSeqHeadMarker )
//			pSeqHeadMarker->SetShowObject(true);
//
//		if( NULL != pSeqEmblem )
//			pSeqEmblem->SetShowObject( true );
//
//#ifdef DO_NOT_SHOW_UI
//
//		if( NULL != pSeqHeadMarker )
//			pSeqHeadMarker->SetShowObject( false );
//
//#endif
//
//	}
//	m_bFirstDataReceive = true;
//	m_bConnect			= true;
//
//}
#endif UNIT_SYNC_PACKET_DUNGEON_FOR_TEST

/*virtual*/ void CX2GUUser::RenderName()
{
	if( false == GetShowObject() )
		return;

	if( true == GetAbsoluteInvisibility() )
		return; 

	if( NULL == g_pX2Game ||
		NULL == g_pX2Game->GetFontForUnitName() ||
		NULL == GetUnit() 
		//{{ JHKang / 강정훈 / 2010/12/08 / RenderName 관련 크래쉬 수정
#ifdef CRASH_RENDER_NAME_CLEAR
		|| false == m_bConnect
#endif CRASH_RENDER_NAME_CLEAR
		//}} JHKang / 강정훈 / 2010/12/08 / RenderName 관련 크래쉬 수정
		)
	{
		return;
	}

#ifdef DIALOG_SHOW_TOGGLE
	if( g_pKTDXApp->GetDGManager()->GetDialogManager()->GetHideDialog() == true )
		return;
#endif

#ifdef EVE_ELECTRA
	if( g_pX2Game->GetMyUnit() != NULL &&
		g_pX2Game->GetMyUnit()->GetWhiteOut() == true )
	{
		return;
	}
#endif EVE_ELECTRA

	if( NULL != g_pData->GetPVPRoom() &&
		g_pData->GetPVPRoom()->GetPVPGameType() == CX2PVPRoom::PGT_SURVIVAL )
	{
		if ( g_pX2Game->GetMyUnit() == this )
		{
			g_pX2Game->GetFontForUnitName()->OutProjectionText( GetPos(), GetUnit()->GetNickName(), 0xffffaa77, 
				CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );
		}
		else
		{
			g_pX2Game->GetFontForUnitName()->OutProjectionText( GetPos(), GetUnit()->GetNickName(), 0xff54ddff, 
				CKTDGFontManager::FS_SHELL, 0xff0000ff, NULL, DT_CENTER  );
		}
	}
	else
	{
		if( GetTeam() == CX2Room::TN_BLUE )
		{
			g_pX2Game->GetFontForUnitName()->OutProjectionText( GetPos(), GetUnit()->GetNickName(), 0xff54ddff, 
				CKTDGFontManager::FS_SHELL, 0xff0000ff, NULL, DT_CENTER  );
		}
		else
		{
			if ( ShouldAttackAllTeam() )
			{
				g_pX2Game->GetFontForUnitName()->OutProjectionText( GetPos(), GetUnit()->GetNickName(), 0xff54ddff, 
					CKTDGFontManager::FS_SHELL, 0xff0000ff, NULL, DT_CENTER  );
			}
			else
			{
				g_pX2Game->GetFontForUnitName()->OutProjectionText( GetPos(), GetUnit()->GetNickName(), 0xffffaa77, 
					CKTDGFontManager::FS_SHELL, 0xffff0000 , NULL, DT_CENTER  );
			}
		}
	}

#ifdef SERV_INTEGRATION

	int iWidthUnitName = 0;
	int iFinalLeft = 0;
	int iFinalTop = 0;

	D3DXVECTOR2 finalPos = g_pKTDXApp->GetProj3DPos(GetPos());

	iWidthUnitName = g_pX2Game->GetFontForUnitName()->GetWidth(GetUnit()->GetNickName());

	iFinalLeft = (int) finalPos.x + (iWidthUnitName / 2);
	iFinalTop = (int) finalPos.y;

#ifndef REMOVE_KR_SERVER_TEXTURE
	RenderServer(iFinalLeft, iFinalTop);
#endif REMOVE_KR_SERVER_TEXTURE

	bool bPvpRank = g_pMain->GetGameOption().GetOptionList().m_bPvpRank;
	
	bool bNothing = g_pMain->GetGameOption().GetOptionList().m_bNothing;
	if( true == bNothing && true == IsMyUnit() )
	{
		bPvpRank = false;
	}

	if( true == bPvpRank )
	{
		int iFinalLeftRank = (int)finalPos.x - (iWidthUnitName / 2);
		RenderRank(iFinalLeftRank, iFinalTop);
	}
#endif SERV_INTEGRATION

	//{{ 허상형 : [2009/10/13] //	길드이름 출력
#ifdef GUILD_MANAGEMENT
	if( GetUnit()->GetUnitData().m_wstrGuildName != L"" )
	{
		D3DXVECTOR3 vPos = GetPos();

		vPos.y -= 22.0f;

		g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, (g_pData->GetGuildManager()->ConvertDisplayGuildName( GetUnit()->GetUnitData().m_wstrGuildName) ).c_str(),
			0xff96ff00, CKTDGFontManager::FS_SHELL, 0xff062507, NULL, DT_CENTER  );
	}
#endif	//	GUILD_MANAGEMENT
	//}} 허상형 : [2009/10/13] //	길드이름 출력



#ifdef _OPEN_TEST_		// 오픈 테스트 서버 일 경우, 개발자 이상 계정에서 콤보 숫자를 보여줌
	if( g_pData->GetMyUser()->GetAuthLevel() >= CX2User::XUAL_DEV )
	{
		if( true == CX2Game::GetRenderNPCName() )
		{
			WCHAR adBuf[200] = {0,};
			D3DXVECTOR3 vPos( GetPos() );
			vPos.y -= 20.0f;

			int iComboNum = GetComboManager()->GetCombo();
			StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"Combo: %d", iComboNum );

			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
				0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );	
		}
	
	#ifdef ADD_EVE_SYSTEM_2014
		// 오픈 테스트 서버 일 경우, 개발자 이상 계정에서 기동 게이가 보임
		if( CX2Unit::UT_EVE == GetUnit()->GetType() )
		{
			CX2GUEve *pEve = (CX2GUEve*)this;
			WCHAR ManeuverGuageBuf[200] = {0,};
			if( IsMyUnit() == true )
				StringCchPrintfW( ManeuverGuageBuf, ARRAY_SIZE( ManeuverGuageBuf ), L"기동게이지: %5.2f(%d)", pEve->GetManeuverGauge(), pEve->GetManeuverCoreLevel() );
			else
				StringCchPrintfW( ManeuverGuageBuf, ARRAY_SIZE( ManeuverGuageBuf ), L"기동게이지: (%d)", pEve->GetManeuverCoreLevel() );
			D3DXVECTOR3 vPos = GetPos() + D3DXVECTOR3( 0, -100, 0 );
			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, ManeuverGuageBuf, 0xff77aaff, CKTDGFontManager::FS_SHELL, 0xff0000ff, NULL, DT_CENTER  );	
		}
	#endif //ADD_EVE_SYSTEM_2014
	}
#endif // _OPEN_TEST_

#ifdef SERV_RELATIONSHIP_EVENT_INT
	IF_EVENT_ENABLED( CEI_RELATIONSHIP_CODE_EVENT )
	{
		if( GetUnit()->GetUnitData().m_bCouple == true && GetUnit()->GetUnitData().m_wstrRelationTargetUserNickname != L"" )
		{
			D3DXVECTOR3 vPos = GetPos();

			if( m_pUnit->GetUnitData().m_wstrGuildName != L"" )
			{
				vPos.y -= 70.0f;
			}
			else
			{
				vPos.y -= 35.0f;
			}

			wstringstream adBuf;
			adBuf << GetUnit()->GetNickName();
			adBuf << L" ♡ ";
			adBuf << GetUnit()->GetUnitData().m_wstrRelationTargetUserNickname;
			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf.str().c_str(), 0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );
		}
	}	
#endif SERV_RELATIONSHIP_EVENT_INT

#ifdef SERV_GATE_OF_DARKNESS_SUPPORT_EVENT
	if( g_pData->GetMyUser()->GetAuthLevel() >= CX2User::XUAL_OPERATOR )
	{
		if( true == CX2Game::GetRenderNPCName() )
		{
			WCHAR adBuf[200] = {0,};
			D3DXVECTOR3 vPos( GetPos() );
			if( g_pData->GetMyUser()->GetAuthLevel() == CX2User::XUAL_OPERATOR )
			{
				vPos.y -= 40.0f;
			}
			else
			{
				vPos.y -= 180.0f;
			}
			
			StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"남은 시간: %d", g_pData->GetMyUser()->GetSelectUnit()->GetUnitData().m_iGateOfDarknessSupportEventTime, (int)MAGIC_OXYGEN_GAGE );
			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );	
		}
	}	
#endif SERV_GATE_OF_DARKNESS_SUPPORT_EVENT

#ifndef _SERVICE_
#ifndef X2TOOL
	if( g_pData->GetMyUser()->GetAuthLevel() >= CX2User::XUAL_DEV )
	{
#ifndef X2OPTIMIZE_REFERENCE_RESOURCE_NEW_FOLDER_FOR_VTUNE
		if( true == CX2Game::GetRenderNPCName() )
		{
			WCHAR adBuf[200] = {0,};
			D3DXVECTOR3 vPos( GetPos() );
			vPos.y -= 20.0f;


/// 콤보 수치 출력
//////////////////////////////////////////////////////////////////////////
			int iComboNum = GetComboManager()->GetCombo();
			StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"Combo: %d", iComboNum );
			
			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
				0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );	
// 
// 			if ( g_pX2Game->IsHost() )
// 			{
// 				vPos.y -= 40.0f;
// 				g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, L"방장",
// 					0xff96ff00, CKTDGFontManager::FS_SHELL, 0xff062507, NULL, DT_CENTER  );
// 			}
// 

/// 다운 수치 출력
//////////////////////////////////////////////////////////////////////////
			float fForceDownValue = m_pGageData->GetNowForceDown();
			//StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"ForceDown: %d, UID: %lld", (int)fForceDownValue, GetUnitUID() );
			StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"ForceDown: %d", static_cast<int>(fForceDownValue) );
			vPos.y -= 20.0f;
			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );
	
			//{{ 허상형 : [2009/8/4] //	플레이어 체력 표시
			StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"HP: %d/%d", (int)GetNowHp(), (int)GetMaxHp() );
/// 체력 출력
//////////////////////////////////////////////////////////////////////////
			//{{ 허상형 : [2009/8/4] //	플레이어 체력 표시			StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"HP: %d/%d", (int)GetNowHp(), (int)GetMaxHp() );

			vPos.y -= 40.0f;
			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
				0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );	


			//}} 허상형 : [2009/8/4] //	플레이어 체력 표시

		
/// 청 캐논볼 출력
//////////////////////////////////////////////////////////////////////////
//{{ kimhc // 2010.12.18 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
// 			if ( CX2Unit::UT_CHUNG == GetUnit()->GetType() )
// 			{
// 				wstringstream wstreamCannonBall;
// 				wstreamCannonBall << L"캐논볼: ";
// 				wstreamCannonBall << GetGageManager()->GetCannonBallUIPtr()->GetCannonBallCount() << L" / ";
// 				wstreamCannonBall << GetGageManager()->GetCannonBallUIPtr()->GetMaxCannonBallCount();
// 				
// 				vPos.y -= 20.0f;
// 				g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, wstreamCannonBall.str().c_str(), 
// 					0xff77aaff, CKTDGFontManager::FS_SHELL, 0xff0000ff, NULL, DT_CENTER  );	
// 			} // if
#endif	NEW_CHARACTER_CHUNG
//}} kimhc // 2010.12.18 //  2010-12-23 New Character CHUNG


/// 레이븐 분노 게이지 출력
//////////////////////////////////////////////////////////////////////////
#ifdef UPGRADE_RAVEN
			if( CX2Unit::UT_RAVEN == GetUnit()->GetType() )
			{
				CX2GURaven *pRaven = (CX2GURaven*)this;

				WCHAR RageGuageBuf[200] = {0,};
				if( IsMyUnit() == true )
					StringCchPrintfW( RageGuageBuf, ARRAY_SIZE( RageGuageBuf ), L"분노게이지: %5.2f(%d)", pRaven->GetRageGuage(), pRaven->GetNasodBall() );
				else
					StringCchPrintfW( RageGuageBuf, ARRAY_SIZE( RageGuageBuf ), L"분노게이지: (%d)", pRaven->GetNasodBall() );

				vPos = GetPos() + D3DXVECTOR3( 0, -100, 0 );
				g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, RageGuageBuf, 0xff77aaff, CKTDGFontManager::FS_SHELL, 0xff0000ff, NULL, DT_CENTER  );	
			}
#endif //UPGRADE_RAVEN


/// 이브 기동 게이지 출력
//////////////////////////////////////////////////////////////////////////
#ifdef ADD_EVE_SYSTEM_2014
			if( CX2Unit::UT_EVE == GetUnit()->GetType() )
			{
				CX2GUEve *pEve = (CX2GUEve*)this;

				WCHAR ManeuverGuageBuf[200] = {0,};
				if( IsMyUnit() == true )
					StringCchPrintfW( ManeuverGuageBuf, ARRAY_SIZE( ManeuverGuageBuf ), L"기동게이지: %5.2f(%d)", pEve->GetManeuverGauge(), pEve->GetManeuverCoreLevel() );
				else
					StringCchPrintfW( ManeuverGuageBuf, ARRAY_SIZE( ManeuverGuageBuf ), L"기동게이지: (%d)", pEve->GetManeuverCoreLevel() );

				vPos = GetPos() + D3DXVECTOR3( 0, -100, 0 );
				g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, ManeuverGuageBuf, 0xff77aaff, CKTDGFontManager::FS_SHELL, 0xff0000ff, NULL, DT_CENTER  );	
			}
#endif //ADD_EVE_SYSTEM_2014
			//{{ JHKang /  / 2010/11/25
#ifdef NEW_SKILL_2010_11
/// ???
//////////////////////////////////////////////////////////////////////////
			StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"Given: %d", m_iTotalGivenDamamge );

			vPos.y -= 20.0f;
			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
				0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );	


/// ???
//////////////////////////////////////////////////////////////////////////
			StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"SlotABkill : %d, %d, %d, %d", m_iSkillSlotBCount[0], m_iSkillSlotBCount[1], m_iSkillSlotBCount[2], m_iSkillSlotBCount[3] );

			vPos.y -= 20.0f;
			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
				0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );	
#endif NEW_SKILL_2010_11


/// 산소량 출력
//////////////////////////////////////////////////////////////////////////
//}} JHKang /  / 2010/11/25
//#ifdef UNDERWATER_LINEMAP
//			StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"산소: %d/%d", (int)m_fOxygenGage, (int)MAGIC_OXYGEN_GAGE );
//
//			vPos.y -= 20.0f;
//			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
//				0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );	
//#endif
/// 엘소드, 엘리시스 검의 길 수치 출력
//////////////////////////////////////////////////////////////////////////
#ifdef ELSWORD_WAY_OF_SWORD
			if ( CX2Unit::UT_ELSWORD == GetUnit()->GetType()
#ifdef NEW_CHARACTER_EL // 검의 길
				|| CX2Unit::UT_ELESIS == GetUnit()->GetType() 
#endif // NEW_CHARACTER_EL
				)
			{
				StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"WSP: %d", (int)GetWayOfSwordPoint() );

				vPos.y -= 20.0f;
				g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
					0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );	
			}
#endif ELSWORD_WAY_OF_SWORD

#ifdef ADD_RENA_SYSTEM //김창한
/// 레나 자연의 기운
//////////////////////////////////////////////////////////////////////////
			if ( CX2Unit::UT_LIRE == GetUnit()->GetType() )
			{
				StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"NF: %d", 
					static_cast<int>( static_cast<CX2RenaGageData*>( m_pGageData )->GetNowNaturalForce() ) );

				vPos.y -= 20.0f;
				g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
					0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );

				CX2GULire_ElvenRanger* pRena = static_cast<CX2GULire_ElvenRanger*>(this);
				if( NULL != pRena )
				{
					StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"NFP: %f", pRena->GetNaturalForceChargeValue() );
					vPos.y -= 20.0f;
					g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
						0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );
				}
			}
#endif //ADD_RENA_SYSTEM

/// 각성 수치 ( 애드는  DP 수치 ) 출력
//////////////////////////////////////////////////////////////////////////
#ifdef SERV_9TH_NEW_CHARACTER // 김태환
			if ( CX2Unit::UT_ADD == GetUnit()->GetType() )
			{
				StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"DP: %d / %d", 
								  static_cast<int>( static_cast<CX2AddGageData*>( m_pGageData )->GetDPValue() ), 
								  static_cast<int>( static_cast<CX2AddGageData*>( m_pGageData )->GetMaxDPValue() ) );
			}
			else
				StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"Hyper Gage: %d / %d", static_cast<int>( GetNowSoul() ), static_cast<int>( GetMaxSoul() ) );

			vPos.y -= 20.0f;
			g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
				0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );	

/// 변이 수치 출력
//////////////////////////////////////////////////////////////////////////
			if ( CX2Unit::UT_ADD == GetUnit()->GetType() )
			{
				StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"Mutation Count: %d / 6", 
					static_cast<int>( static_cast<CX2AddGageData*>( m_pGageData )->GetMutationCount() ) );

				vPos.y -= 20.0f;
				g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
					0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );
			}

/// 스테이시스 필드 누적 수치 표시
//////////////////////////////////////////////////////////////////////////
			if ( CX2Unit::UT_ADD == GetUnit()->GetType() )
			{
				CX2GUAdd *pAdd = static_cast<CX2GUAdd*>( this );

				if ( NULL != pAdd && true == pAdd->GetIsActiveStasisfield() )
				{
					StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"Hit/ Damage: %f/ %f", 
						pAdd->GetStasisfieldData().m_fHitValue, pAdd->GetStasisfieldData().m_fDamageValue );

					vPos.y -= 20.0f;
					g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
						0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );
				}
			}

/// 캐논볼 갯수
//////////////////////////////////////////////////////////////////////////
			if ( CX2Unit::UT_CHUNG == GetUnit()->GetType() )
			{
				StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"Cannon Ball: %d / %d", 
								  static_cast<int>( static_cast<CX2ChungGageData*>( m_pGageData )->GetNowCannonBallCount() ),
								  static_cast<int>( static_cast<CX2ChungGageData*>( m_pGageData )->GetMaxCannonBallCount() ) );

				vPos.y -= 20.0f;
				g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
					0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );	
			}
#endif //SERV_9TH_NEW_CHARACTER
			

/// ???
//////////////////////////////////////////////////////////////////////////
// #ifdef PVP_SEASON2
// 			{
// 				StringCchPrintfW( adBuf, ARRAY_SIZE( adBuf ), L"KFactor: %f", GetUnit()->GetUnitData().m_fKFactor );
// 
// 				vPos = GetPos() + D3DXVECTOR3( 0, -180, 0 );
// 				g_pX2Game->GetFontForUnitName()->OutProjectionText( vPos, adBuf, 
// 					0xffffaa77, CKTDGFontManager::FS_SHELL, 0xffff0000, NULL, DT_CENTER  );
// 			}
// #endif

		}
		


#endif//X2OPTIMIZE_REFERENCE_RESOURCE_NEW_FOLDER_FOR_VTUNE
	}
#endif _X2TOOL
#endif _SERVICE_

#ifdef TITLE_SHOWING_PVP_RESULT
	// 포인트 표시는 이벤트 전용이므로, 하드코딩으로 처리한다.
	if( _CONST_TITLE_SHOWING_PVP_RESULT_::iTitleID == GetUnit()->GetUnitData().m_iTitleId )
	{
		if( m_hHeadMarkerParticle != INVALID_PARTICLE_HANDLE )
		{
			if( false == g_pMain->GetGameOption().GetFieldSD() )
			{
				char szCount[10];
				//대전 패배 횟수
				::itoa( GetUnit()->GetUnitData().m_iAccountPVPLoseCount, szCount, 10 );

				if( CKTDGParticleSystem::CParticle* pHeadMarkerParticle = g_pX2Game->GetMajorParticle()->ValidateParticleHandle( m_hHeadMarkerParticle ) )
				{
					if( g_pX2Game != NULL )
						g_pX2Game->GetFontForUnitName()->OutProjectionText( pHeadMarkerParticle->GetPos() - D3DXVECTOR3(0, 57, 0), KncUtil::toWideString(szCount).c_str(),
						0xe0e0e0ff, CKTDGFontManager::FS_SHELL, 0xff062507, NULL, DT_CENTER );
				}
			}
		}
	}
#endif //TITLE_SHOWING_PVP_RESULT
}

void CX2GUUser::RenderRank(int iFinalLeft, int iFinalTop)
{
	if( NULL != g_pX2Game && CX2Game::GT_BATTLE_FIELD != g_pX2Game->GetGameType() )
		return;

	if(m_pTextureRank == NULL)
		return;

	if ( NULL == g_pMain->GetPVPEmblem() )
		return;

#ifdef PVP_SEASON2
	wstring wstrRankKey = g_pMain->GetPVPEmblem()->GetPVPEmblemData( GetUnit()->GetPvpRank() )->m_TextureKey;
#else
	wstring wstrRankKey = g_pMain->GetPVPEmblem()->GetPVPEmblemData( GetUnit()->GetPVPEmblem() )->m_TextureKey;
#endif

	MakeUpperCase( wstrRankKey );
	const CKTDXDeviceTexture::TEXTURE_UV*	pTexUV = m_pTextureRank->GetTexUV( wstrRankKey );
	if(pTexUV == NULL)
		return;

	float fFinalLeft, fFinalTop, fScaleX, fScaleY, fOffsetX, fOffsetY;

	fOffsetX	= 22.f / g_pKTDXApp->GetResolutionScaleX();
	fOffsetY	= 2.f / g_pKTDXApp->GetResolutionScaleY();
	fScaleX		= 20.f / g_pKTDXApp->GetResolutionScaleX();
	fScaleY		= 20.f; // / g_pKTDXApp->GetResolutionScaleY();
	fFinalLeft	= (iFinalLeft) / g_pKTDXApp->GetResolutionScaleX();
	fFinalTop	= (iFinalTop) / g_pKTDXApp->GetResolutionScaleY();

	fFinalLeft -= fOffsetX;
	fFinalTop -= fOffsetY;

	m_pTextureRank->Draw( fFinalLeft, fFinalTop, fScaleX, fScaleY, 
		(int)pTexUV->leftTop.x, (int)pTexUV->leftTop.y, (int)pTexUV->rightBottom.x - (int)pTexUV->leftTop.x, (int)pTexUV->rightBottom.y - (int)pTexUV->leftTop.y );
}
#ifdef SERV_INTEGRATION
//{{ oasis907 : 김상윤 [2010.5.17] // 
void CX2GUUser::RenderServer(int iFinalLeft, int iFinalTop)
{
	if(m_pTextureServer == NULL)
		return;


	const CKTDXDeviceTexture::TEXTURE_UV*	pTexUV = NULL;

#ifdef EXTEND_SERVER_GROUP_MASK
#else EXTEND_SERVER_GROUP_MASK
	SERVER_GROUP_ID eServerGroupID	= SGI_INVALID;

	eServerGroupID = (SERVER_GROUP_ID) g_pMain->ExtractServerGroupID(GetUnitUID());

	if( eServerGroupID == SGI_SOLES)
	{
		pTexUV = m_pTextureServer->GetTexUV( L"SOLES" );
	}
	else if( eServerGroupID == SGI_GAIA)
	{
		pTexUV = m_pTextureServer->GetTexUV( L"GAIA" );
	}
	else
#endif EXTEND_SERVER_GROUP_MASK
	{
		pTexUV = NULL;
	}

	if(pTexUV == NULL)
		return;

	float fFinalLeft, fFinalTop, fScaleX, fScaleY, fOffsetX, fOffsetY;

	fOffsetX	= 2.f / g_pKTDXApp->GetResolutionScaleX();
	fOffsetY	= -3.f / g_pKTDXApp->GetResolutionScaleY();
	fScaleX		= 21.f ;// g_pKTDXApp->GetResolutionScaleX();
	fScaleY		= 23.f ;// g_pKTDXApp->GetResolutionScaleY();
	fFinalLeft	= (iFinalLeft) / g_pKTDXApp->GetResolutionScaleX();
	fFinalTop	= (iFinalTop) / g_pKTDXApp->GetResolutionScaleY();

	fFinalLeft += fOffsetX;
	fFinalTop += fOffsetY;

	m_pTextureServer->Draw( fFinalLeft, fFinalTop, fScaleX, fScaleY, 
		(int)pTexUV->leftTop.x, (int)pTexUV->leftTop.y, (int)pTexUV->rightBottom.x - (int)pTexUV->leftTop.x, (int)pTexUV->rightBottom.y - (int)pTexUV->leftTop.y );
}
//}} oasis907 : 김상윤 [2010.5.17] // 
#endif SERV_INTEGRATION


void CX2GUUser::Verify()
{
	CX2GameUnit::Verify();

	if ( IsMyUnit() )
	{
		m_FrameDataFuture.syncData.Verify();
		m_FrameDataNow.syncData.Verify();

		if( m_FrameDataFuture.stateParam.Verify()	== false
			|| m_FrameDataNow.stateParam.Verify()	== false )
		{
			g_pKTDXApp->SetFindHacking( true );
		}

#ifdef VERIFY_STAT_BY_BUFF
		if ( NULL != GetUnit() &&
			GetUnit()->GetUnitData().m_UserSkillTree.VerifyEquippedSkillslot() == false )
		{
			if( g_pData->GetMyUser()->GetUserData().hackingUserType != CX2User::HUT_AGREE_HACK_USER &&
				g_pKTDXApp->GetFindHacking() == false )
			{
				g_pData->GetServerProtocol()->SendID( EGS_REPORT_HACK_USER_NOT );
			}

#ifdef ADD_COLLECT_CLIENT_INFO
			g_pMain->SendHackInfo5( ANTIHACKING_ID::ANTIHACKING_GAME_07, "", true, false );
#endif	// ADD_COLLECT_CLIENT_INFO

			g_pKTDXApp->SetFindHacking( true );
		}
#endif // VERIFY_STAT_BY_BUFF
	}
}

void CX2GUUser::SyncData::Verify()
{
	if( nowState.Verify()				== false 
		|| nowSubState.Verify()			== false 
		|| nowAction.Verify()			== false
		|| fNowHP.Verify()				== false 
		|| fNowMP.Verify()				== false
		|| m_HyperModeCount.Verify()	== false
//{{ kimhc // 2010.12.13 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
		|| m_CannonBallCount.Verify()	== false
#endif	NEW_CHARACTER_CHUNG
//}} kimhc // 2010.12.13 //  2010-12-23 New Character CHUNG
		)
	{
		g_pKTDXApp->SetFindHacking( true );
	}
}

#ifdef ELSWORD_WAY_OF_SWORD
int CX2GUUser::SyncData::IsActionActive( UINT uiActionIndex_ )
{
	return (nowAction & (1 << uiActionIndex_) ); 
}

bool CX2GUUser::IsActionActive( USER_ACTION_ID eUserActionID_ )
{
	UINT uiActionIndex = static_cast< UINT > ( eUserActionID_ );
	if( m_FrameDataNow.syncData.IsActionActive( uiActionIndex ) != 0 )
	{
		return true;
	}
	return false;
}
#endif ELSWORD_WAY_OF_SWORD

//{{ kimhc // 2010.12.17 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
/** @function : SetLockOn
	@brief : 락온 타입에 따라 타겟을 정한 후 UID를 얻어오는 함수
	@param : CX2DamageEffect::CEffect* pCEffect, int randomOffset, CX2DamageEffect::LOCK_ON_TYPE eLockOnType_ = CX2DamageEffect::LOT_NONE
*/
void CX2GUUser::SetLockOn( CX2DamageEffect::CEffect* pCEffect, int randomOffset, CX2DamageEffect::LOCK_ON_TYPE eLockOnType_ /*= CX2DamageEffect::LOT_NONE*/, int iModulusFactor /*= 30*/ )
{
	if( pCEffect != NULL )
	{
		bool bUserUnit = false;
		UidType gameUnitUID = -1;

		switch ( eLockOnType_ )
		{
		case CX2DamageEffect::LOT_NEARST_UID_VECTOR:
			{
				CX2GameUnit* pOwnerUnit = pCEffect->GetOwnerUnit();
				// 예외처리
				if ( NULL == pOwnerUnit )
					pOwnerUnit = g_pX2Game->GetMyUnit();

				if( NULL != pOwnerUnit )
				{
					const D3DXVECTOR3& vOwnerUnitPos = pOwnerUnit->GetPos();
					gameUnitUID = g_pX2Game->GetLockOnNearstTarget( static_cast<CX2Room::TEAM_NUM>( GetTeam() ), vOwnerUnitPos, bUserUnit );
				}
			}
			break;

#ifdef LOT_NEARST_UID_VECTOR_IN_RANGE_ADD //김창한
		case CX2DamageEffect::LOT_NEARST_UID_VECTOR_IN_RANGE:
			{
				CX2GameUnit* pOwnerUnit = pCEffect->GetOwnerUnit();
				// 예외처리
				if ( NULL == pOwnerUnit )
					pOwnerUnit = g_pX2Game->GetMyUnit();
				
				if( NULL != pOwnerUnit )
				{
					D3DXVECTOR2 vRange = (g_pMain->GetNowStateID() == CX2Main::XS_PVP_GAME) ? D3DXVECTOR2( 150.f, 300.f) : D3DXVECTOR2( 150.f, 750.f);
					const D3DXVECTOR3& vOwnerUnitPos = pOwnerUnit->GetPos();
					bool bUserUnit = false;

					gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( GetTeam() ), vOwnerUnitPos, vRange, bUserUnit );
				}
			}
			break;
#endif //LOT_NEARST_UID_VECTOR_IN_RANGE_ADD

		default:
			{
				gameUnitUID = g_pX2Game->GetLockOnTarget( static_cast<CX2Room::TEAM_NUM>( GetTeam() ), GetRandomInt() + randomOffset, bUserUnit, iModulusFactor );
				pCEffect->SetLockOnRandomSeed( GetRandomInt() + randomOffset );
			}
			break;
		}

		if( bUserUnit == true )
			pCEffect->SetLockOnUnitUID( gameUnitUID );
		else
			pCEffect->SetLockOnNPCUID( static_cast<int>( gameUnitUID ) );
	}
}

#else	NEW_CHARACTER_CHUNG

void CX2GUUser::SetLockOn( CX2DamageEffect::CEffect* pCEffect, int randomOffset )
{
	if( pCEffect != NULL )
	{
		bool bUserUnit;
		UidType uid = g_pX2Game->GetLockOnTarget( (CX2Room::TEAM_NUM)GetTeam(), (int)GetRandomInt() + randomOffset, bUserUnit );
		if( bUserUnit == true )
			pCEffect->SetLockOnUnitUID( uid );
		else
			pCEffect->SetLockOnNPCUID( (int)uid );

		pCEffect->SetLockOnRandomSeed( (int)GetRandomInt() + randomOffset );
	}
}

#endif	NEW_CHARACTER_CHUNG
//}} kimhc // 2010.12.17 //  2010-12-23 New Character CHUNG


/** @function : ForceChangeHyperMode
	@brief : 강제로 각성 상태로 변경
	@param : int (증가될 각성 구슬 갯수)
*/
void CX2GUUser::ForceChangeHyperMode( int iAddBall_ )
{
	if( IsMyUnit() == true )
	{
		SetHyperModeCount( GetHyperModeCount() + iAddBall_ );
		StateChange( USI_HYPER_MODE );
	}
}

/** @function : ForceChangeHyperModeWithoutMotion
	@brief : 모션 변경없이 각성 시킴
	@param : float fAddTime_( 추가 각성 시간 )
*/
void CX2GUUser::ForceChangeHyperModeWithoutMotion( float fAddTime_ )
{
	ASSERT( NULL != g_pX2Game );
	if( NULL == g_pX2Game )
		return; 

#ifdef SUPERPOSITION_HYPER_MODE_BUG
	IF_HYPER_MODE_STATE( m_NowStateData.stateID )
		return;
#endif // SUPERPOSITION_HYPER_MODE_BUG

	ASSERT( NULL != g_pX2Game->GetWorld() );
	if( NULL == g_pX2Game->GetWorld() )
		return;

	g_pX2Game->GetWorld()->SetWorldColor( 0xff222222 );

	if ( GetShowSmallGageAndName() )
	{
		D3DXVECTOR2 projPos = g_pKTDXApp->GetProj3DPos( GetPos() );
		CKTDGParticleSystem* pMinorParticleSystem = g_pX2Game->GetMinorParticle();

		CKTDGParticleSystem::CParticleEventSequence* pSeqSTR_ToKang = pMinorParticleSystem->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_STR_TOKANG ) );
		PlaySequenceByTriggerCount( pSeqSTR_ToKang, projPos.x, projPos.y, 0.0f, 100, 100, 1 );

		UpDownCrashCamera( 30.0f, 0.4f );
		g_pKTDXApp->GetDGManager()->ClearScreen();
	}	

	// 현재 각성 중이면 시간을 + 시킨다
// 	const float fHyperModeTime 
// 		= ( GetRemainHyperModeTime() > 0.0f ? GetRemainHyperModeTime() + fAddTime_ : fAddTime_ );
	
	SetForceHyperModeTime( fAddTime_ );
	ApplyHyperModeBuff();

	/// 각성 버프 적용 후 ForceHyperModeTime 초기화
	SetForceHyperModeTime( 0.0f );
}


void CX2GUUser::AddEnchantResist( const CX2SocketItem::SocketData& kSocketData )
{
	// 속성 저항
	//map< CX2EnchantItem::ENCHANT_TYPE, int >::iterator mit;
	for( int k= CX2EnchantItem::ET_NONE+1; k<CX2EnchantItem::ET_END; k++ )
	{
		if( 0 == kSocketData.m_aiResistEnchant[ k ] )
			continue; 

		AddDefenceEnchantData( CX2EnchantItem::ENCHANT_TYPE(k), kSocketData.m_aiResistEnchant[ k ]);
	}

}

#ifdef PET_AURA_SKILL
void CX2GUUser::AddEnchantAttack( const CX2SocketItem::SocketData& kSocketData)
{

	// 속성 저항
	map< CX2EnchantItem::ENCHANT_TYPE, float >::iterator mit;
	for( int k= CX2EnchantItem::ET_NONE+1; k<CX2EnchantItem::ET_END; k++ )
	{
		if( 0 == kSocketData.m_afAttackEnchant[ k ] )
			continue; 

		mit = m_mapAttackEnchantData.find( (CX2EnchantItem::ENCHANT_TYPE) k );
		if( mit != m_mapAttackEnchantData.end() )
		{
#ifdef BUFF_TEMPLET_SYSTEM
			mit->second = ( mit->second + kSocketData.m_afAttackEnchant[ k ] ) * kSocketData.m_fAllAttackEnchantRate;	//속성 발동 확률 소켓
#else  BUFF_TEMPLET_SYSTEM
			mit->second += kSocketData.m_afAttackEnchant[ k ];
#endif BUFF_TEMPLET_SYSTEM
		}
		else
		{
			m_mapAttackEnchantData.insert( std::make_pair( (CX2EnchantItem::ENCHANT_TYPE)k, kSocketData.m_afAttackEnchant[ k ] ) );
		}
	}
}
#endif

//{{ kimhc // 2011-07-19 // 옵션데이타 수치화 작업
// 옵션 수치화에 의한 추가 데미지
#ifdef ELSWORD_SHEATH_KNIGHT
/*virtual*/ float CX2GUUser::GetAdditionalAttackDamage( const CX2DamageManager::DamageData* pAttackDamageData )
#else
/*virtual*/ float CX2GUUser::GetAdditionalAttackDamage( const CX2DamageManager::DamageData* pAttackDamageData ) const
#endif ELSWORD_SHEATH_KNIGHT
{

#ifdef FIXED_APPLYING_ADDITINAL_DAMAGE_FOR_SUMMON_MONSTER
	return CalcAdditionalAttackDamage( pAttackDamageData );

#else // FIXED_APPLYING_ADDITINAL_DAMAGE_FOR_SUMMON_MONSTER

	float fAdditionalAttackValue = GetAdditionalAttack();

	if ( 0.0f < fAdditionalAttackValue )
	{
		float fPower = 0.0f;
		switch ( pAttackDamageData->damageType )
		{
		case CX2DamageManager::DT_PHYSIC:
		case CX2DamageManager::DT_WEAPON_PHYSIC:
			fPower = pAttackDamageData->damage.fPhysic;
			break;

		case CX2DamageManager::DT_MAGIC:
		case CX2DamageManager::DT_WEAPON_MAGIC:
			fPower = pAttackDamageData->damage.fMagic;
			break;

		case CX2DamageManager::DT_MIX:
		case CX2DamageManager::DT_WEAPON_MIX:
			fPower = ( pAttackDamageData->damage.fPhysic + pAttackDamageData->damage.fMagic ) * 0.5f;
			break;

		default:
			ASSERT( !"Worng Path" );
			break;
		}

		if ( g_pX2Game->IsDamageFreeGame() )
			return 1.5f * pow( fPower, 0.65f ) * fAdditionalAttackValue;
		else if ( CX2Game::GT_PVP == g_pX2Game->GetGameType() )
			return 0.15f * pow( fPower, 0.65f ) * fAdditionalAttackValue;	/// 대전의 경우 1/10 데미지
		else
			return 1.5f * pow( fPower, 0.65f ) * fAdditionalAttackValue;
	}
	else
	{
		return 0.0f;
	}
#endif // FIXED_APPLYING_ADDITINAL_DAMAGE_FOR_SUMMON_MONSTER

}

//}} kimhc // 2011-07-19 // 옵션데이타 수치화 작업

int CX2GUUser::GetSkillLevelUpNum( CX2SkillTree::SKILL_ID skillID ) const
{
// 	if( NULL != GetUnit()
// 	{
// 		if( false == GetUnit()->GetUnitData().m_UserSkillTree.DoIHaveThisSkill( skillID ) )
// 		{
// 			return 0;
// 		}
// 	}
#ifdef ADDED_RELATIONSHIP_SYSTEM
	if( CX2SkillTree::SI_ETC_WS_COMMON_LOVE == skillID )
		return 0;
#endif //ADDED_RELATIONSHIP_SYSTEM

	int levelUpNum = 0;

#ifdef SERV_NEW_ITEM_SYSTEM_2013_05
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 오현빈
	BOOST_TEST_FOREACH( const SkillLevelUpIDAndNum&, sSkillLevelUpIDAndNum, m_SocketData.m_vecSkillLevelUpID )
	{
		if( skillID == sSkillLevelUpIDAndNum.first )
		{
			levelUpNum += sSkillLevelUpIDAndNum.second;
		}
	}
#else
	BOOST_TEST_FOREACH( CX2SkillTree::SKILL_ID, eLevelUpSkillID, m_SocketData.m_vecSkillLevelUpID )
	{
		if( skillID == eLevelUpSkillID )
		{
			levelUpNum++;
		}
	}
#endif // UPGRADE_SKILL_SYSTEM_2013 
#endif // SERV_NEW_ITEM_SYSTEM_2013_05

	levelUpNum += m_SocketData.m_AllSkillLevelUp;
	levelUpNum += GetAddSkillLevelByBuff();	/// 스킬레벨을 변경시키는 버프 효과 적용


#ifdef SKILL_LEVEL_UP_BY_POWER_RATE_TYPE
	// SKILL_POWER_RATE_TYPE에 따라 다른 레벨 증가 수치 적용
	if( 0 < m_SocketData.m_iAllSkillLevelUpEx &&
		NULL != g_pData->GetSkillTree() )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet(skillID);
		if( NULL != pSkillTemplet )
		{
			const UINT uiLevelUpNumByPowerRateType = g_pData->GetSkillTree()->GetSkillLevelUpNumByPowerRateType( pSkillTemplet->m_eSkillPowerRateType );

			levelUpNum += static_cast<int>((m_SocketData.m_iAllSkillLevelUpEx * uiLevelUpNumByPowerRateType));
		}
	}
#endif // SKILL_LEVEL_UP_BY_POWER_RATE_TYPE

	return levelUpNum;
}

#ifdef VERIFY_STAT_BY_BUFF
/*virtual*/ void CX2GUUser::TransformScale( const PROTECT_VECTOR3& vScale_ )
#else	// VERIFY_STAT_BY_BUFF
/*virtual*/ void CX2GUUser::TransformScale( const D3DXVECTOR3& vScale_ )
#endif // VERIFY_STAT_BY_BUFF
{
	m_vTransScale = vScale_;
	//m_vTransScale += (m_vBasicScale - D3DXVECTOR3( 1.0f, 1.0f, 1.0f ));

	m_FrameDataFuture.unitCondition.fUnitWidth	= m_vOrgUnitSize.x * vScale_.x; 
	m_FrameDataFuture.unitCondition.fUnitHeight = m_vOrgUnitSize.y * vScale_.y;


	m_FrameDataNow.unitCondition.fUnitWidth		= m_FrameDataFuture.unitCondition.fUnitWidth;
	m_FrameDataNow.unitCondition.fUnitHeight	= m_FrameDataFuture.unitCondition.fUnitHeight;
}

/*virtual*/ float CX2GUUser::GetCriticalPercent( BYTE byDamageType, float fExtraCritical )
{
	//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업
	float fCriticalEffectiveRate = GetCriticalRate();
	//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업

	fCriticalEffectiveRate += fExtraCritical;

#ifdef FIX_RAVEN_CRITICAL_RATE
	fCriticalEffectiveRate += m_fPassiveCriticalRate;
#endif //FIX_RAVEN_CRITICAL_RATE

#ifdef SERV_PET_SYSTEM
	if( m_petCheer.m_fTime > 0.f && m_petCheer.m_fCriticalRate > 0.f )
	{
		fCriticalEffectiveRate += m_petCheer.m_fCriticalRate;
	}
#endif

	switch( byDamageType )
	{
	case CX2DamageManager::DT_MAGIC:
	case CX2DamageManager::DT_MIX:
	case CX2DamageManager::DT_WEAPON_MAGIC:
	case CX2DamageManager::DT_WEAPON_MIX:
#ifdef NEW_CHARACTER_EL
		if( 0 < GetAddMagicAttackCriticalRate() )
			fCriticalEffectiveRate += GetAddMagicAttackCriticalRate();
#endif // NEW_CHARACTER_EL
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
			fCriticalEffectiveRate += m_fShadowOfDisasterRate;
#endif //UPGRADE_SKILL_SYSTEM_2013
	default:
		break;
	}

	return fCriticalEffectiveRate;	// kimhc // 2011-08-01 // 옵션 수치화로 보정 수치 사라짐
}

void CX2GUUser::ChangeModelDetail( int detailPercent )
{
	if ( m_pXSkinAnim != NULL )
	{
		m_pXSkinAnim->SetModelDetailPercent( detailPercent );
	}

	if ( m_pXSkinAnimFuture != NULL )
	{
		m_pXSkinAnimFuture->SetModelDetailPercent( detailPercent );	
	}

	if ( m_pOrgXSkinAnim != NULL )
	{
		m_pOrgXSkinAnim->SetModelDetailPercent( detailPercent );
	}

	if ( m_pOrgXSkinAnimFuture != NULL )
	{
		m_pOrgXSkinAnimFuture->SetModelDetailPercent( detailPercent );	
	}

}





bool CX2GUUser::IsImmuneToEnchant( CX2EnchantItem::ENCHANT_TYPE enchantType )
{
	if ( CX2GameUnit::IsImmuneToEnchant( enchantType ) == true )
		return true;

	if( GetRandomFloat( CKTDXRandomNumbers::SRO_RESIST_EXTRA_DAMAGE_ENCHANT ) < GetEnchantResist( enchantType ) / (float)CX2EnchantItem::EAR_MAX_VALUE )
		return true; 

	return false;
}

void CX2GUUser::ShowSnatchCureEffect()
{
	D3DXVECTOR3 hpAndMpUpPos = D3DXVECTOR3(0,0,0);
	hpAndMpUpPos = GetBonePos( L"Bip01_Spine" );


	if( m_hSeqHPUp == INVALID_PARTICLE_SEQUENCE_HANDLE )
		m_hSeqHPUp = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Plus_Hp01", hpAndMpUpPos );

	if( m_hSeqMPUp == INVALID_PARTICLE_SEQUENCE_HANDLE )
		m_hSeqMPUp = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Plus_Mp01", hpAndMpUpPos );

	PlaySound( L"Drain_HPMP.ogg" );
}

float CX2GUUser::GetDamageUpPercentBySMA( int npcID )
{
	map< int, float >::iterator mit = m_mapNpcIdNDamageUpPercent.find( npcID );
	if ( mit != m_mapNpcIdNDamageUpPercent.end() )
	{
		return mit->second;
	}

	return 0.0f;
}

float CX2GUUser::GetEvadeUpPerBySMA( int npcID )
{
	map< int, float >::iterator mit = m_mapNpcIDNDEvadeUpPercent.find( npcID );
	if ( mit != m_mapNpcIDNDEvadeUpPercent.end() )
	{
		return mit->second;
	}

	return 0.0f;
}

/*virtual*/ float CX2GUUser::GetPowerRate()
{
	return m_NowStateData.m_fPowerRate;
}

/** @function : CX2GUUser::ActiveSkillShow
	@brief : 스킬사용시 번쩍이는 이펙트와, 컷인이 보이도록 하는 함수
	@param : 번쩍이는 이펙트가 붙을 본이름, 스킬컷인 구조체의 포인터, 컷인의 첫번째 인덱스(전직에 따라 달라짐), 몇필 스킬인가를 지정, 각성상태인지 지정, 빛만 보이게 할것인지 지정
	@return : void
*/
void CX2GUUser::ActiveSkillShow( const WCHAR* pBoneName, const SkillCutInSet *s_SkillCutInSet, int iCutInSet, int iCutIn, bool bHyper, bool bOnlyLight)
{
	D3DXVECTOR3 bonePos = m_pXSkinAnim->GetCloneFramePosition( pBoneName );

	ActiveSkillShow( bonePos, 
		s_SkillCutInSet[iCutInSet].cutIn[iCutIn].fileName.c_str(), 
		s_SkillCutInSet[iCutInSet].cutIn[iCutIn].vSize, 
		s_SkillCutInSet[iCutInSet].cutIn[iCutIn].vPosition, 
		bHyper, bOnlyLight );
}

/** @function : CX2GUUser::ActiveSkillShow
@brief : 스킬사용시 번쩍이는 이펙트와, 컷인이 보이도록 하는 함수
@param : 번쩍이는 이펙트가 붙을 본이름, 스킬컷인 텍스쳐명, 텍스쳐 사이즈, 텍스쳐가 보일 위치, 각성상태인지 지정, 빛만 보이게 할것인지 지정
@return : void
*/
void CX2GUUser::ActiveSkillShow( const WCHAR* pBoneName, const WCHAR* pBackFaceTexName, D3DXVECTOR2 size, D3DXVECTOR3 pos, bool bHyper, bool bOnlyLight )
{
	D3DXVECTOR3 bonePos = m_pXSkinAnim->GetCloneFramePosition( pBoneName );
	ActiveSkillShow( bonePos, pBackFaceTexName, size, pos, bHyper, bOnlyLight );
}

/** @function : CX2GUUser::ActiveSkillShow
@brief : 스킬사용시 번쩍이는 이펙트와, 컷인이 보이도록 하는 함수
@param : 번쩍이는 이펙트가 붙을 본위치, 스킬컷인 텍스쳐명, 텍스쳐 사이즈, 텍스쳐가 보일 위치, 각성상태인지 지정, 빛만 보이게 할것인지 지정
@return : void
*/
void CX2GUUser::ActiveSkillShow( D3DXVECTOR3 bonePos, const WCHAR* pBackFaceTexName, D3DXVECTOR2 size, D3DXVECTOR3 pos, bool bHyper, bool bOnlyLight )
{
#ifdef DIALOG_SHOW_TOGGLE
	if( g_pKTDXApp->GetDGManager()->GetDialogManager()->GetHideDialog() == true )
		return;
#endif

	CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

#if 0	// 스탑타임 없어지면서 기모으는 이펙트 제거 테스트
	if( bHyper == false )
	{
		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"SpecialEnergyCenter", bonePos );
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"SpecialEnergyLine", bonePos );
		if( pSeq != NULL )
		{
			pSeq->SetBlackHolePosition( bonePos );
			pSeq->UseLookPoint( true );
			pSeq->SetLookPoint( bonePos );
		}	
	}
	else
	{
		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"SpecialEnergyCenterRed", bonePos );
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"SpecialEnergyLineFastRed", bonePos );
		if( pSeq != NULL )
		{
			pSeq->SetBlackHolePosition( bonePos );
			pSeq->UseLookPoint( true );
			pSeq->SetLookPoint( bonePos );
		}
	}
#endif
	if( bOnlyLight == false )
	{
		pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( NULL,  L"FocusLine", D3DXVECTOR3(0,0,0) );
		if( GetIsRight() == true )
		{
			pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( NULL,  L"OutLine", D3DXVECTOR3(0,0,0) );
			CKTDGParticleSystem::CParticleEventSequence* pPart = g_pX2Game->GetMinorParticle()->CreateSequence( NULL,  L"CutIn_Right", 0,0,0 );
			if( pPart != NULL )
			{
				pPart->ChangeTexForce( pBackFaceTexName );
				
				CKTDGParticleSystem::CParticleEventList::iterator iter = 
					( const_cast<CKTDGParticleSystem::CParticleEventList&>( pPart->GetTemplet()->m_EventList ) ).begin();
				CKTDGParticleSystem::CParticleEventList::iterator iterEnd = 
					( const_cast<CKTDGParticleSystem::CParticleEventList&>( pPart->GetTemplet()->m_EventList ) ).end();

				if ( iter == iterEnd )  goto out;
				iter++; if ( iter == iterEnd ) goto out;
				CKTDGParticleSystem::CParticleEvent_Size* pESize = (CKTDGParticleSystem::CParticleEvent_Size*) (*iter);
				pESize->SetSize( CMinMax<D3DXVECTOR3>( D3DXVECTOR3(size.x,size.y,1), D3DXVECTOR3(size.x,size.y,1) ));

				iter++; if ( iter == iterEnd ) goto out;
				CKTDGParticleSystem::CParticleEvent_Position* pEPos = (CKTDGParticleSystem::CParticleEvent_Position*) (*iter);
				pEPos->SetPosition( CMinMax<D3DXVECTOR3>( D3DXVECTOR3(pos.x-size.x, pos.y, 0),D3DXVECTOR3(pos.x-size.x, pos.y, 0) ) );

				iter++; if ( iter == iterEnd ) goto out;
				pEPos = (CKTDGParticleSystem::CParticleEvent_Position*) (*iter);
				pEPos->SetPosition( CMinMax<D3DXVECTOR3>( D3DXVECTOR3(pos.x, pos.y, 0),D3DXVECTOR3(pos.x, pos.y, 0) ) );

				iter++; if ( iter == iterEnd ) goto out;
				pEPos = (CKTDGParticleSystem::CParticleEvent_Position*) (*iter);
				pEPos->SetPosition( CMinMax<D3DXVECTOR3>( D3DXVECTOR3(1024+size.x, pos.y, 0),D3DXVECTOR3(1024+size.x, pos.y, 0) ) );		
			}

out:
			pPart = g_pX2Game->GetMinorParticle()->CreateSequence( NULL,  L"CutIn_Talk_Right", 0,0,0 );
			if( pPart != NULL )
			{
#ifdef _CLASS_CUTIN_
				wstringstream str;
				str << GetCutInFileName(true) << L".dds";				
#else _CLASS_CUTIN_
				int texID = rand() % 3;
				wstringstream str;
				str << L"HQ_CutIn_Talk_R_" << texID << L".dds";
#endif _CLASS_CUTIN_
				pPart->ChangeTexForce( str.str().c_str() );
			}
		}
		else
		{
			pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( NULL,  L"OutLine_Left", D3DXVECTOR3(0,0,0) );
			CKTDGParticleSystem::CParticleEventSequence* pPart = g_pX2Game->GetMinorParticle()->CreateSequence( NULL,  L"CutIn_Left", 0,0,0 );
			if( pPart != NULL )
			{
				pPart->ChangeTexForce( pBackFaceTexName );
				
				CKTDGParticleSystem::CParticleEventList::iterator iter = 
					( const_cast<CKTDGParticleSystem::CParticleEventList&>( pPart->GetTemplet()->m_EventList ) ).begin();
				CKTDGParticleSystem::CParticleEventList::iterator iterEnd = 
					( const_cast<CKTDGParticleSystem::CParticleEventList&>( pPart->GetTemplet()->m_EventList ) ).end();

				if ( iter == iterEnd )  goto out2;
				iter++; if ( iter == iterEnd ) goto out2;
				CKTDGParticleSystem::CParticleEvent_Size* pESize = (CKTDGParticleSystem::CParticleEvent_Size*) (*iter);
				pESize->SetSize( CMinMax<D3DXVECTOR3>( D3DXVECTOR3(size.x,size.y,1), D3DXVECTOR3(size.x,size.y,1) ));

				iter++; if ( iter == iterEnd ) goto out2;
				CKTDGParticleSystem::CParticleEvent_Position* pEPos = (CKTDGParticleSystem::CParticleEvent_Position*) (*iter);
				pEPos->SetPosition( CMinMax<D3DXVECTOR3>( D3DXVECTOR3(1024+size.x, pos.y, 0),D3DXVECTOR3(1024+size.x, pos.y, 0) ) );

				iter++; if ( iter == iterEnd ) goto out2;
				pEPos = (CKTDGParticleSystem::CParticleEvent_Position*) (*iter);
				pEPos->SetPosition( CMinMax<D3DXVECTOR3>( D3DXVECTOR3(1024-pos.x, pos.y, 0),D3DXVECTOR3(1024-pos.x, pos.y, 0) ) );

				iter++; if ( iter == iterEnd ) goto out2;
				pEPos = (CKTDGParticleSystem::CParticleEvent_Position*) (*iter);
				pEPos->SetPosition( CMinMax<D3DXVECTOR3>( D3DXVECTOR3(-size.x, pos.y, 0),D3DXVECTOR3(-size.x, pos.y, 0) ) );
			}
			
out2:
			pPart = g_pX2Game->GetMinorParticle()->CreateSequence( NULL,  L"CutIn_Talk_Left", 0,0,0 );
			if( pPart != NULL )
			{
#ifdef _CLASS_CUTIN_
				wstringstream str;
				str << GetCutInFileName(false) << L".dds";				
#else _CLASS_CUTIN_
				int texID = rand() % 3;
				wstringstream str;
				str << L"HQ_CutIn_Talk_L_" << texID << L".dds";
#endif _CLASS_CUTIN_
				pPart->ChangeTexForce( str.str().c_str() );
			}
		}

	}
}

bool CX2GUUser::CheckDashAngleChangeTime()
{
	if( g_pX2Game->GetGameType() != CX2Game::GT_DUNGEON && g_pX2Game->GetGameType() != CX2Game::GT_BATTLE_FIELD )
		return false;

	if ( GetUnit() != NULL )
	{

		if ( m_FrameDataNow.syncData.nowState == USI_DASH ||
			m_FrameDataNow.syncData.nowState == USI_DASH_JUMP ||
			m_FrameDataNow.syncData.nowState == USI_DASH_JUMP_LANDING ||
			m_FrameDataNow.syncData.nowState == USI_WALK )
		{
			return true;
		}

		//{{ 2009.01.19 김태완 : 코드정리 elseif -> switch
		switch( GetUnit()->GetUnitTemplet()->m_UnitType )
		{
		case CX2Unit::UT_ARME:
			{
				if ( m_FrameDataNow.syncData.nowState == CX2GUArme_VioletMage::AVSI_DASH_JUMP_LEVITATION )
				{
					return true;
				}
			} break;

		default:
			break;

		}//}} elseif -> switch
	}

	return false;
}

float CX2GUUser::GetDashCameraAngleDegree()
{
	if ( g_pMain->GetGameOption().GetCameraDistance() <= 900 )
	{
		return DASH_CAMERA_ANGLE;
	}
	else if ( g_pMain->GetGameOption().GetCameraDistance() <= 1200 && g_pMain->GetGameOption().GetCameraDistance() > 900 )
	{
		return DASH_CAMERA_ANGLE - 20;
	}
	else if ( g_pMain->GetGameOption().GetCameraDistance() > 1200 )
	{
		return DASH_CAMERA_ANGLE - 25;
	}

	return 0;
}

float CX2GUUser::GetBasicReducedDamagePercent()
{
	float fReducedDamagePer = 0;

	//세트 옵션을 뒤져봐서 감소되는 데미지 옵션이 있는지 확인.
	for ( int optionIndex = 0; optionIndex < (int)m_vecSetItemOptions.size(); optionIndex++ )
	{
		const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( m_vecSetItemOptions[optionIndex] );
		if ( pSocketData != NULL )
		{
#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
			if( pSocketData->m_fIntervalTime > 0.f )
			{
				if( GetSocketOptionCoolTime() <= 0.f )
				{
					SetSocketOptionCoolTime( pSocketData->m_fIntervalTime );
					fReducedDamagePer = GetSocketReducedDamagePercentInCase( *pSocketData );

					return fReducedDamagePer;
				}
			}
			else
			{
				fReducedDamagePer = GetSocketReducedDamagePercentInCase( *pSocketData );

				return fReducedDamagePer;
			}
#else //ADJUST_SECRET_ITEM_OPTION
			if ( pSocketData->m_fDamageReduce > 0.0f && pSocketData->m_fPercentDamageReduce > GetRandomFloat() )
			{
				if ( pSocketData->m_bDungeonOnly == true )
				{
					if ( g_pX2Game != NULL && ( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON || g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD ) )
					{
						fReducedDamagePer += pSocketData->m_fDamageReduce;
						return fReducedDamagePer;
					}
				}
				else if ( pSocketData->m_bPVPOnly == true )
				{
					if ( g_pX2Game != NULL && g_pX2Game->GetGameType() == CX2Game::GT_PVP )
					{
						fReducedDamagePer += pSocketData->m_fDamageReduce;
						return fReducedDamagePer;
					}
				}
				else
				{
					fReducedDamagePer += pSocketData->m_fDamageReduce;
					return fReducedDamagePer;
				}
			}
#endif //ADJUST_SECRET_ITEM_OPTION
		}
	}

//#ifdef TITLE_SYSTEM
	for ( int optionIndex = 0; optionIndex < (int)m_vecTitleOptions.size(); optionIndex++ )
	{
		const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( m_vecTitleOptions[optionIndex] );
		if ( pSocketData != NULL )
		{
			if ( pSocketData->m_fDamageReduce > 0.0f && pSocketData->m_fPercentDamageReduce > GetRandomFloat() )
			{
				if ( pSocketData->m_bDungeonOnly == true )
				{
					if ( g_pX2Game != NULL && ( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON || g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD ) )
					{
						fReducedDamagePer += pSocketData->m_fDamageReduce;
						return fReducedDamagePer;
					}
				}
				else if ( pSocketData->m_bPVPOnly == true )
				{
					if ( g_pX2Game != NULL && g_pX2Game->GetGameType() == CX2Game::GT_PVP )
					{
						fReducedDamagePer += pSocketData->m_fDamageReduce;
						return fReducedDamagePer;
					}
				}
				else
				{
					fReducedDamagePer += pSocketData->m_fDamageReduce;
					return fReducedDamagePer;
				}
			}
		}
	}
//#endif

	return fReducedDamagePer;
}


float CX2GUUser::GetReducedDamagePercentByMonsterAttack( int monsterID )
{
	float fReducedDamagePer = 0;


	//세트 옵션을 뒤져봐서 특정 몬스터에의해 감소되는 데미지 옵션이 있는지 확인.
	for ( int optionIndex = 0; optionIndex < (int)m_vecSetItemOptions.size(); optionIndex++ )
	{
		const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( m_vecSetItemOptions[optionIndex] );
		if ( pSocketData != NULL )
		{
			// 특정 몬스터 데미지 감소 옵션 적용안되던 문제 수정
			//if ( pSocketData->m_fDamageReduceByMonsterAttack > 0.0f && pSocketData->m_fPercentDRByMonsterAttack <= GetRandomFloat() )
			if ( pSocketData->m_fDamageReduceByMonsterAttack > 0.0f && pSocketData->m_fPercentDRByMonsterAttack > GetRandomFloat() )
			{
				set<int>::iterator sit = pSocketData->m_setMonsterIDDamageReduced.find( monsterID );
				if ( sit != pSocketData->m_setMonsterIDDamageReduced.end() )
				{
					if ( pSocketData->m_bDungeonOnly == true )
					{
						if ( g_pX2Game != NULL && ( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON || g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD ) )
						{
							fReducedDamagePer += pSocketData->m_fDamageReduceByMonsterAttack;
							return fReducedDamagePer;
						}
					}
					else if ( pSocketData->m_bPVPOnly == true )
					{
						if ( g_pX2Game != NULL && g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON )
						{
							fReducedDamagePer += pSocketData->m_fDamageReduceByMonsterAttack;
							return fReducedDamagePer;
						}
					}
					else
					{
						fReducedDamagePer += pSocketData->m_fDamageReduceByMonsterAttack;
						return fReducedDamagePer;
					}
				}
			}
		}
	}

//#ifdef TITLE_SYSTEM
	for ( int optionIndex = 0; optionIndex < (int)m_vecTitleOptions.size(); optionIndex++ )
	{
		const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( m_vecTitleOptions[optionIndex] );
		if ( pSocketData != NULL )
		{
			// 특정 몬스터 데미지 감소 옵션 적용안되던 문제 수정
			//if ( pSocketData->m_fDamageReduceByMonsterAttack > 0.0f && pSocketData->m_fPercentDRByMonsterAttack <= GetRandomFloat() )
			if ( pSocketData->m_fDamageReduceByMonsterAttack > 0.0f && pSocketData->m_fPercentDRByMonsterAttack > GetRandomFloat() )
			{
				set<int>::iterator sit = pSocketData->m_setMonsterIDDamageReduced.find( monsterID );
				if ( sit != pSocketData->m_setMonsterIDDamageReduced.end() )
				{
					if ( pSocketData->m_bDungeonOnly == true )
					{
						if ( g_pX2Game != NULL && ( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON || g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD ) )
						{
							fReducedDamagePer += pSocketData->m_fDamageReduceByMonsterAttack;
							return fReducedDamagePer;
						}
					}
					else if ( pSocketData->m_bPVPOnly == true )
					{
						if ( g_pX2Game != NULL && g_pX2Game->GetGameType() == CX2Game::GT_PVP )
						{
							fReducedDamagePer += pSocketData->m_fDamageReduceByMonsterAttack;
							return fReducedDamagePer;
						}
					}
					else
					{
						fReducedDamagePer += pSocketData->m_fDamageReduceByMonsterAttack;
						return fReducedDamagePer;
					}
				}
			}
		}
	}
//#endif


	return fReducedDamagePer;
}

/*virtual*/ float CX2GUUser::GetHyperModeTime() const
{
	float fTotalTime 
		= ( GetForceHyperModeTime() > 0.0f ? GetForceHyperModeTime() : GetMaxHyperModeTime() * GetLastStateHyperModeCount() );
	// 기본각성시간(1필각성시간*각성구슬갯수) 에 m_fHyperModeTime 퍼센트 만큼 더해준다.
	fTotalTime += fTotalTime * m_SocketData.m_fHyperModeTime * 0.01f;	/// 재각성에는 적용 안됨..

	return fTotalTime;
}






/*virtual*/ float CX2GUUser::GetDamageUpByAMADS()
{
	// 2010.01.13, dmlee - 옵션의 합을 return 하던 것에서, 옵션중에서 최고값을 return 하는 것으로 수정 - 오당형
	float fMaxDamageUp = 0.f;

	float fDamageUp = 0.f;


	// fix!! 아이템 고유 소켓이나 유저가 박은 소켓에 의한 부분은 일단 빠져있음. 나중에 필요하면 추가해야 함





	//세트아이템용으로 스킬 올라가는 녀석이 있는지 검사해보자.
	for ( int i = 0; i < (int)m_vecSetItemOptions.size(); i++ )
	{
		const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( m_vecSetItemOptions[i] );
		if ( pSocketData != NULL )
		{
			if ( pSocketData->m_bDungeonOnly == true )
			{
				if ( g_pX2Game != NULL && ( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON || g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD ) )
				{
					fDamageUp += pSocketData->m_fDamageUpByAMADS;

					if( pSocketData->m_fDamageUpByAMADS > fMaxDamageUp )
					{
						fMaxDamageUp = pSocketData->m_fDamageUpByAMADS;
					}

				}
			}
			else if ( pSocketData->m_bPVPOnly == true )
			{
				if ( g_pX2Game != NULL && g_pX2Game->GetGameType() == CX2Game::GT_PVP )
				{
					fDamageUp += pSocketData->m_fDamageUpByAMADS;

					if( pSocketData->m_fDamageUpByAMADS > fMaxDamageUp )
					{
						fMaxDamageUp = pSocketData->m_fDamageUpByAMADS;
					}

				}
			}
			else
			{
				fDamageUp += pSocketData->m_fDamageUpByAMADS;

				if( pSocketData->m_fDamageUpByAMADS > fMaxDamageUp )
				{
					fMaxDamageUp = pSocketData->m_fDamageUpByAMADS;
				}
			}
		}
	}

	for ( int i = 0; i < (int)m_vecTitleOptions.size(); i++ )
	{
		const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( m_vecTitleOptions[i] );
		if ( pSocketData != NULL )
		{
			if ( pSocketData->m_bDungeonOnly == true )
			{
				if ( g_pX2Game != NULL && ( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON || g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD ) )
				{
					fDamageUp += pSocketData->m_fDamageUpByAMADS;

					if( pSocketData->m_fDamageUpByAMADS > fMaxDamageUp )
					{
						fMaxDamageUp = pSocketData->m_fDamageUpByAMADS;
					}

				}
			}
			else if ( pSocketData->m_bPVPOnly == true )
			{
				if ( g_pX2Game != NULL && g_pX2Game->GetGameType() == CX2Game::GT_PVP )
				{
					fDamageUp += pSocketData->m_fDamageUpByAMADS;


					if( pSocketData->m_fDamageUpByAMADS > fMaxDamageUp )
					{
						fMaxDamageUp = pSocketData->m_fDamageUpByAMADS;
					}

				}
			}
			else
			{
				fDamageUp += pSocketData->m_fDamageUpByAMADS;

				if( pSocketData->m_fDamageUpByAMADS > fMaxDamageUp )
				{
					fMaxDamageUp = pSocketData->m_fDamageUpByAMADS;
				}
			}
		}
	}


	//return fDamageUp;


	return fMaxDamageUp;

}







void CX2GUUser::GetDamageReduceByResistExtraDamage( CX2DamageManager::EXTRA_DAMAGE_TYPE damageType, float& fFinalDamage )
{
	float fResist = 0.0f;


	// 세트 아이템 소켓 옵션
	for ( int i = 0; i < (int)m_vecSetItemOptions.size(); i++ )
	{
		const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( m_vecSetItemOptions[i] );
		if( NULL == pSocketData )
			continue;

		if( pSocketData->m_bDungeonOnly == true && 
			( g_pX2Game == NULL || ( NULL != g_pX2Game && ( g_pX2Game->GetGameType() != CX2Game::GT_DUNGEON && g_pX2Game->GetGameType() != CX2Game::GT_BATTLE_FIELD ) ) ) )
			continue;


		if( pSocketData->m_bPVPOnly == true && 
			( g_pX2Game == NULL || ( NULL != g_pX2Game && g_pX2Game->GetGameType() != CX2Game::GT_PVP ) ) )
			continue;


		if( pSocketData->m_ResistExtraDamageType != damageType )
		{
			continue;
		}

		fResist += pSocketData->m_fResistExtraDamage;
	}

//#ifdef TITLE_SYSTEM
	// 칭호 소켓옵션
	for ( int i = 0; i < (int)m_vecTitleOptions.size(); i++ )
	{
		const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( m_vecTitleOptions[i] );

		if( NULL == pSocketData )
			continue;

		if( pSocketData->m_bDungeonOnly == true && 
			( g_pX2Game == NULL || (NULL != g_pX2Game && ( g_pX2Game->GetGameType() != CX2Game::GT_DUNGEON && g_pX2Game->GetGameType() != CX2Game::GT_BATTLE_FIELD ) ) ) )
			continue;


		if( pSocketData->m_bPVPOnly == true && 
			( g_pX2Game == NULL || (NULL != g_pX2Game && g_pX2Game->GetGameType() != CX2Game::GT_PVP ) ) )
			continue;


		if( pSocketData->m_ResistExtraDamageType != damageType )
		{
			continue;
		}

		fResist += pSocketData->m_fResistExtraDamage;
	}
//#endif

	float fValue = (1.0f - fResist);
	if ( fValue <= 0.0f )
	{
		fFinalDamage = 1.0f;
	}
	else
	{
		fFinalDamage *= fValue;
	}
}



void CX2GUUser::AnimStop()
{
	if ( m_pXSkinAnimFuture != NULL )
		m_pXSkinAnimFuture->Wait();

	if ( m_pXSkinAnim != NULL )
		m_pXSkinAnim->Wait();

	m_FrameDataNow.stateParam.bSuperArmor = true;
	m_FrameDataNow.stateParam.bSuperArmorNotRed = true;
}

void CX2GUUser::AnimPlay()
{
	if ( m_pXSkinAnimFuture != NULL )
		m_pXSkinAnimFuture->Play( CKTDGXSkinAnim::XAP_LOOP );

	if ( m_pXSkinAnim != NULL )
		m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_LOOP );

	m_FrameDataNow.stateParam.bSuperArmor = false;
	m_FrameDataNow.stateParam.bSuperArmorNotRed = false;
}



void CX2GUUser::ProcessEnchantedWeaponEffectAtHand( CX2Unit::UNIT_TYPE unitType )
{
	KTDXPROFILE();


	if( INVALID_PARTICLE_SEQUENCE_HANDLE == m_hSeqWeaponCommon1 )	// 이 파티클이 없으면 손에 붙는 파티클은 없다고 보면 됨
		return;

	if( m_pXSkinAnim == NULL )
		return;

	D3DXVECTOR3 vHandPos( 0, 0, 0 );
	float aEmitRate[4] = { 0.f, };
	switch( unitType )
	{
	case CX2Unit::UT_ELSWORD:
	case CX2Unit::UT_ARME:
	case CX2Unit::UT_RAVEN:
		//{{ kimhc // 2010.11.24 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
	case CX2Unit::UT_CHUNG:
#endif	NEW_CHARACTER_CHUNG
		//}} kimhc // 2010.11.24 //  2010-12-23 New Character CHUNG
		{
			vHandPos = m_pXSkinAnim->GetCloneFramePosition( L"Dummy1_Rhand" );
			aEmitRate[0] = 10.f;
			aEmitRate[1] = 30.f;
			aEmitRate[2] = 60.f;
			aEmitRate[3] = 25.f;
		} break;

	case CX2Unit::UT_LIRE:
		{
			vHandPos = m_pXSkinAnim->GetCloneFramePosition( L"Dummy2_Lhand" );
			aEmitRate[0] = 15.f;
			aEmitRate[1] = 30.f;
			aEmitRate[2] = 60.f;
			aEmitRate[3] = 25.f;
		} break;

	case CX2Unit::UT_EVE:
		{
			vHandPos = m_pXSkinAnim->GetCloneFramePosition( L"Dummy2_Lhand" );
			aEmitRate[0] = 10.f;
			aEmitRate[1] = 10.f;
			aEmitRate[2] = 10.f;
			aEmitRate[3] = 25.f;
		} break;

	case CX2Unit::UT_ARA:
	case CX2Unit::UT_ELESIS:
		{
			vHandPos = m_pXSkinAnim->GetCloneFramePosition( L"Dummy3_Weapon" );
			aEmitRate[0] = 15.f;
			aEmitRate[1] = 30.f;
			aEmitRate[2] = 60.f;
			aEmitRate[3] = 25.f;
		} break;
#ifdef SERV_9TH_NEW_CHARACTER // 김태환
	case CX2Unit::UT_ADD:
		{
			vHandPos = m_pXSkinAnim->GetCloneFramePosition( L"Weapon02" );
			aEmitRate[0] = 15.f;
			aEmitRate[1] = 30.f;
			aEmitRate[2] = 60.f;
			aEmitRate[3] = 25.f;
		} break;
#endif //SERV_9TH_NEW_CHARACTER
	}


	CKTDGParticleSystem::CParticleEventSequence* pSeqWeaponFire1 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon1 );
	CKTDGParticleSystem::CParticleEventSequence* pSeqWeaponFire2 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon2 );
	CKTDGParticleSystem::CParticleEventSequence* pSeqWeaponFire3 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon3 );
	CKTDGParticleSystem::CParticleEventSequence* pSeqWeaponFire4 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchantedWeaponCommon4 );


#ifdef RIDING_SYSTEM
	/// 탈것을 타고 있으면, 무기 인첸트 효과 모두 꺼주자.
	if ( NULL != CX2RidingPetManager::GetInstance() && true != CX2RidingPetManager::GetInstance()->GetRidingOn() )
#endif RIDING_SYSTEM
	{
		if ( pSeqWeaponFire1 != NULL )
		{	
			pSeqWeaponFire1->SetPosition( vHandPos );
			pSeqWeaponFire1->SetEmitRate( aEmitRate[0], aEmitRate[0] );
		}

		if ( pSeqWeaponFire2 != NULL )
		{
			pSeqWeaponFire2->SetPosition( vHandPos );
			pSeqWeaponFire2->SetEmitRate( aEmitRate[1], aEmitRate[1] );
		}

		if ( pSeqWeaponFire3 != NULL )
		{
			pSeqWeaponFire3->SetPosition( vHandPos );
			pSeqWeaponFire3->SetEmitRate( aEmitRate[2], aEmitRate[2] );
		}

		if ( pSeqWeaponFire4 != NULL )
		{
			pSeqWeaponFire4->SetPosition( vHandPos );
			pSeqWeaponFire4->SetEmitRate( aEmitRate[3], aEmitRate[3] );
		}
	}
#ifdef RIDING_SYSTEM
	else
	{
		if ( pSeqWeaponFire1 != NULL )
		{	
			pSeqWeaponFire1->ClearAllParticle();
			pSeqWeaponFire1->SetEmitRate( 0, 0 );
		}

		if ( pSeqWeaponFire2 != NULL )
		{
			pSeqWeaponFire2->ClearAllParticle();
			pSeqWeaponFire2->SetEmitRate( 0, 0 );
		}

		if ( pSeqWeaponFire3 != NULL )
		{
			pSeqWeaponFire3->ClearAllParticle();
			pSeqWeaponFire3->SetEmitRate( 0, 0 );
		}

		if ( pSeqWeaponFire4 != NULL )
		{
			pSeqWeaponFire4->ClearAllParticle();
			pSeqWeaponFire4->SetEmitRate( 0, 0 );
		}
	}
#endif RIDING_SYSTEM

}


#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
/*static*/
void	CX2GUUser::AppendEnchantedWeaponEffectAtHandToDeviceList( CKTDXDeviceDataList& listInOut_, CX2DamageManager::EXTRA_DAMAGE_TYPE eDamageType_ )
{

	switch( eDamageType_ )
	{
	case CX2DamageManager::EDT_ENCHANT_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_POISON_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_BLAZE_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_POISON_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_FROZEN_PIERCING:
		{
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property02_Wind01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property03_Wind01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_MASTER_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_DOUBLE_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_DOUBLE_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_POISON_DOUBLE_PIERCING:
		{
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property02_M_Wind01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property03_Wind01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property04_Wind01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_DOUBLE_MASTER_PIERCING:
		{
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property02_M_Wind01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property03_Wind01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property04_Wind01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Triple_Weapon_Property_Wind01" );
		} break;
		
	case CX2DamageManager::EDT_ENCHANT_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_POISON_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_BLAZE_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_POISON_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_FROZEN_SHOCK:
		{
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property02_Light01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property03_Light01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_MASTER_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_DOUBLE_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_DOUBLE_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_POISON_DOUBLE_SHOCK:
		{
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property02_M_Light01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property03_Light01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property04_Light01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_DOUBLE_MASTER_SHOCK:
		{
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property02_M_Light01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property03_Light01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property04_Light01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Triple_Weapon_Property_Light01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_POISON_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_BLAZE_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_POISON_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_FROZEN_SNATCH:
		{
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property02_Curse01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property03_Curse01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_MASTER_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_DOUBLE_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_DOUBLE_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_POISON_DOUBLE_SNATCH:
		{
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property02_M_Curse01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property03_Curse01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property04_Curse01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_DOUBLE_MASTER_SNATCH:
		{
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property02_M_Curse01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property03_Curse01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Weapon_Elsword_Property04_Curse01" );
			g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"Triple_Weapon_Property_Curse01"  );
		} break;
	}
}
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD



void CX2GUUser::InitEnchantedWeaponEffectAtHand()
{
 	// attribute postfix에 대한 이펙트 생성

	switch( GetEnchantExtraDamageType() )
	{
	case CX2DamageManager::EDT_ENCHANT_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_POISON_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_BLAZE_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_POISON_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_FROZEN_PIERCING:
		{
			CreateEnchantedWeaponParticleAtHand( L"Weapon_Elsword_Property02_Wind01",
				L"Weapon_Elsword_Property03_Wind01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_MASTER_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_DOUBLE_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_DOUBLE_PIERCING:
	case CX2DamageManager::EDT_ENCHANT_POISON_DOUBLE_PIERCING:
		{
			CreateEnchantedWeaponParticleAtHand( L"Weapon_Elsword_Property02_M_Wind01",
				L"Weapon_Elsword_Property03_Wind01",
				L"Weapon_Elsword_Property04_Wind01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_DOUBLE_MASTER_PIERCING:
		{
			CreateEnchantedWeaponParticleAtHand( L"Weapon_Elsword_Property02_M_Wind01",
				L"Weapon_Elsword_Property03_Wind01",
				L"Weapon_Elsword_Property04_Wind01",
				L"Triple_Weapon_Property_Wind01" );
		} break;
		

		
	case CX2DamageManager::EDT_ENCHANT_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_POISON_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_BLAZE_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_POISON_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_FROZEN_SHOCK:
		{
			CreateEnchantedWeaponParticleAtHand( L"Weapon_Elsword_Property02_Light01",
				L"Weapon_Elsword_Property03_Light01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_MASTER_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_DOUBLE_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_DOUBLE_SHOCK:
	case CX2DamageManager::EDT_ENCHANT_POISON_DOUBLE_SHOCK:
		{
			CreateEnchantedWeaponParticleAtHand( L"Weapon_Elsword_Property02_M_Light01",
				L"Weapon_Elsword_Property03_Light01",
				L"Weapon_Elsword_Property04_Light01" );

		} break;


	case CX2DamageManager::EDT_ENCHANT_DOUBLE_MASTER_SHOCK:
		{
			CreateEnchantedWeaponParticleAtHand( L"Weapon_Elsword_Property02_M_Light01",
				L"Weapon_Elsword_Property03_Light01",
				L"Weapon_Elsword_Property04_Light01",
				L"Triple_Weapon_Property_Light01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_POISON_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_BLAZE_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_POISON_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_DOUBLE_FROZEN_SNATCH:
		{
			CreateEnchantedWeaponParticleAtHand( L"Weapon_Elsword_Property02_Curse01",
				L"Weapon_Elsword_Property03_Curse01" );
		} break;

	case CX2DamageManager::EDT_ENCHANT_MASTER_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_BLAZE_DOUBLE_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_FROZEN_DOUBLE_SNATCH:
	case CX2DamageManager::EDT_ENCHANT_POISON_DOUBLE_SNATCH:
		{
			CreateEnchantedWeaponParticleAtHand( L"Weapon_Elsword_Property02_M_Curse01",
				L"Weapon_Elsword_Property03_Curse01",
				L"Weapon_Elsword_Property04_Curse01" );
		} break;


	case CX2DamageManager::EDT_ENCHANT_DOUBLE_MASTER_SNATCH:
		{
			CreateEnchantedWeaponParticleAtHand( L"Weapon_Elsword_Property02_M_Curse01",
				L"Weapon_Elsword_Property03_Curse01",
				L"Weapon_Elsword_Property04_Curse01",
				L"Triple_Weapon_Property_Curse01" );
		} break;
	}
}






void CX2GUUser::SetShowEnchantedWeaponEffectAtHand( bool bShow )
{
	CKTDGParticleSystem::CParticleEventSequence* pSeqWeapon = NULL;
	pSeqWeapon = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon1 );
	if( pSeqWeapon != NULL )
		pSeqWeapon->SetShowObject(bShow);
	pSeqWeapon = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon2 );
	if( pSeqWeapon != NULL )
		pSeqWeapon->SetShowObject(bShow);
	pSeqWeapon = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqWeaponCommon3 );
	if( pSeqWeapon != NULL )
		pSeqWeapon->SetShowObject(bShow);
	pSeqWeapon = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqEnchantedWeaponCommon4 );
	if( pSeqWeapon != NULL )
		pSeqWeapon->SetShowObject(bShow);
}


bool CX2GUUser::IsImmuneBySocketOption( CX2DamageManager::EXTRA_DAMAGE_TYPE exDamageType )
{
	map< CX2DamageManager::EXTRA_DAMAGE_TYPE, float >::iterator mit = m_mapExtraDamageNImmunePer.find( exDamageType );
	if ( mit != m_mapExtraDamageNImmunePer.end() )
	{	
		if ( mit->second > GetRandomFloat( CKTDXRandomNumbers::SRO_IMMUNE_EXTRA_DAMAGE_SCRIPTED ) )
		{
			return true;
		}
	}

	return false;
}

void CX2GUUser::PEPPER_RUN_READY_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.3f )
	{
		StateChange( USI_PEPPER_RUN );
		m_TimerPepperRun.restart();
	}

	CommonEventProcess();
}

void CX2GUUser::PEPPER_RUN_FrameMoveFuture()
{
	if( m_InputData.pureRight == true )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
	}
	else if( m_InputData.pureLeft == true )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
	}

	m_PhysicParam.nowSpeed.x = GetDashSpeed() * 1.5f;

	CommonFrameMoveFuture();
}

void CX2GUUser::PEPPER_RUN_EventProcess()
{
	if( 0.f != m_fPepperRunTime && 
		m_TimerPepperRun.elapsed() > m_fPepperRunTime )
	{
		m_fPepperRunTime = 0.f;
		StateChange( USI_PEPPER_RUN_END );
	}
	else if( m_InputData.pureUp == true )
	{
		StateChange( USI_PEPPER_RUN_JUMP_UP );
	}
	else if( m_InputData.oneDown == true 
		&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS, &m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{
		StateChange( USI_PEPPER_RUN_JUMP_DOWN );
	}

	CommonEventProcess();
}


void CX2GUUser::PEPPER_RUN_END_FrameMove()
{
	CommonFrameMove();
}

void CX2GUUser::PEPPER_RUN_END_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( false == IsOnSomethingFuture() )
		{
			StateChange( USI_JUMP_DOWN );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
		else
		{
			StateChange( m_CommonState.m_Wait );
		}
	}

	CommonEventProcess();
}

void CX2GUUser::PEPPER_RUN_JUMP_UP_StateStartFuture()
{
	switch( GetUnit()->GetType() )
	{
	default:
		{
			m_PhysicParam.nowSpeed.y = GetDashJumpSpeed();
		} break;

	case CX2Unit::UT_EVE:
		{
			m_PhysicParam.nowSpeed.y = 2300.f;
		} break;
	}

	m_FrameDataFuture.syncData.position.y += LINE_RADIUS;

}

void CX2GUUser::PEPPER_RUN_JUMP_UP_FrameMoveFuture()
{
	if( m_InputData.pureRight == true )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
	}
	else if( m_InputData.pureLeft == true )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
	}

	m_PhysicParam.nowSpeed.x = GetDashSpeed() * 1.5f;		

	if( m_InputData.pureDown == true && m_InputData.pureUp == false )
	{
		m_PhysicParam.nowSpeed.y -= m_PhysicParam.fGAccel * m_fElapsedTime;
	}

	CommonFrameMoveFuture();
}

void CX2GUUser::PEPPER_RUN_JUMP_UP_EventProcess()
{
	if( 0.f != m_fPepperRunTime && 
		m_TimerPepperRun.elapsed() > m_fPepperRunTime )
	{
		m_fPepperRunTime = 0.f;
		StateChange( USI_PEPPER_RUN_END );
	}
	else if( m_PhysicParam.nowSpeed.y <= 0.0f )
	{
		StateChange( USI_PEPPER_RUN_JUMP_DOWN );
	}

	CommonEventProcess();
}

void CX2GUUser::PEPPER_RUN_JUMP_DOWN_StateStartFuture()
{
	CommonStateStartFuture();
	
	m_FrameDataFuture.syncData.position.y -= LINE_RADIUS;

}

void CX2GUUser::PEPPER_RUN_JUMP_DOWN_FrameMoveFuture()
{
	if( m_InputData.pureRight == true )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
	}
	else if( m_InputData.pureLeft == true )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
	}

	m_PhysicParam.nowSpeed.x = GetDashSpeed() * 1.5f;		

	if( m_InputData.pureDown == true  && m_InputData.pureUp == false )
	{
		m_PhysicParam.nowSpeed.y -= m_PhysicParam.fGAccel * m_fElapsedTime;
	}

	CommonFrameMoveFuture();
}

void CX2GUUser::PEPPER_RUN_JUMP_DOWN_EventProcess()
{
	if( 0.f != m_fPepperRunTime && 
		m_TimerPepperRun.elapsed() > m_fPepperRunTime )
	{
		m_fPepperRunTime = 0.f;
		StateChange( USI_PEPPER_RUN_END );
	}
	else if( true == IsOnSomethingFuture() )
	{
		StateChange( USI_PEPPER_RUN );
	}
	else if( m_PhysicParam.nowSpeed.y >= 0.0f )
	{
		StateChange( USI_PEPPER_RUN_JUMP_UP );
	}

	CommonEventProcess();
}


void CX2GUUser::StartPepperRun( float fTime )
{
	m_fPepperRunTime *= 1.1f;
	m_fPepperRunTime += fTime;

	StateChange( USI_PEPPER_RUN_READY, true );
}

/*virtual*/ void CX2GUUser::DAMAGE_GROGGY_EventProcess()
{
	if ( m_vecStunPtr.empty() )
	{
		StateChange( m_CommonState.m_Wait );
	}
	
	CommonEventProcess();
}

#ifdef SPECIAL_USE_ITEM
void CX2GUUser::THROW_ITEM_StateStart()
{
	m_bThrowSuccess = false;
	CommonStateStart();
}

void CX2GUUser::THROW_ITEM_FrameMoveFuture()
{
	CommonFrameMoveFuture();
}

void CX2GUUser::THROW_ITEM_CameraMove()
{
	CommonCameraMove();
}

void CX2GUUser::THROW_ITEM_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( m_CommonState.m_Wait );
	}
	CommonEventProcess();
}

void CX2GUUser::THROW_ITEM_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( m_fThrowStartTime ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( m_fThrowStartTime ) == true && EventCheck( m_fThrowStartTime, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vEffectPos = ( CX2Item::SST_CHILDRENSDAY_SHPERE_03 != m_iThrowItemValue ? GetPos() : GetLandPosition() );

		
		D3DXVECTOR3 vRotate = GetRotateDegree();

		//vEffectPos = GetPos();
		vEffectPos.y += m_vThrowStartPosOffset.y;

		if(GetIsRight() == true)
			vEffectPos += ( m_vThrowStartPosOffset.x * GetDirVector() );
		else
			vEffectPos -= ( m_vThrowStartPosOffset.x * GetDirVector() );

		CX2DamageEffect::CEffect *pEffect = NULL;

		m_bThrowSuccess = true;
		switch( m_iThrowItemValue )
		{
		case CX2Item::SST_WOODEN_SPEAR:
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_WOODEN_SPEAR", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_LIGHT_SPEAR:
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_LIGHT_SPEAR", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_FIRE_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_FIRE_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_WATER_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_WATER_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_NATURE_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_NATURE_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_WIND_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_WIND_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_LIGHT_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_LIGHT_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_DARK_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_DARK_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;

		case CX2Item::SST_CHILDRENSDAY_SHPERE_01:	/// 분노의 어린이탄
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_FIRE_SPHERE_CHILDRENS_DAY", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_CHILDRENSDAY_SHPERE_02:	/// 냉정한 어린이탄
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_WATER_SPHERE_CHILDRENS_DAY", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_CHILDRENSDAY_SHPERE_03:	/// 사랑의 어린이탄
			{
				vEffectPos.y -= 100;
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_NUCLEAR_SPHERE_ITEM_CHILDRENS_DAY", this, NULL, false, GetPowerRate(), -1.f, D3DXVECTOR3( 1, 1, 1 ),
					true, vEffectPos );
			} break;

		case CX2Item::SST_CHILDRENSDAY_SHPERE_04:	/// 행복한 어린이탄
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_LIGHT_SPHERE_CHILDRENS_DAY", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;

		case CX2Item::SST_ANGER_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_ANGER_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
#ifdef EVENT_CHINA_THROW_ITEM
		case CX2Item::SST_CHINA_EVENT_SPEAR:
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVENT_SPECIAL_ITEM_LIGHT_SPEAR", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
#endif //EVENT_CHINA_THROW_ITEM
#ifdef EVENT_ICICLE_THROW_ITEM
		case CX2Item::SST_ICICLE_SPEAR:
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVENT_SPECIAL_ITEM_ICICLE_SPEAR", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
#endif EVENT_ICICLE_THROW_ITEM
#ifdef EVENT_FIRE_CRACKER_THROW_ITEM
		case CX2Item::SST_FIRE_CRACKER:
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_FIRE_CRACKER", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_GOOD_FIRE_CRACKER:
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_GOOD_FIRE_CRACKER", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
#endif //EVENT_FIRE_CRACKER_THROW_ITEM
		default:
			break;
		}

		if( pEffect != NULL )
		{
			m_vThrowStartVelocity.x = m_fWalkCancelAfter;
			m_vThrowStartVelocity.y = m_fDashCancelAfter;
            if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
			    pMeshInstance->SetVelocity( m_vThrowStartVelocity );
		}

	}

	CommonFrameMove();
}

void CX2GUUser::THROW_ITEM_StateEnd()
{
	if( m_bThrowSuccess == false )
	{
		D3DXVECTOR3 vEffectPos;
		D3DXVECTOR3 vRotate;

		vEffectPos = GetPos();
		vEffectPos.y += m_vThrowStartPosOffset.y;

		if(GetIsRight() == true)
			vEffectPos += ( m_vThrowStartPosOffset.x * GetDirVector() );
		else
			vEffectPos -= ( m_vThrowStartPosOffset.x * GetDirVector() );

		vRotate = GetRotateDegree();

		CX2DamageEffect::CEffect *pEffect = NULL;
		switch( m_iThrowItemValue )
		{
		case CX2Item::SST_FIRE_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_FIRE_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_WATER_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_WATER_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_NATURE_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_NATURE_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_WIND_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_WIND_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_LIGHT_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_LIGHT_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_DARK_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_DARK_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		case CX2Item::SST_ANGER_SPHERE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECIAL_ITEM_ANGER_SPHERE", GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
			break;
		default:
			break;
		}

		if( pEffect != NULL )
		{
			m_vThrowStartVelocity.x = 0.f;
			m_vThrowStartVelocity.y = 200.f;
            if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
			    pMeshInstance->SetVelocity( m_vThrowStartVelocity );
		}
	}

	CommonStateEnd();
}

#else SPECIAL_USE_ITEM
//HROW_WOODEN_PIECE
void CX2GUUser::THROW_WOODEN_PIECE_FrameMoveFuture()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnimFuture->EventTimerOneshot( 0.5f ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnimFuture->EventTimer( 0.5f ) == true && EventCheck( 0.5f, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}

	CommonFrameMoveFuture();
}

void CX2GUUser::THROW_WOODEN_PIECE_CameraMove()
{
	CommonCameraMove();
}

void CX2GUUser::THROW_WOODEN_PIECE_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( m_CommonState.m_Wait );
	}
	CommonEventProcess();
}
#endif SPECIAL_USE_ITEM


//MACHINE_GUN_RIDE
void CX2GUUser::MACHINE_GUN_RIDE_StartFuture()
{

	m_pOrgMotionFuture		= m_pMotionFuture;

	m_pOrgXSkinAnimFuture	= m_pXSkinAnimFuture;


	m_pOrgXSkinAnimFuture->SetShowObject( false );


	m_pMotionFuture		= g_pKTDXApp->GetDeviceManager()->OpenXSkinMesh( L"Motion_BunkerCannon.x" );


	m_pXSkinAnimFuture	= CKTDGXSkinAnim::CreateSkinAnim();


	m_pXSkinAnimFuture->SetAnimXSkinMesh( m_pMotionFuture );
	m_pXSkinAnimFuture->AddModelXSkinMesh( m_pMotionFuture, NULL, NULL, NULL );
	m_pXSkinAnimFuture->SetModelDetailPercent( g_pData->GetModelDetailPercent() );

	CommonStateStartFuture();

}

void CX2GUUser::MACHINE_GUN_RIDE_Start()
{

	m_pOrgMotion			= m_pMotion;

	m_pOrgXSkinAnim			= m_pXSkinAnim;


	m_pOrgXSkinAnim->SetShowObject( false );


	m_pMotion			= g_pKTDXApp->GetDeviceManager()->OpenXSkinMesh( L"Motion_BunkerCannon.x" );

	m_pXSkinAnim		= CKTDGXSkinAnim::CreateSkinAnimPtr();

	m_pXSkinAnim->SetAnimXSkinMesh( m_pMotion );
	m_pXSkinAnim->AddModelXSkinMesh( m_pMotion, NULL, NULL, NULL );
	m_pXSkinAnim->SetModelDetailPercent( g_pData->GetModelDetailPercent() );


	m_CollisionListSet.clear();
	m_AttackListSet.clear();

	m_CollisionListSet.insert( &m_pXSkinAnim->GetCollisionDataList() );
	m_AttackListSet.insert( &m_pXSkinAnim->GetAttackDataList() );

	for( int i =0; i < (int)m_ViewEqipList.size(); i++ )
	{
		//CKTDGXSkinAnim* pAnim = NULL;
		CX2EqipPtr pEqip = m_ViewEqipList[i];
		if ( pEqip == NULL )
			continue;

		//{{ robobeg : 2008-10-18
		//pEqip->SetShow( false );
		pEqip->SetShowObject( false );
		//}} robobeg : 2008-10-18
	}

	m_pFrame_Bip01_Head			= m_pXSkinAnim->GetCloneFrame( L"Cannon_Head" );


	m_bRidingMachine = true;

	CommonStateStart();

}

void CX2GUUser::MACHINE_GUN_RIDE_FrameMoveFuture()
{
	CommonFrameMoveFuture();
}

void CX2GUUser::MACHINE_GUN_RIDE_FrameMove()
{
	CommonFrameMove();
}

void CX2GUUser::MACHINE_GUN_RIDE_CameraMove()
{
	CommonCameraMove();
}

void CX2GUUser::MACHINE_GUN_RIDE_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( m_MachineGunWaitState );
	}
	CommonEventProcess();
}

//MACHINE_GUN_LEAVE
void CX2GUUser::MACHINE_GUN_LEAVE_StartFuture()
{


	SAFE_CLOSE( m_pMotionFuture );

	CKTDGXSkinAnim::DeleteKTDGObject( m_pXSkinAnimFuture );
	m_pXSkinAnimFuture = NULL;


	m_pMotionFuture		= m_pOrgMotionFuture;
	m_pOrgMotionFuture = NULL;

	m_pXSkinAnimFuture	= m_pOrgXSkinAnimFuture;
	m_pOrgXSkinAnimFuture = NULL;

	m_pXSkinAnimFuture->SetShowObject( true );

	CommonStateStartFuture();
}

void CX2GUUser::MACHINE_GUN_LEAVE_Start()
{
	SAFE_CLOSE( m_pMotion );

	//CKTDGXSkinAnim::DeleteKTDGObject( m_pXSkinAnim );
	//m_pXSkinAnim = NULL;
	m_pXSkinAnim.reset();


	m_pMotion		= m_pOrgMotion;
	m_pOrgMotion = NULL;

	m_pXSkinAnim	= m_pOrgXSkinAnim;
	//m_pOrgXSkinAnim = NULL;


	m_pXSkinAnim->SetShowObject( true );


	//{{ kimhc // 2010.12.10 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
	UpdateEquipCollisionData( m_ViewEqipList );
#else	NEW_CHARACTER_CHUNG
	UpdateEquipCollisionData();
#endif	NEW_CHARACTER_CHUNG
	//}} kimhc // 2010.12.10 //  2010-12-23 New Character CHUNG

	for( int i =0; i < (int)m_ViewEqipList.size(); i++ )
	{
		//CKTDGXSkinAnim* pAnim = NULL;
		CX2EqipPtr pEqip = m_ViewEqipList[i];
		if ( pEqip == NULL )
			continue;
		//{{ robobeg : 2008-10-18
		//pEqip->SetShow( true );
		pEqip->SetShowObject( true );
		//}} robobeg : 2008-10-18
	}


	m_pFrame_Bip01_Head			= m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );

	m_bRidingMachine = false;

	CommonStateStart();
}

void CX2GUUser::MACHINE_GUN_LEAVE_FrameMoveFuture()
{
	CommonFrameMoveFuture();
}

void CX2GUUser::MACHINE_GUN_LEAVE_FrameMove()
{
	CommonFrameMove();
}

void CX2GUUser::MACHINE_GUN_LEAVE_CameraMove()
{
	CommonCameraMove();
}

void CX2GUUser::MACHINE_GUN_LEAVE_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( m_CommonState.m_Wait );
	}
	CommonEventProcess();
}

//MACHINE_GUN_WAIT
void CX2GUUser::MACHINE_GUN_WAIT_StartFuture()
{
	CommonStateStartFuture();
}

void CX2GUUser::MACHINE_GUN_WAIT_Start()
{
	CommonStateStart();
}

void CX2GUUser::MACHINE_GUN_WAIT_FrameMoveFuture()
{
	//GetGageManager()->GetAttackDelayGage()->fNow -= 10.0f * m_fElapsedTime;
	//if( GetGageManager()->GetAttackDelayGage()->fNow < 0.0f )
	//	GetGageManager()->GetAttackDelayGage()->fNow = 0.0f;

	//GetGageManager()->GetForceDownGage()->fNow -= 10.0f * m_fElapsedTime;
	//if( GetGageManager()->GetForceDownGage()->fNow < 0.0f )
	//	GetGageManager()->GetForceDownGage()->fNow = 0.0f;

	CommonFrameMoveFuture();
}

void CX2GUUser::MACHINE_GUN_WAIT_EventProcess()
{
	/*
	if( false == IsOnSomethingFuture() )
	{
	m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
	//StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_WALK );
	}
	else */if( m_InputData.pureUp == true )
	{
		//StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_JUMP_UP );
		//m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		//m_FrameDataFuture.syncData.position.y += LINE_RADIUS;

		m_PhysicParam.nowSpeed.y = GetDashSpeed();
	}
	else if( m_InputData.oneZ == true  )
	{
		StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_ATTACK );
	}
	else if( /*m_InputData.oneDown*/ m_InputData.pureDown == true
		&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
		LINE_RADIUS, 
		&m_FrameDataFuture.unitCondition.landPosition, 
		&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{

		//StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_JUMP_DOWN );
		if ( true == IsOnSomethingFuture() )
		{
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS;
		}


		m_PhysicParam.nowSpeed.y = -( GetDashSpeed() );
	}

	if( m_InputData.pureRight == true )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}
	else if( m_InputData.pureLeft == true )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}
	else
	{
		m_PhysicParam.nowSpeed.x = 0.0f;
	}

	if ( m_InputData.pureUp == false && m_InputData.pureDown == false )
	{
		m_PhysicParam.nowSpeed.y = 0;
	}

	CommonEventProcess();
}

//MACHINE_GUN_WALK
void CX2GUUser::MACHINE_GUN_WALK_FrameMoveFuture()
{
	if( m_InputData.pureRight == true )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
		m_PhysicParam.nowSpeed.x = GetJumpSpeed();
	}
	else if( m_InputData.pureLeft == true )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
		m_PhysicParam.nowSpeed.x = GetJumpSpeed();
	}
	else
	{
		m_PhysicParam.nowSpeed.x = 0.0f;
	}

	CommonFrameMoveFuture();
}

void CX2GUUser::MACHINE_GUN_WALK_EventProcess()
{

	if( false == IsOnSomethingFuture() )
	{
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.pureUp == true )
	{
		StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_JUMP_UP );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
	}
	else if( m_InputData.oneZ == true  )
	{
		StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_ATTACK );
	}
	else if( m_InputData.oneDown == true 
		&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
		LINE_RADIUS, 
		&m_FrameDataFuture.unitCondition.landPosition, 
		&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{
		StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}

	CommonEventProcess();
}

//MACHINE_GUN_ATTACK
void CX2GUUser::MACHINE_GUN_ATTACK_FrameMoveFuture()
{
	//m_PhysicParam.nowSpeed.x = 0.0f;
	//m_PhysicParam.nowSpeed.y = 0.0f;

	/*
	if( m_InputData.pureRight == true )
	{
	m_FrameDataFuture.syncData.bIsRight = true;
	m_PhysicParam.nowSpeed.x = GetJumpSpeed();
	}
	else if( m_InputData.pureLeft == true )
	{
	m_FrameDataFuture.syncData.bIsRight = false;
	m_PhysicParam.nowSpeed.x = GetJumpSpeed();
	}
	else
	{
	m_PhysicParam.nowSpeed.x = 0.0f;
	}
	*/


	CommonFrameMoveFuture();
}

void CX2GUUser::MACHINE_GUN_ATTACK_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimerOneshot( 0.433f ) == true ||
		m_pXSkinAnim->EventTimerOneshot( 0.933f ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.433f ) == true && EventCheck( 0.433f, false ) == true ||
		m_pXSkinAnim->EventTimer( 0.933f ) == true && EventCheck( 0.933f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		g_pX2Game->GetDamageEffect()->CreateInstance_LUA( this, "MACHINE_GUN_STRAIGHT", GetBonePos( L"Dummy2_Cannon" ), GetLandPosition().y );


	}




#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.666f ) == true  )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.666f ) == true && EventCheck( 0.666f, false ) == true  )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		g_pX2Game->GetDamageEffect()->CreateInstance_LUA( this, "MACHINE_GUN_STRAIGHT", GetBonePos( L"Dummy1_Cannon" ), GetLandPosition().y );

		//g_pX2Game->GetDamageEffect()->CreateInstance_LUA( this, "MORTAR_BOMB", GetBonePos( L"Cannon_Head" ), GetLandPosition().y );


		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance_LUA2( this, "WALLY_8TH_GUIDED_MISSILE", GetBonePos( L"Cannon_Head" ), GetLandPosition().y, GetRotateDegree() );

		SetLockOn( pEffect, 0 );

		D3DXVECTOR3 rotateValue = GetRotateDegree();
		rotateValue.y += 180.0f;

		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance_LUA2( this, "WALLY_8TH_GUIDED_MISSILE", GetBonePos( L"Cannon_Head" ), GetLandPosition().y, rotateValue );
		SetLockOn( pEffect, 1 );
		//g_pX2Game->GetDamageEffect()->CreateInstance_LUA2( this, "MORTAR_BOMB", GetBonePos( L"Cannon_Head" ), GetLandPosition().y, rotateValue );
	}

	CommonFrameMove();
}

void CX2GUUser::MACHINE_GUN_ATTACK_EventProcess()
{


	/*

	if( m_InputData.pureLeft == true && m_FrameDataFuture.syncData.bIsRight == true )
	{
	m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}
	if( m_InputData.pureRight == true && m_FrameDataFuture.syncData.bIsRight == false )
	{
	m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}
	else
	{
	m_PhysicParam.nowSpeed.x = 0.0f;
	}

	if ( m_InputData.pureUp == false && m_InputData.pureDown == false )
	{
	m_PhysicParam.nowSpeed.y = 0;
	}

	*/

	/*
	if( false == IsOnSomethingFuture() )
	{
	m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
	//StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_WALK );
	}
	else */if( m_InputData.pureUp == true )
	{
		//StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_JUMP_UP );
		//m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		//m_FrameDataFuture.syncData.position.y += LINE_RADIUS;

		m_PhysicParam.nowSpeed.y = GetDashSpeed();
	}
	else if( m_InputData.oneZ == true  )
	{
		StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_ATTACK );
	}
	else if( /*m_InputData.oneDown*/ m_InputData.pureDown == true
		&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
		LINE_RADIUS, 
		&m_FrameDataFuture.unitCondition.landPosition, 
		&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{

		//StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_JUMP_DOWN );
		if ( true == IsOnSomethingFuture() )
		{
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS;
		}


		m_PhysicParam.nowSpeed.y = -( GetDashSpeed() );
	}

	if( m_InputData.pureRight == true )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}
	else if( m_InputData.pureLeft == true )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}
	else
	{
		m_PhysicParam.nowSpeed.x = 0.0f;
	}

	if ( m_InputData.pureUp == false && m_InputData.pureDown == false )
	{
		m_PhysicParam.nowSpeed.y = 0;
	}


	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		m_fCanNotAttackTime = 0.2f;
		StateChange( m_MachineGunWaitState );
	}

	CommonEventProcess();
}

void CX2GUUser::MACHINE_GUN_JUMP_UP_FrameMoveFuture()
{
	if( m_InputData.pureRight == true )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
		m_PhysicParam.nowSpeed.x = GetWalkSpeed();
	}
	else if( m_InputData.pureLeft == true )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
		m_PhysicParam.nowSpeed.x = GetWalkSpeed();
	}

	if( m_InputData.pureDown == true && m_InputData.pureUp == false )
	{
		m_PhysicParam.nowSpeed.y -= m_PhysicParam.fGAccel * m_fElapsedTime;
	}

	CommonFrameMoveFuture();
}

void CX2GUUser::MACHINE_GUN_JUMP_UP_EventProcess()
{
	if( m_PhysicParam.nowSpeed.y <= 0.0f )
	{
		StateChange( CX2GUElsword_SwordMan::ESSI_MACHINE_GUN_JUMP_DOWN );
	}

	CommonEventProcess();
}


void CX2GUUser::MACHINE_GUN_JUMP_DOWN_FrameMoveFuture()
{
	if( m_InputData.pureRight == true )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
		m_PhysicParam.nowSpeed.x = GetWalkSpeed();
	}
	else if( m_InputData.pureLeft == true )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
		m_PhysicParam.nowSpeed.x = GetWalkSpeed();
	}

	if( m_InputData.pureDown == true  && m_InputData.pureUp == false )
	{
		m_PhysicParam.nowSpeed.y -= m_PhysicParam.fGAccel * m_fElapsedTime;
	}
	CommonFrameMoveFuture();
}

void CX2GUUser::MACHINE_GUN_JUMP_DOWN_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		StateChange( m_MachineGunWaitState );
	}



	CommonEventProcess();
}

//SUMMON_MAGIC_SPEAR
void CX2GUUser::SUMMON_MAGIC_SPEAR_FrameMove()
{
	g_pX2Game->GetWorld()->SetWorldColor( 0xff222222 );

	/*
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
	{
	ActiveSkillShow( L"Dummy2_Lhand", L"HQ_CutIn_Elsword_2.dds", D3DXVECTOR2(670.0f,670.0f), D3DXVECTOR3(275.0f,471.0f,0.0f), false );
	}
	else*/ 
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.55f ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimer( 0.55f ) == true && EventCheck( 0.55f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LizardMan_Older_PowerBooster01", GetPos() );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.65f ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.65f ) == true && EventCheck( 0.65f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 landPos = GetLandPosition();
		landPos.x = landPos.x + GetDirVector().x * 250.0f;
#ifdef SPECIAL_USE_ITEM // 지헌-던전 사용 아이템 : 여기서 데미지 이펙트를 만드네. 이펙트 셋으로 고쳐야 할 듯?
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"ENT_SPIKE_BOARD", GetPowerRate(), landPos, GetRotateDegree(), GetRotateDegree() );
#else SPECIAL_USE_ITEM
		g_pX2Game->GetDamageEffect()->CreateInstance_LUA( this, "ENT_SPIKE_BOARD", landPos, landPos.y );
#endif SPECIAL_USE_ITEM
	}

	CommonFrameMove();
}

void CX2GUUser::SUMMON_MAGIC_SPEAR_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( m_CommonState.m_Wait );
	}
	CommonEventProcess();
}

/** @function : COMMON_BUFF_EventProcess
	@brief : 공통적으로 쓰는 버프 스킬의 EventProcess
*/
void CX2GUUser::COMMON_BUFF_EventProcess()
{
	if( true == m_pXSkinAnimFuture->IsAnimationEnd() )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}	

	CommonEventProcess();
}

/** @function : StartEventProcess
	@brief : Start 스테이트에서 일정 시간이 지나면 Wait 상태로 변경
*/
void CX2GUUser::StartEventProcess()
{
	CommonEventProcess();

	const float EVENT_TIME = 4.5f;

	if( EVENT_TIME <= m_FrameDataFuture.unitCondition.fStateTime )
	{
		StateChange( USI_WAIT );
	}
}

/** @function : StartEnd
	@brief : 자기 유닛인 경우에만 시작했다는 파티클을 보여주고, 펫은 초기화 함
*/
void CX2GUUser::StartEnd()
{
	CommonStateEnd();

	if( IsMyUnit() == true )
	{
#ifdef SERV_PLAY_WITH_CHAR_PARTY_BONUS_EXP		/// 던전 시작할 때, "아라와 함깨 파티하면 경험치 올라가는 버프" 를 갖고 있다면 공존의 축제와 같은 UI 표기 해주자
		if( NULL != g_pData && NULL != g_pData->GetUIMajorParticle() &&
			NULL != g_pMain && CX2Main::XS_PVP_GAME != g_pMain->GetNowStateID() &&
			true == HaveThisBuff( BTI_EMPTY_EXP_BUFF ) )
		{

#ifdef SERV_PLAY_WITH_CHAR_PARTY_BONUS_EXP_RENA		
			//2014.01.24 이브 추가 시스템 이벤트
			CKTDGParticleSystem::CParticleEventSequenceHandle m_Seq = g_pData->GetUIMajorParticle()->CreateSequenceHandle( NULL, L"UI_Eve_Party_Event_StartEffect", 
				512, 284-60, 0, 9999, 9999, -1, 1, -1.0f, true, 1.2f, false );

			/// 던전 시작할 때, "레나와 함깨 파티하면 경험치 올라가는 버프" 를 갖고 있다면 공존의 축제와 같은 UI를 표기
			/*CKTDGParticleSystem::CParticleEventSequenceHandle m_Seq = g_pData->GetUIMajorParticle()->CreateSequenceHandle( NULL, L"UI_Rena_Party_Event_StartEffect", 
				512, 284-60, 0, 9999, 9999, -1, 1, -1.0f, true, 1.2f, false );
			PlaySound( L"Event_ReturnOfEldrasil.ogg" , false );*/
#else // SERV_PLAY_WITH_CHAR_PARTY_BONUS_EXP_RENA	/// 던전 시작할 때, "레나와 함깨 파티하면 경험치 올라가는 버프" 를 갖고 있다면 공존의 축제와 같은 UI를 표기
			CKTDGParticleSystem::CParticleEventSequenceHandle m_Seq = g_pData->GetUIMajorParticle()->CreateSequenceHandle( NULL, L"UI_Ara_Party_Event_StartEffect", 
																			   512, 284+60, 0, 9999, 9999, -1, 1, -1.0f, true, 1.2f, false );
#endif // SERV_PLAY_WITH_CHAR_PARTY_BONUS_EXP_RENA	/// 던전 시작할 때, "레나와 함깨 파티하면 경험치 올라가는 버프" 를 갖고 있다면 공존의 축제와 같은 UI를 표기
			if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_Seq )
			{
				CKTDGParticleSystem::CParticleEventSequence* pParticle = g_pData->GetUIMajorParticle()->GetInstanceSequence( m_Seq );
				if( pParticle != NULL )
				{
					pParticle->SetOverUI( true );
				}
			}
		}
#endif SERV_PLAY_WITH_CHAR_PARTY_BONUS_EXP


		PlaySound( L"Fight.ogg" ,false);

		if( g_pX2Game->GetGameType() == CX2Game::GT_PVP )
			g_pX2Game->GetMajorParticle()->CreateSequence( NULL,  L"GameFight", 0,0,0, 1000, 1000, 1, 1 );
		else if( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON )
#ifdef SERV_INSERT_GLOBAL_SERVER
		{
			if( NULL != g_pX2Game && CX2Game::GT_DUNGEON == g_pX2Game->GetGameType() )
			{
				CX2DungeonGame* pDungeonGame = static_cast<CX2DungeonGame*>(g_pX2Game);

				if( pDungeonGame != NULL && 
					pDungeonGame->GetDungeon() != NULL && 
					pDungeonGame->GetDungeon()->GetDungeonData() != NULL )
				{
					int iNowDungeonID = pDungeonGame->GetDungeon()->GetDungeonData()->m_DungeonID;

#ifdef SERV_NEW_DEFENCE_DUNGEON // 적용날짜: 2013-04-15
					/// 어둠의 문이 아닐 때만 Start 재생
					if( false == g_pData->GetDungeonManager()->IsDefenceDungeon(iNowDungeonID))
						g_pX2Game->GetMajorParticle()->CreateSequence( NULL,  L"GameStart", 0,0,0, 1000, 1000, 1, 1 );
#else // SERV_NEW_DEFENCE_DUNGEON
					if( true == g_pData->GetDungeonManager()->IsDefenceDungeon(iNowDungeonID))
						g_pX2Game->GetMajorParticle()->CreateSequence( NULL,  L"UI_Defence_Start_Effect", 512, 324, 0, 1, 1, 1, 1 );
					else
						g_pX2Game->GetMajorParticle()->CreateSequence( NULL,  L"GameStart", 0,0,0, 1000, 1000, 1, 1 );
#endif // SERV_NEW_DEFENCE_DUNGEON

					g_pKTDXApp->GetDGManager()->ClearScreen( 10 );
				}
			}
		}
#else
			g_pX2Game->GetMajorParticle()->CreateSequence( NULL,  L"GameStart", 0,0,0, 1000, 1000, 1, 1 );
#endif SERV_INSERT_GLOBAL_SERVER
		
	}	

#ifdef SERV_EVENT_VALENTINE_DUNGEON
	// Start 이펙트가 뜨는 시점에, 서버로 시작 알림을 보내주기 위해 여기서 패킷 전송.
	if( true == IsMyUnit() &&
		CX2Main::XS_DUNGEON_GAME == g_pMain->GetNowStateID() )
	{		
		CX2StateDungeonGame* pStateDungeonGame = static_cast<CX2StateDungeonGame*>( g_pMain->GetNowState() );
		if( NULL != pStateDungeonGame )
		{
			pStateDungeonGame->Send_EGS_SYNC_DUNGEON_TIMER_NOT();
		}
	}
#endif //SERV_EVENT_VALENTINE_DUNGEON

#ifdef SERV_PET_SYSTEM
	CommonStartStateEnd();
#endif

	//{{ 임규수 임규수 던전 스타트 표시 나오기 전 , 던전 보스 죽인 후에 퀵슬롯 사용 못하도록 수정
#ifdef FIX_QUICK_SLOT_USE_DUNGEON_PLAY
	m_bStarted = true;
#endif 
	//}}
}

/** @function : StartIntrudeStart
	@brief : 난입한 경우, 난입시작 스테이트에서 처리해줘야 할것들 처리
*/
void CX2GUUser::StartIntrudeStart()
{
	CommonStateStart();

	CKTDGXMeshPlayer* pMinorMeshPlayer = g_pX2Game->GetMinorXMeshPlayer();

	pMinorMeshPlayer->CreateInstance( (CKTDGObject*) this,  L"RespawnLanding01", GetPos(), GetRotateDegree(), GetRotateDegree() );
	pMinorMeshPlayer->CreateInstance( (CKTDGObject*) this,  L"RespawnLanding02", GetPos(), GetRotateDegree(), GetRotateDegree() );

	CKTDGParticleSystem* pMinorParticleSystem = g_pX2Game->GetMinorParticle();

	pMinorParticleSystem->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P01", GetPos() );
	pMinorParticleSystem->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P02", GetPos() );

	D3DXVECTOR3 vDirVector = GetDirVector();
	pMinorParticleSystem->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P03", GetPos() + vDirVector * 10.f );

#ifndef	X2OPTIMIZE_GAME_PET_BACKGROUND_LOAD
#ifdef SERV_PET_SYSTEM
	if( NULL != g_pData && NULL != g_pData->GetPetManager() )
	{
		for ( UINT i = 0; i < g_pData->GetPetManager()->GetPetNum(); ++i )
		{
			CX2PET *pPet = g_pData->GetPetManager()->GetPetInx( i );
			
			if( NULL != pPet )
			{
				pPet->InitGamePet();
			}
		}
	}
#endif
#endif	X2OPTIMIZE_GAME_PET_BACKGROUND_LOAD
}


/** @function : StartIntrudeFrameMove
	@brief : 난입시 파티클 출력
*/
void CX2GUUser::StartIntrudeFrameMove()
{
	if( true == m_pXSkinAnim->EventTimer( 0.1f ) )
	{
		D3DXVECTOR3 vDirVector = GetDirVector();
		D3DXVECTOR3 vUpVector(0, 1, 0);

		g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", GetPos() + vDirVector * 10.f + vUpVector * 50.f );
	}


	if( true == m_pXSkinAnim->EventTimer( 0.26f ) )
	{
		D3DXVECTOR3 vDirVector = GetDirVector();
		D3DXVECTOR3 vUpVector(0, 1, 0);

		g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", GetPos() + vDirVector * 10.f + vUpVector * 100.f );
	}


	if( true == m_pXSkinAnim->EventTimer( 0.39f ) )
	{
		D3DXVECTOR3 vDirVector = GetDirVector();
		D3DXVECTOR3 vUpVector(0, 1, 0);

		g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", GetPos() + vDirVector * 10.f + vUpVector * 150.f );
	}


	if( true == m_pXSkinAnim->EventTimer( 0.52f ) )
	{
		D3DXVECTOR3 vDirVector = GetDirVector();
		D3DXVECTOR3 vUpVector(0, 1, 0);

		g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", GetPos() + vDirVector * 10.f + vUpVector * 200.f );
	}

	CommonFrameMove();
}

/** @function : StartIntrudeEventProcess
	@brief : 난입 애니메이션이 종료되면 Wait으로 상태 변경
*/
void CX2GUUser::StartIntrudeEventProcess()
{
	CommonEventProcess();

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
}

/** @function : DieFrameMove
	@brief : front, back에 관계없이 죽는 스테이트의 FrameMove에서 공통적으로 실행되어야 하는 함수
	@param : float fTimeCreateStepDust_(바닥에 연기를 발생시키는 애니메이션 타임), float TimeSacrificeOfHero_(영웅의 희생이 실행되는 애니메이션 타임)
*/
void CX2GUUser::DieFrameMove( float fTimeCreateStepDust_, float fTimeSacrificeOfHero_ )
{
	if( m_pXSkinAnim->IsAnimationEnd() == true )
	{
		// 죽었으니깐, 각성 상태인 경우 각성을 풀어줌
		SetRemainHyperModeTime( 0.0f );
		SetAlphaObject( true );
		m_RenderParam.bAlphaBlend	= true;

		if( m_RenderParam.color.a > 0.0f )
		{
			m_RenderParam.color.a	-= 1.5f * m_fElapsedTime;
		}
		else
		{
			//{{ robobeg : 2008-10-21
			if ( GetShowObject() == true )
				//}} robobeg : 2008-10-21
			{
				//{{ robobeg : 2008-10-21
				SetShowObject( false );
				//}} robobeg : 2008-10-21
				SetAlphaObject( false );
				m_RenderParam.bAlphaBlend	= false;

				//{{ kimhc // 2009-12-29 // Die의 알파 블렌드가 끝났을때 영웅의 희생 RT_CARTOON_FADE_NONTEX를 꺼줌
#ifdef	GUILD_SKILL_PART_2
				m_bHaveSacrificeOfHero = false;
				m_RenderParam.renderType = CKTDGXRenderer::RT_CARTOON_BLACK_EDGE;
#endif	GUILD_SKILL_PART_2
				//}} kimhc // 2009-12-29 // Die의 알파 블렌드가 끝났을때 영웅의 희생 RT_CARTOON_FADE_NONTEX를 꺼줌
			}
		}
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( fTimeCreateStepDust_ ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( fTimeCreateStepDust_ ) == true && EventCheck( fTimeCreateStepDust_, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CreateStepDust();
	}

	//{{ kimhc // 2009-12-28 // 길드 스킬, 영웅의 희생, 죽으면 주변의 동료를 HP를 일정량 채워줌
#ifdef	GUILD_SKILL_PART_2
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( fTimeSacrificeOfHero_ ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( fTimeSacrificeOfHero_ ) == true && EventCheck( fTimeSacrificeOfHero_, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		ProcessSacrificeOfHero();
	}
#endif	GUILD_SKILL_PART_2
	//}} kimhc // 2009-12-28 // 길드 스킬, 영웅의 희생, 죽으면 주변의 동료를 HP를 일정량 채워줌

	//{{ mauntain : 김태환 [2012.06.14] 몬스터 카드 소환 기능 - 해당 User 이탈 시 몬스터 처리
#ifdef SUMMON_MONSTER_CARD_SYSTEM
	int SummonMonsterUID = GetSummonMonsterCardData().GetSummonMonsterUID();

	if( -1 != SummonMonsterUID )
	{
		CX2GUNPC* pNPCUnit = g_pX2Game->GetNPCUnitByUID( SummonMonsterUID );

#ifdef CHRISTMAS_EVENT_2013
		if( pNPCUnit->GetNPCTemplet().m_nNPCUnitID == CX2UnitManager::NUI_SOCCER_PPORU )
			pNPCUnit = NULL;
#endif CHRISTMAS_EVENT_2013

		if( NULL != pNPCUnit )
		{
			pNPCUnit->SetNowHp( 0.f );

#ifdef NO_COPY_CARD_MONSTER_DATA_SHASHA // 카드 몬스터로 제작된 하멜 비던 샤샤에 대한 예외 처리, 13-09-06 kimjh, 나중에 NPC Type 을 추가하거나 인자를 추가하여 변경할 것!	

			if ( false == pNPCUnit->IsUnitID( CX2UnitManager::NUI_SHASHA_STAGE0 ) &&
				 false == pNPCUnit->IsUnitID( CX2UnitManager::NUI_SHASHA_STAGE1 ) &&
				 false == pNPCUnit->IsUnitID( CX2UnitManager::NUI_SHASHA_STAGE2 ) )
#endif // NO_COPY_CARD_MONSTER_DATA_SHASHA // 카드 몬스터로 제작된 하멜 비던 샤샤에 대한 예외 처리, 13-09-06 kimjh, 나중에 NPC Type 을 추가하거나 인자를 추가하여 변경할 것!		
				AccessSummonMonsterCardData().init();
		}
	}
#endif SUMMON_MONSTER_CARD_SYSTEM
	//}}

#ifdef RIDING_SYSTEM
	if ( true == GetRidingOn() && NULL != CX2RidingPetManager::GetInstance() &&
		 NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimPtr() && true == m_ptrRidingPet->GetXSkinAnimPtr()->IsAnimationEnd() )
	{
		CX2RidingPetManager::GetInstance()->Handler_EGS_UNSUMMON_RIDING_PET_REQ();
	}
#endif //RIDING_SYSTEM

#ifdef SERV_GATE_OF_DARKNESS_SUPPORT_EVENT
	if( -1 != m_iAllyEventMonsterUID )
	{
		CX2GUNPC* pNPCUnit = g_pX2Game->GetNPCUnitByUID( m_iAllyEventMonsterUID );

		if( NULL != pNPCUnit )
			pNPCUnit->SetNowHp( 0.f );

		m_iAllyEventMonsterUID = -1;

		g_pX2Game->SetEventMonsterOut( GetUnitUID() );
	}
#endif SERV_GATE_OF_DARKNESS_SUPPORT_EVENT

	CommonFrameMove();	// 각 캐릭터가 override 한 CommonFrameMove 수행
}

/** @function : PlayAnimationWaitStart
	@brief : WaitStart 상태에서 조건에 따라 애니메이션을 실행 시킴
*/
void CX2GUUser::PlayAnimationWaitStart( CKTDGXSkinAnim* pXSkinAnim_, const FrameData& refFrameData_ )
{
	if( true == PlaySitReadyWaitStart(pXSkinAnim_) )
		return;

	CKTDGXSkinAnim::XSKIN_ANIM_PLAYTYPE playType;
	LUA_GET_VALUE_ENUM ( m_LuaManager, "PLAY_TYPE", playType, CKTDGXSkinAnim::XSKIN_ANIM_PLAYTYPE, CKTDGXSkinAnim::XAP_ONE_WAIT );

	// FATAL_HP_PERCENT 보다 HP가 적으면 fatal 애니메이션이 실행
	const float FATAL_HP_PERCENT = 0.25f;
	if( GetMaxHp() * FATAL_HP_PERCENT >= refFrameData_.syncData.fNowHP )
	{
		bool bTransition = true;
		LUA_GET_VALUE( m_LuaManager, "TRANSITION", bTransition, true );

		if( false == refFrameData_.unitCondition.bTransitionChange || false == bTransition )
			pXSkinAnim_->ChangeAnim( L"Fatal", false );
		else
			pXSkinAnim_->ChangeAnim( L"Fatal", true );		
	}
	else
	{
		bool bTransition = true;
		LUA_GET_VALUE( m_LuaManager, "TRANSITION", bTransition, true );
		if( false == refFrameData_.unitCondition.bTransitionChange || false == bTransition )
			pXSkinAnim_->ChangeAnim( L"Wait", false );
		else
			pXSkinAnim_->ChangeAnim( L"Wait", true );
	}

	pXSkinAnim_->Play( playType );
}
bool CX2GUUser::PlaySitReadyWaitStart( CKTDGXSkinAnim* pXSkinAnim_ )
{
	if( false == m_bReserveSitReadyEmotion )
		return false;

	wstring wstrName = L"Emotion_SitReady";

#ifdef RIDING_SYSTEM
	if ( true == GetRidingOn() && NULL != GetRidingPet() && false == m_wstrRidingMotionName.empty() )
	{
		wstrName = m_wstrRidingMotionName;
		GetRidingPet()->StateChange( GetRidingPet()->m_SitReadyState );
	}
#endif //RIDING_SYSTEM

	pXSkinAnim_->ChangeAnim( wstrName.c_str(), true );
	pXSkinAnim_->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );

	m_ePlayedEmotion = CX2Unit::ET_SITREADY;

	m_bReserveSitReadyEmotion = false;
	return true;
}

/** @function : WalkFrameMoveFuture
	@brief : Walk 상태의 FrameMoveFuture 로 키입력에 따라 걷는 속도로 이동
*/
void CX2GUUser::WalkFrameMoveFuture()
{
	if( true == m_InputData.pureRight )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
		m_PhysicParam.nowSpeed.x = GetWalkSpeed();
	}
	else if( true == m_InputData.pureLeft )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
		m_PhysicParam.nowSpeed.x = GetWalkSpeed();
	}
	else
	{
		m_PhysicParam.nowSpeed.x = 0.0f;
	}

	CommonFrameMoveFuture();	// override 된 함수 실행
}

/** @function : JumpFrameMoveFuture
	@brief : JumpUp, JumpDown 상태에서 이동과 관련하여 공통으로 처리되는 부분
*/
void CX2GUUser::JumpFrameMoveFuture()
{
	if( m_InputData.pureRight == true )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
		m_PhysicParam.nowSpeed.x = GetWalkSpeed();
	}
	else if( m_InputData.pureLeft == true )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
		m_PhysicParam.nowSpeed.x = GetWalkSpeed();
	}

	if( m_InputData.pureDown == true  && m_InputData.pureUp == false )
	{
		m_PhysicParam.nowSpeed.y -= m_PhysicParam.fGAccel * m_fElapsedTime;
	}

	CommonFrameMoveFuture();
}

/** @function : JumpLandingStart
	@brief : 착지 상태의 Start 함수 (먼지 파티클 출력)
*/
void CX2GUUser::JumpLandingStart()
{
	CommonStateStart();
	CreateStepDust();
}

void CX2GUUser::DashJumpLandingStartFuture()
{
#ifdef RIDING_SYSTEM
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_JumpLandingState );
#endif //RIDING_SYSTEM

	CommonStateStartFuture();

	m_PhysicParam.nowSpeed.x *= 0.5f;
}

/** @function : DashStartFuture
	@brief : 대시 전에 필요한 값 초기화
*/
void CX2GUUser::DashStartFuture()
{
#ifdef RIDING_SYSTEM
	if ( true == GetRidingOn() && NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_DashState );
#endif //RIDING_SYSTEM

	CommonStateStartFuture();
	m_PhysicParam.nowSpeed.x = 0.0f;
}

/** @function : DashStart
	@brief : 먼지 파티클 출력
*/
void CX2GUUser::DashStart()
{
	CommonStateStart();
	CreateStepDust();
}

/** @function : DashFrameMoveFuture
	@brief : 대시 상태의 스피드 값 적용
*/
void CX2GUUser::DashFrameMoveFuture()
{
	// 왼쪽 또는 오른쪽 방향키를 두번 누른후 떼지 않은 상때면
	if( ( true == m_InputData.pureRight && true == m_BeforeInputData.pureRight ) ||
		( true == m_InputData.pureLeft  && true == m_BeforeInputData.pureLeft  ) )
	{
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}
	
	CommonFrameMoveFuture();
}

/** @function : DamageStandUpEventProcess
	@brief : 넘어진 후 일어 났을 때의 EventProcess
*/
void CX2GUUser::DamageStandUpEventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		
		const float MAGIC_NUMBER_MULTIPLY_LINE_RADIUS = 1.5f;
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * MAGIC_NUMBER_MULTIPLY_LINE_RADIUS;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

/** @function : DamageStandUpEventProcess
	@brief : 넘어진 후 일어 났을 때의 End
*/
void CX2GUUser::DamageStandUpEnd()
{
	CommonStateEnd();

	const float INVINCIBLE_TIME = 0.3f;

	SetForceInvincible( INVINCIBLE_TIME );
	SetShowInvincible( INVINCIBLE_TIME );
}

/** @function : DamageAirSmallStartFuture
	@brief : 공중에 다운이 아닌 타격을 받았을 때의 StartFuture
*/
void CX2GUUser::DamageAirSmallStartFuture()
{
	CommonStateStartFuture();

	const float ADD_Y_SPEED = 700.f;
	m_PhysicParam.nowSpeed.y		+= ADD_Y_SPEED;

	const float DECREASE_WALK_SPEED_FACTOR = 0.33f;

	if( true == m_FrameDataNow.unitCondition.bAttackerFront )
		m_PhysicParam.nowSpeed.x	-= GetWalkSpeed() * DECREASE_WALK_SPEED_FACTOR;
	else
		m_PhysicParam.nowSpeed.x	+= GetWalkSpeed() * DECREASE_WALK_SPEED_FACTOR;
}

/** @function : DamageAirSmallEventProcess
	@brief : 공중에 다운이 아닌 타격을 받았을 때의 EventProcess
*/
void CX2GUUser::DamageAirSmallEventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_LANDING );
	}

	CommonEventProcess();
}

/** @function : DamageAirDownEventProcess
	@brief : 공중에 다운 타격을 받았을 때의 EventProcess
*/
void CX2GUUser::DamageAirDownEventProcess()
{
//#ifdef LINEMAP_FAST_WIND_TEST
//	IF_TIME_ELAPSED_IN_THE_AIR_THEN_STATE_CHANGE( 1.f, USI_JUMP_DOWN )
//#endif LINEMAP_FAST_WIND_TEST

	if( true == IsOnSomethingFuture() )
	{
		StateChange( USI_DAMAGE_AIR_DOWN_LANDING );
	}

	CommonEventProcess();
}

/** @function : DamageAirDownInvincibleEventProcess
	@brief : 공중에 다운 타격을 받았을 때 무적 상태의 EventProcess
*/
void CX2GUUser::DamageAirDownInvincibleEventProcess()
{
//#ifdef LINEMAP_FAST_WIND_TEST
//	IF_TIME_ELAPSED_IN_THE_AIR_THEN_STATE_CHANGE( 1.f, USI_JUMP_DOWN )
//#endif LINEMAP_FAST_WIND_TEST

	if( true == IsOnSomethingFuture() )
	{
		StateChange( USI_DAMAGE_AIR_DOWN_LANDING );
	}

	CommonEventProcess();
}

/** @function : DamageAirDownLandingStart
	@brief : 공중에서 타격을 받아 다운 된 후의 Landing 상태의 Start
*/
void CX2GUUser::DamageAirDownLandingStart()
{
#ifdef TEST_GROUP_GRAP
	if ( GetGrap() == true )
		SetGrap( false );
#endif TEST_GROUP_GRAP

#ifdef NEW_GRAPPLE_ATTACK
	
#endif NEW_GRAPPLE_ATTACK

	CommonStateStart();

	UpDownCrashCameraNoReset( 20.0f, 0.3f );

	g_pX2Game->GetMinorXMeshPlayer()->CreateInstance( this,  L"DropDown", 
		m_FrameDataNow.syncData.position, m_FrameDataNow.unitCondition.dirDegree,
		m_FrameDataNow.unitCondition.dirDegree,	XL_EFFECT_0 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqGroundShockWave = g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_GROUND_SHOCK_WAVE ) );
	PlaySequenceByTriggerCount( pSeqGroundShockWave, m_FrameDataNow.unitCondition.landPosition.x, m_FrameDataNow.unitCondition.landPosition.y + 5.0f, m_FrameDataNow.unitCondition.landPosition.z,  5, 10,  1 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqAirDownTick = g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_AIR_DOWN_TICK ) );

	if( NULL != pSeqAirDownTick )
	{
		PlaySequenceByTriggerCount( pSeqAirDownTick, m_FrameDataNow.syncData.position,  200.f, 200.f, 10 );
		pSeqAirDownTick->SetLandPosition( m_FrameDataNow.unitCondition.landPosition.y );
	}
}

/** @function : DamageAirDownLandingFrameMove
	@brief : 공중에서 타격을 받아 다운 된 후의 Landing 상태의 FrameMove
*/
void CX2GUUser::DamageAirDownLandingFrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( true == m_pXSkinAnim->EventTimerOneshot( 0.029f ) || true == m_pXSkinAnim->EventTimerOneshot( 0.46f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( ( true == m_pXSkinAnim->EventTimer( 0.029f ) && true == EventCheck( 0.029f, false ) )
		|| ( true == m_pXSkinAnim->EventTimer( 0.46f ) && true == EventCheck( 0.46f, false ) ) )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
#ifdef  X2OPTIMIZE_HANDLE_VALIDITY_CHECK
        CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_DOWN_SMOKE ) );
#else   X2OPTIMIZE_HANDLE_VALIDITY_CHECK
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_DOWN_SMOKE ) );
#endif  X2OPTIMIZE_HANDLE_VALIDITY_CHECK
		PlaySequenceByTriggerCount( pSeq, m_FrameDataNow.unitCondition.landPosition, 100, 100, 7 );
	}

	CommonFrameMove();
}

/** @function : DamageAirFallEventProcess
	@brief : UP Type의 공격에 의해 수직으로 올라갔다가 떨어지는 스테이트
*/
void CX2GUUser::DamageAirFallEventProcess()
{
//#ifdef LINEMAP_FAST_WIND_TEST
//	m_bEnableUpsideWind = false;
//#endif LINEMAP_FAST_WIND_TEST

	if( 0.f < m_PhysicParam.nowSpeed.y )
	{
		StateChange( USI_DAMAGE_AIR_UP );
	}
	else if( true == IsOnSomethingFuture() )
	{
		StateChange( USI_DAMAGE_AIR_DOWN_LANDING );
	}

	CommonEventProcess();
}

/** @function : DamageAirUpEventProcess 
	@brief : UP Type의 공격을 받은 상태의 EventProcess
*/
void CX2GUUser::DamageAirUpEventProcess()
{
//#ifdef LINEMAP_FAST_WIND_TEST
//	IF_TIME_ELAPSED_IN_THE_AIR_THEN_STATE_CHANGE( 1.f, USI_JUMP_DOWN )
//#endif LINEMAP_FAST_WIND_TEST

	if( 0.f > m_PhysicParam.nowSpeed.y )
	{
		StateChange( USI_DAMAGE_AIR_FALL );
	}
	else if( true == IsOnSomethingFuture() )
	{
		StateChange( USI_DAMAGE_AIR_DOWN_LANDING );
	}

	CommonEventProcess();
}

/** @function : DamageAirFlyEventProcess
	@brief : Fly Type의 공격을 받은 상태의 EventProcess
*/
void CX2GUUser::DamageAirFlyEventProcess()
{
//#ifdef LINEMAP_FAST_WIND_TEST
//	IF_TIME_ELAPSED_IN_THE_AIR_THEN_STATE_CHANGE( 1.f, USI_JUMP_DOWN )
//#endif LINEMAP_FAST_WIND_TEST

	if( true == IsOnSomethingFuture() )
	{
		//{{ kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함
		if ( false == GetHold() )
		//}} kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함

#ifdef TEST_GROUP_GRAP
		if ( false == GetGrap() )
#endif TEST_GROUP_GRAP

		{
#ifdef RIDING_SYSTEM
			/// 탈것에 탑승중이라면, 탑승물의 스테이트로 변경한다.
			if ( true == GetRidingOn() )
				StateChange( USI_RIDING_DAMAGE_FRONT );
			else
#endif // RIDING_SYSTEM
				StateChange( USI_DAMAGE_DOWN_FRONT );
		}
	}
	
	CommonEventProcess();
}

/** @function : DamageRevengeStart
	@brief : 엘소드의 반격 스킬에 당했을 때의 스테이트
*/
void CX2GUUser::DamageRevengeStart()
{
	CommonStateStart();
	
	CKTDGParticleSystem::CParticleEventSequence* pSeqExclamation = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hExclamationMark );
	if( NULL != pSeqExclamation )
	{
		pSeqExclamation->CreateNewParticle( pSeqExclamation->GetPosition() );
	}
}

/** @function : DamageRevengeCameraMove
	@brief : 반격 스킬에 당했을 때의 카메라 이동
*/
void CX2GUUser::DamageRevengeCameraMove()
{
	CommonCameraMove();

	if( false == m_FrameDataNow.stateParam.bEventFlagList[0] )
	{  
		switch( m_FrameDataNow.stateParam.normalCamera )
		{
		case 0:
			break;
		case 1:
			{
				if( true == m_LuaManager.BeginTable( "CAMERA", m_FrameDataNow.stateParam.normalCamera ) )
				{
					g_pX2Game->GetX2Camera()->PlayLuaCamera( this, m_LuaManager, "SUB_CAMERA0" );
					g_pX2Game->GetX2Camera()->PlayLuaCamera( this, m_LuaManager, "SUB_CAMERA1" );
					m_LuaManager.EndTable();
				}
			}
			break;

		case 2:
			{
				if( true == m_LuaManager.BeginTable( "CAMERA", m_FrameDataNow.stateParam.normalCamera ) )
				{
					g_pX2Game->GetX2Camera()->PlayLuaCamera( this, m_LuaManager, "SUB_CAMERA0" );
					g_pX2Game->GetX2Camera()->PlayLuaCamera( this, m_LuaManager, "SUB_CAMERA1" );
					m_LuaManager.EndTable();
				}
			}
			break;

		default:
			ASSERT( !L"WorngPath" );
			break;
		}
	}

	m_FrameDataNow.stateParam.bEventFlagList[0] = true;
}

/** @function : DamageRevengeEventProcess
	@brief : 반격 스킬에 당했을 때의 EventProcess
*/
void CX2GUUser::DamageRevengeEventProcess()
{
	if( true == m_pXSkinAnimFuture->IsAnimationEnd() )
	{	
		if( true == IsOnSomethingFuture() )
			StateChange( USI_WAIT );
		else
			StateChange( USI_JUMP_DOWN );
	}	

	CommonEventProcess();
}

/** @function : WallLandingEventProcess
	@brief : Wall 속성을 가진 라인맵에서 Jump Down 중일 때 위쪽 방향 키보드를 누르면 수행 되는 WallLanding 상태의 EventProcess\n
			 ( 실제로 수행 되는지는 잘 모르겠음 )
*/

#ifdef WALL_JUMP_TEST
void CX2GUUser::WallLandingEventProcess()
{
	if( true == m_FrameDataFuture.stateParam.bEventFlagList[0] &&
		0.15f < m_pXSkinAnimFuture->GetNowAnimationTime() )
	{
		if( true == m_InputData.pureUp )
		{
			m_bDisableGravity = false;
			m_FrameDataFuture.unitCondition.bFootOnWall = false;
			StateChange( USI_JUMP_UP );
			m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		}
		else
		{
			StateChange( USI_JUMP_DOWN );
		}
	}
	else if( 0.05f < m_pXSkinAnimFuture->GetNowAnimationTime() )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}

	CommonEventProcess();
}

/** @function : WalllandingEndFuture
	@brief : Wall 속성을 가진 라인맵에서 Jump Down 중일 때 위쪽 방향 키보드를 누르면 수행 되는 WallLanding 상태의 EndProcess\n
			 ( 실제로 수행 되는지는 잘 모르겠음 )
*/
void CX2GUUser::WallLandingEndFuture()
{
	m_bDisableGravity = false;
	m_FrameDataFuture.unitCondition.bFootOnWall = false;
	CommonStateEndFuture();
}
#endif WALL_JUMP_TEST


/** @function : HyperModeStart
	@brief : 하이퍼 모드를 사용한다는 플래그 셋팅
*/
void CX2GUUser::HyperModeStart()
{
	CommonStateStart();
	m_bHyperModeUsed = true;
#ifdef HYPER_MODE_FIX
	m_iLastStateHyperModeCount = m_FrameDataNow.syncData.m_HyperModeCount;
	m_iHyperModeCountUsed = m_FrameDataNow.syncData.m_HyperModeCount;

	if ( GetRemainHyperModeTime() > 0.0f )
	{
#ifdef SUPERPOSITION_HYPER_MODE_BUG
		if( true == GetCanChangeHyperModeInHyperModeState() )/// 각성중 재각성 처리(레피)
#endif // SUPERPOSITION_HYPER_MODE_BUG
		{
			SetHyperModeCount( max( GetLastStateHyperModeCount() - 1, 0 ) );	 
		}
	}
	else
		SetHyperModeCount( 0 );

	m_FrameDataNow.syncData.m_HyperModeCount = 0;
	m_bReserveHyperModeZero = false;
#endif HYPER_MODE_FIX

}
#ifdef HYPER_MODE_FIX
void CX2GUUser::HyperModeStartFuture()
{
	CommonStateStartFuture();
	m_bReserveHyperModeZero = true;
}
#endif HYPER_MODE_FIX

void CX2GUUser::HyperModeEventProcess()
{
	if( true == m_pXSkinAnimFuture->IsAnimationEnd() )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}	
// #ifdef SUPERPOSITION_HYPER_MODE_BUG
// 	else if ( GetRemainHyperModeTime() > 0.0f && 
// 		false == GetCanChangeHyperModeInHyperModeState() )
// 	{
// 		// 각성 중 각성이 불가능 한데, 현재 루틴 돌고 있다면 대기 상태로 강제 변경
// 		if( false == IsOnSomethingFuture() )
// 			StateChange( USI_JUMP_DOWN );
// 		else
// 			StateChange( USI_WAIT );
// 	}
// #endif // SUPERPOSITION_HYPER_MODE_BUG
	 
	CommonEventProcess();
}
#ifdef HYPER_MODE_FIX
void CX2GUUser::HyperModeEnd()
{
	CommonStateEnd();
	m_iLastStateHyperModeCount = 0;
}
#endif HYPER_MODE_FIX

/** @function : ShowMinorParticleHyperModeChange
	@brief : 각성 상태로 변경하는 파티클을 보여줌
*/
#ifdef SERV_9TH_NEW_CHARACTER // 김태환
void CX2GUUser::ShowMinorParticleHyperModeChange( const wstring& wstrBoneName /*= L"Dummy1_Rhand"*/ )
#else // SERV_9TH_NEW_CHARACTER
void CX2GUUser::ShowMinorParticleHyperModeChange()
#endif // SERV_9TH_NEW_CHARACTER
{
	CKTDGParticleSystem* pMinorParticleSystem = g_pX2Game->GetMinorParticle();

#ifdef SERV_9TH_NEW_CHARACTER // 김태환
	D3DXVECTOR3 pos = GetBonePos( wstrBoneName.c_str() );
#else // SERV_9TH_NEW_CHARACTER
	D3DXVECTOR3 pos = GetBonePos( L"Dummy1_Rhand" );
#endif // SERV_9TH_NEW_CHARACTER

	CKTDGParticleSystem::CParticleEventSequence* pSeqHyperModeChangeCenter = pMinorParticleSystem->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_HYPER_MODE_CHANGE_CENTER ) );
	PlaySequenceByTriggerCount( pSeqHyperModeChangeCenter, pos,  20, 40,  10 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqHyperModeChangeLine   = pMinorParticleSystem->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_HYPER_MODE_CHANGE_LINE ) );
	PlaySequenceByTriggerCount( pSeqHyperModeChangeLine, pos,  40, 80, 10 );

	if( NULL != pSeqHyperModeChangeLine )
	{
		pSeqHyperModeChangeLine->SetBlackHolePosition( pos );
		pSeqHyperModeChangeLine->UseLookPoint( true );
		pSeqHyperModeChangeLine->SetLookPoint( pos );
	}
}

/** @function : ShowMinorParticleHyperModeShock
	@brief : 각성 상태로 변경하는 파티클을 보여줌
*/
#ifdef SERV_9TH_NEW_CHARACTER // 김태환
void CX2GUUser::ShowMinorParticleHyperModeShock( const wstring& wstrBoneName /*= L"Dummy1_Rhand"*/ )
#else // SERV_9TH_NEW_CHARACTER
void CX2GUUser::ShowMinorParticleHyperModeShock()
#endif // SERV_9TH_NEW_CHARACTER
{
	CKTDGParticleSystem* pMinorParticleSystem = g_pX2Game->GetMinorParticle();
	
#ifdef SERV_9TH_NEW_CHARACTER // 김태환
	D3DXVECTOR3 pos = GetBonePos( wstrBoneName.c_str() );
#else // SERV_9TH_NEW_CHARACTER
	D3DXVECTOR3 pos = GetBonePos( L"Dummy1_Rhand" );
#endif // SERV_9TH_NEW_CHARACTER

	CKTDGParticleSystem::CParticleEventSequence* pSeqGroundShockWave = pMinorParticleSystem->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_GROUND_SHOCK_WAVE ) );
	PlaySequenceByTriggerCount( pSeqGroundShockWave, m_FrameDataNow.unitCondition.landPosition.x, m_FrameDataNow.unitCondition.landPosition.y + 5.0f, m_FrameDataNow.unitCondition.landPosition.z,  5, 10,  3 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqWhiteShockWave = pMinorParticleSystem->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_WHITE_SHOCK_WAVE ) );
	PlaySequenceByTriggerCount( pSeqWhiteShockWave, pos, 10, 10,  1 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqImpactTick = pMinorParticleSystem->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_IMPACT_TICK ) );
	PlaySequenceByTriggerCount( pSeqImpactTick, pos,  200, 200,  30 );
	
	if ( GetShowSmallGageAndName() )
	{
		D3DXVECTOR2 projPos = g_pKTDXApp->GetProj3DPos( m_FrameDataNow.syncData.position );
		CKTDGParticleSystem::CParticleEventSequence* pSeqSTR_ToKang = pMinorParticleSystem->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_STR_TOKANG ) );
		PlaySequenceByTriggerCount( pSeqSTR_ToKang, projPos.x, projPos.y, 0.0f, 100, 100, 1 );
	}
#ifdef HYPER_MODE_EFFECT_ADD_BY_ITEM
	ShowSpecialEffectHyperMode();
#endif // HYPER_MODE_EFFECT_ADD_BY_ITEM
}

/** @function : ShowMinorParticleHyperModeShock
	@brief : 각성 상태에서 캐릭터의 몸에 붙어 다니는 파티클을 보여줌
*/
void CX2GUUser::ShowMinorParticleHyperModeTrace()
{
	CKTDGParticleSystem* pMinorParticleSystem = g_pX2Game->GetMinorParticle();

	CKTDGParticleSystem::CParticleEventSequence* pSeq_RFoot = pMinorParticleSystem->GetInstanceSequence( m_hHyperBoostRFoot );
	if( pSeq_RFoot != NULL )
	{
		pSeq_RFoot->SetPosition( GetBonePos( L"Bip01_R_Foot" ) );
		pSeq_RFoot->SetEmitRate( 30, 40 );
		pSeq_RFoot->SetTrace( true );
	}

	CKTDGParticleSystem::CParticleEventSequence* pSeq_LFoot = pMinorParticleSystem->GetInstanceSequence( m_hHyperBoostLFoot );
	if( pSeq_LFoot != NULL )
	{
		pSeq_LFoot->SetPosition( GetBonePos( L"Bip01_L_Foot" ) );
		pSeq_LFoot->SetEmitRate( 30, 40 );
		pSeq_LFoot->SetTrace( true );
	}

	CKTDGParticleSystem::CParticleEventSequence* pSeq_RArm = pMinorParticleSystem->GetInstanceSequence( m_hHyperBoostRArm );
	if( pSeq_RArm != NULL )
	{
		pSeq_RArm->SetPosition( GetBonePos( L"Bip01_R_UpperArm" ) );
		pSeq_RArm->SetEmitRate( 30, 40 );
		pSeq_RArm->SetTrace( true );
	}

	CKTDGParticleSystem::CParticleEventSequence* pSeq_LArm = pMinorParticleSystem->GetInstanceSequence( m_hHyperBoostLArm );
	if( pSeq_LArm != NULL )
	{
		pSeq_LArm->SetPosition( GetBonePos( L"Bip01_L_UpperArm" ) );
		pSeq_LArm->SetEmitRate( 30, 40 );
		pSeq_LArm->SetTrace( true );
	}
}

// 콤보 마지막 타격에 쓸 수 있는 일반적인 eventprocess
void CX2GUUser::GenericGroundComboEndEventProcess()
{

	float fSkipTime = -1.f;
	LUA_GET_VALUE( m_LuaManager, "SKIP_TIME",	fSkipTime,		-1.f );


	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( m_CommonState.m_Wait );
	}
	ELSE_IF_ARROW_ZXASDC_PRESSED_AFTER( fSkipTime )
	{
		StateChange( m_CommonState.m_Wait );
	}

	CommonEventProcess();

}



void CX2GUUser::GenericSpecialActiveSkillEventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( m_CommonState.m_Wait );
	}

	CommonEventProcess();
}



void CX2GUUser::GenericActiveSkillEventProcess()
{

	float fSkipTime = -1.f;
	LUA_GET_VALUE( m_LuaManager, "SKIP_TIME",	fSkipTime,		-1.f );

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( m_CommonState.m_Wait );
	}
	ELSE_IF_ARROW_ZXASDC_PRESSED_AFTER( fSkipTime )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( m_CommonState.m_Wait );
	}

	CommonEventProcess();

}





#ifdef CLIFF_CLIMBING_TEST


	bool CX2GUUser::IsOnCliffFuture()
	{
		if( true == IsOnSomethingFuture() )
			return false;

		int iLineIndex = GetLastTouchLineIndex( true );
		const CKTDGLineMap::LineData* pLineData = g_pX2Game->GetLineMap()->GetLineData( iLineIndex );
		if( NULL == pLineData )
			return false;

		if( CKTDGLineMap::LT_CLIFF != pLineData->lineType )
			return false;

		float fHeight = GetPos( true ).y - GetLandPos( true ).y;
		if( fHeight <= 0.f ||
			fHeight > pLineData->m_fCliffHeight )
		{
			return false;
		}

		return true;
	}


	void CX2GUUser::ClimbWaitEventProcess()
	{
		if( true == IsOnSomethingFuture() )
		{
			StateChange( m_CommonState.m_Wait );
		}
		else if( false == IsOnCliffFuture() )
		{
			StateChange( USI_JUMP_DOWN );
		}
		else if( true == m_InputData.pureUp )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChange( m_CommonState.m_ClimbUpFront );
			}
			else
			{
				StateChange( m_CommonState.m_ClimbUp );
			}
		}
		else if( true == m_InputData.pureDown )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChange( m_CommonState.m_ClimbDownFront );
			}
			else
			{
				StateChange( m_CommonState.m_ClimbDown );
			}
		}
		else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChange( m_CommonState.m_ClimbFront );
		}

		CommonEventProcess();
	}




	void CX2GUUser::ClimbFrontFrameMoveFuture()
	{
		if( m_InputData.pureRight == true )
		{
			m_FrameDataFuture.syncData.bIsRight = true;
			//m_PhysicParam.nowSpeed.x = GetWalkSpeed() * 0.5f;
		}
		else if( m_InputData.pureLeft == true )
		{
			m_FrameDataFuture.syncData.bIsRight = false;
			//m_PhysicParam.nowSpeed.x = GetWalkSpeed() * 0.5f;
		}
		//else
		//{
		//	m_PhysicParam.nowSpeed.x = 0.f;
		//}

		CommonFrameMoveFuture();
	}

	void CX2GUUser::ClimbFrontEventProcess()
	{
		if( true == IsOnSomethingFuture() )
		{
			StateChange( m_CommonState.m_Wait );
		}
		else if( false == IsOnCliffFuture() )
		{
			StateChange( USI_JUMP_DOWN );
		}
		else if( true == m_InputData.pureUp )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChange( m_CommonState.m_ClimbUpFront );
			}
			else
			{
				StateChange( m_CommonState.m_ClimbUp );
			}
		}
		else if( true == m_InputData.pureDown )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChange( m_CommonState.m_ClimbDownFront );
			}
			else
			{
				StateChange( m_CommonState.m_ClimbDown );
			}
		}
		else if( m_InputData.pureRight == false && m_InputData.pureLeft == false )
		{
			StateChange( m_CommonState.m_ClimbWait );
		}

		CommonEventProcess();
	}







	//void CX2GUUser::ClimbUpFrameMoveFuture()
	//{
	//	if( true == m_InputData.pureUp )
	//	{
	//		m_PhysicParam.nowSpeed.y = GetWalkSpeed() * 0.5f;
	//	}
	//	

	//	//if( m_InputData.pureRight == true )
	//	//{
	//	//	m_FrameDataFuture.syncData.bIsRight = true;
	//	//	
	//	//}
	//	//else if( m_InputData.pureLeft == true )
	//	//{
	//	//	m_FrameDataFuture.syncData.bIsRight = false;
	//	//}

	//	CommonFrameMoveFuture();
	//}

	

	void CX2GUUser::ClimbUpEventProcess()
	{
		if( true == IsOnSomethingFuture() )
		{
			StateChange( m_CommonState.m_Wait );
		}
		else if( false == IsOnCliffFuture() )
		{
			StateChange( USI_JUMP_DOWN );
		}
		else if( true == m_InputData.pureUp )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChange( m_CommonState.m_ClimbUpFront );
			}
			//else
			//{
			//	StateChange( m_CommonState.m_ClimbUp );
			//}
		}
		else if( true == m_InputData.pureDown )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChange( m_CommonState.m_ClimbDownFront );
			}
			else
			{
				StateChange( m_CommonState.m_ClimbDown );
			}
		}
		else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChange( m_CommonState.m_ClimbFront );
		}
		else
		{
			StateChange( m_CommonState.m_ClimbWait );
		}

		CommonEventProcess();
	}








	//void CX2GUUser::ClimbDownFrameMoveFuture()
	//{
	//	if( true == m_InputData.pureDown )
	//	{
	//		m_PhysicParam.nowSpeed.y = -GetWalkSpeed() * 0.5f;
	//	}


	//	//if( m_InputData.pureRight == true )
	//	//{
	//	//	m_FrameDataFuture.syncData.bIsRight = true;

	//	//}
	//	//else if( m_InputData.pureLeft == true )
	//	//{
	//	//	m_FrameDataFuture.syncData.bIsRight = false;
	//	//}

	//	CommonFrameMoveFuture();
	//}



	void CX2GUUser::ClimbDownEventProcess()
	{
		if( true == IsOnSomethingFuture() )
		{
			StateChange( m_CommonState.m_Wait );
		}
		else if( false == IsOnCliffFuture() )
		{
			StateChange( USI_JUMP_DOWN );
		}
		else if( true == m_InputData.pureUp )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChange( m_CommonState.m_ClimbUpFront );
			}
			else
			{
				StateChange( m_CommonState.m_ClimbUp );
			}
		}
		else if( true == m_InputData.pureDown )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChange( m_CommonState.m_ClimbDownFront );
			}
			//else
			//{
			//	StateChange( m_CommonState.m_ClimbDown );
			//}
		}
		else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChange( m_CommonState.m_ClimbFront );
		}
		else
		{
			StateChange( m_CommonState.m_ClimbWait );
		}

		CommonEventProcess();
	}


	void CX2GUUser::ClimbUpFrontFrameMoveFuture()
	{
		//if( true == m_InputData.pureUp )
		//{
		//	m_PhysicParam.nowSpeed.y = GetWalkSpeed() * 0.5f;
		//}


		if( m_InputData.pureRight == true )
		{
			m_FrameDataFuture.syncData.bIsRight = true;
			//m_PhysicParam.nowSpeed.x = GetWalkSpeed() * 0.5f;
		}
		else if( m_InputData.pureLeft == true )
		{
			m_FrameDataFuture.syncData.bIsRight = false;
			//m_PhysicParam.nowSpeed.x = GetWalkSpeed() * 0.5f;
		}
		//else
		//{
		//	m_PhysicParam.nowSpeed.x = 0.f;
		//}

		CommonFrameMoveFuture();
	}



	void CX2GUUser::ClimbUpFrontEventProcess()
	{
		if( true == IsOnSomethingFuture() )
		{
			StateChange( m_CommonState.m_Wait );
		}
		else if( false == IsOnCliffFuture() )
		{
			StateChange( USI_JUMP_DOWN );
		}
		else if( true == m_InputData.pureUp )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				//StateChange( m_CommonState.m_ClimbUpFront );
			}
			else
			{
				StateChange( m_CommonState.m_ClimbUp );
			}
		}
		else if( true == m_InputData.pureDown )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChange( m_CommonState.m_ClimbDownFront );
			}
			else
			{
				StateChange( m_CommonState.m_ClimbDown );
			}
		}
		else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChange( m_CommonState.m_ClimbFront );
		}
		else
		{
			StateChange( m_CommonState.m_ClimbWait );
		}

		CommonEventProcess();
	}







	void CX2GUUser::ClimbDownFrontFrameMoveFuture()
	{
		//if( true == m_InputData.pureUp )
		//{
		//	m_PhysicParam.nowSpeed.y = GetWalkSpeed() * 0.5f;
		//}


		if( m_InputData.pureRight == true )
		{
			m_FrameDataFuture.syncData.bIsRight = true;
			//m_PhysicParam.nowSpeed.x = GetWalkSpeed() * 0.5f;
		}
		else if( m_InputData.pureLeft == true )
		{
			m_FrameDataFuture.syncData.bIsRight = false;
			//m_PhysicParam.nowSpeed.x = GetWalkSpeed() * 0.5f;
		}
		//else
		//{
		//	m_PhysicParam.nowSpeed.x = 0.f;
		//}

		CommonFrameMoveFuture();
	}



	void CX2GUUser::ClimbDownFrontEventProcess()
	{
		if( true == IsOnSomethingFuture() )
		{
			StateChange( m_CommonState.m_Wait );
		}
		else if( false == IsOnCliffFuture() )
		{
			StateChange( USI_JUMP_DOWN );
		}
		else if( true == m_InputData.pureUp )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChange( m_CommonState.m_ClimbUpFront );
			}
			else
			{
				StateChange( m_CommonState.m_ClimbUp );
			}
		}
		else if( true == m_InputData.pureDown )
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				//StateChange( m_CommonState.m_ClimbDownFront );
			}
			else
			{
				StateChange( m_CommonState.m_ClimbDown );
			}
		}
		else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChange( m_CommonState.m_ClimbFront );
		}
		else
		{
			StateChange( m_CommonState.m_ClimbWait );
		}

		CommonEventProcess();
	}


#endif CLIFF_CLIMBING_TEST

// 라인맵에서 포탈 타고 다른 라인으로 이동할 때 보이는 이펙트 생성하는 함수
	void CX2GUUser::CreateTeleportEffect( const D3DXVECTOR3& vPos_, const D3DXVECTOR3& vRotDegree_ )
	{
	PlaySound( L"Nasod_Element_Teleport.ogg" );

	g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P01", vPos_ );
	g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P02", vPos_ );
	g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P03", vPos_ );
	g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos_ + D3DXVECTOR3( 0,  50, 0 ) * 0.8f );
	g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos_ + D3DXVECTOR3( 0, 100, 0 ) * 0.8f );
	g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos_ + D3DXVECTOR3( 0, 200, 0 ) * 0.8f );
	g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos_ + D3DXVECTOR3( 0, 300, 0 ) * 0.8f );
	g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos_ + D3DXVECTOR3( 0, 450, 0 ) * 0.8f );

	g_pX2Game->GetMinorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"RespawnLanding01", vPos_, vRotDegree_, vRotDegree_ );
	g_pX2Game->GetMinorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"RespawnLanding02", vPos_, vRotDegree_, vRotDegree_ );

}


// @bSpeedUpByItem: 아이템 소켓 옵션에 의해 애니메이션 속도 증가 적용할지 말지
void CX2GUUser::ResetAnimSpeed( float fAnimSpeed, bool bSpeedUpByItem, bool bFuture, float fExtraSpeedRate /*= 1.f*/ )
{

#ifdef NEW_SKILL_TREE
	if( 1.f != fExtraSpeedRate )
	{
		fAnimSpeed *= fExtraSpeedRate;
	}
#endif NEW_SKILL_TREE

	if( true == bSpeedUpByItem )
	{
		float fSpeedUpRate = GetAnimSpeedValue();

		//{{ kimhc // 2011.4.24 // 월드버프 2단계, 드래곤의 숨결
#ifdef	SERV_INSERT_GLOBAL_SERVER
		if ( NULL != g_pData->GetWorldMissionManager() && CX2Game::GT_PVP != g_pX2Game->GetGameType() )
		{
			fSpeedUpRate += g_pData->GetWorldMissionManager()->GetDragonBreathAnimSpeedRateIncreased() * 0.01f;

			//{{ kimhc // 2011-07-05 // 옵션데이타 수치화 작업
			//}} kimhc // 2011-07-05 // 옵션데이타 수치화 작업
		}
#endif	SERV_INSERT_GLOBAL_SERVER
		//}} kimhc // 2011.4.24 // 월드버프 2단계, 드래곤의 숨결


		fAnimSpeed *= fSpeedUpRate;

#ifdef ELSWORD_WAY_OF_SWORD
		if( CX2Unit::UT_ELSWORD == GetUnit()->GetType() )
		{
			if( GetWayOfSwordState() == CX2GUElsword_SwordMan::WSS_VIGOR )
			{
				CX2GUElsword_SwordMan* pElsword = static_cast< CX2GUElsword_SwordMan* >( this );
				fAnimSpeed *= pElsword->GetAnimSpeedUpByVigor();
			}
		}
#endif ELSWORD_WAY_OF_SWORD
	}

#ifdef CHUNG_SECOND_CLASS_CHANGE
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CDC_INTENSE_SHOWTIME, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CDC_INTENSE_SHOWTIME );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
		if ( true == IsFullHyperMode() )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_CDC_INTENSE_SHOWTIME );
			if( NULL != pSkillTemplet )
			{
				const float fAniSpeedUp = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ANI_SPEED, iSkillLevel );
				fAnimSpeed *= fAniSpeedUp;
			}
	#else // UPGRADE_SKILL_SYSTEM_2013
			const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_CDC_INTENSE_SHOWTIME, iSkillLevel );
			if( NULL != pSkillTemplet )
			{
				const float fAniSpeedUp = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ANI_SPEED );
				fAnimSpeed *= fAniSpeedUp;
			}
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}
	}
#endif

#ifdef UPGRADE_SKILL_SYSTEM_2013 //김창한
	//컴뱃레인져 - 재빠른 몸놀림
	iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_LCR_AGILE_MOVEMENT, true );
	if( iSkillLevel > 0 && ( CX2Unit::UC_LIRE_COMBAT_RANGER == GetUnitClass() || CX2Unit::UC_LIRE_WIND_SNEAKER == GetUnitClass() ) )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_LCR_AGILE_MOVEMENT );
		if( NULL != pSkillTemplet )
		{
			const float fAniSpeedUp = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ANI_SPEED, iSkillLevel );
			fAnimSpeed *= fAniSpeedUp;
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013

	// 속성 공격등에 의해 애니메이션 속도가 변했는지
	if( m_fAnimSpeedRate < 0.1f )
	{
		m_fAnimSpeedRate = 0.1f;
	}
	fAnimSpeed *= m_fAnimSpeedRate;


#ifdef DEEP_WATER_DUNGEON_TEST

	if( NULL != g_pX2Game &&
		NULL != g_pX2Game->GetWorld() &&
		1.f != g_pX2Game->GetWorld()->GetUnitAnimSpeedRate() )
	{
		fAnimSpeed *= g_pX2Game->GetWorld()->GetUnitAnimSpeedRate();
	}

#endif DEEP_WATER_DUNGEON_TEST




	if( true == bFuture )
	{
		if( NULL != m_pXSkinAnimFuture )
		{
			m_pXSkinAnimFuture->SetPlaySpeed( fAnimSpeed );
		}
	}
	else
	{
		if( m_pXSkinAnim != NULL )
		{
			m_pXSkinAnim->SetPlaySpeed( fAnimSpeed );
		}
	}
}


float CX2GUUser::GetStopTime()
{
	return m_FrameDataFuture.unitCondition.fStopTime;

}

void CX2GUUser::SetStopTime( float fStopTime )
{
	m_FrameDataFuture.unitCondition.fStopTime = fStopTime; 

	if( NULL != g_pX2Game &&
		NULL != g_pX2Game->GetWorld() &&
		NULL != g_pX2Game->GetWorld()->GetLineMap() )
	{
		g_pX2Game->GetWorld()->GetLineMap()->SetStopTime( max( g_pX2Game->GetWorld()->GetLineMap()->GetStopTime(), fStopTime ) );
	}

#ifdef STOP_UNIT_STOP_EFFECT_TEST
	SetEffectStopTime( fStopTime );
#endif STOP_UNIT_STOP_EFFECT_TEST


}

void CX2GUUser::SetStop2Time( float fStopTime )
{
	m_FrameDataFuture.unitCondition.fStop2Time = fStopTime; 

	if( NULL != g_pX2Game &&
		NULL != g_pX2Game->GetWorld() &&
		NULL != g_pX2Game->GetWorld()->GetLineMap() )
	{
		g_pX2Game->GetWorld()->GetLineMap()->SetStopTime( max( g_pX2Game->GetWorld()->GetLineMap()->GetStopTime(), fStopTime ) );
	}

#ifdef STOP_UNIT_STOP_EFFECT_TEST
	SetEffectStopTime( fStopTime );
#endif STOP_UNIT_STOP_EFFECT_TEST


}

#ifdef UNIT_EMOTION
void CX2GUUser::EmotionFrameMove()
{
	if(m_ePlayedEmotion == CX2Unit::ET_NONE)
		return;

	if(m_pXSkinAnim != NULL && m_pXSkinAnim->IsAnimationEnd() == true)
	{
		switch(m_ePlayedEmotion)
		{
		case CX2Unit::ET_SITREADY:
			{
#ifdef RIDING_SYSTEM
				wstring wstrEmotionName = L"Emotion_SitWait";

				if ( true == GetRidingOn() && NULL != GetRidingPet() && false == m_wstrRidingMotionName.empty() && 
					 NULL != GetRidingPet()->GetXSkinAnimPtr() && true == GetRidingPet()->GetXSkinAnimPtr()->IsAnimationEnd() )
				{
					wstrEmotionName = m_wstrRidingMotionName;
					GetRidingPet()->StateChange( GetRidingPet()->m_SitWaitState );
				}				
#else //RIDING_SYSTEM
				wstring wstrEmotionName = L"Emotion_SitWait";

				PlayEmotion(CX2Unit::ET_SITWAIT, wstrEmotionName);
				if( NULL != g_pX2Game && NULL != g_pX2Game->GetMyUnit() &&
					CX2Main::XS_BATTLE_FIELD == g_pMain->GetNowStateID() )
				{//앉기 이모션 사용 시 체력 회복 버프('편안한 휴식' 적용)
					SetBuffFactorToGameUnitByBuffFactorID( static_cast<UINT>( BFI_CALM_REST ) );
				}
#endif //RIDING_SYSTEM

				PlayEmotion(CX2Unit::ET_SITWAIT, wstrEmotionName);
				if( NULL != g_pX2Game && NULL != g_pX2Game->GetMyUnit() &&
					CX2Main::XS_BATTLE_FIELD == g_pMain->GetNowStateID() )
				{//앉기 이모션 사용 시 체력 회복 버프('편안한 휴식' 적용)
					SetBuffFactorToGameUnitByBuffFactorID( static_cast<UINT>( BFI_CALM_REST ) );
				}
			}			
			break;
		case CX2Unit::ET_SITWAIT:
			break;
		default:
			{
				StateChange(GetWaitStateID(), true);				
			}			
			break;
		}
	}
}

bool CX2GUUser::PlayEmotion(CX2Unit::EMOTION_TYPE eEmotionId, wstring &wstrEmotionType)
{
	if( CX2Unit::IsAvatarEmotion( eEmotionId ) )
	{		
		wstring wstrEmotionName = L"";
		CX2Unit::EMOTION_TYPE eEmotion = CX2Unit::ET_NONE;
#ifdef CRAYONPOP_EMOTION_WITH_MUSIC		// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨
		if ( true == IsPlayAvatarEmotionSoundWithouEmotion ( eEmotionId ) )
			return true;
#endif // CRAYONPOP_EMOTION_WITH_MUSIC	// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨
		bool bMixEmotion = GetUnit()->GetAvatarEmotion(wstrEmotionName, eEmotion);
		if( bMixEmotion == false )
			return false;
		
		if( eEmotionId != eEmotion )
			return false;
		

		if( bMixEmotion == true && wstrEmotionName.empty() != true && 
			( (eEmotion == CX2Unit::ET_EMOTION_AVATAR1 && m_bMixedEmotion[0] == false) ||
			(eEmotion == CX2Unit::ET_EMOTION_AVATAR2 && m_bMixedEmotion[1] == false)  ||
			(eEmotion == CX2Unit::ET_EMOTION_AVATAR3 && m_bMixedEmotion[2] == false) ||
			(eEmotion == CX2Unit::ET_EMOTION_AVATAR4 && m_bMixedEmotion[3] == false) ||
			(eEmotion == CX2Unit::ET_EMOTION_AVATAR5 && m_bMixedEmotion[4] == false) 
		#ifdef CRAYONPOP_SECOND_EMOTION
			|| (eEmotion == CX2Unit::ET_EMOTION_AVATAR6 && m_bMixedEmotion[5] == false) 
		#endif // CRAYONPOP_SECOND_EMOTION
			) 
			
			)
		//if( bMixEmotion == true && m_bMixedEmotion == false && wstrEmotionName.empty() != true )
		{		
			CKTDXDeviceXSkinMesh *pMixMotion = g_pKTDXApp->GetDeviceManager()->OpenXSkinMesh( wstrEmotionName );
			if( pMixMotion != NULL )
			{
				m_pXSkinAnim->MixAnim( pMixMotion );
				//m_bMixedEmotion = true;
				switch( eEmotion )
				{
				case CX2Unit::ET_EMOTION_AVATAR1:
					m_bMixedEmotion[0] = true;
					break;
				case CX2Unit::ET_EMOTION_AVATAR2:
					m_bMixedEmotion[1] = true;
					break;
				case CX2Unit::ET_EMOTION_AVATAR3:
					m_bMixedEmotion[2] = true;
					break;
				case CX2Unit::ET_EMOTION_AVATAR4:
					m_bMixedEmotion[3] = true;
					break;

				case CX2Unit::ET_EMOTION_AVATAR5:
					m_bMixedEmotion[4] = true;
					break;
#ifdef CRAYONPOP_SECOND_EMOTION
				case CX2Unit::ET_EMOTION_AVATAR6:
					m_bMixedEmotion[5] = true;
					break;
#endif // CRAYONPOP_SECOND_EMOTION
				}
				SAFE_CLOSE( pMixMotion );
			}
		}
	}


	int iWaitStateId = GetNowStateID();

#ifdef RIDING_SYSTEM
	if ( true == GetRidingOn() )
	{
		if ( iWaitStateId != GetRidingWaitStateID() )
			return false;
	}
	else
	{
		if( iWaitStateId != GetWaitStateID() )
			return false;
	}
#else //RIDING_SYSTEM
	if( iWaitStateId != GetWaitStateID() )
	{
		return false;
	}
#endif //RIDING_SYSTEM

	if( eEmotionId == CX2Unit::ET_SITREADY )
	{
		switch( GetUnit()->GetType() )
		{
		case CX2Unit::UT_LIRE:
			{
				if( CX2GULire_ElvenRanger::LESI_CHARGE_MP == GetNowStateID() )
				{
					StateChange( GetWaitStateID(), true );
					m_bReserveSitReadyEmotion = true;
				}
			}break;
		case CX2Unit::UT_ARME:
			{
				if( CX2GUArme_VioletMage::AVSI_CHARGE_MP == GetNowStateID() )
				{
					StateChange( GetWaitStateID(), true );
					m_bReserveSitReadyEmotion = true;
				}
			}break;
		case CX2Unit::UT_CHUNG:
			{
				if( CX2GUChung::CSI_CHARGE_CANNON_BALL == GetNowStateID() )
				{
					StateChange( GetWaitStateID(), true );
					m_bReserveSitReadyEmotion = true;
				}
			}break;
		}
	}
#ifdef RIDING_SYSTEM
	if( true == GetRidingOn() )
	{
		if ( m_ePlayedEmotion == CX2Unit::ET_NONE && iWaitStateId != GetRidingWaitStateID() )
			return false;

		if(m_pXSkinAnim != NULL)
		{
			if(eEmotionId == CX2Unit::ET_SITWAIT)
				m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_LOOP );
			else
				m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		}

		if ( ( eEmotionId != CX2Unit::ET_SITREADY && eEmotionId != CX2Unit::ET_STANDUP ) && iWaitStateId == GetRidingWaitStateID() )
			return false;
	}
	else
	{ 
		if ( m_ePlayedEmotion == CX2Unit::ET_NONE && iWaitStateId != GetWaitStateID() )
		return false;
	}
#else
	//캐릭터 기본 행동 중일 때는 즉시 변경하지 않고 예약 후 waitstate에서 처리
	if( m_ePlayedEmotion == CX2Unit::ET_NONE && iWaitStateId != GetWaitStateID())
		return false;
#endif //RIDING_SYSTEM

	if(eEmotionId == CX2Unit::ET_NONE || wstrEmotionType.empty() == true)
		return false;		

	if( eEmotionId == CX2Unit::ET_SITREADY &&
		(m_ePlayedEmotion == CX2Unit::ET_SITREADY || m_ePlayedEmotion == CX2Unit::ET_SITWAIT) )
		return false;

	if( eEmotionId == CX2Unit::ET_STANDUP && m_ePlayedEmotion != CX2Unit::ET_SITWAIT )
		return false;

	if(m_pXSkinAnim != NULL)
	{						
		if( CX2Unit::IsAvatarEmotion( eEmotionId ) ) 
			m_pXSkinAnim->ChangeAnim( wstrEmotionType.c_str(), false );
		else
			m_pXSkinAnim->ChangeAnim( wstrEmotionType.c_str(), true );

		if(eEmotionId == CX2Unit::ET_SITWAIT)
			m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_LOOP );
		else
			m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );

		m_ePlayedEmotion = eEmotionId;

		if( eEmotionId == CX2Unit::ET_EMOTION_AVATAR1 || eEmotionId == CX2Unit::ET_EMOTION_AVATAR3 || 
			eEmotionId == CX2Unit::ET_EMOTION_AVATAR4 || eEmotionId == CX2Unit::ET_EMOTION_AVATAR5 
#ifdef CRAYONPOP_SECOND_EMOTION
			|| eEmotionId == CX2Unit::ET_EMOTION_AVATAR6  
#endif // CRAYONPOP_SECOND_EMOTION

#ifdef CRAYONPOP_EMOTION_WITH_MUSIC		// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨
			|| eEmotionId == CX2Unit::ET_EMOTION_AVATAR7
#endif // CRAYONPOP_EMOTION_WITH_MUSIC	// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨
			)
		{
			wstring wstrEmotionSoundName = L"";
			switch( eEmotionId )
			{
			case CX2Unit::ET_EMOTION_AVATAR1:
				wstrEmotionSoundName = L"Emotion_BigBangDance.ogg";
				break;
			case CX2Unit::ET_EMOTION_AVATAR3:
				wstrEmotionSoundName = L"Emotion_APinkDance.ogg";
				break;
			case CX2Unit::ET_EMOTION_AVATAR4:
				wstrEmotionSoundName = L"Emotion_APink_Love.ogg";
				break;
			case CX2Unit::ET_EMOTION_AVATAR5:
				wstrEmotionSoundName = L"DancingQueen_Music.ogg";
				break;
#ifdef CRAYONPOP_SECOND_EMOTION
			case CX2Unit::ET_EMOTION_AVATAR6:
				wstrEmotionSoundName = L"Emotion_Bbabbabba.ogg";
				break;
#endif // CRAYONPOP_SECOND_EMOTION


			default:
				break;
			}

			if( m_pAvatarEmotionSound != NULL )
			{
				m_pAvatarEmotionSound->Stop();
				SAFE_CLOSE( m_pAvatarEmotionSound );
			}
			const float MAGIC_NUMBER = 500.f;
			const float fMaxDist = g_pKTDXApp->GetDGManager()->GetCamera().GetCameraDistance() + MAGIC_NUMBER;
			m_pAvatarEmotionSound = g_pKTDXApp->GetDeviceManager()->OpenSound( wstrEmotionSoundName, 10, true, fMaxDist );
			if( m_pAvatarEmotionSound != NULL )
			{
				if( CX2Main::XS_SQUARE_GAME != g_pMain->GetNowStateID() &&			// note!! 거래광장에서는 일단 2D 사운드로
					CX2Main::XS_PVP_ROOM	!= g_pMain->GetNowStateID() &&
					CX2Main::XS_WEDDING_GAME != g_pMain->GetNowStateID() &&
					true == g_pKTDXApp->GetDSManager()->GetCapable3DSound() &&
					true == g_pKTDXApp->GetDSManager()->GetEnable3DSound() &&
					true == g_pMain->GetGameOption().GetOptionList().m_bEnable3DSound )
				{
					m_pAvatarEmotionSound->Set3DPosition( GetPos() );
					m_pAvatarEmotionSound->Play( false );
				}
				else
				{
					m_pAvatarEmotionSound->Play( false, false );
				}
			}
		}
		else
		{
			if( NULL != g_pChatBox )
			{
				g_pChatBox->PlayEmotionSound( GetUnit()->GetType(), eEmotionId, GetPos(), true );
			}
		}
		if ( eEmotionId == CX2Unit::ET_EMOTION_AVATAR4 )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Head" );
			g_pData->GetUIMajorParticle()->CreateSequenceHandle( NULL, L"Emotion_APINK_LOVE_P01", vBonePos );
		}

		return true;
	}

	return false;
}
#endif UNIT_EMOTION



#ifdef EQUIP_STRIP_TEST

bool CX2GUUser::IsEquipStripped( CX2Unit::EQIP_POSITION eEquipPosition )
{
	std::map< CX2Unit::EQIP_POSITION, bool >::iterator it = m_mapEquipStripped.find( eEquipPosition );
	if( it != m_mapEquipStripped.end() )
		return false;

	return it->second;
}




void CX2GUUser::SetEquipStrippedState( CX2Unit::EQIP_POSITION eEquipPosition, bool bStripped )
{
	// 이미 장비가 탈의된 상태이면 
	if( bStripped == IsEquipStripped(eEquipPosition) )
		return;

	CX2EqipPtr pEquipBasic = GetBasicEquipAtStrippedPosition( eEquipPosition );
	if( pEquipBasic == NULL )
		return;


	m_mapEquipStripped[ eEquipPosition ] = bStripped;


	// 렌더링될 장비 기본장비로 바꾸기
	for( UINT i=0; i<m_ViewEqipList.size(); i++ )
	{
		CX2EqipPtr pEquip = m_ViewEqipList[i];
		if( pEquip == NULL )
			continue;

		if( pEquip->GetEqipPos() == eEquipPosition )
		{
			pEquip->SetShowObject( false );
			pEquipBasic->SetShowObject( true );

			m_ViewEqipList[i] = pEquipBasic;
			SetBasicEquipAtStrippedPosition( eEquipPosition, pEquip );
			break;
		}
	}

	// fix!!!! 장착장비 기능 임시로 막기
	if( true == bStripped )
	{

	}
	else
	{

	}
}



CX2EqipPtr CX2GUUser::GetBasicEquipAtStrippedPosition( CX2Unit::EQIP_POSITION eEquipPosition )
{
	CX2ItemManager::EquipPositionMap::iterator it = m_mapBasicEquip.find( eEquipPosition );
	if( it != m_mapBasicEquip.end() )
		return it->second;

	return CX2EqipPtr();
}

void CX2GUUser::SetBasicEquipAtStrippedPosition( CX2Unit::EQIP_POSITION eEquipPosition, CX2EqipPtr pEquip )
{
	m_mapBasicEquip[ eEquipPosition ] = pEquip;
}

#endif EQUIP_STRIP_TEST





void CX2GUUser::ResetMaxHP()
{
	SetMaxHp( GetStat().GetStat().m_fBaseHP );


//#ifdef PVP_BOSS_COMBAT_TEST
//
//	if( NULL != g_pX2Room )
//	{
//		CX2Room::SlotData* pSlotData = g_pX2Room->GetSlotDataByUnitUID( GetUnitUID() );
//		if( NULL != pSlotData )
//		{
//			if( true == pSlotData->GetIsBoss() )
//			{
//				SetMaxHp( GetStat().GetStat().m_fBaseHP * 2.f );
//			}
//		}
//	}
//
//#endif PVP_BOSS_COMBAT_TEST
//
}


void CX2GUUser::ResetMaxMP()
{
	//SetMaxMP( ONE_CHARGE * 3.f );
	
	const float fMaxMp = ONE_CHARGE * 3.0f;

	m_AdditionalMaxMp.SetBasicStatValue( fMaxMp );

	float fResultMaxMp = GetUnit()->ResetMaxMp( fMaxMp );


#ifdef BUFF_TEMPLET_SYSTEM
	fResultMaxMp += ( fResultMaxMp * m_SocketData.m_Stat.m_ExtraStat.m_fIncreaseMPRate + m_SocketData.m_iAddMPValue );
#else  BUFF_TEMPLET_SYSTEM
	// 마이너스도 가능 하도록.. (모든 소켓옵션은 SumSocketOption() 함수에서 계산되었음)
	fResultMaxMp += fResultMaxMp * m_SocketData.m_Stat.m_ExtraStat.m_fIncreaseMPRate;
#endif BUFF_TEMPLET_SYSTEM
	
//{{ 김상훈 2010.10.29
#ifdef NEW_SKILL_2010_11
	#ifndef FIX_LIMITED_MANA_MANAGEMENT
	int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_AVP_LIMITED_MANA_MANAGEMENT, true );
	if( iSkillLevel > 0 && GetRemainHyperModeTime() > 0.f )
	{
		if ( m_bLimitManaManagement == true )
		{

			const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_AVP_LIMITED_MANA_MANAGEMENT, iSkillLevel );
			if( NULL != pSkillTemplet )
			{
				const float maxMPIncrement = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MAX_MP_ABS );
				fResultMaxMp += maxMPIncrement;
			}
		}
	}
	else
		m_bLimitManaManagement = false;
	#endif //FIX_LIMITED_MANA_MANAGEMENT
#endif NEW_SKILL_2010_11
//}} 김상훈 2010.10.29

	//SetMaxMp( fResultMaxMp );
	
	m_AdditionalMaxMp.SetOptionValue( fResultMaxMp - fMaxMp );

	m_AdditionalMaxMp.CheckAndUpdateResultValue();

	SetMaxMp( m_AdditionalMaxMp.GetResultValue() );
}



void CX2GUUser::ResetMPChangeRate( float fMPChangeRate )
{
	SetChangeRateMp( fMPChangeRate ); 

	//{{ dmlee 2008.7.13 play channel
	if( KPVPChannelInfo::PCC_PLAY == g_pMain->GetPVPChannelClass( g_pMain->GetConnectedChannelID() ) &&
		CX2Main::XS_PVP_GAME == g_pMain->GetNowStateID() )
	{
		const float MAGIC_PLAY_CHANNEL_MP_CHANGE_RATE_SCALE = 7.f;
		SetChangeRateMp( GetChangeRateMp() * MAGIC_PLAY_CHANNEL_MP_CHANGE_RATE_SCALE );
	}
	//}} dmlee 2008.7.13 play channel
}



//{{ kimhc // 실시간 엘소드 중 실시간 칭호 획득 및 교체 관련 부분 추가
#ifdef REAL_TIME_ELSWORD
void CX2GUUser::UpdateSocketDataAndEnchantData()
{
	m_SocketData.ReInit();
	m_vecTitleOptions.resize( 0 );
	m_mapDefenceEnchantData.clear();
	m_mapNpcIdNDamageUpPercent.clear();
	m_mapNpcIDNDEvadeUpPercent.clear();
	m_mapExtraDamageNImmunePer.clear();

//{{ kimhc // 2010.4.2 // 비밀던전 작업(셋트아이템효과)
#ifdef SERV_SECRET_HELL
	m_mapSocketItemEffectEx.clear();
#endif SERV_SECRET_HELL
//}} kimhc // 2010.4.2 // 비밀던전 작업(셋트아이템효과)

#ifdef PET_AURA_SKILL
	m_mapAttackEnchantData.clear();
#endif

	m_vecSummonNpcSocket.clear();

	m_vecBuffFactorPtr.resize( 0 );

	ClearAllDelegateProcess();

	InitSocketData();
	InitEnchantData();
	ResetPhysicParam();
}

/** @function : UpdatePassiveAndActiveSkillState
	@brief : 패시브, 액티브 스킬 업데이트
*/
void CX2GUUser::UpdatePassiveAndActiveSkillState()
{
	InitAdditionalPassive();
	InitPassiveSkillState();
	InitEquippedActiveSkillState( true );
	ResetMaxMP();

	if ( IsMyUnit() )
	{
		g_pX2Game->UpdateSkillSlotUI(true);
	}
}

void CX2GUUser::UpdateEquippedEmblem()
{
	if( NULL != GetUnit() )
	{
		int iTitleId			= GetUnit()->GetTitleId();
		g_pData->GetUIMajorParticle()->DestroyInstanceHandle( m_hSeqEmblem );
		m_hSeqEmblem			= INVALID_PARTICLE_SEQUENCE_HANDLE;
		// m_pPart_Emblem_200은 m_hSeqEmblem의 Particle 포인터와 같기 때문에 NULL 해줘야 함		
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_hPart_Emblem_200		= INVALID_PARTICLE_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		m_pPart_Emblem_200		= NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

		if ( iTitleId > 0)
		{
			wstring titleName = g_pData->GetTitleManager()->GetTitleModel(iTitleId);
			m_hSeqEmblem = g_pData->GetUIMajorParticle()->CreateSequenceHandle( NULL,  titleName.c_str(), 0.0f, 0.0f, 0.0f, 0.0f, 0.0f );

			CKTDGParticleSystem::CParticleEventSequence* pSeqEmblem = g_pData->GetUIMajorParticle()->GetInstanceSequence( m_hSeqEmblem );

			if( pSeqEmblem != NULL )
			{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                m_hPart_Emblem_200 = pSeqEmblem->CreateNewParticleHandle( D3DXVECTOR3(0.0f,0.0f,0.0f) );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
				m_pPart_Emblem_200 = pSeqEmblem->CreateNewParticle( D3DXVECTOR3(0.0f,0.0f,0.0f) );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
				pSeqEmblem->SetShowObject( false );
			}
		}
	}
}

//{{ kimhc // 2010.12.10 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
CX2EqipPtr	CX2GUUser::GetEquipPtrFromEquipViewListByEquipPosition( const CX2Unit::EQIP_POSITION eEquipPosition )
{
	BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquipPtr, m_ViewEqipList )
	{
		if ( eEquipPosition == pViewEquipPtr->GetEqipPos() )
		{
			return pViewEquipPtr;
		}
	}

	return CX2EqipPtr();
}

/** @function : UpdateEquipViewListInfo
	@brief : 장비의 장착, 탈착에 따라 ViewList를 갱신함
	@param :  CX2Item* pItemToAddInViewList(추가될 장비), CX2Item* const pItemToRemoveInViewList(탈착될 장비)
	@return : 함수의 성공 여부
*/
bool CX2GUUser::UpdateEquipViewListInfo( CX2Item* pItemToAddInViewList, CX2Item* const pItemToRemoveInViewList )
{
	{	// kimhc // 이 중괄호는 꼭 있어야 합니다.
		CX2EqipPtr pEquipPtrToRemove;
		int iIndexInViewListForRemove_ = 0;
		if ( false == GetAddItemAndRemoveItemToViewList( pEquipPtrToRemove, &pItemToAddInViewList, pItemToRemoveInViewList, iIndexInViewListForRemove_ ) )
			return false;

		if ( pEquipPtrToRemove.get() != NULL )
		{
			RemoveEquipFromViewList( pEquipPtrToRemove, iIndexInViewListForRemove_ );
		}
	}

	if ( pItemToAddInViewList != NULL )
	{
		AddEquipToViewList( pItemToAddInViewList );
	}
	return true;
}

/** @function : SetShowViewList
	@brief : ViewList내에 있는 것들으 보여줘야 할지를 지정
	@param : bool bShow_ = true
*/
/*virtual*/ void CX2GUUser::SetShowViewList( bool bShow_ )
{
	BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquipPtr, m_ViewEqipList )
	{
		if ( pViewEquipPtr != NULL )
		{
			pViewEquipPtr->SetShowObject( bShow_ );
		}
	}
}

#else	NEW_CHARACTER_CHUNG
//{{AFX
bool CX2GUUser::UpdateEquipViewListInfo( CX2Item* pItemToAddInViewList, CX2Item* const pItemToRemoveInViewList ) 
{
	CX2EqipPtr	pEquipPtrToRemove;
	int			index				= 0;

	if (pItemToAddInViewList != NULL )		// 장착할et 장비가 있는 경우
	{	
        const CX2Item::ItemTemplet* pItemTempletForItemToAdd  = NULL;
		pItemTempletForItemToAdd = pItemToAddInViewList->GetItemTemplet();

		if ( pItemTempletForItemToAdd == NULL )
		{
			ASSERT( false );
			return false;
		}

		for ( size_t numViewEquipInUser = 0; numViewEquipInUser < m_ViewEqipList.size(); numViewEquipInUser++ )
		{
			if ( pItemTempletForItemToAdd->GetEqipPosition() == m_ViewEqipList[numViewEquipInUser]->GetEqipPos() )
			{
				// 장착할 장비가 Normal이고 해당 위치에 이미 Fashion 템이 있는 경우에는 기존의 아이템을 View에서 제거 하지 추가도 하지 않음
				if (  pItemTempletForItemToAdd->GetFashion() == false && GetUnit()->IsFashionEquipInThePosition( pItemTempletForItemToAdd->GetEqipPosition() ) == true )
				{
					pItemToAddInViewList = NULL;
				}
				else 
				{
					pEquipPtrToRemove = m_ViewEqipList[numViewEquipInUser];
					// 이부분에서 remove 해야할듯
				}
				index = numViewEquipInUser;
				break;
			}
		}		
	}
	else if ( pItemToRemoveInViewList != NULL )		// 장비를 해제만 했을 경우
	{
        const CX2Item::ItemTemplet* pItemTempletForItemToRemove = NULL;
		pItemTempletForItemToRemove = pItemToRemoveInViewList->GetItemTemplet();

		if ( pItemTempletForItemToRemove == NULL)
		{
			ASSERT( 0 );
			return false;
		}


		for ( size_t numViewEquipInUser = 0; numViewEquipInUser < m_ViewEqipList.size(); numViewEquipInUser++ )
		{
			if ( pItemTempletForItemToRemove->GetEqipPosition() == m_ViewEqipList[numViewEquipInUser]->GetEqipPos() )
			{
				switch ( pItemTempletForItemToRemove->GetFashion() )
				{
				case true:	// 해제 할 장비가 패션 템인 경우
					{
						pEquipPtrToRemove = m_ViewEqipList[numViewEquipInUser];	// 해제할 장비

						// 해제한 곳에 노말 장비가 있는 경우
						if ( GetUnit()->IsNormalEquipInThePosition( pItemTempletForItemToRemove->GetEqipPosition() ) == true )
						{
							CX2Item* pNormalEquip	= NULL;

							pNormalEquip	= GetUnit()->GetInventory().GetEquippingItemByEquipPos( pItemTempletForItemToRemove->GetEqipPosition(), false );

							if ( pNormalEquip == NULL )
								return false;

							if ( pNormalEquip->GetItemData().m_PeriodType != CX2Item::PT_ENDURANCE		// 내구도가 없는 장비거나
								|| pNormalEquip->GetItemData().m_Endurance > 0)		// 내구도가 0이하가 아니라면 노말 장비를 넣어줌
								pItemToAddInViewList = pNormalEquip;
							else
								pItemToAddInViewList = GetUnit()->CreateBasicEquip( pItemTempletForItemToRemove->GetEqipPosition() );

						}
						else	// 해제한 곳에 노말 장비도 없는 경우
						{
							pItemToAddInViewList = GetUnit()->CreateBasicEquip( pItemTempletForItemToRemove->GetEqipPosition() );
						}
					}
					break;

				case false: // 해제 할 아이템이 노말 템인 경우
					{
						// 해제한 곳에 패션 템도 없는 경우
						if (  GetUnit()->IsFashionEquipInThePosition( pItemTempletForItemToRemove->GetEqipPosition() ) == false )
						{
							pEquipPtrToRemove		= m_ViewEqipList[numViewEquipInUser];	// 해제할 장비
							pItemToAddInViewList	= GetUnit()->CreateBasicEquip( pItemTempletForItemToRemove->GetEqipPosition() );
						}
					}
					break;
				}

				index = numViewEquipInUser;
				break;	// for문에 대한
			}
		} // for ( size_t numViewEquipInUser = 0; numViewEquipInUser < m_ViewEqipList.size(); numViewEquipInUser++ )
	}

	if ( pEquipPtrToRemove.get() != NULL )
	{
		RemoveEquipFromViewList( pEquipPtrToRemove, index );
	}

	if ( pItemToAddInViewList != NULL )
	{
		AddEquipToViewList( pItemToAddInViewList );
	}

#ifdef	NOT_RENDERING_OTHER_EQUIP_POS
	if ( pItemToRemoveInViewList != NULL && 
        pItemToRemoveInViewList->GetItemTemplet() != NULL 
        )
	{
        DWORD   dwItemID = pItemToRemoveInViewList->GetItemTemplet()->GetItemID();
		// kimhc // 이 이상 안보여야 할 분류가 달라 진다면
		// 안보여야할 부위 및 그런 기능을 가지고 있는 아이템을 스크립트로 빼야할듯
		// 현재는 헤어만 안보이게 하는 아이템과 헤어, 얼굴 악세(중,하)를 안보이게 하는 아이템이 같은 위치 이므로
		// 한개만 착용 할 수 있음
		if ( IsNoRenderHairFace2Face3Equip( dwItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
				case CX2Unit::EP_AC_FACE2:
				case CX2Unit::EP_AC_FACE3:
					(*vItr)->SetShowObject( true );
					break;

				default:
					break;
				}
				vItr++;
			}
		}
		else if ( IsNoRenderHair( dwItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					(*vItr)->SetShowObject( true );
					break;

				default:
					break;
				}
				vItr++;
			}
		}
	}

	if ( pItemToAddInViewList != NULL && ]
            pItemToAddInViewList->GetItemTemplet() != NULL 
                )
	{
		// kimhc // 이 이상 안보여야 할 분류가 달라 진다면
		// 안보여야할 부위 및 그런 기능을 가지고 있는 아이템을 스크립트로 빼야할듯
		// 현재는 헤어만 안보이게 하는 아이템과 헤어, 얼굴 악세(중,하)를 안보이게 하는 아이템이 같은 위치 이므로
		// 한개만 착용 할 수 있음
        DWORD   dwItemID = pItemToAddInViewList->GetItemTemplet()->GetItemID();

		if ( IsNoRenderHairFace2Face3Equip( dwItemID ) == true )	// 장착 한 것이 호박이면
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
				case CX2Unit::EP_AC_FACE2:
				case CX2Unit::EP_AC_FACE3:
					(*vItr)->SetShowObject( false );
					break;

				default:
					break;
				}

				vItr++;
			}
		}
		else if ( IsNoRenderHair( dwItemID ) == true )
		{
			vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

			while ( vItr != m_ViewEqipList.end() )
			{
				switch ( (*vItr)->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					(*vItr)->SetShowObject( false );
					break;

				default:
					break;
				}

				vItr++;
			}
		}
		// 장착한 장비가 기존에 장착되어져 있는 장비에 의해서 보이지 않아야 한다면
		else if( pItemToAddInViewList->GetItemTemplet()->GetEqipPosition() == CX2Unit::EP_DEFENCE_HAIR ) // 장착 한 것이 헤어 이고
		{
			CX2Item* pItem = GetUnit()->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_AC_FACE1, false );

			if ( pItem != NULL && 
                pItem->GetItemTemplet() != NULL 
                )
			{
                DWORD   dwItemID2 = pItem->GetItemTemplet()->GetItemID();

				// kimhc // 이 이상 안보여야 할 분류가 달라 진다면
				// 안보여야할 부위 및 그런 기능을 가지고 있는 아이템을 스크립트로 빼야할듯
				// 현재는 헤어만 안보이게 하는 아이템과 헤어, 얼굴 악세(중,하)를 안보이게 하는 아이템이 같은 위치 이므로
				// 한개만 착용 할 수 있음
				if ( IsNoRenderHairFace2Face3Equip( dwItemID2 ) == true )
				{
					vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

					while ( vItr != m_ViewEqipList.end() )
					{
						switch ( (*vItr)->GetEqipPos() )
						{
						case CX2Unit::EP_DEFENCE_HAIR:
						case CX2Unit::EP_AC_FACE2:
						case CX2Unit::EP_AC_FACE3:
							(*vItr)->SetShowObject( false );
							break;

						default:
							break;
						}

						vItr++;
					}
				}
				else if ( IsNoRenderHair( dwItemID ) == true )
				{
					vector<CX2EqipPtr>::iterator vItr = m_ViewEqipList.begin();

					while ( vItr != m_ViewEqipList.end() )
					{
						switch ( (*vItr)->GetEqipPos() )
						{
						case CX2Unit::EP_DEFENCE_HAIR:
							(*vItr)->SetShowObject( false );
							break;

						default:
							break;
						}

						vItr++;
					}
				}
			}
		}
	}
#endif	NOT_RENDERING_OTHER_EQUIP_POS

	UpdateEquipCollisionData();

	SetEnableAttackBox( L"Rfoot", false );
	SetEnableAttackBox( L"Lfoot", false );
	SetEnableAttackBox( L"Lhand2", false );		

	return true;
}
//}}AFX
#endif	NEW_CHARACTER_CHUNG
//}} kimhc // 2010.12.10 //  2010-12-23 New Character CHUNG

/** @function : UpdateWeaponEnchantEffectAndExtraDamageType
	@brief : 무기에 붙는 이펙트, 트레이스, ExtraDamageType을 갱신
*/
/*virtual*/ void CX2GUUser::UpdateWeaponEnchantEffectAndExtraDamageType()
{
	UpdateSlashTraceTextureName();
	DeleteEnchantedWeaponEffectAtHand();
	DeleteEnchantWeaponEffectUnitSpecific( 0 );
	CalcWeaponEnchantExtraDamageType();
	InitEnchantedWeaponEffectAtHand();
	InitEnchantWeaponEffectUnitSpecific();				
#ifdef FIX_SLASH_TRACE
	UpdateSlashTrace();
#endif

#ifdef ADD_UPGRADE_WEAPON_PARTICLE
	BOOST_FOREACH( Weapon* pWeapon, m_vecpWeapon )		/// 강화 무기 이펙트 설정
	{
		if( NULL != pWeapon )
		{
			pWeapon->DeleteUpgradeWeaponParticle();		/// 설정되어 있을지도 모르니, 삭제
			pWeapon->InitUpgradeWeaponParticle();		/// 강화 무기 이펙트 초기화
		}
	}
#endif ADD_UPGRADE_WEAPON_PARTICLE
}

void CX2GUUser::AddEquipToViewList( CX2Item* const pItem )
{
	if ( pItem == NULL || pItem->GetItemTemplet() == NULL )
		return;

	CX2EqipPtr	pCX2EquipPtr;
	int			enchantLevel = 0;

	enchantLevel = pItem->GetItemData().m_EnchantLevel;
	
	bool bBasicEquip = GetUnit()->IsBasicEquip( 
        pItem->GetItemTemplet()->GetItemID()
        );

	if( pItem->GetItemTemplet()->GetUseCondition() == CX2Item::UC_ANYONE )
	{
		pCX2EquipPtr = CX2Eqip::CreateEquip( pItem, m_pXSkinAnim, enchantLevel, bBasicEquip, true, GetUnit()->GetType() );
	}
	else
	{
		pCX2EquipPtr = CX2Eqip::CreateEquip( pItem, m_pXSkinAnim, enchantLevel, bBasicEquip, true );
	}

	pCX2EquipPtr->SetManagerObject( this );
	// 새로운 장비에 특수능력이 붙어 있었다면 특수능력 부여해 주기

	if ( IsRecursivelyManagedByDGManager() )
		g_pKTDXApp->GetDGManager()->AddObjectChain( pCX2EquipPtr.get() );

	m_ViewEqipList.push_back( pCX2EquipPtr );

    const CX2Item::ItemTemplet*	pItemTemplet	= pItem->GetItemTemplet();
	int						weaponIndex		= 0;

	switch ( pItemTemplet->GetEqipPosition() )
	{
	case CX2Unit::EP_WEAPON_HAND:
		weaponIndex = 0;				// InitEqip 부분에서 0과 1로 구분되어 있음
		break;

	case CX2Unit::EP_WEAPON_SECOND:
		weaponIndex = 1;
		break;
	}

	// 새로운 장비가 Weapon 일 경우
	switch ( pItemTemplet->GetEqipPosition() )
	{
	case CX2Unit::EP_WEAPON_HAND:
	case CX2Unit::EP_WEAPON_SECOND:
		{
			Weapon* pWeapon = Weapon::CreateWeapon( *this );
			ASSERT( pWeapon != NULL );

			pWeapon->m_iWeaponIndex			= weaponIndex;
			pWeapon->m_pUserWeaponEquip		= pCX2EquipPtr;
			pWeapon->m_bUseSlashTrace		= true;


#ifdef ITEM_SLASH_TRACE_COLOR_TEST
#ifdef	X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
			if( NULL != GetUnit() )
			{
				pItemTemplet->GetSlashTraceColors( pWeapon->m_coSlashTrace, pWeapon->m_coSlashTraceTip
					, pWeapon->m_coSlashTraceHyper, pWeapon->m_coSlashTraceTipHyper, GetUnit()->GetType() );
			}
#else   //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
			pWeapon->m_coSlashTrace			= pItemTemplet->m_coSlashTrace;
			pWeapon->m_coSlashTraceHyper	= pItemTemplet->m_coSlashTraceHyper;
			pWeapon->m_coSlashTraceTip		= pItemTemplet->m_coSlashTraceTip;
			pWeapon->m_coSlashTraceTipHyper	= pItemTemplet->m_coSlashTraceTipHyper;
#endif  //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
#endif ITEM_SLASH_TRACE_COLOR_TEST


			if( NULL != g_pX2Game &&
				NULL != g_pX2Game->GetMajorParticle() )
			{
                unsigned uNumParticle = pItemTemplet->GetNumAttachedParticleData();
				for( size_t numParticle = 0; numParticle < uNumParticle; numParticle++ )
				{

                    const wchar_t*  pwszParticleName = L"";
                    const wchar_t*  pwszBoneName = L"";
#ifdef	X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
                    pItemTemplet->GetAttachedParticleData( numParticle, &pwszParticleName, &pwszBoneName );
#else   //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
                    const CX2Item::AttachedParticleData& particleData = pItemTemplet->GetAttachedParticleData(numParticle);
                    pwszParticleName = particleData.wstrParticleName.c_str();
                    pwszBoneName = particleData.wstrBoneName.c_str();
#endif  //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
					CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this, pwszParticleName, D3DXVECTOR3( 0, 0, 0 ) );
					if( NULL != pSeq )
					{
						AttachWeaponParticle( pWeapon->m_iWeaponIndex, true, pwszBoneName, pSeq->GetHandle() );
					}
				}
			}

#ifndef	FIX_SLASH_TRACE
			// trace, afterImage 등 생성
			if( m_LuaManager.BeginTable( "INIT_COMPONENT" ) == true )
			{
				pWeapon->LoadDataForUser( m_LuaManager );

				m_LuaManager.EndTable(); // INIT_COMPONENT
			}
#endif	FIX_SLASH_TRACE

			m_vecpWeapon.push_back( pWeapon );
		}		
		break;	// switch ( pItemTemplet->GetEqipPosition() )
	}
}	
void CX2GUUser::RemoveEquipFromViewList( CX2EqipPtr pEquipPtrToRemove, int index )
{
	CX2Unit::EQIP_POSITION	equipPosition	= pEquipPtrToRemove->GetEqipPos();
	int						weaponIndex		= 0;

	
// 	pEquipPtrToRemove->SetManagerObject( NULL );
// 	pEquipPtrToRemove.reset();
	m_ViewEqipList.erase( m_ViewEqipList.begin() + index );

	switch ( equipPosition )
	{
	case CX2Unit::EP_WEAPON_HAND:
		weaponIndex = 0;				// InitEqip 부분에서 0과 1로 구분되어 있음
		break;

	case CX2Unit::EP_WEAPON_SECOND:
		weaponIndex = 1;
		break;
	}

	switch ( equipPosition )
	{
	case CX2Unit::EP_WEAPON_HAND:		// pWeapon->m_iWeaponIndex이 0인것
	case CX2Unit::EP_WEAPON_SECOND:

		for ( size_t numWeapon = 0; numWeapon < m_vecpWeapon.size(); numWeapon++ )								
		{
			Weapon* pWeapon	= m_vecpWeapon[numWeapon];

			if ( pWeapon->m_iWeaponIndex == weaponIndex )
			{										
				m_vecpWeapon.erase( m_vecpWeapon.begin() + numWeapon );
				Weapon::DeleteKTDGObject( pWeapon );

				--numWeapon;	// added by wonpok, 20100318
			}
		}
		
		break;	// switch
	}
}

void CX2GUUser::DeleteEnchantedWeaponEffectAtHand()
{
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqWeaponCommon1 );

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqWeaponCommon2 );

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqWeaponCommon3 );

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqEnchantedWeaponCommon4 );	
}


#endif REAL_TIME_ELSWORD



// note!! 소환 필살기 종류는 게임이 끝난 시점에서 몬스터 생성이 안되므로 필살기 사용이 안되도록 막기 위해서 하드코딩, 
// 소환 필살기 추가되면 추가해줘야 함
bool CX2GUUser::IsSummonSpecialAttack( CX2SkillTree::SKILL_ID iSkillID )
{
	switch( iSkillID )
	{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_EN_DIMENSION_LINK:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EN_DIMENSION_LINK:
#endif //UPGRADE_SKILL_SYSTEM_2013
	case CX2SkillTree::SI_SA_EN_DIMENSION_LINK_BLADER:
	case CX2SkillTree::SI_SA_EN_DIMENSION_LINK_GUARDIAN:
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_EAT_SURFACE_CUTING:
		case CX2SkillTree::SI_A_RNW_ANGER_OF_ELF:	//김창한 엘드랏실의 분노 추가
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EAT_SURFACE_CUTING:
#endif //UPGRADE_SKILL_SYSTEM_2013
	case CX2SkillTree::SI_SA_EAT_SONIC_WAVE:
	case CX2SkillTree::SI_A_LSR_ENTANGLE:

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	case CX2SkillTree::SI_A_ADM_HELL_DROP:
#else //UPGRADE_SKILL_SYSTEM_2013
	case CX2SkillTree::SI_SA_AVP_HELL_DROP:
#endif //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_A_AEM_STONE_WALL:

		//{{ JHKang / 강정훈 / 2010/12/06 / 아토믹 쉴드
#ifdef NEW_SKILL_2010_11
	case CX2SkillTree::SI_SA_ENS_ATOMIC_SHIELD:
#endif NEW_SKILL_2010_11
		//}} JHKang / 강정훈 / 2010/12/06 / 아토믹 쉴드

#ifdef CHUNG_SECOND_CLASS_CHANGE
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_SA_CTT_ARTILLERY_STRIKE:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_CDC_ARTILLERY_STRIKE:
#endif //UPGRADE_SKILL_SYSTEM_2013
#endif

#ifdef SERV_TRAPPING_RANGER_TEST
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_LTR_EVOKE:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_RTR_EVOKE:
#endif //UPGRADE_SKILL_SYSTEM_2013
#endif SERV_TRAPPING_RANGER_TEST

#ifdef SERV_CHUNG_TACTICAL_TROOPER
	case CX2SkillTree::SI_A_CTT_AUTOMATIC_MORTAR: // 박격포
#endif //SERV_CHUNG_TACTICAL_TROOPER
#ifdef SERV_ARME_DIMENSION_WITCH
	case CX2SkillTree::SI_A_ADW_DISTORTION:// 공간 왜곡
#endif
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환
	case CX2SkillTree::SI_SA_CSG_ARTILLERY_STRIKE_QUANTUM_BALLISTA:
#endif //UPGRADE_SKILL_SYSTEM_2013
#ifdef SERV_9TH_NEW_CHARACTER // 김태환
	case CX2SkillTree::SI_SA_AN_PARTICLE_PRISM:
#endif //SERV_9TH_NEW_CHARACTER
		{
			return true;
		} break;
	}

	return false;
}

/** @function : CheckSummonSpecialAttack
	@brief : 소환 필살기 종류를 사용 할 수 있는 상태인지 체크
	@param : iSkillID_ : 체크할 스킬 ID
	@return : 사용 가능 true, 사용 불가능 false
*/
bool CX2GUUser::CheckSummonSpecialAttack( CX2SkillTree::SKILL_ID iSkillID_ )
{
	//소환류 스킬이 아니라면 사용 가능
	if( false == IsSummonSpecialAttack( iSkillID_ ) )
		return true;

	bool bCheck = true;

	if( NULL == g_pX2Game )
		return false;

	switch ( g_pX2Game->GetGameType() )
	{
	case CX2Game::GT_BATTLE_FIELD:
		{
			//필드내 몬스터가 생성되지 않았을 때는 스킬 사용 할 수 없도록.
			if( false == static_cast<CX2BattleFieldGame*>(g_pX2Game)->GetIsNpcLoadComplete() )
				bCheck = false;

			//포탈 위에서는 스킬 사용 할 수 없도록.
			if( true == static_cast<CX2BattleFieldGame*>(g_pX2Game)->IsNearPortalLineMap()	)
				bCheck = false;
		} break;
	default:
		{
			if( true == g_pX2Game->GetGameEnd() )
				bCheck = false;

			if( true == g_pX2Game->GetLastKillCheck() )
				bCheck = false;

			if( true == true == g_pX2Game->GetLastKillCheck() )
				bCheck = false;
		} break;
	}

	if( false == bCheck ) 
	{
		g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, 
			GET_STRING( STR_ID_226 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
	}

	return bCheck;
}




//#ifdef PVP_BOSS_COMBAT_TEST
//	void CX2GUUser::Frozen_StateStart()
//	{
//		CommonStateStart();
//		m_TeamNum = 9;
//		m_iFriendlyHittedCountAtFrozenState = 0;
//	}
//
//	void CX2GUUser::Frozen_StateEnd()
//	{
//		m_TeamNum = m_TeamNumOriginal;
//		m_iFriendlyHittedCountAtFrozenState = 0;
//		CommonStateEnd();
//	}
//
//	void CX2GUUser::Frozen_EventProcess()
//	{
//		const float MAGIC_FROZEN_TIME = 10.f;
//		if( m_FrameDataFuture.unitCondition.fStateTime > MAGIC_FROZEN_TIME )
//		{
//			SetNowHp( GetMaxHp() * 0.5f );
//			StateChange( USI_DAMAGE_AIR_FALL );
//		}
//		else if( true == m_FrameDataFuture.syncData.bIsRight && true == m_InputData.pureLeft )
//		{
//			m_FrameDataFuture.unitCondition.fStateTime += g_pKTDXApp->GetElapsedTime();
//			//m_FrameDataFuture.syncData.bIsRight = !m_FrameDataFuture.syncData.bIsRight;
//		}
//		else if( false == m_FrameDataFuture.syncData.bIsRight && true == m_InputData.pureRight )
//		{
//			m_FrameDataFuture.unitCondition.fStateTime += g_pKTDXApp->GetElapsedTime();
//			//m_FrameDataFuture.syncData.bIsRight = !m_FrameDataFuture.syncData.bIsRight;
//		}
//	}
//#endif PVP_BOSS_COMBAT_TEST



//}} kimhc // 실시간 엘소드 중 실시간 칭호 획득 및 교체 관련 부분 추가

//#ifndef NOT_USE_DICE_ROLL
////////////////////////////////////////////////////////////////////////////
//CX2GUUser::DiceRoll::DiceRoll( CX2GUUser* pGUUser )
//{
//	m_pGUUser = pGUUser;
//
//	m_iNowRollingDiceCount = -1;
//	m_iNowDiceSeqIndex = -1;
//	m_pParticle = NULL;
//	m_hSeqDiceBalloon = INVALID_PARTICLE_SEQUENCE_HANDLE;
//
//
//	//CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;
//	WCHAR wszText[64] = L"";
//	for( int i=0; i<6; i++ )
//	{
//		m_hSeqRollingDice[i]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
//		m_hSeqDice[i]			= INVALID_PARTICLE_SEQUENCE_HANDLE;
//				
//		swprintf( wszText, sizeof(wszText)/sizeof(WCHAR)-1, L"Rolling_Dice_%d", i+1 );
//#ifdef FIX_DICEROLL_CRASH
//		m_hSeqRollingDice[i] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( NULL,  wszText, D3DXVECTOR3(0, 0, 0), 0.f, 0.f );
//#else
//		m_hSeqRollingDice[i] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  wszText, D3DXVECTOR3(0, 0, 0), 0.f, 0.f );
//#endif //FIX_DICEROLL_CRASH
//		//pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqRollingDice[i] );
//		//if( NULL != pSeq )
//		//{
//		//	pSeq->SetTriggerWait( true );
//		//}
//
//		swprintf( wszText, sizeof(wszText)/sizeof(WCHAR)-1, L"Dice_%d", i+1 );
//#ifdef FIX_DICEROLL_CRASH
//		m_hSeqDice[i] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( NULL,  wszText, D3DXVECTOR3(0, 0, 0), 0.f, 0.f );
//#else
//		m_hSeqDice[i] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  wszText, D3DXVECTOR3(0, 0, 0), 0.f, 0.f );
//#endif //FIX_DICEROLL_CRASH
//		//pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqDice[i] );
//		//if( NULL != pSeq )
//		//{
//		//	pSeq->SetTriggerWait( true );
//		//}
//	}
//}
//
//
//CX2GUUser::DiceRoll::~DiceRoll()
//{
//	for( int i=0; i<6; i++ )
//	{
//		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqRollingDice[i] );
//		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hSeqDice[i] );
//
//		m_hSeqRollingDice[i]	= INVALID_PARTICLE_SEQUENCE_HANDLE;		
//		m_hSeqDice[i]			= INVALID_PARTICLE_SEQUENCE_HANDLE;				
//	}
//}
//
//
//
//
//void CX2GUUser::DiceRoll::OnFrameMove( double fTime, float fElapsedTime )
//{
//	const int MAGIC_ROLLING_COUNT = 8;
//
//
//	if( -1 == m_iNowRollingDiceCount )
//	{
//		if( m_vecDiceRoll.size() > 0 )
//		{
//			m_iNowRollingDiceCount = 0;
//
//			if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_hSeqRollingDice[ m_iNowRollingDiceCount%6 ] )
//			{
//#ifdef FIX_DICEROLL_CRASH
//				m_hSeqDiceBalloon = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( NULL,  L"Dice_Balloon", GetParticlePos() );
//#else
//				m_hSeqDiceBalloon = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Dice_Balloon", GetParticlePos() );
//#endif //FIX_DICEROLL_CRASH
//			}
//		}
//		return;
//	}
//
//	if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_hSeqDiceBalloon )
//	{
//		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqDiceBalloon );
//		if( NULL != pSeq )
//		{
//			pSeq->SetPosition( GetParticlePos() );
//		}
//		else
//		{
//			m_hSeqDiceBalloon = INVALID_PARTICLE_SEQUENCE_HANDLE;
//		}
//	}
//
//
//	if( m_iNowRollingDiceCount > MAGIC_ROLLING_COUNT )
//	{
//		if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_hSeqDice[ m_iNowDiceSeqIndex ] )
//		{
//			CKTDGParticleSystem::CParticleEventSequence* pSeq = 
//				g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqDice[ m_iNowDiceSeqIndex ] );
//			if( NULL != pSeq )
//			{
//				if( 0 == pSeq->GetLiveParticleNum() )
//				{
//					m_pParticle = NULL;
//					m_iNowRollingDiceCount = -1;
//
//					if( m_vecDiceRoll.size() > 0 )
//					{
//						m_vecDiceRoll.erase( m_vecDiceRoll.begin() );
//					}
//				}
//				else
//				{
//					m_pParticle->SetPos( GetParticlePos() );
//				}
//			}
//		}
//	}
//	else
//	{
//		if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_hSeqRollingDice[ m_iNowRollingDiceCount%6 ] )
//		{
//			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqRollingDice[ m_iNowRollingDiceCount%6 ] );
//			if( NULL != pSeq )
//			{
//				if( 0 == pSeq->GetLiveParticleNum() )
//				{
//					m_pParticle = NULL;
//					m_iNowRollingDiceCount += 1;
//
//					if( m_iNowRollingDiceCount > MAGIC_ROLLING_COUNT )
//					{
//						if( m_vecDiceRoll.size() > 0 )
//						{
//							// 6
//							if( true == m_vecDiceRoll[0] )
//							{
//								CKTDGParticleSystem::CParticleEventSequence* pSeqDice = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqDice[ 5 ] );
//								if( NULL != pSeqDice )
//								{
//									m_pParticle = pSeqDice->CreateNewParticle( GetParticlePos() );
//									m_iNowDiceSeqIndex = 5;
//								}
//							}
//							else // 6을 제외한 나머지 숫자
//							{
//								int iRandomDice = rand()%5;
//								CKTDGParticleSystem::CParticleEventSequence* pSeqDice = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqDice[ iRandomDice ] );
//								if( NULL != pSeqDice )
//								{
//									m_pParticle = pSeqDice->CreateNewParticle( GetParticlePos() );
//									m_iNowDiceSeqIndex = iRandomDice;
//								}
//							}
//						}
//					}
//					else
//					{
//						CKTDGParticleSystem::CParticleEventSequence* pSeqDice = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hSeqRollingDice[ m_iNowRollingDiceCount%6 ] );
//						if( NULL != pSeqDice )
//						{
//							m_pParticle = pSeqDice->CreateNewParticle( GetParticlePos() );
//						}
//					}
//				}
//				else
//				{
//					m_pParticle->SetPos( GetParticlePos() );
//				}
//			}
//		}
//	}
//}
//
//D3DXVECTOR3 CX2GUUser::DiceRoll::GetParticlePos()
//{
//	if( NULL == m_pGUUser )
//		return D3DXVECTOR3(0, 0, 0);
//
//	D3DXVECTOR3 vPos = m_pGUUser->GetBonePos( L"Bip01_Head" );
//	vPos.y += 100.f;
//
//	D3DXVECTOR3 vDirVector = m_pGUUser->GetDirVector();
//	D3DXVECTOR3 vZVector = GetZVector( vDirVector );
//	vPos += vZVector * (-100.f);
//
//	return vPos;
//}
//
//D3DXVECTOR3 CX2GUUser::DiceRoll::GetZVector( D3DXVECTOR3& vDirVector )
//{
//	D3DXVECTOR3 vZVector;
//
//	vZVector.y = 0.f;
//	vZVector.z = vDirVector.x;
//	vZVector.x = -vDirVector.z;
//
//	D3DXVec3Normalize( &vZVector, &vZVector );
//
//	return vZVector;
//}
//#endif //NOT_USE_DICE_ROLL

//{{ lucidash // 2010.12.14 // 타격잡기 기능. 
#ifdef TEST_GROUP_GRAP
void CX2GUUser::SetGrap(bool val)				
{ 
	if ( m_iGrapShakeCount <= 0 || 
		false == val )
	{
		m_bDisableGravity = false;
		m_bGrap = false;
		return;
	}

	if( GetNowHp() > 0.f )
	{
		StateChange( GetGrapStateID(), true );
		m_PhysicParam.nowSpeed = D3DXVECTOR2( 0, 0 );
		m_bGrap = val;
	}

}

void CX2GUUser::SetGrappedPosition( D3DXVECTOR3 vPos )
{
	m_vGrap = vPos;
	return;
}
void CX2GUUser::SetBeforeGrapPosition( D3DXVECTOR3 vPos )
{
	m_vBeforeGrapPos = vPos;
	return;
}
void CX2GUUser::ResetToBeforeGrapPos()
{
	m_FrameDataFuture.syncData.position				= m_vBeforeGrapPos;
	m_FrameDataNow.syncData.position				= m_vBeforeGrapPos;
	return;
}

#endif TEST_GROUP_GRAP
//}} lucidash // 2010.12.14 // 타격잡기 기능.


#ifdef NEW_GRAPPLE_ATTACK
void CX2GUUser::SetGrappled( bool val )
{
	
	m_bGrappled = val;

}
#endif NEW_GRAPPLE_ATTACK

#ifdef USER_HOLD
void CX2GUUser::SetHold(bool val)				
{ 
#ifdef UPGRADE_RAVEN
	if( GetUnit() != NULL && GetUnit()->GetType() == CX2Unit::UT_RAVEN )
	{
		CX2GURaven *pRaven = (CX2GURaven*)this;
		if( pRaven != NULL &&
			GetRemainHyperModeTime() > 0.f && 
			( pRaven->CanParryingState() == true || pRaven->GetParrying() == true ) &&			
			( pRaven->GetNasodBall() > 0 || pRaven->CanParrying() == true ) &&
			IsSuperArmor() != true &&
			m_FrameDataFuture.unitCondition.bAttackerFront == true )
		{
				return;
		}
	}
#endif
#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	if( GetUnit() != NULL && GetUnit()->GetType() == CX2Unit::UT_EVE )
	{
		CX2GUEve *pEve = static_cast<CX2GUEve*> ( this );
		if( pEve != NULL &&
			GetRemainHyperModeTime() > 0.f && 
			( pEve->CanParryingState() == true || pEve->GetParrying() == true ) &&			
			( pEve->GetManeuverCoreLevel() > 0 || pEve->CanParrying() == true ) &&
			IsSuperArmor() != true &&
			m_FrameDataFuture.unitCondition.bAttackerFront == true )
		{
			return;
		}
	}
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

	if( GetHold() == val )
		return;
	m_bHold = val; 

//{{ kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함
	if(GetHold() == true)
	{
#ifdef RIDING_SYSTEM
		/// 탈것 탑승시 탈것 스테이트로 변경
		if ( true == GetRidingOn() )
			StateChange( USI_RIDING_DAMAGE_FRONT, true );
		else
#endif // RIDING_SYSTEM
			StateChange( GetHoldStateID(), true );
	}
//}} kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함

}

void CX2GUUser::SetPos( D3DXVECTOR3 vPos )
{
	m_vHold = vPos;

#ifdef TEST_GROUP_GRAP
	m_vGrap = vPos;
#endif TEST_GROUP_GRAP

	if( NULL == g_pX2Game ||
		NULL == g_pX2Game->GetWorld() ||
		NULL == g_pX2Game->GetWorld()->GetLineMap() )
	{
		ASSERT( !"CX2GUUser::SetPosition, null world" );
		return; 
	}

	CKTDGLineMap*	pLineMap = g_pX2Game->GetWorld()->GetLineMap();
	D3DXVECTOR3		startPos;

	startPos = vPos;
	int lineIndex = -1;
	D3DXVECTOR3	landPos = vPos;
	landPos = pLineMap->GetLandPosition( startPos, LINE_RADIUS, &lineIndex );
	//pLineMap->IsOnLineConnect( startPos, &lineIndex, LINE_RADIUS, &landPos );
	pLineMap->IsOnLine( startPos, LINE_RADIUS, &startPos, &lineIndex, false );

	const CKTDGLineMap::LineData* pLineData = pLineMap->GetLineData( lineIndex );
	if( NULL == pLineData )
	{
		ASSERT( !"CX2GUUser::SetPosition, null linedata" );
		return; 
	}
	//startPos = landPos;

	//최초 프레임 데이타에 업데이트 한다.

//	THEMIDA_VM_START
	//m_FrameDataFuture.syncData.position				= startPos;
	m_FrameDataFuture.unitCondition.dirDegree			= pLineData->dirDegree;
	m_FrameDataFuture.unitCondition.landPosition		= landPos;
	m_FrameDataFuture.syncData.lastTouchLineIndex		= lineIndex;
	//if( m_FrameDataFuture.syncData.bIsRight == false )
	//	m_FrameDataFuture.unitCondition.dirDegree.y		+= 180.0f;

	//m_FrameDataNow.syncData.position = vPos;
	m_FrameDataNow.syncData.lastTouchLineIndex = lineIndex;

//	THEMIDA_VM_END

	//m_PhysicParam.nowSpeed.x = 0.0f;
	//m_PhysicParam.nowSpeed.y = 0.0f;
}


#endif USER_HOLD







void CX2GUUser::SetPositionOnLine( const D3DXVECTOR3& vPosition, const int iLineIndex )
{
#ifdef ENABLE_SET_UNIT_POSITION_TEST
	ASSERT( NULL != g_pX2Game );
	ASSERT( NULL != g_pX2Game->GetWorld() );
	ASSERT( NULL != g_pX2Game->GetWorld()->GetLineMap() );

	if( NULL == g_pX2Game )
		return;

	if( NULL == g_pX2Game->GetWorld() )
		return; 

	if( NULL == g_pX2Game->GetWorld()->GetLineMap() )
		return;



	const CKTDGLineMap::LineData* pLineData = g_pX2Game->GetWorld()->GetLineMap()->GetLineData( iLineIndex );
	ASSERT( NULL != pLineData );
	if( NULL == pLineData )
		return;


	// 던져지는 캐릭터의 위치를 라인맵 위로 옮겨준다
	D3DXVECTOR3 vPlaneNormal;
	D3DXVec3Cross( &vPlaneNormal, &pLineData->dirVector, &Y_AXIS );
	//D3DXVec3Normalize( &vPlaneNormal, &vPlaneNormal );
	D3DXVECTOR3 vPlaneVertex = pLineData->startPos;

	D3DXVECTOR3 vRayStart = vPosition - vPlaneNormal * 100000.f;

	float fDistance = 0.f;
	D3DXVECTOR3 vIntersection( 0, 0, 0 );
	bool bIntesected = g_pKTDXApp->GetCollision()->RayToPlane( fDistance, vIntersection, vRayStart, vPlaneNormal, vPlaneVertex, vPlaneNormal );
	ASSERT( true == bIntesected );
	if( false == bIntesected )
		return;

	m_FrameDataFuture.syncData.position = vIntersection;
	m_FrameDataFuture.syncData.lastTouchLineIndex = iLineIndex;
	m_FrameDataFuture.unitCondition.dirDegree = pLineData->dirDegree;
	m_FrameDataFuture.unitCondition.dirVector = pLineData->dirVector;
	m_FrameDataFuture.unitCondition.landPosition = vIntersection;


	m_FrameDataNow.syncData.position = vIntersection;
	m_FrameDataNow.syncData.lastTouchLineIndex = iLineIndex;
	m_FrameDataNow.unitCondition.dirDegree = pLineData->dirDegree;
	m_FrameDataNow.unitCondition.dirVector = pLineData->dirVector;
	m_FrameDataNow.unitCondition.landPosition = vIntersection;


	BOOST_TEST_FOREACH( SyncData&, syncData, m_ReceiveSyncDataList )
	{
		syncData.position = vIntersection;
		syncData.lastTouchLineIndex = iLineIndex;
	}

	BOOST_TEST_FOREACH( SyncData&, syncData, m_SendSyncDataList )
	{
		syncData.position = vIntersection;
		syncData.lastTouchLineIndex = iLineIndex;
	}
#endif ENABLE_SET_UNIT_POSITION_TEST
}



void CX2GUUser::SetEnableDash( bool bEnableDash,  CX2GameUnit::ENABLE_DASH_STATE eState /*= EDS_END*/ )
{
	CX2GameUnit::SetEnableDash( bEnableDash, eState );

	if( false == bEnableDash )
	{
		if( USI_DASH == GetGameUnitState()
#ifdef FIX_MEDITATION_RUN
			|| USI_DASH == GetGameUnitStateFuture()
#endif FIX_MEDITATION_RUN			
			)
		{
			StateChange( USI_WALK, true );
		}
	}
}

void CX2GUUser::StateChangeDashIfPossible()
{
	if( true == GetEnableDash() )
	{
#ifdef RIDING_SYSTEM
		if ( true == GetRidingOn() )
			StateChange( USI_RIDING_DASH );
		else
			StateChange( USI_DASH );
#else //RIDING_SYSTEM
		StateChange( USI_DASH );
#endif //RIDING_SYSTEM Dash 변경
#ifdef DUNGEON_DASH_LOG
		++m_iDashCount;
#endif DUNGEON_DASH_LOG
	}
	else
	{
		StateChange( USI_WALK );
	}
}

void CX2GUUser::SetInputData( InputData* pInputData )
{
	m_OrgInputData		= *pInputData;

	if( m_fCanNotAttackTime > 0.0f )
	{				
		pInputData->oneX			= false;
		pInputData->pureX			= false;
		pInputData->oneDoubleX		= false;
		pInputData->pureDoubleX		= false;

		pInputData->oneZ			= false;
		pInputData->pureZ			= false;
		pInputData->oneDoubleZ		= false;
		pInputData->pureDoubleZ		= false;

#ifdef GRAPPLING_TEST
		pInputData->oneF			= false;
		pInputData->pureF			= false;
		pInputData->oneDoubleF		= false;
		pInputData->pureDoubleF		= false;
#endif GRAPPLING_TEST
	}	

	if ( false == m_vecAttackImpossiblePtr.empty() ||
		false == m_vecZXImpossiblePtr.empty() )
	{
		pInputData->oneX			= false;
		pInputData->pureX			= false;
		pInputData->oneDoubleX		= false;
		pInputData->pureDoubleX		= false;

		pInputData->oneZ			= false;
		pInputData->pureZ			= false;
		pInputData->oneDoubleZ		= false;
		pInputData->pureDoubleZ		= false;
	}

#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
	// Z 공격 불가, X 공격 불가 버프 추가
	if ( false == m_vecZImpossiblePtr.empty() )
	{
		pInputData->oneZ			= false;
		pInputData->pureZ			= false;
		pInputData->oneDoubleZ		= false;
		pInputData->pureDoubleZ		= false;
	}

	if ( false == m_vecXImpossiblePtr.empty() )
	{
		pInputData->oneX			= false;
		pInputData->pureX			= false;
		pInputData->oneDoubleX		= false;
		pInputData->pureDoubleX		= false;
	}
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편

	if( false == m_vecAttackImpossiblePtr.empty() ||
		false == m_vecSkillImpossiblePtr.empty() )
	{
		pInputData->oneA			= false;
		pInputData->pureA			= false;
		pInputData->oneDoubleA		= false;
		pInputData->pureDoubleA		= false;

		pInputData->oneS			= false;
		pInputData->pureS			= false;
		pInputData->oneDoubleS		= false;
		pInputData->pureDoubleS		= false;

		pInputData->oneD			= false;
		pInputData->pureD			= false;
		pInputData->oneDoubleD		= false;
		pInputData->pureDoubleD		= false;

		pInputData->oneC			= false;
		pInputData->pureC			= false;
		pInputData->oneDoubleC		= false;
		pInputData->pureDoubleC		= false;

		pInputData->oneC			= false;
		pInputData->pureC			= false;
		pInputData->oneDoubleC		= false;
		pInputData->pureDoubleC		= false;

		pInputData->oneQ			= false;
		pInputData->pureQ			= false;
		pInputData->oneDoubleQ		= false;
		pInputData->pureDoubleQ		= false;

		pInputData->oneW			= false;
		pInputData->pureW			= false;
		pInputData->oneDoubleW		= false;
		pInputData->pureDoubleW		= false;

		pInputData->oneE			= false;
		pInputData->pureE			= false;
		pInputData->oneDoubleE		= false;
		pInputData->pureDoubleE		= false;

		pInputData->oneR			= false;
		pInputData->pureR			= false;
		pInputData->oneDoubleR		= false;
		pInputData->pureDoubleR		= false;
	}

	if ( !m_vecDownImpossiblePtr.empty() )
	{
		pInputData->oneDown			= false;
		pInputData->pureDown		= false;
		pInputData->oneDoubleDown	= false;
		pInputData->pureDoubleDown	= false;
	}

	if( m_fCanNotJumpTime > 0.0f )
	{				
		pInputData->oneUp			= false;
		pInputData->pureUp			= false;
		pInputData->oneDoubleUp		= false;
		pInputData->pureDoubleUp	= false;			
	}

	if( !m_vecDashImpossiblePtr.empty() )
	{
		pInputData->oneDoubleRight	= false;
		pInputData->oneDoubleLeft	= false;
		pInputData->pureDoubleRight	= false;
		pInputData->pureDoubleLeft	= false;
	}

	if( m_ExtraDamagePack.m_Slow.m_fTime > 0.0f )
	{
		pInputData->oneDoubleRight	= false;
		pInputData->oneDoubleLeft	= false;
		pInputData->pureDoubleRight	= false;
		pInputData->pureDoubleLeft	= false;
	}

	if ( !m_vecReverseLeftRightPtr.empty() )
	{
		if ( m_vecReverseLeftRightPtr[0]->GetReverse() )
		{
			std::swap( pInputData->pureLeft,		pInputData->pureRight );
			std::swap( pInputData->oneLeft,			pInputData->oneRight );
			std::swap( pInputData->pureDoubleLeft,  pInputData->pureDoubleRight );
			std::swap( pInputData->oneDoubleLeft,	pInputData->oneDoubleRight );
		}
	}	

	//{{ 2011-04 에 패치될 청 캐시 스킬
#ifdef	CASH_SKILL_FOR_CHUNG_2011_04				
	if ( 0.0f < m_ExtraDamagePack.m_Panic.m_fTime  )
	{
		m_ExtraDamagePack.m_Panic.m_fElapsedTimeToEffectDamage += m_fElapsedTime;

		if ( 2.0f < m_ExtraDamagePack.m_Panic.m_fElapsedTimeToEffectDamage )
		{
			m_ExtraDamagePack.m_Panic.m_fElapsedTimeToEffectDamage = 0.0f;
			m_ExtraDamagePack.m_Panic.m_bCorrectDirection = !( m_ExtraDamagePack.m_Panic.m_bCorrectDirection );
		}		

		if ( false == m_ExtraDamagePack.m_Panic.m_bCorrectDirection )
		{
			std::swap( pInputData->pureLeft,		pInputData->pureRight );
			std::swap( pInputData->oneLeft,			pInputData->oneRight );
			std::swap( pInputData->pureDoubleLeft,  pInputData->pureDoubleRight );
			std::swap( pInputData->oneDoubleLeft,	pInputData->oneDoubleRight );
		}
	}
#endif	CASH_SKILL_FOR_CHUNG_2011_04				
	//}} 2011-04 에 패치될 청 캐시 스킬

	m_BeforeInputData	= m_InputData;
	m_InputData			= *pInputData;	// kimhc // m_InputData는 GUUser의 InputData, pInputData가 가리키는 m_InputData는 X2Game의 InputData 이다.

#ifdef FIX_SHOOTING_MEGABALL_AT_JUMP_LINE_MAP
	InitInpuDataProcess();
#else
	if( m_fCanNotInputTimeZXArrow > 0.f )
	{
		m_InputData.Init_ZXArrowOnly();
	}

	if( true == IsCanNotIntput() )
	{
		m_InputData.Init();
	}
#endif // FIX_SHOOTING_MEGABALL_AT_JUMP_LINE_MAP

//#ifdef TRANSFORMER_TEST
//
//	if( true == GetTransformed() &&
//		NULL != GetTransformer() )
//	{
//		GetTransformer()->SetInputData( &m_InputData );
//		
//		m_InputData.Init();
//
//	}
//
//#endif TRANSFORMER_TEST

}




// commmoncameramove 함수에 다가 합쳤음
//void CX2GUUser::PlayLuaSubCamera( int iCameraTableIndex )
//{
//	std::vector< float > vecSubCameraTiming;
//
//	if( m_LuaManager.BeginTable( "CAMERA", iCameraTableIndex ) == true )
//	{
//		if( m_LuaManager.BeginTable( "SUB_CAMERA_TIMING" ) == true )
//		{
//			float fSubCameraTiming = 0.f;
//			for( int i=1; ; i++ )
//			{
//				if( true == m_LuaManager.GetValue( i, fSubCameraTiming ) )
//				{
//					vecSubCameraTiming.push_back( fSubCameraTiming );
//				}
//				else
//				{
//					break;
//				}
//			}
//			m_LuaManager.EndTable(); // SUB_CAMERA_TIMING
//		}
//
//		if( false == vecSubCameraTiming.empty() )
//		{
//			bool bDone = false;
//			for( int i=0; i<(int)vecSubCameraTiming.size(); i++ )
//			{
//				float fTiming = vecSubCameraTiming[i];
//
//				if( m_pXSkinAnim->GetNowAnimationTime() < fTiming )
//				{
//					char tableName[64] = L"";
//					StringCchPrintfA( tableName, ARRAY_SIZE(tableName), "SUB_CAMERA%d", i );
//					g_pX2Game->GetX2Camera()->PlayLuaCamera( this, m_LuaManager, tableName );
//					bDone = true;
//					break;
//				}
//			}
//
//			if( false == bDone )
//			{
//				char tableName[64] = L"";
//				StringCchPrintfA( tableName, ARRAY_SIZE(tableName), "SUB_CAMERA%d", (int)vecSubCameraTiming.size() );
//				g_pX2Game->GetX2Camera()->PlayLuaCamera( this, m_LuaManager, tableName );
//			}
//		}
//
//		m_LuaManager.EndTable(); // CAMERA
//	}
//}
//
//

void CX2GUUser::InitStateCommonRandom( OUT std::string &tableNameStartUTF8, OUT std::string &tableNameWinUTF8, OUT std::string &tableNameLoseUTF8 )
{

	int iRandomPercent = rand() % 100;
	int iAccumulatedPercent = 0;
	BOOST_TEST_FOREACH( const CommonRandomState&, commonRandomState, m_vecRandomStartState )
	{
		iAccumulatedPercent += commonRandomState.m_iPercent;
		if( iRandomPercent < iAccumulatedPercent )
		{
			tableNameStartUTF8 = commonRandomState.m_StateName;
			break;
		}
	}
	ASSERT( false == tableNameStartUTF8.empty() );




	iRandomPercent = rand() % 100;
	iAccumulatedPercent = 0;
	BOOST_TEST_FOREACH( const CommonRandomState&, commonRandomState, m_vecRandomWinState )
	{
		iAccumulatedPercent += commonRandomState.m_iPercent;
		if( iRandomPercent < iAccumulatedPercent )
		{
			tableNameWinUTF8 = commonRandomState.m_StateName;
			break;
		}
	}
	ASSERT( false == tableNameWinUTF8.empty() );



	iRandomPercent = rand() % 100;
	iAccumulatedPercent = 0;
	BOOST_TEST_FOREACH( const CommonRandomState&, commonRandomState, m_vecRandomLoseState )
	{
		iAccumulatedPercent += commonRandomState.m_iPercent;
		if( iRandomPercent < iAccumulatedPercent )
		{
			tableNameLoseUTF8 = commonRandomState.m_StateName;
			break;
		}
	}
	ASSERT( false == tableNameLoseUTF8.empty() );
}

bool CX2GUUser::DoScaleHeadBone()
{
#if 0 // edt_bighead 유저에게 적용시 reform 스케일과 총돌로 유저에게는 사용하면 안됨
	if( m_pXSkinAnim != NULL && m_fExtraBigHead > 0.f )
	{
		CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
		if(pFrame != NULL && pFrame->m_bScale == false)
		{
			D3DXVECTOR3 vScale = D3DXVECTOR3(1.5f, 1.5f, 1.5f);
			SetFrameScale(&vScale, true, pFrame);

			return true;
		}		
	}
	else if( m_pXSkinAnim != NULL )
	{
		CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
		if(pFrame != NULL && pFrame->m_bScale == true)
		{
			SetFrameScaleRestore(pFrame);
		}
	}
#endif
	return false;
}

#ifdef DUNGEON_ITEM
void CX2GUUser::ScaleHead()
{
	if( m_pXSkinAnim != NULL )
	{
		CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
		if( pFrame != NULL )
		{
			D3DXVECTOR3 vScale = D3DXVECTOR3(2.0f, 2.0f, 2.0f);
			SetFrameScale(&vScale, false, pFrame);
		}

		pFrame = m_pXSkinAnim->GetCloneFrame(L"COLLISION_SPHERE1_Face");
		if(pFrame != NULL )
		{
			D3DXVECTOR3 vScale = D3DXVECTOR3(1.8f, 1.8f, 1.8f);
			SetFrameScale(&vScale, false, pFrame);
		}
	}
}

void CX2GUUser::RestoreHead()
{
	CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame = m_pXSkinAnim->GetCloneFrame(L"COLLISION_SPHERE1_Face");
	if(pFrame != NULL)
	{
		SetFrameScaleRestore(pFrame);
		//D3DXVECTOR3 vScale = D3DXVECTOR3(1.0f, 1.0f, 1.0f);
		//SetFrameScale(&vScale, false, pFrame);
	}

	pFrame = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
	if(pFrame != NULL)
	{
		SetFrameScaleRestore(pFrame);
	}

	SetUnitReForm();	
}

#endif

#ifdef SERV_NEW_DEFENCE_DUNGEON	// 적용날짜: 2013-04-01

/** @function	: ScaleHand
	@brief		: 어둠의 문 비약 효과로 인한 손 및 무기 스케일 증가
*/
void CX2GUUser::ScaleHand( D3DXVECTOR3 vChangeScale )
{
	if( m_pXSkinAnim != NULL )
	{
		const wstring wstrBoneName[] = { L"Bip01_R_Hand", L"Bip01_L_Hand" };

		CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame = NULL;

		for ( int i = 0; i < ARRAY_SIZE( wstrBoneName ); ++i )
		{
			pFrame = m_pXSkinAnim->GetCloneFrame( wstrBoneName[i].c_str() );

			if(pFrame != NULL)
				SetFrameScale(&vChangeScale, true, pFrame);
		}

		/// 이브는 따로 기어 크기를 증가시켜 주자
		if ( NULL != GetUnit() && CX2Unit::UT_EVE == GetUnit()->GetType() )
		{
			pFrame = m_pXSkinAnim->GetCloneFrame( L"Dummy1_Rhand" );

			if(pFrame != NULL)
				SetFrameScale(&vChangeScale, true, pFrame);

			pFrame = m_pXSkinAnim->GetCloneFrame( L"Dummy2_Lhand" );

			if(pFrame != NULL)
				SetFrameScale(&vChangeScale, true, pFrame);
		}
	}
}

/** @function	: RestoreHand
	@brief		: 어둠의 문 비약 효과로 인하여 증가된 손 및 무기 스케일 복구
*/
void CX2GUUser::RestoreHand()
{
	const wstring wstrBoneName[] = { L"Bip01_R_Hand", L"Bip01_L_Hand" };

	CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame = NULL;

	for ( int i = 0; i < ARRAY_SIZE( wstrBoneName ); ++i )
	{
		pFrame = m_pXSkinAnim->GetCloneFrame( wstrBoneName[i].c_str() );

		if(pFrame != NULL)
			SetFrameScaleRestore(pFrame);
	}

	/// 이브의 커진 기어 크기를 복구 시키자
	if ( NULL != GetUnit() && CX2Unit::UT_EVE == GetUnit()->GetType() )
	{
		pFrame = m_pXSkinAnim->GetCloneFrame( L"Dummy1_Rhand" );

		if(pFrame != NULL)
			SetFrameScaleRestore(pFrame);

		pFrame = m_pXSkinAnim->GetCloneFrame( L"Dummy2_Lhand" );

		if(pFrame != NULL)
			SetFrameScaleRestore(pFrame);
	}

	SetUnitReForm();	
}
#endif // SERV_NEW_DEFENCE_DUNGEON

#ifdef ELSWORD_SECOND_CLASS_CHANGE
void CX2GUUser::SetUnitReForm()
{
	if( m_pXSkinAnim == NULL )
		return;
	
	float fMoveBip01 = 10.f;
	float fMoveFootStep = -15.f;
	D3DXVECTOR3 vHead = D3DXVECTOR3(1.f, 1.f, 1.f);
	D3DXVECTOR3 vThigh = D3DXVECTOR3(1.f, 1.f, 1.f);
	D3DXVECTOR3 vCalf = D3DXVECTOR3(1.f, 1.f, 1.f);
	D3DXVECTOR3 vFoot = D3DXVECTOR3(1.f, 1.f, 1.f);
	D3DXVECTOR3 vHand = D3DXVECTOR3(1.f, 1.f, 1.f);	
	D3DXVECTOR3 vSpine = D3DXVECTOR3(1.f, 1.f, 1.f);	

#ifndef _SERVICE_
	// 실시간 테스트용
	FILE *fp = fopen("reform.txt", "r");	
	if(fp != NULL)
	{
		fscanf(fp, "%f%f", &fMoveBip01, &fMoveFootStep);
		fscanf(fp, "%f%f%f", &vHead.x, &vHead.y, &vHead.z);
		fscanf(fp, "%f%f%f", &vThigh.x, &vThigh.y, &vThigh.z);
		fscanf(fp, "%f%f%f", &vCalf.x, &vCalf.y, &vCalf.z);
		fscanf(fp, "%f%f%f", &vFoot.x, &vFoot.y, &vFoot.z);
		fscanf(fp, "%f%f%f", &vHand.x, &vHand.y, &vHand.z);
		fscanf(fp, "%f%f%f", &vSpine.x, &vSpine.y, &vSpine.z);

		fclose(fp);
	}
#endif

#ifdef UNIT_SCALE_COMBINE_ONE
	if ( m_pUnit != NULL )
	{
		#ifdef MOVE_BONE
		switch ( m_pUnit->GetType() )
		{
		case CX2Unit::UT_ELSWORD:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01" ), 10.f );
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01_Footsteps" ), -10.f );

				D3DXVECTOR3 vHead	= D3DXVECTOR3( 0.93f, 0.90f, 0.93f );
				D3DXVECTOR3 vThigh	= D3DXVECTOR3( 1.08f, 1.f, 0.98f );
				D3DXVECTOR3 vCalf	= D3DXVECTOR3( 1.12f, 0.97f, 0.94f );
				D3DXVECTOR3 vFoot	= D3DXVECTOR3( 0.895f, 0.94f, 0.94f );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );
				if ( pFrameHead != NULL )
					SetFrameScale( &vHead, true, pFrameHead );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Thigh" );
				if ( pFrame_R_Leg != NULL )
					SetFrameScale( &vThigh, true, pFrame_R_Leg );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Thigh" );
				if ( pFrame_L_Leg != NULL )
					SetFrameScale( &vThigh, true, pFrame_L_Leg );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Calf" );
				if ( pFrame_R_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_R_Calf );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Calf" );
				if ( pFrame_L_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_L_Calf );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Foot" );
				if ( pFrame_R_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_R_Foot );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Foot" );
				if ( pFrame_L_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_L_Foot );
			} break;

		case CX2Unit::UT_ARME:
			{
				if( IsTransformed() )
				{
					SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), 5.f);
					SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), 5.f);
				}
				else
				{
					SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01" ), 4.f );
					SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01_Footsteps" ), -4.f );
				}

				D3DXVECTOR3 vHead		= D3DXVECTOR3( 0.95f, 0.93f, 0.93f );
				D3DXVECTOR3 vThigh		= D3DXVECTOR3( 1.f, 1.f, 1.f );
				D3DXVECTOR3 vCalf		= D3DXVECTOR3( 1.1f, 1.f, 1.f );
				D3DXVECTOR3 vHand		= D3DXVECTOR3( 0.9f, 0.93f, 0.93f );
				D3DXVECTOR3 vFoot		= D3DXVECTOR3( 0.9f, 1.f, 1.f );
				D3DXVECTOR3 vDummyHand	= D3DXVECTOR3( 1.f, 1.f, 1.f );

				m_fBasicBoneScale = 1.f;

				if( IsTransformed() )
				{
					m_fBasicBoneScale = 1.1f;
					vHead = D3DXVECTOR3( 0.93f, 0.88f, 0.9f );
					vThigh = D3DXVECTOR3( 1.04f, 1.f, 1.f );
					vCalf = D3DXVECTOR3( 1.1f, 1.f, 1.f );
					vFoot = D3DXVECTOR3( 0.9f, 1.f, 0.9f );
					vHand = D3DXVECTOR3( 0.8f, 0.86f, 0.86f );
				}

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );
				if ( pFrameHead != NULL )
					SetFrameScale( &vHead, true, pFrameHead );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Thigh" );
				if ( pFrame_R_Leg != NULL )
					SetFrameScale( &vThigh, true, pFrame_R_Leg );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Thigh" );
				if ( pFrame_L_Leg != NULL )
					SetFrameScale( &vThigh, true, pFrame_L_Leg );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Calf" );
				if ( pFrame_R_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_R_Calf );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Calf" );
				if ( pFrame_L_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_L_Calf );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Foot" );
				if ( pFrame_R_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_R_Foot );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Foot" );
				if ( pFrame_L_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_L_Foot );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Hand = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Hand" );
				if ( pFrame_R_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_R_Hand );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Hand = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Hand" );
				if ( pFrame_L_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_L_Hand );

				vDummyHand.x = 1.f / vHand.x;
				vDummyHand.y = 1.f / vHand.y;
				vDummyHand.z = 1.f / vHand.z;

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy1_Rhand" );
				if ( pFrame_R_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_R_Dummy );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy2_Lhand" );
				if ( pFrame_L_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_L_Dummy );
			}

		case CX2Unit::UT_LIRE:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01" ), 1.0f );
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01_Footsteps" ), -1.0f );

				D3DXVECTOR3 vHead = D3DXVECTOR3( 0.94f, 0.92f, 0.90f );
				D3DXVECTOR3 vThigh = D3DXVECTOR3( 1.02f, 1.f, 1.f );
				D3DXVECTOR3 vCalf = D3DXVECTOR3( 1.02f, 1.f, 1.f );
				D3DXVECTOR3 vFoot = D3DXVECTOR3( 0.93f, 0.93f, 0.93f );
				D3DXVECTOR3 vHand = D3DXVECTOR3( 0.9f, 0.9f, 0.9f );
				D3DXVECTOR3 vDummyHand = D3DXVECTOR3( 1.f, 1.f, 1.f );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );
				if ( pFrameHead != NULL )
					SetFrameScale( &vHead, true, pFrameHead );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Thigh" );
				if ( pFrame_R_Leg != NULL )
					SetFrameScale( &vThigh, true, pFrame_R_Leg );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Thigh" );
				if ( pFrame_L_Leg != NULL )
					SetFrameScale( &vThigh, true, pFrame_L_Leg );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Calf" );
				if ( pFrame_R_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_R_Calf );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Calf" );
				if ( pFrame_L_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_L_Calf );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Foot" );
				if ( pFrame_R_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_R_Foot );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Foot" );
				if ( pFrame_L_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_L_Foot );		

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Hand");
				if ( pFrame_R_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_R_Hand );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Hand = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Hand" );
				if ( pFrame_L_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_L_Hand );

				vDummyHand.x = 1.f / vHand.x;
				vDummyHand.y = 1.f / vHand.y;
				vDummyHand.z = 1.f / vHand.z;

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy1_Rhand" );
				if ( pFrame_R_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_R_Dummy );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy2_Lhand" );
				if ( pFrame_L_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_L_Dummy );	
			} break;

		case CX2Unit::UT_RAVEN:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01" ), 5.0f );
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01_Footsteps" ), -5.0f );

				D3DXVECTOR3 vHead = D3DXVECTOR3( 0.88f, 0.9f, 0.92f );
				D3DXVECTOR3 vThigh = D3DXVECTOR3( 1.05f, 0.94f, 0.92f );
				D3DXVECTOR3 vCalf = D3DXVECTOR3( 1.065f, 0.93f, 0.9f );
				D3DXVECTOR3 vFoot = D3DXVECTOR3( 0.93f, 0.85f, 0.83f );
				D3DXVECTOR3 vDummyHand = D3DXVECTOR3( 1.f, 1.f, 1.f );
				D3DXVECTOR3 vSpine = D3DXVECTOR3( 0.94f, 0.97f, 1.f );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );
				if ( pFrameHead != NULL )
					SetFrameScale( &vHead, true, pFrameHead );		

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Thigh" );
				if ( pFrame_R_Leg != NULL )
					SetFrameScale( &vThigh, true, pFrame_R_Leg );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Thigh" );
				if ( pFrame_L_Leg != NULL )
					SetFrameScale( &vThigh, true, pFrame_L_Leg );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Calf" );
				if ( pFrame_R_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_R_Calf );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Calf" );
				if ( pFrame_L_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_L_Calf );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Foot" );
				if ( pFrame_R_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_R_Foot );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Foot" );
				if ( pFrame_L_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_L_Foot );		

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameSpine = m_pXSkinAnim->GetCloneFrame( L"Bip01_Spine" );
				if ( pFrameSpine != NULL )
					SetFrameScale( &vSpine, false, pFrameSpine );
			} break;

		case CX2Unit::UT_EVE:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01" ), -0.8f );
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01_Footsteps" ), 0.8f );

				D3DXVECTOR3 vHead = D3DXVECTOR3( 0.94f, 0.97f, 0.98f );
				D3DXVECTOR3 vThigh = D3DXVECTOR3( 1.0f, 0.98f, 0.98f );
				D3DXVECTOR3 vCalf = D3DXVECTOR3( 1.0f, 0.98f, 0.98f );
				D3DXVECTOR3 vFoot = D3DXVECTOR3( 0.95f, 0.95f, 0.95f );
				D3DXVECTOR3 vHand = D3DXVECTOR3( 0.9f, 0.96f, 0.96f );		
				D3DXVECTOR3 vDummyHand = D3DXVECTOR3( 1.f, 1.f, 1.f );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );
				if ( pFrameHead != NULL )
					SetFrameScale( &vHead, true, pFrameHead );		

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Thigh" );
				if ( pFrame_R_Leg != NULL )
					SetFrameScale( &vThigh, true, pFrame_R_Leg );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Thigh" );
				if ( pFrame_L_Leg != NULL )
					SetFrameScale( &vThigh, true, pFrame_L_Leg );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Calf" );
				if ( pFrame_R_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_R_Calf );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Calf" );
				if ( pFrame_L_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_L_Calf );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Foot");
				if(pFrame_R_Foot != NULL)
					SetFrameScale(&vFoot, true, pFrame_R_Foot);
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Foot");
				if(pFrame_L_Foot != NULL)
					SetFrameScale(&vFoot, true, pFrame_L_Foot);		

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Hand = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Hand" );
				if ( pFrame_R_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_R_Hand );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Hand = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Hand" );
				if ( pFrame_L_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_L_Hand );		

				vDummyHand.x = 1.f;
				vDummyHand.y = 1.f;
				vDummyHand.z = 1.f;

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy1_Rhand" );
				if ( pFrame_R_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_R_Dummy );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy2_Lhand" );
				if ( pFrame_L_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_L_Dummy );
			} break;

		case CX2Unit::UT_CHUNG:
			{
				D3DXVECTOR3 vHead = D3DXVECTOR3( 0.93f, 0.93f, 0.93f );
				D3DXVECTOR3 vDummyHand = D3DXVECTOR3( 0.92f, 0.92f, 0.92f );
				m_fBasicBoneScale = 1.08f;
				float fScale = m_fBasicBoneScale;

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );
				if ( pFrameHead != NULL )
					SetFrameScale( &vHead, true, pFrameHead );		

				vDummyHand = vDummyHand / fScale;

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy1_Rhand" );
				if ( pFrame_R_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_R_Dummy );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy2_Lhand" );
				if ( pFrame_L_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_L_Dummy );

				m_pXSkinAnim->GetMatrix().Scale( D3DXVECTOR3( fScale, fScale, fScale ) );

				pFrameHead = m_pXSkinAnimFuture->GetCloneFrame( L"Bip01_Head" );
				if ( pFrameHead != NULL )
					SetFrameScale( &vHead, true, pFrameHead );		
				pFrame_R_Dummy = m_pXSkinAnimFuture->GetCloneFrame( L"Dummy1_Rhand" );
				if ( pFrame_R_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_R_Dummy );
				pFrame_L_Dummy = m_pXSkinAnimFuture->GetCloneFrame( L"Dummy2_Lhand" );
				if ( pFrame_L_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_L_Dummy );

				m_pXSkinAnimFuture->GetMatrix().Scale( D3DXVECTOR3( fScale, fScale, fScale ) );
			} break;

		case CX2Unit::UT_ARA:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01" ), 2.0f );
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01_Footsteps" ), -2.0f );

				D3DXVECTOR3 vHead = D3DXVECTOR3( 0.96f, 0.96f, 0.96f );
				D3DXVECTOR3 vCalf = D3DXVECTOR3( 1.02f, 1.f, 1.f );
				D3DXVECTOR3 vFoot = D3DXVECTOR3( 1.0f, 0.96f, 0.96f );
				D3DXVECTOR3 vHand = D3DXVECTOR3( 0.96f, 0.96f, 0.96f );	
				D3DXVECTOR3 vDummyHand = D3DXVECTOR3( 1.f, 1.f, 1.f );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );
				if ( pFrameHead != NULL )
					SetFrameScale( &vHead, true, pFrameHead );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Calf" );
				if ( pFrame_R_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_R_Calf );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Calf" );
				if ( pFrame_L_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_L_Calf );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Foot" );
				if ( pFrame_R_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_R_Foot );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Foot" );
				if ( pFrame_L_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_L_Foot );		

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Hand");
				if ( pFrame_R_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_R_Hand );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Hand = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Hand" );
				if ( pFrame_L_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_L_Hand );

				vDummyHand.x = 1.f / vHand.x;
				vDummyHand.y = 1.f / vHand.y;
				vDummyHand.z = 1.f / vHand.z;

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy1_Rhand" );
				if ( pFrame_R_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_R_Dummy );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy2_Lhand" );
				if ( pFrame_L_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_L_Dummy );	
			} break;

		case CX2Unit::UT_ELESIS:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01" ), 2.0f );
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01_Footsteps" ), -2.0f );

				D3DXVECTOR3 vHead = D3DXVECTOR3( 0.96f, 0.96f, 0.96f );
				D3DXVECTOR3 vCalf = D3DXVECTOR3( 1.02f, 1.f, 1.f );
				D3DXVECTOR3 vFoot = D3DXVECTOR3( 1.0f, 0.96f, 0.96f );
				D3DXVECTOR3 vHand = D3DXVECTOR3( 0.96f, 0.96f, 0.96f );	
				D3DXVECTOR3 vDummyHand = D3DXVECTOR3( 1.f, 1.f, 1.f );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );
				if ( pFrameHead != NULL )
					SetFrameScale( &vHead, true, pFrameHead );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Calf" );
				if ( pFrame_R_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_R_Calf );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Calf" );
				if ( pFrame_L_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_L_Calf );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Foot" );
				if ( pFrame_R_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_R_Foot );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Foot" );
				if ( pFrame_L_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_L_Foot );		

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Hand");
				if ( pFrame_R_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_R_Hand );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Hand = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Hand" );
				if ( pFrame_L_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_L_Hand );

				vDummyHand.x = 1.f / vHand.x;
				vDummyHand.y = 1.f / vHand.y;
				vDummyHand.z = 1.f / vHand.z;

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy1_Rhand" );
				if ( pFrame_R_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_R_Dummy );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy2_Lhand" );
				if ( pFrame_L_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_L_Dummy );	
			} break;

		#ifdef SERV_9TH_NEW_CHARACTER // JHKang
		case CX2Unit::UT_ADD:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01" ), 2.0f );
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame( L"Bip01_Footsteps" ), -2.0f );

				D3DXVECTOR3 vHead = D3DXVECTOR3( 0.93f, 0.93f, 0.93f );
				D3DXVECTOR3 vCalf = D3DXVECTOR3( 1.02f, 1.f, 1.f );
				D3DXVECTOR3 vFoot = D3DXVECTOR3( 1.0f, 0.96f, 0.96f );
				D3DXVECTOR3 vHand = D3DXVECTOR3( 0.96f, 0.96f, 0.96f );	
				D3DXVECTOR3 vDummyHand = D3DXVECTOR3( 1.f, 1.f, 1.f );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame( L"Bip01_Head" );
				if ( pFrameHead != NULL )
					SetFrameScale( &vHead, true, pFrameHead );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Calf" );
				if ( pFrame_R_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_R_Calf );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Calf" );
				if ( pFrame_L_Calf != NULL )
					SetFrameScale( &vCalf, true, pFrame_L_Calf );

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_R_Foot" );
				if ( pFrame_R_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_R_Foot );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Foot" );
				if ( pFrame_L_Foot != NULL )
					SetFrameScale( &vFoot, true, pFrame_L_Foot );		

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Hand");
				if ( pFrame_R_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_R_Hand );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Hand = m_pXSkinAnim->GetCloneFrame( L"Bip01_L_Hand" );
				if ( pFrame_L_Hand != NULL )
					SetFrameScale( &vHand, true, pFrame_L_Hand );

				vDummyHand.x = 1.f / vHand.x;
				vDummyHand.y = 1.f / vHand.y;
				vDummyHand.z = 1.f / vHand.z;

				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy1_Rhand" );
				if ( pFrame_R_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_R_Dummy );
				CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame( L"Dummy2_Lhand" );
				if ( pFrame_L_Dummy != NULL )
					SetFrameScale( &vDummyHand, true, pFrame_L_Dummy );	
			} break;
		#endif

		default:
			break;
		}
		#endif //MOVE_BONE	
	}
#else //UNIT_SCALE_COMBINE_ONE
#ifdef MOVE_BONE
	if( GetUnit() != NULL )
	{
		switch( GetUnit()->GetType() )
		{
		case CX2Unit::UT_LIRE:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), 1.0f);
				SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), 1.0f);
				//SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01_Footsteps"), -0.4f);
			}
			break;
	#ifdef RAVEN_SECOND_CLASS_CHANGE
		case CX2Unit::UT_RAVEN:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), 7.0f);				
				SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), 7.0f);
				//SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01_Footsteps"),-2.0f);
			}
			break;
	#endif
	#ifdef EVE_SECOND_CLASS_CHANGE
		case CX2Unit::UT_EVE:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), -0.8f);				
				SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), -0.8f);
				//SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01_Footsteps"),-2.0f);
			}
			break;
	#endif

		default:
			break;
		}

		switch( GetUnit()->GetClass() )
		{
	#ifdef ELSWORD_SHEATH_KNIGHT
		case CX2Unit::UC_ELSWORD_SWORDMAN:
			{

				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), 2.f );
				//SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01_Footsteps"), fMoveFootStep );
				SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), 2.f );
				//SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Footsteps"), fMoveFootStep );
			}
			break;
		case CX2Unit::UC_ELSWORD_KNIGHT:
		case CX2Unit::UC_ELSWORD_MAGIC_KNIGHT:
		case CX2Unit::UC_ELSWORD_SHEATH_KNIGHT:
	#endif ELSWORD_SHEATH_KNIGHT
		case CX2Unit::UC_ELSWORD_LORD_KNIGHT:
		case CX2Unit::UC_ELSWORD_RUNE_SLAYER:
	#ifdef SERV_ELSWORD_INFINITY_SWORD
		case CX2Unit::UC_ELSWORD_INFINITY_SWORD:
	#endif
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), 10.f);
				//SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01_Footsteps"), fMoveFootStep);
				SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), 10.f);
				//SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Footsteps"), fMoveFootStep);
			}
			break;
		case CX2Unit::UC_ARME_ELEMENTAL_MASTER:
		case CX2Unit::UC_ARME_VOID_PRINCESS:
			{
				SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), 3.f);
				SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), 3.f);
			}
			break;
	#ifdef SERV_ADD_ARME_BATTLE_MAGICIAN
		case CX2Unit::UC_ARME_BATTLE_MAGICIAN:
			{
				if( IsTransformed() )
				{
					SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), 5.f);
					SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), 5.f);
				}
				else
				{
					SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), 0.f);
					SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), 0.f);
				}				
			}
			break;
	#endif
	#ifdef SERV_ARME_DIMENSION_WITCH
		case CX2Unit::UC_ARME_DIMENSION_WITCH:
			{
				if( IsTransformed() )
				{
					SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), 5.f);
					SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), 5.f);
				}
				else
				{
					SetFrameMoveBoneY( m_pXSkinAnim->GetCloneFrame(L"Bip01"), 3.f);
					SetFrameMoveBoneY( m_pXSkinAnimFuture->GetCloneFrame(L"Bip01"), 3.f);
				}				
			}
			break;
	#endif
		default:
			break;
		}
	}
	#endif //MOVE_BONE

	#ifdef ELSWORD_SHEATH_KNIGHT
		if( m_pUnit != NULL && 
			( m_pUnit->GetClass() == CX2Unit::UC_ELSWORD_SWORDMAN ) )
		{
			D3DXVECTOR3 vHead = D3DXVECTOR3(1.f, 0.95f, 0.97f);
			D3DXVECTOR3 vThigh = D3DXVECTOR3(1.f, 1.f, 1.f);
			D3DXVECTOR3 vCalf = D3DXVECTOR3(1.05f, 1.f, 1.f);
			D3DXVECTOR3 vFoot = D3DXVECTOR3(0.9f, 1.f, 0.9f);


			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);	


			pFrameHead = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);

			pFrame_R_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			pFrame_L_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			pFrame_R_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			pFrame_L_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			pFrame_R_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			pFrame_L_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);	
		}
		else if( m_pUnit != NULL && 
			( m_pUnit->GetClass() == CX2Unit::UC_ELSWORD_KNIGHT || 
			m_pUnit->GetClass() == CX2Unit::UC_ELSWORD_MAGIC_KNIGHT || 
			m_pUnit->GetClass() == CX2Unit::UC_ELSWORD_SHEATH_KNIGHT ||
	#ifdef SERV_ELSWORD_INFINITY_SWORD
			m_pUnit->GetClass() == CX2Unit::UC_ELSWORD_INFINITY_SWORD ||
	#endif
			m_pUnit->GetClass() == CX2Unit::UC_ELSWORD_LORD_KNIGHT || 
			m_pUnit->GetClass() == CX2Unit::UC_ELSWORD_RUNE_SLAYER ) )		
			#else
	if( m_pUnit != NULL && 
		( m_pUnit->GetClass() == CX2Unit::UC_ELSWORD_LORD_KNIGHT || m_pUnit->GetClass() == CX2Unit::UC_ELSWORD_RUNE_SLAYER ) )
	#endif ELSWORD_SHEATH_KNIGHT
		{		
			D3DXVECTOR3 vHead = D3DXVECTOR3(1.f, 0.95f, 0.97f);
			D3DXVECTOR3 vThigh = D3DXVECTOR3(1.07f, 1.f, 1.f);
			D3DXVECTOR3 vCalf = D3DXVECTOR3(1.12f, 1.f, 1.f);
			D3DXVECTOR3 vFoot = D3DXVECTOR3(0.9f, 1.f, 1.f);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);	


			pFrameHead = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);

			pFrame_R_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			pFrame_L_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			pFrame_R_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			pFrame_L_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			pFrame_R_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			pFrame_L_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);	
		}
		else if( m_pUnit != NULL && m_pUnit->GetType() == CX2Unit::UT_LIRE )
		{
			D3DXVECTOR3 vHead = D3DXVECTOR3(0.96f, 0.94f, 0.92f);
			D3DXVECTOR3 vThigh = D3DXVECTOR3(1.02f, 1.f, 1.f);
			D3DXVECTOR3 vCalf = D3DXVECTOR3(1.02f, 1.f, 1.f);
			D3DXVECTOR3 vFoot = D3DXVECTOR3(0.93f, 0.93f, 0.93f);
			D3DXVECTOR3 vHand = D3DXVECTOR3(0.9f, 0.9f, 0.9f);	
			D3DXVECTOR3 vDummyHand = D3DXVECTOR3(1.f, 1.f, 1.f);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Hand");
			if(pFrame_R_Hand != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_R_Hand);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Hand");
			if(pFrame_L_Hand != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_L_Hand);		

			vDummyHand.x = 1.f / vHand.x;
			vDummyHand.y = 1.f / vHand.y;
			vDummyHand.z = 1.f / vHand.z;

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame(L"Dummy1_Rhand");
			if(pFrame_R_Dummy != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_R_Dummy);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame(L"Dummy2_Lhand");
			if(pFrame_L_Dummy != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_L_Dummy);

			/////////////////////////////////////////////////////////////////////////////////////////////////////////
			pFrameHead = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			pFrame_R_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			pFrame_L_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			pFrame_R_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			pFrame_L_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			pFrame_R_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			pFrame_L_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);		

			pFrame_R_Hand = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Hand");
			if(pFrame_R_Hand != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_R_Hand);
			pFrame_L_Hand = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Hand");
			if(pFrame_L_Hand != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_L_Hand);		

			pFrame_R_Dummy = m_pXSkinAnimFuture->GetCloneFrame(L"Dummy1_Rhand");
			if(pFrame_R_Dummy != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_R_Dummy);
			pFrame_L_Dummy = m_pXSkinAnimFuture->GetCloneFrame(L"Dummy2_Lhand");
			if(pFrame_L_Dummy != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_L_Dummy);	
		}
		else if( m_pUnit != NULL && 
			( m_pUnit->GetClass() == CX2Unit::UC_ARME_ELEMENTAL_MASTER || m_pUnit->GetClass() == CX2Unit::UC_ARME_VOID_PRINCESS ) )
		{
			D3DXVECTOR3 vHead	= D3DXVECTOR3(0.97f, 0.95f, 0.95f);
			D3DXVECTOR3 vThigh	= D3DXVECTOR3(1.f, 1.f, 1.f);
			D3DXVECTOR3 vCalf	= D3DXVECTOR3(1.06f, 1.f, 1.f);
			D3DXVECTOR3 vFoot	= D3DXVECTOR3(1.f, 1.f, 1.f);
			D3DXVECTOR3 vHand	= D3DXVECTOR3(0.9f, 0.93f, 0.93f);	
			D3DXVECTOR3 vDummyHand = D3DXVECTOR3(1.f, 1.f, 1.f);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Hand");
			if(pFrame_R_Hand != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_R_Hand);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Hand");
			if(pFrame_L_Hand != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_L_Hand);		

			vDummyHand.x = 1.f / vHand.x;
			vDummyHand.y = 1.f / vHand.y;
			vDummyHand.z = 1.f / vHand.z;

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame(L"Dummy1_Rhand");
			if(pFrame_R_Dummy != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_R_Dummy);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame(L"Dummy2_Lhand");
			if(pFrame_L_Dummy != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_L_Dummy);

			/////////////////////////////////////////////////////////////////////////////////////////////////////////
			pFrameHead = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			pFrame_R_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			pFrame_L_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			pFrame_R_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			pFrame_L_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			pFrame_R_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			pFrame_L_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);		

			pFrame_R_Hand = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Hand");
			if(pFrame_R_Hand != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_R_Hand);
			pFrame_L_Hand = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Hand");
			if(pFrame_L_Hand != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_L_Hand);		

			pFrame_R_Dummy = m_pXSkinAnimFuture->GetCloneFrame(L"Dummy1_Rhand");
			if(pFrame_R_Dummy != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_R_Dummy);
			pFrame_L_Dummy = m_pXSkinAnimFuture->GetCloneFrame(L"Dummy2_Lhand");
			if(pFrame_L_Dummy != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_L_Dummy);	
		}
	#ifdef RAVEN_SECOND_CLASS_CHANGE
		else if( m_pUnit != NULL && m_pUnit->GetType() == CX2Unit::UT_RAVEN )
		{
			D3DXVECTOR3 vHead = D3DXVECTOR3(0.9f, 0.92f, 0.94f);
			D3DXVECTOR3 vThigh = D3DXVECTOR3(1.05f, 0.98f, 0.98f);
			D3DXVECTOR3 vCalf = D3DXVECTOR3(1.05f, 1.f, 1.f);
			D3DXVECTOR3 vFoot = D3DXVECTOR3(0.95f, 0.95f, 0.85f);		
			D3DXVECTOR3 vSpine = D3DXVECTOR3(0.93f, 0.97f, 1.f);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameSpine = m_pXSkinAnim->GetCloneFrame(L"Bip01_Spine");
			if(pFrameSpine != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vSpine, false, pFrameSpine);	

			/////////////////////////////////////////////////////////////////////////////////////////////////////////// 
			pFrameHead = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			pFrame_R_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			pFrame_L_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			pFrame_R_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			pFrame_L_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			pFrame_R_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			pFrame_L_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);		

			pFrameSpine = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Spine");
			if(pFrameSpine != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vSpine, false, pFrameSpine);	
		}
	#endif
	#ifdef EVE_SECOND_CLASS_CHANGE
		else if( m_pUnit != NULL && m_pUnit->GetType() == CX2Unit::UT_EVE )
		{
			D3DXVECTOR3 vHead = D3DXVECTOR3(0.94f, 0.97f, 0.98f);
			D3DXVECTOR3 vThigh = D3DXVECTOR3(1.0f, 0.98f, 0.98f);
			D3DXVECTOR3 vCalf = D3DXVECTOR3(1.f, 0.98f, 0.98f);
			D3DXVECTOR3 vFoot = D3DXVECTOR3(0.95f, 0.95f, 0.95f);
			D3DXVECTOR3 vHand = D3DXVECTOR3(0.9f, 0.96f, 0.96f);		
			D3DXVECTOR3 vDummyHand = D3DXVECTOR3(1.f, 1.f, 1.f);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Hand");
			if(pFrame_R_Hand != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_R_Hand);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Hand");
			if(pFrame_L_Hand != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_L_Hand);		

			vDummyHand.x = 1.f; // / vHand.x;
			vDummyHand.y = 1.f; // / vHand.y;
			vDummyHand.z = 1.f; // / vHand.z;

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame(L"Dummy1_Rhand");
			if(pFrame_R_Dummy != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_R_Dummy);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame(L"Dummy2_Lhand");
			if(pFrame_L_Dummy != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_L_Dummy);

			/////////////////////////////////////////////////////////////////////////////////////////////////////////// 
			pFrameHead = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			pFrame_R_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			pFrame_L_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			pFrame_R_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			pFrame_L_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			pFrame_R_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			pFrame_L_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);		

			pFrame_R_Hand = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Hand");
			if(pFrame_R_Hand != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_R_Hand);
			pFrame_L_Hand = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Hand");
			if(pFrame_L_Hand != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_L_Hand);		

			pFrame_R_Dummy = m_pXSkinAnimFuture->GetCloneFrame(L"Dummy1_Rhand");
			if(pFrame_R_Dummy != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_R_Dummy);
			pFrame_L_Dummy = m_pXSkinAnimFuture->GetCloneFrame(L"Dummy2_Lhand");
			if(pFrame_L_Dummy != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_L_Dummy);	

		}
	#endif
	#ifdef CHUNG_SECOND_CLASS_CHANGE
	#ifdef SERV_CHUNG_TACTICAL_TROOPER
		else if( m_pUnit != NULL && 
			( m_pUnit->GetClass() == CX2Unit::UC_CHUNG_IRON_PALADIN || m_pUnit->GetClass() == CX2Unit::UC_CHUNG_DEADLY_CHASER || m_pUnit->GetClass() == CX2Unit::UC_CHUNG_TACTICAL_TROOPER ) )	
	#else
		else if( m_pUnit != NULL && 
			( m_pUnit->GetClass() == CX2Unit::UC_CHUNG_IRON_PALADIN || m_pUnit->GetClass() == CX2Unit::UC_CHUNG_DEADLY_CHASER ) )	
	#endif SERV_CHUNG_TACTICAL_TROOPER
		{
			D3DXVECTOR3 vHead = D3DXVECTOR3(0.93f, 0.96f, 0.96f);
			D3DXVECTOR3 vDummyHand = D3DXVECTOR3(1.f, 1.f, 1.f);	
			m_fBasicBoneScale = 1.13f;
			float fScale = m_fBasicBoneScale;

			vDummyHand = vDummyHand / fScale;

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame(L"Dummy1_Rhand");
			if(pFrame_R_Dummy != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_R_Dummy);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame(L"Dummy2_Lhand");
			if(pFrame_L_Dummy != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_L_Dummy);

			m_pXSkinAnim->GetMatrix().Scale( D3DXVECTOR3(fScale, fScale, fScale) );

			///////////////////////////////////////////////////////////////////////////////////////////////////////
			pFrameHead = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		
			pFrame_R_Dummy = m_pXSkinAnimFuture->GetCloneFrame(L"Dummy1_Rhand");
			if(pFrame_R_Dummy != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_R_Dummy);
			pFrame_L_Dummy = m_pXSkinAnimFuture->GetCloneFrame(L"Dummy2_Lhand");
			if(pFrame_L_Dummy != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_L_Dummy);
		
			m_pXSkinAnimFuture->GetMatrix().Scale( D3DXVECTOR3(fScale, fScale, fScale) );		
		}
	#endif
	#ifdef SERV_ADD_ARME_BATTLE_MAGICIAN
		else if( m_pUnit != NULL && 
	#ifdef SERV_ARME_DIMENSION_WITCH
			( m_pUnit->GetClass() == CX2Unit::UC_ARME_BATTLE_MAGICIAN  || m_pUnit->GetClass() == CX2Unit::UC_ARME_DIMENSION_WITCH )
	#else
			( m_pUnit->GetClass() == CX2Unit::UC_ARME_BATTLE_MAGICIAN )
	#endif //SERV_ARME_DIMENSION_WITCH
			)
		{
			D3DXVECTOR3 vHead = D3DXVECTOR3(1.f, 1.f, 1.f);
			D3DXVECTOR3 vThigh = D3DXVECTOR3(1.f, 1.f, 1.f);
			D3DXVECTOR3 vCalf = D3DXVECTOR3(1.f, 1.f, 1.f);
			D3DXVECTOR3 vFoot = D3DXVECTOR3(1.f, 1.f, 1.f);
			D3DXVECTOR3 vHand = D3DXVECTOR3(1.f, 1.f, 1.f);
			D3DXVECTOR3 vDummyHand = D3DXVECTOR3(1.f, 1.f, 1.f);	

			m_fBasicBoneScale = 1.f;

			if( IsTransformed() )
			{
				m_fBasicBoneScale = 1.1f;
				vHead = D3DXVECTOR3(0.93f, 0.88f, 0.9f);
				vThigh = D3DXVECTOR3(1.04f, 1.f, 1.f);
				vCalf = D3DXVECTOR3(1.1f, 1.f, 1.f);
				vFoot = D3DXVECTOR3(0.9f, 1.f, 0.9f);
				vHand = D3DXVECTOR3(0.8f, 0.86f, 0.86f);
			}

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrameHead = m_pXSkinAnim->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);		

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Leg = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Calf = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Foot = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);	

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_R_Hand");
			if(pFrame_R_Hand != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_R_Hand);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Hand = m_pXSkinAnim->GetCloneFrame(L"Bip01_L_Hand");
			if(pFrame_L_Hand != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_L_Hand);		

			vDummyHand.x = 1.f / vHand.x;
			vDummyHand.y = 1.f / vHand.y;
			vDummyHand.z = 1.f / vHand.z;

			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_R_Dummy = m_pXSkinAnim->GetCloneFrame(L"Dummy1_Rhand");
			if(pFrame_R_Dummy != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_R_Dummy);
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pFrame_L_Dummy = m_pXSkinAnim->GetCloneFrame(L"Dummy2_Lhand");
			if(pFrame_L_Dummy != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_L_Dummy);




			pFrameHead = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_Head");
			if(pFrameHead != NULL) // && pFrameHead->m_bScale == false)
				SetFrameScale(&vHead, true, pFrameHead);

			pFrame_R_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Thigh");
			if(pFrame_R_Leg != NULL) // && pFrame_R_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_R_Leg);
			pFrame_L_Leg = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Thigh");
			if(pFrame_L_Leg != NULL) // && pFrame_L_Leg->m_bScale == false)
				SetFrameScale(&vThigh, true, pFrame_L_Leg);

			pFrame_R_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Calf");
			if(pFrame_R_Calf != NULL) // && pFrame_R_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_R_Calf);
			pFrame_L_Calf = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Calf");
			if(pFrame_L_Calf != NULL) // && pFrame_L_Calf->m_bScale == false)
				SetFrameScale(&vCalf, true, pFrame_L_Calf);

			pFrame_R_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Foot");
			if(pFrame_R_Foot != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_R_Foot);
			pFrame_L_Foot = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Foot");
			if(pFrame_L_Foot != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vFoot, true, pFrame_L_Foot);	

			pFrame_R_Hand = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_R_Hand");
			if(pFrame_R_Hand != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_R_Hand);
			pFrame_L_Hand = m_pXSkinAnimFuture->GetCloneFrame(L"Bip01_L_Hand");
			if(pFrame_L_Hand != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vHand, true, pFrame_L_Hand);		

			pFrame_R_Dummy = m_pXSkinAnimFuture->GetCloneFrame(L"Dummy1_Rhand");
			if(pFrame_R_Dummy != NULL) // && pFrame_R_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_R_Dummy);
			pFrame_L_Dummy = m_pXSkinAnimFuture->GetCloneFrame(L"Dummy2_Lhand");
			if(pFrame_L_Dummy != NULL) // && pFrame_L_Foot->m_bScale == false)
				SetFrameScale(&vDummyHand, true, pFrame_L_Dummy);	
		}
	#endif	//SERV_ADD_ARME_BATTLE_MAGICIAN

#endif //UNIT_SCALE_COMBINE_ONE
}


#endif

//{{ kimhc // 2009-11-20 // 길드 스킬 3, 4라인
// 횟수와 시간 고려함
#ifdef	GUILD_SKILL_PART_2
void CX2GUUser::GuildSkillProcess( CX2SkillTree::SKILL_ID eSkillID_ )
{
	switch ( eSkillID_ )
	{
	case CX2SkillTree::SI_GP_COMMON_CHANCE_TO_REVERSE:
		{
			if ( m_GuildSkillData.m_bLearnChanceToReverse )
				DoGuildSkillChanceToReverse();

// 			if ( m_GuildSkillData.m_ChangeToReverse.m_bProcessingBuff == false &&
// 				 GetNowStateID()	!= GUSI_DIE	)
// 			{
// 				m_GuildSkillData.m_ChangeToReverse.m_bProcessingBuff	= true;
// 				m_GuildSkillData.m_ChangeToReverse.m_byCountLeft		= (BYTE)(int)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_COUNT );
// 				m_GuildSkillData.m_ChangeToReverse.m_fTimeLeft			= 30.0f;
// 					
// 				if ( m_GuildSkillData.m_ChangeToReverse.m_hEffectSet == INVALID_EFFECTSET_HANDLE )
// 				{
// 					m_GuildSkillData.m_ChangeToReverse.m_hEffectSet = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_ChanceToReverse", this, this );
// 					PlaySound( L"GS_Chance_To_Reverse01.ogg" );
// 				}
// 			}
		}
		break;

	case CX2SkillTree::SI_GP_COMMON_INFINITE_STRENGTH:
		{
			const CX2Unit::UnitData*	pUnitData	=	&GetUnit()->GetUnitData();

			const CX2SkillTree::SkillTemplet* pSkillTemplet = 
				pUnitData->m_UserSkillTree.GetUserSkillTemplet( eSkillID_, pUnitData->m_byMemberShipGrade );

			if ( pSkillTemplet == NULL )
				return;

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			const CX2UserSkillTree& userSkillTree = pUnitData->m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID, true ) );	/// 스킬 레벨
	
			if ( m_GuildSkillData.m_InfiniteStrength.m_byCountLeft == 0 &&
				m_GuildSkillData.m_InfiniteStrength.m_hSeqEffect == INVALID_PARTICLE_SEQUENCE_HANDLE &&
				GetNowStateID() != GUSI_DIE &&
				GetRandomFloat() < pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE, iSkillTempletLevel ) )
	#else // UPGRADE_SKILL_SYSTEM_2013
			if ( m_GuildSkillData.m_InfiniteStrength.m_byCountLeft == 0 &&
				m_GuildSkillData.m_InfiniteStrength.m_hSeqEffect == INVALID_PARTICLE_SEQUENCE_HANDLE &&
				GetNowStateID() != GUSI_DIE &&
				GetRandomFloat() < pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE ) )
	#endif // UPGRADE_SKILL_SYSTEM_2013
			{
				m_GuildSkillData.m_InfiniteStrength.m_byCountLeft = 3; // 무조건 3
			}
		}

	default:
		// 영웅의 희생은 유저가 죽었다는 패킷을 받은 즉시 실행, CX2DungeonGame, X2Game의 UserUnitDieNot 에서 구현되어있음
		break;
	}
}

void CX2GUUser::ProcessSacrificeOfHero()		// 영웅의 희생 길드스킬
{
	if ( g_pX2Game == NULL )
	{
		ASSERT( !L"g_pX2Game is NULL" );
		return;
	}

	m_bHaveSacrificeOfHero = true;
	m_RenderParam.renderType = CKTDGXRenderer::RT_CARTOON_FADE_NONTEX;

	const CX2Unit::UnitData* pUnitData = &GetUnit()->GetUnitData();

	const CX2SkillTree::SkillTemplet* pSkillTemplet = 
		pUnitData->m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_GP_COMMON_SACRIFICE_OF_HERO, pUnitData->m_byMemberShipGrade );

	if ( pSkillTemplet != NULL )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2UserSkillTree& userSkillTree = pUnitData->m_UserSkillTree;
	
		const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID, true ) );	/// 스킬 레벨
	
		float fPercent = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_HP_GAIN_REL_MAX_HP, iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
		float fPercent = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_HP_GAIN_REL_MAX_HP );
	#endif // UPGRADE_SKILL_SYSTEM_2013

		if ( g_pX2Game->GetGameType() == CX2Game::GT_PVP )
			fPercent *= 0.5f;

		// 이펙트 실행!!
		g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_SacrificeOfHero", this );

		PlaySound( L"GS_Sacrifice_of_Hero.ogg" );

		for ( int i = 0; i < g_pX2Game->GetUnitNum(); i++ )
		{
			CX2GameUnit *pGameUnit = g_pX2Game->GetUnit( i );
			if ( pGameUnit->GetGameUnitType() == CX2GameUnit::GUT_USER )
			{
				CX2GUUser* pPartyUser = (CX2GUUser*)g_pX2Game->GetUnit( i );

				if ( pPartyUser != NULL )
				{
					if ( GetDistance( GetPos(), pPartyUser->GetPos() ) < 1500.0f &&
						GetTeam() == pPartyUser->GetTeam() &&
						pPartyUser->GetNowStateID() != GUSI_DIE &&
						GetUnitUID() != pPartyUser->GetUnitUID() && 
						( g_pX2Game->GetGameType() == CX2Game::GT_PVP || 
						( NULL != g_pData && NULL != g_pData->GetPartyManager() && true == g_pData->GetPartyManager()->IsMyPartyMember( pPartyUser->GetUnitUID() ) ) ) )
					{
							float fHpToBeUp = pPartyUser->GetMaxHp() * fPercent;

							pPartyUser->UpNowHp( fHpToBeUp );

							std::wstringstream strStream;
							strStream << L"HP+ " << static_cast< int >( fHpToBeUp );
							D3DXVECTOR3 pos = pPartyUser->GetPos();
							pos.y += 50.0f;
							if( NULL != g_pData->GetPicCharGreen() )
								g_pData->GetPicCharGreen()->DrawText( strStream.str().c_str(), pos, pPartyUser->GetDirVector(), CKTDGPicChar::AT_CENTER );
					}
				}
			}
		}
	}
}


#endif	GUILD_SKILL_PART_2
//}} kimhc // 2009-11-20 // 길드 스킬 3, 4라인


//{{ kimhc // 2010.4.1 // 비밀던전 작업(셋트아이템효과)
#ifdef SERV_SECRET_HELL
void CX2GUUser::Bone_Shield::DestroyParticle()
{
	// 이펙트셋 종료
	if ( m_hEffectSet != INVALID_EFFECTSET_HANDLE )
		g_pX2Game->GetEffectSet()->StopEffectSet( m_hEffectSet );
}

float CX2GUUser::GetOriginalMPChangeRate()
{
	float m_fMpRate = m_fOriginalMPChangeRate;

	// 드래고닉 셋트효과가 아직 진행 중이면
	if ( GetManaRecoveryTime() > 0.0f )
		m_fMpRate += GetManaRecoveryVal();

	//{{ mauntain : 김태환 [2012.07.26] 클로킹 메모 쓸쓸한 기다림 버그 수정 ( 작업자 : 엘소드 대만 이지헌 )
#ifdef EVE_MEMO5_BUG_FIX
	return m_fMpRate + m_fAdditionalMPChangeRateByPassive;
#else
	return m_fMpRate; 
#endif EVE_MEMO5_BUG_FIX
	//}}
}

float	CX2GUUser::GetNowMPChange()
{
	float fMpChageRate = GetChangeRateMp(); 
		
	 
	//{{ dmlee 2008.7.13 play channel
	const float MAGIC_PLAY_CHANNEL_MP_CHANGE_RATE_SCALE = 7.f;
	if( CX2Main::XS_PVP_GAME == g_pMain->GetNowStateID()
		&& KPVPChannelInfo::PCC_PLAY == g_pMain->GetPVPChannelClass( g_pMain->GetConnectedChannelID() ) )
	{
		fMpChageRate /= MAGIC_PLAY_CHANNEL_MP_CHANGE_RATE_SCALE;
	}
	//}} dmlee 2008.7.13 play channel

	return fMpChageRate;
}

bool CX2GUUser::InitSocketEffectEx( const CX2SocketItem::SocketData& kSocketData )
{
	switch ( kSocketData.m_eTypeSocketItemEffectEx )		// 비밀던전시 추가된 옵션이 검사
	{
	default:
	case CX2SocketItem::SIEE_NONE:
		return false;
		break;

	case CX2SocketItem::SIEE_STAT_UP:
	case CX2SocketItem::SIEE_UP_MANA_RECOVERY_VALUE:
	case CX2SocketItem::SIEE_CURE_DEBUFF:
	case CX2SocketItem::SIEE_DEBUFF_ATTACKER:
	case CX2SocketItem::SIEE_BONE_SHIELD:
	case CX2SocketItem::SIEE_ATTACK_SPEED_UP:

	//{{ kimhc // 2010.12.31 // 하멜 마을 추가시 들어가는 ExtraDamage
#ifdef	ADD_HAMEL_VILLAGE
	case CX2SocketItem::SIEE_ICE_NOVA:
#endif	ADD_HAMEL_VILLAGE
	//}} kimhc // 2010.12.31 // 하멜 마을 추가시 들어가는 ExtraDamage

#ifdef ADD_SOCKET_FOR_SECRET_SET
	case CX2SocketItem::SIEE_POISON_BURST:
	case CX2SocketItem::SIEE_ABSORB_HP:
#endif

#ifdef HAMEL_SECRET_DUNGEON // 김태환
	case CX2SocketItem::SIEE_ABSORB_HP_NO_REACT:	/// 피격 시 HP 흡수 세트 효과 ( 경직 제거 )
	case CX2SocketItem::SIEE_ACTIVE_BUFF:			/// 피격 시 버프 적용 효과
#endif // HAMEL_SECRET_DUNGEON
		break;
	}

	SOCKET_EFFECT_EX_MAP::iterator mItr = m_mapSocketItemEffectEx.find( kSocketData.m_eTypeSocketItemEffectEx );

	// 해당 소켓효과 타입이 현재 맵에 없으면
	if ( mItr == m_mapSocketItemEffectEx.end() )
	{	
		vector<int> tempVec;
		tempVec.push_back( kSocketData.m_ID );
		m_mapSocketItemEffectEx.insert( make_pair( kSocketData.m_eTypeSocketItemEffectEx, tempVec ) );
	}
	else		// 해당 소켓효과 타입이 맵에 있으면
	{
		mItr->second.push_back( kSocketData.m_ID );
	}

	return true;
	
}

CX2SocketItem::SOCKET_ITEM_EFFECT_EX CX2GUUser::ProcessSocketEffectEx( const CX2SocketItem::SOCKET_ITEM_EFFECT_EX eEx_, CX2GameUnit* pGameUnit_ )
{
	SOCKET_EFFECT_EX_MAP::iterator mItr = m_mapSocketItemEffectEx.find( eEx_ );
	CX2SocketItem::SOCKET_ITEM_EFFECT_EX eReturnVal = CX2SocketItem::SIEE_NONE;

	if ( mItr == m_mapSocketItemEffectEx.end() )
		return eReturnVal;

	switch ( eEx_ )
	{
	case CX2SocketItem::SIEE_STAT_UP:
		{
			// 현재 진행 중인 버프가 있으면 실행 안함
			if ( m_StatUpBufferBySocketItem.m_fBufferTime > 0.0f )
				return eReturnVal;

			BOOST_TEST_FOREACH( int, val, mItr->second )
			{
				const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( val );

				if ( pSocketData != NULL && pSocketData->m_fProbability > GetRandomFloat( CKTDXRandomNumbers::SRO_STAT_PERCENT_UP ) )
				{
					// 해당 버프를 실행 시킴
					SetStatUpBufferBySocketItem( pSocketData->m_fIncOrDecVal, pSocketData->m_fDurationTime );
					TRACE( L"Socket On\n" );
					m_StatUpType = pSocketData->m_eStatUpType;
					eReturnVal = CX2SocketItem::SIEE_STAT_UP;
					break;
				}
			}

		} break;

	case CX2SocketItem::SIEE_UP_MANA_RECOVERY_VALUE:
		{
			// 현재 진행 중인 버프가 있으면 실행 안함
			if ( GetManaRecoveryTime() > 0.0f )
				return eReturnVal;

			vector<int> &vecOptionID = mItr->second;

			const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( vecOptionID[0] );
            if ( pSocketData != NULL )
            {
    			SetManaRecoveryVal( pSocketData->m_fIncOrDecVal );
	    		SetManaRecoveryTime( pSocketData->m_fDurationTime );
		    	ResetMPChangeRate( GetNowMPChange() + GetManaRecoveryVal() );	
    			eReturnVal = CX2SocketItem::SIEE_UP_MANA_RECOVERY_VALUE;
            }
			
		} break;

	case CX2SocketItem::SIEE_CURE_DEBUFF:
		{
			// 인터벌 시간이 지나지 않았으면 효과 적용 하지 않음
			if ( m_fIntervalTimeForCureDebuff > 0.0f )
				return eReturnVal;

			BOOST_TEST_FOREACH( int, val, mItr->second )
			{
				const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( val );

				if ( pSocketData != NULL && pSocketData->m_fProbability > GetRandomFloat( CKTDXRandomNumbers::SRO_CURE_DEBUFF ) )
				{
					CureExtraDamage( pSocketData->m_iCount );
					m_fIntervalTimeForCureDebuff = pSocketData->m_fIntervalTime;
					eReturnVal = CX2SocketItem::SIEE_CURE_DEBUFF;
					break;
				}
			}

		} break;

	case CX2SocketItem::SIEE_DEBUFF_ATTACKER:		// 자신을 공격한 유닛에게 상태이상을 적용
		{
			BOOST_TEST_FOREACH( int, val, mItr->second )
			{
				const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( val );
				
				if ( pSocketData != NULL && pSocketData->m_fProbability > GetRandomFloat( CKTDXRandomNumbers::SRO_DEBUFF_ATTACKER ) )
				{
					if ( NULL != pSocketData->m_ptrBuffFactor )
					{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
						CX2BuffFactorPtr ptrBuffFactor = pSocketData->m_ptrBuffFactor->GetClonePtr( 0 );
#else //UPGRADE_SKILL_SYSTEM_2013
						CX2BuffFactorPtr ptrBuffFactor = pSocketData->m_ptrBuffFactor->GetClonePtr();
#endif //UPGRADE_SKILL_SYSTEM_2013
						if ( NULL != ptrBuffFactor )
						{
							ptrBuffFactor->SetGameUnitBuffFactor( this );
							pGameUnit_->SetBuffFactorToGameUnit( *ptrBuffFactor );
							break;
						}
					}
					//CreateDamageDataForDebuffAttacker( pSocketData->m_SocketExtraDamage );				
					//eReturnVal = CX2SocketItem::SIEE_DEBUFF_ATTACKER;
					break;
				}
			}
		} break;

	case CX2SocketItem::SIEE_BONE_SHIELD:
		{
			BOOST_TEST_FOREACH( int, val, mItr->second )
			{
				const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( val );

				if ( pSocketData != NULL && pSocketData->m_fProbability > GetRandomFloat( CKTDXRandomNumbers::SRO_BONE_SHIELD ) )
				{
					CreateBoneShield( *pSocketData );
					eReturnVal = CX2SocketItem::SIEE_BONE_SHIELD;
					break;
				}
			}
		} break;

	case CX2SocketItem::SIEE_ATTACK_SPEED_UP:
		{
			BOOST_TEST_FOREACH( int, val, mItr->second )
			{
				const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( val );

				if ( pSocketData != NULL && pSocketData->m_fProbability > GetRandomFloat( CKTDXRandomNumbers::SRO_ATTACK_SPEED_UP ) )
				{
					//SetAnimSpeedFactor( pSocketData->m_fIncOrDecRate, pSocketData->m_fDurationTime, SFI_SPEED_2, SFST_ONLY );
					SetBuffFactorToGameUnitByBuffFactorID( BFI_BUFF_MECHANIZATION_SPEED_UP );
					break;
				}
			}
		} break;

	//{{ kimhc // 2010.12.31 // 하멜 마을 추가시 들어가는 ExtraDamage
#ifdef	ADD_HAMEL_VILLAGE
	case CX2SocketItem::SIEE_ICE_NOVA:
		{
			BOOST_TEST_FOREACH( int, val, mItr->second )
			{
				const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( val );

				if ( pSocketData != NULL && pSocketData->m_fProbability > GetRandomFloat( CKTDXRandomNumbers::SRO_ICE_NOVA ) )
				{
					g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_SIEE_ICE_NOVA", this );

					eReturnVal = CX2SocketItem::SIEE_ICE_NOVA;
					break;
				}
			}
		} break;
#endif	ADD_HAMEL_VILLAGE
//}} kimhc // 2010.12.31 // 하멜 마을 추가시 들어가는 ExtraDamage

#ifdef ADD_SOCKET_FOR_SECRET_SET
	case CX2SocketItem::SIEE_POISON_BURST:
		{
			BOOST_TEST_FOREACH( int, val, mItr->second )
			{
				const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( val );

				if ( pSocketData != NULL && pSocketData->m_fProbability > GetRandomFloat( CKTDXRandomNumbers::SRO_POISON_BURST ) )
				{
					g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_SIEE_POISON_BURST", this );

					eReturnVal = CX2SocketItem::SIEE_POISON_BURST;
					break;
				}
			}
		} break;
	case CX2SocketItem::SIEE_ABSORB_HP:
		{
			BOOST_TEST_FOREACH( int, val, mItr->second )
			{
				const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( val );

				if ( pSocketData != NULL && pSocketData->m_fProbability > GetRandomFloat( CKTDXRandomNumbers::SRO_ABSORB_HP ) )
				{
					g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_SIEE_ABSORB_HP", this );

					eReturnVal = CX2SocketItem::SIEE_ABSORB_HP;
					break;
				}
			}
		} break;
#endif

#ifdef HAMEL_SECRET_DUNGEON // 김태환
	case CX2SocketItem::SIEE_ABSORB_HP_NO_REACT:	/// 피격 시 HP 흡수 세트 효과 ( 경직 제거 )
		{
#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
			//쿨타임이 지나지 않았으면 효과 적용 하지 않음
			if ( GetSocketOptionCoolTime() > 0.0f )
				return eReturnVal;
#endif //ADJUST_SECRET_ITEM_OPTION

			BOOST_TEST_FOREACH( int, val, mItr->second )
			{
				const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( val );

				if ( pSocketData != NULL && pSocketData->m_fProbability > GetRandomFloat( CKTDXRandomNumbers::SRO_ABSORB_HP ) )
				{
					D3DXVECTOR3 vPos = GetBonePos(L"Bip01");	/// 생성 위치

					/// 경직 데미지 이펙트 생성
					CX2DamageEffect::CEffect* pCEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, 
													L"DAMAGE_EFFECT_SIEE_ABSORB_HP_NO_REACT", GetPowerRate(), 
													vPos, GetDirVector(), GetDirVector(),
													m_FrameDataNow.unitCondition.landPosition.y );
					/// 타격수 설정
					if ( NULL != pCEffect )
						pCEffect->SetDamageTime( static_cast<int>( pSocketData->m_fEffectiveValue ) );

					// 오현빈 // 2013-08-28 // DamageTime이 0이되면 DamageEffect는 제거되기 때문에 연출을 위한 이펙트셋 추가
					if( NULL != g_pX2Game->GetEffectSet() )
						g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Siee_Absorb_Hp", this );

					eReturnVal = CX2SocketItem::SIEE_ABSORB_HP_NO_REACT;

#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
					SetSocketOptionCoolTime( pSocketData->m_fIntervalTime );
#endif //ADJUST_SECRET_ITEM_OPTION

					break;
				}
			}
		} break;

	case CX2SocketItem::SIEE_ACTIVE_BUFF:			/// 피격 시 버프 적용 효과
		{
#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
			//쿨타임이 지나지 않았으면 효과 적용 하지 않음
			if ( GetSocketOptionCoolTime() > 0.0f )
				return eReturnVal;
#endif //ADJUST_SECRET_ITEM_OPTION

			BOOST_TEST_FOREACH( int, val, mItr->second )
			{
				const CX2SocketItem::SocketData* pSocketData = g_pData->GetSocketItem()->GetSocketData( val );

				/// 확률 조건에 충족되고, 설정할 버프가 있을 때
				if ( pSocketData != NULL && pSocketData->m_fProbability > GetRandomFloat( CKTDXRandomNumbers::SRO_ACTIVE_BUFF ) &&
					NULL != pSocketData->m_ptrBuffFactorCustomUse )
				{
					/// 클론 버프 생성
					CX2BuffFactorPtr pCloneBuffFactorPtr = pSocketData->m_ptrBuffFactorCustomUse->GetClonePtr( 0 );

					/// 버프 설정
					if ( NULL != pCloneBuffFactorPtr )
						SetBuffFactorToGameUnit( *pCloneBuffFactorPtr );

					eReturnVal = CX2SocketItem::SIEE_ACTIVE_BUFF;

#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
					SetSocketOptionCoolTime( pSocketData->m_fIntervalTime );
#endif //ADJUST_SECRET_ITEM_OPTION

					break;
				}
			}
		} break;
#endif // HAMEL_SECRET_DUNGEON

	default:
		break;
	}
	
	return eReturnVal;
}

void CX2GUUser::CheckNChangeManaRecoveryValueNTime( float fElpasedTime )
{
	if ( GetManaRecoveryTime() > 0.0f )
	{
		SetManaRecoveryTime( GetManaRecoveryTime() - fElpasedTime );

		if ( GetManaRecoveryTime() <= 0.0f )
		{
			SetManaRecoveryTime( 0.0f );
			ResetMPChangeRate( GetNowMPChange() - GetManaRecoveryVal() );
			SetManaRecoveryVal( 0.0f );
		}
	}	
}

void CX2GUUser::CheckNChangeIntervalTimeForCureDebuff( float fElpasedTime )
{
	if ( GetIntervalTimeForCureDebuff() > 0.0f )
	{
		SetIntervalTimeForCureDebuff( GetIntervalTimeForCureDebuff() - fElpasedTime );

		if ( GetIntervalTimeForCureDebuff() <= 0.0f )
			SetIntervalTimeForCureDebuff( 0.0f );
	}
}

void CX2GUUser::CreateBoneShield( const CX2SocketItem::SocketData& kSocketData )
{
//{{ robobeg : 2013-11-04
    SAFE_DELETE( m_pBoneShieldData );
//}} robobeg : 2013-11-04

	m_pBoneShieldData = new Bone_Shield;

	m_pBoneShieldData->m_fIntervalTime	= kSocketData.m_fIntervalTime;
	m_pBoneShieldData->m_fTimeLeft		= kSocketData.m_fDurationTime;
	m_pBoneShieldData->m_byCountLeft	= kSocketData.m_iCount;
	m_pBoneShieldData->m_fReducePercent	= kSocketData.m_fIncOrDecRate;

	if ( kSocketData.m_vecEffectName.size() != 2 )
	{
		ASSERT( !L"m_vecEffectName size is fault" );
		m_pBoneShieldData->m_hEffectSet		= g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_BesmaHell_Set_Barrier_Wait", this, this );
		g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_BesmaHell_Set_Barrier", this, this );
	}
	else
	{
		m_pBoneShieldData->m_hEffectSet		= g_pX2Game->GetEffectSet()->PlayEffectSet( kSocketData.m_vecEffectName[0], this, this );
		m_pBoneShieldData->m_wstrEffectName = kSocketData.m_vecEffectName[1];		// 타격 당했을 때 나올 이펙트 셋 명
	}

	g_pX2Game->GetEffectSet()->PlayEffectSet( m_pBoneShieldData->m_wstrEffectName, this, this );
}

void CX2GUUser::CheckAndDeleteBoneShield( float fElpasedTime )
{
	if ( m_pBoneShieldData != NULL )
	{
		m_pBoneShieldData->m_fTimeLeft		-= fElpasedTime;
		m_pBoneShieldData->m_fIntervalTime	-= fElpasedTime;

		if ( m_pBoneShieldData->m_hEffectSet != INVALID_EFFECTSET_HANDLE 
			 && ( m_pBoneShieldData->m_fTimeLeft <= 0.0f || m_pBoneShieldData->m_byCountLeft <= 0 ) )
			m_pBoneShieldData->DestroyParticle();

		if ( m_pBoneShieldData->m_fIntervalTime <= 0.0f && m_pBoneShieldData->m_hEffectSet == INVALID_EFFECTSET_HANDLE )
			DeleteBoneShield();
	}
}

// kimhc // 2010-11-01 GameUnit으로 옮김
// bool CX2GUUser::GreaterExtraDamageTime( CX2DamageManager::ExtraDamageData* pFirst, CX2DamageManager::ExtraDamageData *pSecond )
// {
// 	return pFirst->m_fTime > pSecond->m_fTime;
// }

#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
void CX2GUUser::CheckSocketOptionCoolTime( const float fElpasedTime_ )
{
	if ( GetSocketOptionCoolTime() > 0.0f )
	{
		SetSocketOptionCoolTime( GetSocketOptionCoolTime() - fElpasedTime_ );

		if ( GetSocketOptionCoolTime() <= 0.0f )
			SetSocketOptionCoolTime( 0.0f );
	}
}

void CX2GUUser::CheckSocketOptionHyperCoolTime( const float fElpasedTime_ )
{
	if ( GetSocketOptionHyperCoolTime() > 0.0f )
	{
		SetSocketOptionHyperCoolTime( GetSocketOptionHyperCoolTime() - fElpasedTime_ );

		if ( GetSocketOptionHyperCoolTime() <= 0.0f )
			SetSocketOptionHyperCoolTime( 0.0f );
	}
}

void CX2GUUser::CheckSocketMpUpAttackedCoolTime( const float fElpasedTime_ )
{
	if( false == m_SocketData.m_vecMpUpByAttacked.empty() )
	{
		BOOST_TEST_FOREACH( D3DXVECTOR4&, val,  m_SocketData.m_vecMpUpByAttacked )
		{
			if ( val.z > 0.0f ) // m_fIntervalTime이 세팅되어 있다면 쿨타임 체크 시작.
			{
				if( val.w > 0.0f ) 
				{
					val.w -= fElpasedTime_;

					if( val.w <= 0.0f )
						val.w = 0.0f;
				}
			}
		}
	}
}

const float CX2GUUser::GetSocketReducedDamagePercentInCase( const CX2SocketItem::SocketData& kSocketData_ )
{
	float fReducedDamagePer = 0;

	if ( kSocketData_.m_fDamageReduce > 0.0f && kSocketData_.m_fPercentDamageReduce > GetRandomFloat() )
	{
		if ( kSocketData_.m_bDungeonOnly == true )
		{
			if ( g_pX2Game != NULL && ( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON || g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD ) )
			{
				fReducedDamagePer += kSocketData_.m_fDamageReduce;		
			}
		}
		else if ( kSocketData_.m_bPVPOnly == true )
		{
			if ( g_pX2Game != NULL && g_pX2Game->GetGameType() == CX2Game::GT_PVP )
			{
				fReducedDamagePer += kSocketData_.m_fDamageReduce;
			}
		}
		else
		{
			fReducedDamagePer += kSocketData_.m_fDamageReduce;
		}
	}

	return fReducedDamagePer;
}
#endif //ADJUST_SECRET_ITEM_OPTION

#endif SERV_SECRET_HELL
//}} kimhc // 2010.4.1 // 비밀던전 작업(셋트아이템효과)


#ifdef LINKED_LINEMAP_JUMP_USER_TEST

void CX2GUUser::LinkJumpEventProcess()
{
	if( m_fLinkJumpTime <= 0.f )
	{
		//StateChange( m_CommonState.m_Wait );
		StateChange( USI_JUMP_DOWN );
	}

	CommonEventProcess();
}

void CX2GUUser::LinkJumpPhysicProcess( double fTime, float fElapsedTime )
{
	KTDXPROFILE();

	//if( m_NPCStateData.stateID == m_LinkJumpState )
	{
		if( m_fLinkJumpTime > 0.f )
		{
			m_vLinkJumpSpeed += m_vLinkJumpAcceleration * fElapsedTime;
			m_FrameDataFuture.syncData.position += m_vLinkJumpSpeed * fElapsedTime;

			m_fLinkJumpTime -= fElapsedTime;
			if( m_fLinkJumpTime <= 0.f )
			{
				m_fLinkJumpTime = 0.f;
				m_vLinkJumpSpeed = D3DXVECTOR3( 0, 0, 0 );
				m_vLinkJumpAcceleration = D3DXVECTOR3( 0, 0, 0);
			}
		}
	}
}


bool CX2GUUser::CanLinkJumpNow( float fElapsedTimeLastLinkJump /*= 0.f*/ )
{
	if( m_fElapsedTimeAfterLastLinkJump < fElapsedTimeLastLinkJump )
		return false;

	const CKTDGLineMap::LineData* pCurrLineData = g_pX2Game->GetLineMap()->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );
	if( NULL != pCurrLineData && true == pCurrLineData->bEnable )
	{
		m_iLinkJumpTargetLineIndex = pCurrLineData->GetRandomLinkedLineIndex( GetRandomInt() );
		ASSERT( m_iLinkJumpTargetLineIndex >= 0 );
		const CKTDGLineMap::LineData* pTargetLineData = g_pX2Game->GetLineMap()->GetLineData( m_iLinkJumpTargetLineIndex );
		ASSERT( NULL != pTargetLineData );
		if( NULL != pTargetLineData && true == pTargetLineData->bEnable )
		{
			return true;
		}
	}

	return false;
}


void CX2GUUser::LinkJumpStart()
{
	//if( m_NPCStateData.stateID == m_LinkJumpState )
	{
		m_fElapsedTimeAfterLastLinkJump = 0.f;

		bool bDone = false;

		const CKTDGLineMap::LineData* pCurrLineData = g_pX2Game->GetLineMap()->GetLineData( m_FrameDataFuture.syncData.lastTouchLineIndex );
		if( NULL != pCurrLineData && true == pCurrLineData->bEnable )
		{
			m_iLinkJumpTargetLineIndex = pCurrLineData->GetRandomLinkedLineIndex( GetRandomInt() );
			ASSERT( m_iLinkJumpTargetLineIndex >= 0 );
			const CKTDGLineMap::LineData* pTargetLineData = g_pX2Game->GetLineMap()->GetLineData( m_iLinkJumpTargetLineIndex );
			ASSERT( NULL != pTargetLineData );
			if( NULL != pTargetLineData && true == pTargetLineData->bEnable )
			{
				////float fRandomInterpolation = GetRandomFloat();
				//D3DXVECTOR3 vDist = GetPos( true ) - pCurrLineData->endPos;
				//float fRandomInterpolation = D3DXVec3Length( &vDist ) / pCurrLineData->fLength;
				//ASSERT( fRandomInterpolation >= 0.f && fRandomInterpolation <= 1.f );
				//if( fRandomInterpolation < 0.f )
				//{
				//	fRandomInterpolation = 0.f;
				//}
				//else if( fRandomInterpolation > 1.f )
				//{
				//	fRandomInterpolation = 1.f;
				//}
				//m_vLinkJumpTarget = pTargetLineData->startPos * fRandomInterpolation + pTargetLineData->endPos * (1.f - fRandomInterpolation);
				m_vLinkJumpTarget = g_pKTDXApp->GetCollision()->FindNearestPointOnLineSegment( GetPos( true ), pTargetLineData->startPos, pTargetLineData->endPos );


				// 이동거리 = 초기속도 * 시간 + 가속도 * 시간의 제곱 * 0.5
				D3DXVECTOR3 vDistance = m_vLinkJumpTarget - GetPos();
				m_vLinkJumpSpeed.x = vDistance.x - m_vLinkJumpAcceleration.x * m_fLinkJumpTime * m_fLinkJumpTime * 0.5f;
				m_vLinkJumpSpeed.y = vDistance.y - m_vLinkJumpAcceleration.y * m_fLinkJumpTime * m_fLinkJumpTime * 0.5f;
				m_vLinkJumpSpeed.z = vDistance.z - m_vLinkJumpAcceleration.z * m_fLinkJumpTime * m_fLinkJumpTime * 0.5f;
				m_vLinkJumpSpeed /= m_fLinkJumpTime;

				SetCanNotInputTime_LUA( m_fLinkJumpTime );

				bDone = true;
			}
		}

		if( false == bDone )
		{
			m_fLinkJumpTime = 0.f;
		}
	}
}


void CX2GUUser::LinkJumpEnd()
{
	KTDXPROFILE();

	//if( m_NPCStateData.stateID == m_LinkJumpState )
	{
		m_fElapsedTimeAfterLastLinkJump = 0.f;

		const CKTDGLineMap::LineData* pTargetLineData = g_pX2Game->GetLineMap()->GetLineData( m_iLinkJumpTargetLineIndex );
		if( NULL != pTargetLineData && true == pTargetLineData->bEnable )
		{
			m_FrameDataFuture.syncData.lastTouchLineIndex = m_iLinkJumpTargetLineIndex;
			m_FrameDataFuture.syncData.position = m_vLinkJumpTarget;
			m_vLinkJumpSpeed = D3DXVECTOR3( 0, 0, 0 );
			m_vLinkJumpAcceleration = D3DXVECTOR3( 0, 0, 0);
			m_fLinkJumpTime = 0.f;

			//SetCanNotInputTime_LUA( 0 );

		}
		else
		{
			ASSERT( !"NO NO NO" );			
		}
	}
}

#endif LINKED_LINEMAP_JUMP_USER_TEST

//{{ kimhc // 2010.6.16 
// 1. GameUnit::Weapon::SetEnchantParticleShow() 과 GUUser::SetShowEnchantedWeaponEffectAtHand()을
// 같이 쓰는 경우가 많으므로 한데 묶음
// 2. NotifyShowObjectChanged()에서는 서로 따로 호출하도록 되어있는것을 한곳에서만 호출하도록 수정
// 3. virtual로 만들어서 GameUnit에서는 GameUnit::Weapon::SetEnchantParticleShow()를 호출하고
// GUUser에서는 SetShowEnchantedWeaponEffectAtHand()를 호출하도록 변경
#ifdef	ENCHANT_BUG_TEST
/*virtual*/ void CX2GUUser::SetShowEnchantWeaponParticle( bool bShow )
{
	CX2GameUnit::SetShowEnchantWeaponParticle( bShow );
	SetShowEnchantedWeaponEffectAtHand( bShow );
}
#endif	ENCHANT_BUG_TEST

#ifdef SERV_PET_SYSTEM
void CX2GUUser::CommonStartStateEnd()
{
// 	CX2PET *pPet = g_pData->GetPetManager()->GetPet( GetUnitUID() );
// 	if( pPet != NULL )
// 	{
// 		pPet->InitGamePet();
// 	}
}

void CX2GUUser::WinStateStart()
{
	CommonStateStart();

	if( g_pX2Game != NULL && g_pX2Game->IsHost() == true )
	{
		CX2PET *pPet = g_pData->GetPetManager()->GetPet( GetUnitUID() );
		if( pPet != NULL )
		{
			int iRand = rand() % 2;
			if( iRand == 0 )
				pPet->StateChange( pPet->m_Happy1State, true, true );
			else
				pPet->StateChange( pPet->m_Happy2State, true, true );
		}
	}	
}
void CX2GUUser::LoseStateStart()
{
	CommonStateStart();

	if( g_pX2Game != NULL && g_pX2Game->IsHost() == true )
	{
		CX2PET *pPet = g_pData->GetPetManager()->GetPet( GetUnitUID() );
		if( pPet != NULL )
		{
			pPet->StateChange( pPet->m_SadState, true, true );
		}
	}	
}

#endif

/** @function : CreateStepDust
	@brief : 대시 등의 상태에서 라인맵의 eDustType에 따라 다른 파티클을 보여주기 위한 함수
	@param : void
	@return : void
*/
/*virtual*/ void CX2GUUser::CreateStepDust()
{
	CKTDGParticleSystem*	pMinorParticleSystem = g_pX2Game->GetMinorParticle();
	CX2World*				pWorld = g_pX2Game->GetWorld();

	if( NULL != pWorld &&
		NULL != pWorld->GetLineMap() )
	{
		const CKTDGLineMap::LineData* pLineData = pWorld->GetLineMap()->GetLineData( m_FrameDataNow.syncData.lastTouchLineIndex );

		if( NULL != pLineData )
		{
			switch( pLineData->eDustType )
			{
			default:
			case CKTDGLineMap::LDT_DEFALT_DUST:
				{
					CKTDGParticleSystem::CParticleEventSequence* pSeq = pMinorParticleSystem->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_STEP_SMOKE ) );
					PlaySequenceByTriggerCount( pSeq, m_FrameDataNow.unitCondition.landPosition, 100, 100, 5 );
				} break;

			case CKTDGLineMap::LDT_WATER_SPLASH:
				{
					CKTDGParticleSystem::CParticleEventSequence* pSeq = pMinorParticleSystem->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_STEP_WATER ) );
					PlaySequenceByTriggerCount( pSeq, m_FrameDataNow.unitCondition.landPosition, 100, 100, 12 );

				} break;
			}
		}
	}
	else	// World or LineMap이 없으면
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = pMinorParticleSystem->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_STEP_SMOKE ) );
		PlaySequenceByTriggerCount( pSeq, m_FrameDataNow.unitCondition.landPosition, 100, 100, 5 );
	}
}

//{{ kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함
void CX2GUUser::SetHoldStateByReactType( CX2DamageManager::REACT_TYPE eReactType /*= CX2DamageManager::RT_DOWN */ )
{
	switch ( eReactType )
	{
	default:
	case CX2DamageManager::RT_DOWN:
		SetHoldStateID( USI_DAMAGE_AIR_FALL );
		break;
	}
}
//}} kimhc // 2010.7.12 // 여러명의 유저를 HOLD 할 수 있도록 함

/** @function : PlayCommonBuffMinorParticle
	@brief : CommonBuffFrame에서 쓰이는 파티클 출력
*/
void CX2GUUser::PlayCommonBuffMinorParticle()
{
	D3DXVECTOR3 pos = GetBonePos( L"Dummy1_Rhand" );

	CKTDGParticleSystem::CParticleEventSequence* pSeqGroundShockWave = g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_GROUND_SHOCK_WAVE ) );
	PlaySequenceByTriggerCount( pSeqGroundShockWave, m_FrameDataNow.unitCondition.landPosition.x, m_FrameDataNow.unitCondition.landPosition.y + 5.0f, m_FrameDataNow.unitCondition.landPosition.z,  5, 10,  3 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqWhiteShockWave  = g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_WHITE_SHOCK_WAVE ) );
	PlaySequenceByTriggerCount( pSeqWhiteShockWave, pos, 10, 10,  1 );

	CKTDGParticleSystem::CParticleEventSequence* pSeqImpactTick		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_IMPACT_TICK ) );
	PlaySequenceByTriggerCount( pSeqImpactTick, pos,  200, 200,  30 );
	
	if( pSeqImpactTick != NULL )
	{
		pSeqImpactTick->SetLandPosition( m_FrameDataNow.unitCondition.landPosition.y );
	}
}

/** @function : GetSkillSlotIndexUsed
	@brief : 사용된 슬롯의 인덱스 및 B슬롯 사용여부를 리턴 ( 각 클래스의 COMMON_BUFF_FrameMove에 있는 것을 옮겨옴 )
*/
bool CX2GUUser::GetSkillSlotIndexUsed( OUT int& iSkillSlotIndex_, OUT bool& bSlotB_ )
{
	//const CX2Unit::UnitData* pUnitData = &GetUnit()->GetUnitData();

	//현재 사용된 스킬이 뭔지 알아낸다
	switch( m_NowStateData.stateID )
	{
	case USI_SPECIAL_ATTACK_1:
	case USI_SPECIAL_ATTACK_HYPER_1:
		{
			iSkillSlotIndex_ = 0;
		} break;
	case USI_SPECIAL_ATTACK_2:
	case USI_SPECIAL_ATTACK_HYPER_2:
		{
			iSkillSlotIndex_ = 1;
		} break;
	case USI_SPECIAL_ATTACK_3:
	case USI_SPECIAL_ATTACK_HYPER_3:
		{
			iSkillSlotIndex_ = 2;
		} break;
	case USI_SPECIAL_ATTACK_4:
	case USI_SPECIAL_ATTACK_HYPER_4:
		{
			iSkillSlotIndex_ = 3;
		} break;

	case USI_SPECIAL_ATTACK_SLOTB_1:
	case USI_SPECIAL_ATTACK_SLOTB_HYPER_1:
		{
			iSkillSlotIndex_ = 0;
			bSlotB_ = true;
		} break;
	case USI_SPECIAL_ATTACK_SLOTB_2:
	case USI_SPECIAL_ATTACK_SLOTB_HYPER_2:
		{
			iSkillSlotIndex_ = 1;
			bSlotB_ = true;
		} break;
	case USI_SPECIAL_ATTACK_SLOTB_3:
	case USI_SPECIAL_ATTACK_SLOTB_HYPER_3:
		{
			iSkillSlotIndex_ = 2;
			bSlotB_ = true;
		} break;
	case USI_SPECIAL_ATTACK_SLOTB_4:
	case USI_SPECIAL_ATTACK_SLOTB_HYPER_4:
		{
			iSkillSlotIndex_ = 3;
			bSlotB_ = true;
		} break;

	default:
		ASSERT( !L"Wrong Path" );
		return false;
		break;
	}

	return true;
}


//{{ kimhc // 2010.12.6 // 2010-12-23 New Character CHUNG
#ifdef	NEW_CHARACTER_CHUNG
/** @function : SetDamageData
	@brief : 각 스테이트의 FrameMove 중간에 DAMAGE_DATA 타입을 변경하기 위한 함수
	@param :  const wstring& wstrTableName_ (데미지 데이터 테이블 네임)
*/            //<ADD_MEMO_1ST_CLASS>  const bool IsEqippedMemo_ (메모 배웠는지 여부)
#ifdef ADD_MEMO_1ST_CLASS
bool CX2GUUser::SetDamageData( const char* pszTableNameUTF8_, const bool IsEqippedMemo_ /*= false*/ )
#else //ADD_MEMO_1ST_CLASS
void CX2GUUser::SetDamageData( const char* pszTableNameUTF8_ )
#endif //ADD_MEMO_1ST_CLASS
{
#ifdef ADD_MEMO_1ST_CLASS
	bool bIsSetDamageData = g_pData->GetDamageManager()->SetDamageDataFromLUA( &m_DamageData, m_LuaManager, pszTableNameUTF8_, GetPowerRate(), IsEqippedMemo_ );
#else //ADD_MEMO_1ST_CLASS
	g_pData->GetDamageManager()->SetDamageDataFromLUA( &m_DamageData, m_LuaManager, pszTableNameUTF8_, GetPowerRate() );
#endif //ADD_MEMO_1ST_CLASS

	if( m_DamageData.attackType != CX2DamageManager::AT_SPECIAL &&
		false == IsSamef(m_DamageData.fForceDownValue, 0.f) )
	{
		// 패시브 스킬에 따라 강제다운 수치 조정
		if( 1.f != m_SkillRelatedData.GetForceDownValueRateOfMeleeAttack() )
		{
			m_DamageData.fForceDownValue *= m_SkillRelatedData.GetForceDownValueRateOfMeleeAttack();//+= CalulateIncreaseingRate( m_SkillRelatedData.m_fForceDownValueRateOfMeleeAttack );
		}
	}
#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE	  // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트
	ChangeDamageData ();				  // 패시브에 영향을 받는 커맨드 등, 데미지가 일어났을 때에 대한 처리를 스크립트, 각 캐릭터 소스 코드 내에서 처리 할 수 없을 때, 하드 코딩
#endif // SERV_ELESIS_SECOND_CLASS_CHANGE // 김종훈, 엘리시스 1-2 그랜드 마스터, 2-2 블레이징 하트

#ifdef ADD_MEMO_1ST_CLASS //김창한
	return bIsSetDamageData;
#endif //ADD_MEMO_1ST_CLASS
}

/** @function : CreateWeapon
	@brief : 아이템 템플릿과 EquipPtr을 사용하여 Weapon 객체를 생성, 
	@param :  IN const CX2Item::ItemTemplet* pItemTemplet (무기 아이템의 템플릿)
*/
void CX2GUUser::CreateWeapon( 
    IN const CX2Item::ItemTemplet* pItemTemplet_, 
    CX2EqipPtr pEquipWeaponPtr_ )
{
	if ( pEquipWeaponPtr_ == NULL || 
        NULL == pItemTemplet_ 
        )
		return;

	int iWeaponIndex = 0;
	switch ( pItemTemplet_->GetEqipPosition() )
	{
	case CX2Unit::EP_WEAPON_HAND:
		iWeaponIndex = 0;
		break;

	case CX2Unit::EP_WEAPON_SECOND:
		iWeaponIndex = 1;
		break;

	default:
		return;
		break;
	}

	//{{ robobeg : 2008-10-28
	CX2GameUnit::Weapon* pWeapon = CX2GameUnit::Weapon::CreateWeapon( *this, pItemTemplet_ );
	ASSERT( pWeapon != NULL );
	//}} robobeg : 2008-10-28
	pWeapon->m_iWeaponIndex			= iWeaponIndex;
	pWeapon->m_pUserWeaponEquip		= pEquipWeaponPtr_;
	pWeapon->m_bUseSlashTrace		= true;
	
#ifdef ITEM_SLASH_TRACE_COLOR_TEST
#ifdef	X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
	if( NULL != GetUnit() )
	{
		pItemTemplet_->GetSlashTraceColors( pWeapon->m_coSlashTrace, pWeapon->m_coSlashTraceTip
			, pWeapon->m_coSlashTraceHyper, pWeapon->m_coSlashTraceTipHyper, GetUnit()->GetType() );
	}
#else   //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
	pWeapon->m_coSlashTrace			= pItemTemplet_->m_coSlashTrace;
	pWeapon->m_coSlashTraceHyper	= pItemTemplet_->m_coSlashTraceHyper;
	pWeapon->m_coSlashTraceTip		= pItemTemplet_->m_coSlashTraceTip;
	pWeapon->m_coSlashTraceTipHyper	= pItemTemplet_->m_coSlashTraceTipHyper;
#endif  //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
#endif ITEM_SLASH_TRACE_COLOR_TEST

	m_vecpWeapon.push_back( pWeapon );

#ifdef USER_WEAPON_PARTICLE_SCRIPT_TEST
	if( NULL != g_pX2Game &&
		NULL != g_pX2Game->GetMajorParticle() )
	{
        DWORD   dwNumParticles = pItemTemplet_->GetNumAttachedParticleData();
		for( UINT j=0; j<dwNumParticles; j++ )
		{
            const wchar_t*  pwszParticleName = L"";
            const wchar_t*  pwszBoneName = L"";
#ifdef  X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
            pItemTemplet_->GetAttachedParticleData( j, &pwszParticleName, &pwszBoneName );
#else   //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
			const CX2Item::AttachedParticleData& particleData = pItemTemplet_->GetAttachedParticleData(j);
            pwszParticleName = particleData.wstrParticleName.c_str();
            pwszBoneName = particleData.wstrBoneName.c_str();
#endif  //X2OPTIMIZE_ITEM_TEMPLET_PREPROCESSING
			CKTDGParticleSystem::CParticleEventSequence* pSeq = 
				g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  pwszParticleName, D3DXVECTOR3( 0, 0, 0 ) );
			if( NULL != pSeq )
			{
				AttachWeaponParticle( pWeapon->m_iWeaponIndex, true, pwszBoneName, pSeq->GetHandle() );
			}
		}
	}
#endif USER_WEAPON_PARTICLE_SCRIPT_TEST
}

#ifdef	NOT_RENDERING_OTHER_EQUIP_POS
/** @function : UpdateNotRenderingOtherEquipList
	@brief : AC_FACE1 악세사리에 의해 렌더링 되지 말아야할 아이템들을 m_ViewEqipList에서 false 시켜줌
*/
void CX2GUUser::UpdateNotRenderingOtherEquipList()
{
#ifdef FACE_OFF_MONSTER_HEAD_TEST
	SetHideNoRenderable(false);
#endif FACE_OFF_MONSTER_HEAD_TEST

#ifdef MODIFY_AFTER_IMAGE
	m_pHairXSkinMesh = NULL;
#endif //MODIFY_AFTER_IMAGE

#ifdef ONE_PIECE_AVATAR
	// oasis907 : 김상윤 [2011.8.22] 한벌 상의 아바타
	bool bOnePieceAvatarCheck = false;

#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
	CX2EqipPtr pNoRenderFactorEquipBody = GetEquipPtrFromEquipViewListByEquipPosition( CX2Unit::EP_ONEPIECE_FASHION );
#else //SERV_NEW_ONE_PIECE_AVATAR_SLOT
	CX2EqipPtr pNoRenderFactorEquipBody = GetEquipPtrFromEquipViewListByEquipPosition( CX2Unit::EP_DEFENCE_BODY );
#endif //SERV_NEW_ONE_PIECE_AVATAR_SLOT
	
	if( pNoRenderFactorEquipBody != NULL )
	{
#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
		if ( IsOnePieceAvatarRenderHair( pNoRenderFactorEquipBody->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				if( IsOnePieceAvatarWithNotRenderHairItem( pViewEquip->GetItemID() ) == true )
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_AC_FACE2:
					case CX2Unit::EP_DEFENCE_LEG:
					case CX2Unit::EP_DEFENCE_HAND:
					case CX2Unit::EP_DEFENCE_FOOT:
					case CX2Unit::EP_DEFENCE_BODY:
						{
							pViewEquip->SetShowObject( false );
							bOnePieceAvatarCheck = true;
						}
						break;

					default:
						break;
					}
				}
				else
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_DEFENCE_LEG:
					case CX2Unit::EP_DEFENCE_HAND:
					case CX2Unit::EP_DEFENCE_FOOT:
					case CX2Unit::EP_DEFENCE_BODY:
						{
							pViewEquip->SetShowObject( false );
							bOnePieceAvatarCheck = true;
						}
						break;

					default:
						break;
					}
				}
			}
		}
#endif SERV_NEW_ONE_PIECE_AVATAR_SLOT
		if ( IsOnePieceAvatar( pNoRenderFactorEquipBody->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					{
						pViewEquip->SetShowObject( false );
						bOnePieceAvatarCheck = true;
#ifdef MODIFY_AFTER_IMAGE
						if( NULL == m_pHairXSkinMesh )
						{
							m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
						}
#endif //MODIFY_AFTER_IMAGE
					} break;
				case CX2Unit::EP_DEFENCE_LEG:
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_DEFENCE_FOOT:
#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
				case CX2Unit::EP_DEFENCE_BODY:
#endif //SERV_NEW_ONE_PIECE_AVATAR_SLOT
					{
						pViewEquip->SetShowObject( false );
						bOnePieceAvatarCheck = true;
					}
					break;

				default:
					break;
				}
			}
		}
		if ( IsOnePieceAvatarNotRenderFace1( pNoRenderFactorEquipBody->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					{
						pViewEquip->SetShowObject( false );
						bOnePieceAvatarCheck = true;
#ifdef MODIFY_AFTER_IMAGE
						if( NULL == m_pHairXSkinMesh )
						{
							m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
						}
#endif //MODIFY_AFTER_IMAGE
					} break;
				case CX2Unit::EP_DEFENCE_LEG:
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_DEFENCE_FOOT:
				case CX2Unit::EP_AC_FACE1:
#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
				case CX2Unit::EP_DEFENCE_BODY:
#endif //SERV_NEW_ONE_PIECE_AVATAR_SLOT
					{
						pViewEquip->SetShowObject( false );
						bOnePieceAvatarCheck = true;
					}
					break;

				default:
					break;
				}
			}
		}
		if ( IsOnePieceAvatarNotRenderFace1Face2( pNoRenderFactorEquipBody->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					{
						pViewEquip->SetShowObject( false );
						bOnePieceAvatarCheck = true;
#ifdef MODIFY_AFTER_IMAGE
						if( NULL == m_pHairXSkinMesh )
						{
							m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
						}
#endif //MODIFY_AFTER_IMAGE
					} break;
				case CX2Unit::EP_DEFENCE_LEG:
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_DEFENCE_FOOT:
				case CX2Unit::EP_AC_FACE1:
				case CX2Unit::EP_AC_FACE2:
					{
						pViewEquip->SetShowObject( false );
						bOnePieceAvatarCheck = true;
					}
					break;

				default:
					break;
				}
			}
		}
		if ( IsOnePieceAvatarNotRenderFace( pNoRenderFactorEquipBody->GetItemID() ) == true )
		{
			SetHideNoRenderable(true);
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					{
						pViewEquip->SetShowObject( false );
						bOnePieceAvatarCheck = true;
#ifdef MODIFY_AFTER_IMAGE
						if( NULL == m_pHairXSkinMesh )
						{
							m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
						}
#endif //MODIFY_AFTER_IMAGE
					} break;
#ifdef FIX_ARA_ONE_PIECE_FOR_BERSERK
				case CX2Unit::EP_DEFENCE_FACE:
#endif //FIX_ARA_ONE_PIECE_FOR_BERSERK
				case CX2Unit::EP_DEFENCE_LEG:
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_DEFENCE_FOOT:
				case CX2Unit::EP_AC_FACE2:
				case CX2Unit::EP_AC_FACE3:
#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
				case CX2Unit::EP_DEFENCE_BODY:
#endif //SERV_NEW_ONE_PIECE_AVATAR_SLOT
					{
						pViewEquip->SetShowObject( false );
						bOnePieceAvatarCheck = true;
					}
					break;

				default:
					break;
				}
			}
		}
		/// 한벌 아바타 외에 헤어와 모든 악세서리를 꺼야 하는 아이템
		if ( IsOnePieceAvatarNotRenderHairAndAllAccessory( pNoRenderFactorEquipBody->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					{
						bOnePieceAvatarCheck = true;
						pViewEquip->SetShowObject( false );
#ifdef MODIFY_AFTER_IMAGE
						if( NULL == m_pHairXSkinMesh )
						{
							m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
						}
#endif //MODIFY_AFTER_IMAGE
					} break;
				case CX2Unit::EP_DEFENCE_LEG:
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_DEFENCE_FOOT:
				case CX2Unit::EP_AC_FACE1:
				case CX2Unit::EP_AC_FACE2:
				//case CX2Unit::EP_AC_FACE3:	/// 요청으로 인한 얼굴 (하) 제외
				case CX2Unit::EP_AC_BODY:
				case CX2Unit::EP_AC_LEG:
				case CX2Unit::EP_AC_ARM:
				case CX2Unit::EP_AC_NECKLESS:
#ifdef SERV_NEW_ONE_PIECE_AVATAR_SLOT
				case CX2Unit::EP_DEFENCE_BODY:
#endif //SERV_NEW_ONE_PIECE_AVATAR_SLOT
					pViewEquip->SetShowObject( false );
					bOnePieceAvatarCheck = true;
					break;

				default:
					break;
				}
			}
		}
		if ( IsOnePieceAvatarRenderingHairAndFace1( pNoRenderFactorEquipBody->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_LEG:
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_DEFENCE_FOOT:
					{
						pViewEquip->SetShowObject( false );
					}
					break;

				default:
					break;
				}
			}
		}

		// 2012.12.02 darkstarbt_조성욱 // 한벌 아바타 인데 상의랑 하의가 비어 있어서 기존 입고 있는 아바타 들이 나와야 하는 경우
		if ( IsOnePieceAvatarWithRenderBodyItem( pNoRenderFactorEquipBody->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					{
						bOnePieceAvatarCheck = true;
						pViewEquip->SetShowObject( false );
#ifdef MODIFY_AFTER_IMAGE
						if( NULL == m_pHairXSkinMesh )
						{
							m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
						}
#endif //MODIFY_AFTER_IMAGE
					} break;
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_AC_FACE1:
				case CX2Unit::EP_AC_FACE2:
				case CX2Unit::EP_AC_NECKLESS:
					{
						bOnePieceAvatarCheck = true;
						pViewEquip->SetShowObject( false );
					}
					break;

				default:
					break;
				}
			}
		}
#ifdef CRAYONPOP_EMOTION_WITH_MUSIC		// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨
		if ( IsOnePieceAvatarOnlyRenderFace1Face2Face3Equip( pNoRenderFactorEquipBody->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					{
						pViewEquip->SetShowObject( false );
						if( NULL == m_pHairXSkinMesh )
						{
							m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
						}
					} break;
				case CX2Unit::EP_DEFENCE_LEG:
				case CX2Unit::EP_DEFENCE_HAND:
				case CX2Unit::EP_DEFENCE_FOOT:
				case CX2Unit::EP_AC_BODY:
				case CX2Unit::EP_AC_LEG:
				case CX2Unit::EP_AC_ARM:
				case CX2Unit::EP_AC_NECKLESS:
					pViewEquip->SetShowObject( false );
					bOnePieceAvatarCheck = true;
					break;

				default:
					break;
				}
			}
		}

#endif // CRAYONPOP_EMOTION_WITH_MUSIC	// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨
	}
#endif ONE_PIECE_AVATAR

#ifdef FACE_OFF_MONSTER_HEAD_TEST
	CX2EqipPtr pNoRenderFactorEquipACArm = GetEquipPtrFromEquipViewListByEquipPosition( CX2Unit::EP_AC_ARM );
	if( pNoRenderFactorEquipACArm != NULL )
	{
		if ( IsNoRenderHandEquip( pNoRenderFactorEquipACArm->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAND:
					{
						pViewEquip->SetShowObject( false );
					}
					break;

				default:
					break;
				}
			}
		}
	}
#endif FACE_OFF_MONSTER_HEAD_TEST

	//CX2Item* pItem = GetUnit()->GetInventory().GetEquippingItemByEquipPos( CX2Unit::EP_AC_FACE1, false );
	// EP_AC_FACE1 장착위치에 있는 아이템의 id를 얻어옴
#ifdef HIDE_HAIR_BY_EP_AC_FACE2
	for( int i = 0; i < 2; ++i )
	{
		CX2EqipPtr pNoRenderFactorEquip;
		
		if( i == 0)
			pNoRenderFactorEquip = GetEquipPtrFromEquipViewListByEquipPosition( CX2Unit::EP_AC_FACE1 );
		else if( i == 1 )
			pNoRenderFactorEquip = GetEquipPtrFromEquipViewListByEquipPosition( CX2Unit::EP_AC_FACE2 );
#else
	CX2EqipPtr pNoRenderFactorEquip = GetEquipPtrFromEquipViewListByEquipPosition( CX2Unit::EP_AC_FACE1 );
#endif HIDE_HAIR_BY_EP_AC_FACE2

	if ( NULL != pNoRenderFactorEquip )
	{
		// kimhc // 이 이상 안보여야 할 분류가 달라 진다면
		// 안보여야할 부위 및 그런 기능을 가지고 있는 아이템을 스크립트로 빼야할듯
		// 현재는 헤어만 안보이게 하는 아이템과 헤어, 얼굴 악세(중,하)를 안보이게 하는 아이템이 같은 위치 이므로
		// 한개만 착용 할 수 있음
		if ( IsNoRenderHairFace2Face3Equip( pNoRenderFactorEquip->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					{
						pViewEquip->SetShowObject( false );
#ifdef MODIFY_AFTER_IMAGE
						if( NULL == m_pHairXSkinMesh )
						{
							m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
						}
#endif //MODIFY_AFTER_IMAGE
					} break;
				case CX2Unit::EP_AC_FACE2:
				case CX2Unit::EP_AC_FACE3:
					pViewEquip->SetShowObject( false );
					break;

				default:
					break;
				}
			}
		}
		else if ( IsNoRenderHairFace2Equip( pNoRenderFactorEquip->GetItemID() ) == true )
		{
			BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
			{
				switch ( pViewEquip->GetEqipPos() )
				{
				case CX2Unit::EP_DEFENCE_HAIR:
					{
						pViewEquip->SetShowObject( false );
#ifdef MODIFY_AFTER_IMAGE
						if( NULL == m_pHairXSkinMesh )
						{
							m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
						}
#endif //MODIFY_AFTER_IMAGE
					} break;
				case CX2Unit::EP_AC_FACE2:
					pViewEquip->SetShowObject( false );
					break;

				default:
					break;
				}
			}
		}
		else if ( IsNoRenderHair( pNoRenderFactorEquip->GetItemID() ) == true )
		{
#ifdef ONE_PIECE_AVATAR
			if(bOnePieceAvatarCheck == true)
			{
				BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_AC_FACE1:
					case CX2Unit::EP_AC_FACE2:
						pViewEquip->SetShowObject( false );
						break;

					default:
						break;
					}
				}
			}
			else
#endif ONE_PIECE_AVATAR
			{
				BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_DEFENCE_HAIR:
					{
						pViewEquip->SetShowObject( false );
#ifdef MODIFY_AFTER_IMAGE
						if( NULL == m_pHairXSkinMesh )
						{
							m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
						}
#endif //MODIFY_AFTER_IMAGE
					} break;

					default:
						break;
					}
				}
			}
		}
#ifdef FACE_OFF_MONSTER_HEAD_TEST
		else if ( IsNoRenderHairFaceFace2Face3Equip( pNoRenderFactorEquip->GetItemID() ) == true )
		{
#ifdef ONE_PIECE_AVATAR
			if(bOnePieceAvatarCheck == true)
			{
				BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_AC_FACE1:
						pViewEquip->SetShowObject( false );
						break;

					default:
						break;
					}
				}
			}
			else
#endif ONE_PIECE_AVATAR
			{
				SetHideNoRenderable(true);
				BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_DEFENCE_HAIR:
						{
							pViewEquip->SetShowObject( false );
#ifdef MODIFY_AFTER_IMAGE
							if( NULL == m_pHairXSkinMesh )
							{
								m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
							}
#endif //MODIFY_AFTER_IMAGE
						} break;
#ifdef FIX_ARA_ONE_PIECE_FOR_BERSERK
					case CX2Unit::EP_DEFENCE_FACE:
#endif //FIX_ARA_ONE_PIECE_FOR_BERSERK
					case CX2Unit::EP_AC_FACE2:
					case CX2Unit::EP_AC_FACE3:
						pViewEquip->SetShowObject( false );
						break;
					default:
						break;
					}
				}
			}
		}
#endif FACE_OFF_MONSTER_HEAD_TEST
	}

	pNoRenderFactorEquip = GetEquipPtrFromEquipViewListByEquipPosition( CX2Unit::EP_AC_FACE2 );

	if ( NULL != pNoRenderFactorEquip )
	{
#ifdef FACE_OFF_MONSTER_HEAD_TEST
		if ( IsNoRenderHairFaceFace1Face3Equip( pNoRenderFactorEquip->GetItemID() ) == true )
		{
		#ifdef ONE_PIECE_AVATAR
			if(bOnePieceAvatarCheck == true)
			{
				BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_AC_FACE2:
						pViewEquip->SetShowObject( false );
						break;

					default:
						break;
					}
				}
			}
			else
		#endif ONE_PIECE_AVATAR
			{
				SetHideNoRenderable(true);
				BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_DEFENCE_HAIR:
						{
							pViewEquip->SetShowObject( false );
	#ifdef MODIFY_AFTER_IMAGE
							if( NULL == m_pHairXSkinMesh )
							{
								m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
							}
	#endif //MODIFY_AFTER_IMAGE
						} break;
	#ifdef FIX_ARA_ONE_PIECE_FOR_BERSERK
					case CX2Unit::EP_DEFENCE_FACE:
	#endif //FIX_ARA_ONE_PIECE_FOR_BERSERK
					case CX2Unit::EP_AC_FACE1:
					case CX2Unit::EP_AC_FACE3:
						pViewEquip->SetShowObject( false );
						break;
					default:
						break;
					}
				}
			}
		}
		else if ( IsNoRenderHair( pNoRenderFactorEquip->GetItemID() ) == true )
		{
#ifdef ONE_PIECE_AVATAR
			if(bOnePieceAvatarCheck == true)
			{
				BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_AC_FACE1:
					case CX2Unit::EP_AC_FACE2:
						pViewEquip->SetShowObject( false );
						break;

					default:
						break;
					}
				}
			}
			else
#endif ONE_PIECE_AVATAR
			{
				BOOST_TEST_FOREACH( CX2EqipPtr, pViewEquip, m_ViewEqipList )
				{
					switch ( pViewEquip->GetEqipPos() )
					{
					case CX2Unit::EP_DEFENCE_HAIR:
						{
							pViewEquip->SetShowObject( false );
#ifdef MODIFY_AFTER_IMAGE
							if( NULL == m_pHairXSkinMesh )
							{
								m_pHairXSkinMesh = pViewEquip->GetNormalModel(0);
							}
#endif //MODIFY_AFTER_IMAGE
						} break;

					default:
						break;
					}
				}
			}
		}
	}
#endif FACE_OFF_MONSTER_HEAD_TEST

#ifdef MODIFY_AFTER_IMAGE
	if( NULL != m_pAfterImage )
	{
		m_pAfterImage->SetpHairSkinMesh( m_pHairXSkinMesh );
	}
#endif //MODIFY_AFTER_IMAGE
}
#ifdef HIDE_HAIR_BY_EP_AC_FACE2
}
#endif HIDE_HAIR_BY_EP_AC_FACE2
#endif	NOT_RENDERING_OTHER_EQUIP_POS

//{{ kimhc // 2010.12.10 // 신캐 작업하면서 추가함
#ifdef REAL_TIME_ELSWORD
/** @function : GetAddItemAndRemoveItemToViewList
	@brief : 장비를 장착하거나 교체할 때는 탈착 할 장비(EquipPtr)를 얻어오고, 추가해야 할 장비(pItemToAddInViewList)를 전달함\n
	장비를 탈착만 할 때는 탈착 할 장비(EquipPtr), 추가되어야 할 장비(pItemToAddInViewList)를 얻어오고, 탈착 할 장비(pItemToRemoveInViewList) 를 전달함\n
	장비를 탈착만 할 때 추가되야할 장비란 아바타 등을 탈착했을 때 보여야 할 기본장비 or normal 장비등을 말한다.
	iIndexInViewListForRemove_은 지워져야할 장비의 ViewList내에서의 index를 얻어옴
	@param : OUT CX2EqipPtr& pEquipPtrToRemove_, OUT pItemToAddInViewList_, IN CX2Item* const pItemToRemoveInViewList_, OUT int& iIndexInViewListForRemove_
	@return : bool(함수의 성공 여부)
*/
bool CX2GUUser::GetAddItemAndRemoveItemToViewList( OUT CX2EqipPtr& pEquipPtrToRemove_, IN OUT CX2Item** ppItemToAddInViewList_, IN CX2Item* const pItemToRemoveInViewList_, OUT int& iIndexInViewListForRemove_ )
{
	if (*ppItemToAddInViewList_ != NULL )		// 장착할et 장비가 있는 경우
	{	
		const CX2Item::ItemTemplet* pItemTempletForItemToAdd = (*ppItemToAddInViewList_)->GetItemTemplet();
		if ( pItemTempletForItemToAdd == NULL )
		{
			ASSERT( false );
			return false;
		}

		for ( size_t numViewEquipInUser = 0; numViewEquipInUser < m_ViewEqipList.size(); numViewEquipInUser++ )
		{
			if ( pItemTempletForItemToAdd->GetEqipPosition() == m_ViewEqipList[numViewEquipInUser]->GetEqipPos() )
			{
				// 장착할 장비가 Normal이고 해당 위치에 이미 Fashion 템이 있는 경우에는 기존의 아이템을 View에서 제거 하지 추가도 하지 않음
				if (  pItemTempletForItemToAdd->GetFashion() == false && GetUnit()->IsFashionEquipInThePosition( pItemTempletForItemToAdd->GetEqipPosition() ) == true )
				{
					*ppItemToAddInViewList_ = NULL;
				}
				else 
				{
					pEquipPtrToRemove_ = m_ViewEqipList[numViewEquipInUser];
					// 이부분에서 remove 해야할듯
				}
				iIndexInViewListForRemove_ = numViewEquipInUser;
				break;
			}
		}		
	}
	else if ( pItemToRemoveInViewList_ != NULL )		// 장비를 해제만 했을 경우
	{
		const CX2Item::ItemTemplet* pItemTempletForItemToRemove = pItemToRemoveInViewList_->GetItemTemplet();
		if ( pItemTempletForItemToRemove == NULL)
		{
			ASSERT( 0 );
			return false;
		}
		for ( size_t numViewEquipInUser = 0; numViewEquipInUser < m_ViewEqipList.size(); numViewEquipInUser++ )
		{
			if ( pItemTempletForItemToRemove->GetEqipPosition() == m_ViewEqipList[numViewEquipInUser]->GetEqipPos() )
			{
				switch ( pItemTempletForItemToRemove->GetFashion() )
				{
				case true:	// 해제 할 장비가 패션 템인 경우
					{
						pEquipPtrToRemove_ = m_ViewEqipList[numViewEquipInUser];	// 해제할 장비

						// 해제한 곳에 노말 장비가 있는 경우
						if ( GetUnit()->IsNormalEquipInThePosition( pItemTempletForItemToRemove->GetEqipPosition() ) == true )
						{
							CX2Item* pNormalEquip	= NULL;

							pNormalEquip	= GetUnit()->GetInventory().GetEquippingItemByEquipPos( pItemTempletForItemToRemove->GetEqipPosition(), false );

							if ( pNormalEquip == NULL )
								return false;

							if ( pNormalEquip->GetItemData().m_PeriodType != CX2Item::PT_ENDURANCE		// 내구도가 없는 장비거나
								|| pNormalEquip->GetItemData().m_Endurance > 0)		// 내구도가 0이하가 아니라면 노말 장비를 넣어줌
								*ppItemToAddInViewList_ = pNormalEquip;
							else
								*ppItemToAddInViewList_ = GetUnit()->CreateBasicEquip( pItemTempletForItemToRemove->GetEqipPosition() );

						}
						else	// 해제한 곳에 노말 장비도 없는 경우
						{
							*ppItemToAddInViewList_ = GetUnit()->CreateBasicEquip( pItemTempletForItemToRemove->GetEqipPosition() );
						}
					}
					break;

				case false: // 해제 할 아이템이 노말 템인 경우
					{
						// 해제한 곳에 패션 템도 없는 경우
						if (  GetUnit()->IsFashionEquipInThePosition( pItemTempletForItemToRemove->GetEqipPosition() ) == false )
						{
							pEquipPtrToRemove_		= m_ViewEqipList[numViewEquipInUser];	// 해제할 장비
							*ppItemToAddInViewList_	= GetUnit()->CreateBasicEquip( pItemTempletForItemToRemove->GetEqipPosition() );
						}
					}
					break;
				}

				iIndexInViewListForRemove_ = numViewEquipInUser;
				break;	// for문에 대한
			}
		} // for ( size_t numViewEquipInUser = 0; numViewEquipInUser < m_ViewEqipList.size(); numViewEquipInUser++ )
	}

	return true;

}
#endif REAL_TIME_ELSWORD
//}} kimhc // 2010.12.10 // 신캐 작업하면서 추가함

#endif	NEW_CHARACTER_CHUNG
//}} kimhc // 2010.12.6 //  2010-12-23 New Character CHUNG

//{{ JHKang / 강정훈 / 2011/02/14 / 던전 랭크 개선 관련
#ifdef DUNGEON_RANK_NEW
/** @function	GetUsingSkillCount
	@retrun		m_iUsingSkillCount : 계산된 스킬 사용 횟수
	@brief		사용자가 사용한 스킬의 횟수를 넘긴다. 다만 2회 이상 사용할 스킬의 경우만 횟수에 포함된다.
*/
int CX2GUUser::GetUsingSkillCount( void )
{
	for ( int i = 0; i < 4; ++i )
	{
		if ( m_iSkillSlotACount[i] > 2 )
			m_iUsingSkillCount++;

		if ( m_iSkillSlotBCount[i] > 2 )
			m_iUsingSkillCount++;
	}

	return m_iUsingSkillCount;
}

/** @function	CountUsedSkill
	@param		iSlotNumber : 슬롯 번호(A,S,D,C)
	@param		bSlotB_ : 슬롯 B 인지 확인
	@brief		A, B 슬롯 구분하여 스킬 사용 시 사용 횟수를 누적한다.
	*/
void CX2GUUser::CountUsedSkill( int iSlotNumber_ )
{
	bool bSlotB_ = (iSlotNumber_ > 3) ? true : false;
	iSlotNumber_ = (iSlotNumber_ > 3) ? iSlotNumber_-4 : iSlotNumber_;
	if ( true == bSlotB_ )
		m_iSkillSlotBCount[iSlotNumber_]++;
	else
		m_iSkillSlotACount[iSlotNumber_]++;
}
#endif DUNGEON_RANK_NEW
//}} JHKang / 강정훈 / 2011/02/14 / 던전 랭크 개선 관련

#ifdef NEW_HENIR_TEST
#ifndef ADD_HENIR_BUFF		/// 버프로 변경되면서 쓰이지 않게 된 구문
void CX2GUUser::StartHenirBuffFire()
{
	m_fTimeHenirBuff_Fire = 300.f;
	PulseWeaponRenderEffect(D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f), D3DXCOLOR(1.f, 0.0f, 0.0f, 0.1f), 0.5f, m_fTimeHenirBuff_Fire);
	if( IsLocalUnit() == true )
		g_pChatBox->AddChatLog( GET_STRING(STR_ID_13776), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
	
	return;
}

void CX2GUUser::StartHenirBuffWater()
{
	m_fTimeHenirBuff_Water = 300.f;
	PulseWeaponRenderEffect(D3DXCOLOR(0.0f, 0.8f, 1.0f, 1.0f), D3DXCOLOR(0.0f, 0.8f, 1.0f, 0.1f), 0.5f, m_fTimeHenirBuff_Water);
	if( IsLocalUnit() == true )
		g_pChatBox->AddChatLog( GET_STRING(STR_ID_13777), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
	
	return;
}

void CX2GUUser::StartHenirBuffNature()
{
	m_fTimeHenirBuff_Nature = 300.f;

	if( INVALID_EFFECTSET_HANDLE != m_hHenirBuff_Nature )
	{
		g_pX2Game->GetEffectSet()->StopEffectSet( m_hHenirBuff_Nature );
		m_hHenirBuff_Nature = INVALID_EFFECTSET_HANDLE;
	}

	if( INVALID_EFFECTSET_HANDLE == m_hHenirBuff_Nature )
	{
		m_hHenirBuff_Nature = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_HENIR_BUFF_NATURE", this );
		m_vecEffectSetToDeleteOnDie.push_back( m_hHenirBuff_Nature );
	}
	if( IsLocalUnit() == true )
		g_pChatBox->AddChatLog( GET_STRING(STR_ID_13778), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
	
	return;
}

void CX2GUUser::StartHenirBuffWind()
{
	m_fTimeHenirBuff_Wind = 300.f;

	const float MAGIC_ANIM_SPEED_FACTOR = 1.05f;
	const float MAGIC_MOVE_SPEED_FACTOR = 1.1f;
	const float MAGIC_JUMP_SPEED_FACTOR = 1.1f;

	SetAnimSpeedFactor( MAGIC_ANIM_SPEED_FACTOR,	m_fTimeHenirBuff_Wind, CX2GameUnit::SFI_SPEED_7, CX2GameUnit::SFST_UPDATE);
	SetVecMoveSpeedFactor( MAGIC_MOVE_SPEED_FACTOR,	m_fTimeHenirBuff_Wind, CX2GameUnit::SFI_SPEED_7, CX2GameUnit::SFST_UPDATE);
	SetVecJumpSpeedFactor( MAGIC_JUMP_SPEED_FACTOR,	m_fTimeHenirBuff_Wind, CX2GameUnit::SFI_SPEED_7, CX2GameUnit::SFST_UPDATE);


	if( INVALID_EFFECTSET_HANDLE != m_hHenirBuff_Wind )
	{
		g_pX2Game->GetEffectSet()->StopEffectSet( m_hHenirBuff_Wind );
		m_hHenirBuff_Wind = INVALID_EFFECTSET_HANDLE;
	}

	if( INVALID_EFFECTSET_HANDLE == m_hHenirBuff_Wind )
	{
		m_hHenirBuff_Wind = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_HENIR_BUFF_WIND", this );
		m_vecEffectSetToDeleteOnDie.push_back( m_hHenirBuff_Wind );
	}
	if( IsLocalUnit() == true )
		g_pChatBox->AddChatLog( GET_STRING(STR_ID_13779), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
	
	return;
}

void CX2GUUser::StartHenirBuffLight()
{
	m_fTimeHenirBuff_Light = 300.f;
	PulseWeaponRenderEffect(D3DXCOLOR(0.9f, 0.9f, 0.2f, 0.8f), D3DXCOLOR(0.9f, 0.9f, 0.2f, 0.1f), 0.5f, m_fTimeHenirBuff_Light);
	if( IsLocalUnit() == true )
		g_pChatBox->AddChatLog( GET_STRING(STR_ID_13780), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
	
	return;
}
#endif ADD_HENIR_BUFF


void CX2GUUser::EndHenirBuff()
{
#ifndef ADD_HENIR_BUFF		/// 버프로 변경되면서 쓰이지 않게 된 구문
	if(m_fTimeHenirBuff_Fire > 0.f)
		m_fTimeHenirBuff_Fire = 0.01f;

	if(m_fTimeHenirBuff_Water > 0.f)
		m_fTimeHenirBuff_Water = 0.01f;

	if(m_fTimeHenirBuff_Nature > 0.f)
		m_fTimeHenirBuff_Nature = 0.01f;

	if(m_fTimeHenirBuff_Wind > 0.f)
		m_fTimeHenirBuff_Wind = 0.01f;

	if(m_fTimeHenirBuff_Light > 0.f)
		m_fTimeHenirBuff_Light = 0.01f;
#endif

#ifdef ADD_DISPLAYER_WEAPON_AFTER_IMAGE
	/// 만약 헤니르 버프가 걸려있다면, 제거해주자
	EraseBuffTempletFromGameUnit( BTI_BUFF_HENIR_FIRE );
	EraseBuffTempletFromGameUnit( BTI_BUFF_HENIR_WATER );
	EraseBuffTempletFromGameUnit( BTI_BUFF_HENIR_NATURE );
	EraseBuffTempletFromGameUnit( BTI_BUFF_HENIR_WIND );
	EraseBuffTempletFromGameUnit( BTI_BUFF_HENIR_LIGHT );
#endif ADD_DISPLAYER_WEAPON_AFTER_IMAGE

	return;
}

void CX2GUUser::StartHenirBuffDark()
{
	if(GetNowHp() <= 0.0f)
		return;
	
	const float MAGIC_HENIR_DARK_HP_PERCENT_UP = 20.f;
	const float MAGIC_HENIR_DARK_MP_PERCENT_UP = 20.f;

	float fHenirDarkHpPercentUp = 0.f;
	float fHenirDarkMpPercentUp = 0.f;

	fHenirDarkHpPercentUp = MAGIC_HENIR_DARK_HP_PERCENT_UP / 100.f;
	fHenirDarkMpPercentUp = MAGIC_HENIR_DARK_MP_PERCENT_UP / 100.f;

	float fHPUpRate = GetMaxHp() * fHenirDarkHpPercentUp * GetHpUpRateBySkill();
	UpNowHp( fHPUpRate );

	g_pX2Game->GetEffectSet()->PlayEffectSet(L"EffectSet_Heal", (CX2GameUnit*)this );	
	PlaySound( L"Nasod_Healer_Heal.ogg" );

	float fMPUpRate = GetMaxMp() * fHenirDarkMpPercentUp * GetMpUpRateBySkill();;
	UpNowMp( fMPUpRate );

	if( IsLocalUnit() == true )
		g_pChatBox->AddChatLog( GET_STRING(STR_ID_13781), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
	
	return;
}

void CX2GUUser::StartHenirBuffFirst()
{
	if(GetNowHp() <= 0.0f)
		return;

	const float MAGIC_HENIR_FIRST_HP_PERCENT_UP = 70.f;
	const float MAGIC_HENIR_FIRST_MP_PERCENT_UP = 70.f;

	float fHenirFirstHpPercentUp = 0.f;
	float fHenirFirstMpPercentUp = 0.f;

	if( CX2Main::XS_DUNGEON_GAME == g_pMain->GetNowStateID() )
	{
		CX2DungeonGame* pDungeonGame = static_cast<CX2DungeonGame*>(g_pX2Game);
		if( NULL != pDungeonGame &&
			NULL != pDungeonGame->GetDungeon() )
		{
			int iCurrentHenirStageIndex = pDungeonGame->GetDungeon()->GetNowStageIndex();
			fHenirFirstHpPercentUp = (MAGIC_HENIR_FIRST_HP_PERCENT_UP - (float)iCurrentHenirStageIndex) / 100.f;
			fHenirFirstMpPercentUp = (MAGIC_HENIR_FIRST_MP_PERCENT_UP - (float)iCurrentHenirStageIndex) / 100.f;
		}
	}
	
	float fHPUpRate = GetMaxHp() * fHenirFirstHpPercentUp * GetHpUpRateBySkill();
	UpNowHp( fHPUpRate );
	
	g_pX2Game->GetEffectSet()->PlayEffectSet(L"EffectSet_Heal", (CX2GameUnit*)this );	
	PlaySound( L"Nasod_Healer_Heal.ogg" );
	
	float fMPUpRate = GetMaxMp() * fHenirFirstMpPercentUp * GetMpUpRateBySkill();;
	UpNowMp( fMPUpRate );

	if( IsLocalUnit() == true )
		g_pChatBox->AddChatLog( GET_STRING(STR_ID_13775), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
	
	return;
}

float CX2GUUser::GetHpUpRateBySkill()
{
	float fIncreaseRateFromMasterOfAlchemistSkill = 1.f;
	if ( GetUnit() != NULL )
	{
		BYTE byMemberShipGrade = GetUnit()->GetUnitData().m_byMemberShipGrade;
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetUnit()->GetUnitData().m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_GP_COMMON_MASTER_OF_ALCHEMIST, byMemberShipGrade);
		if ( pSkillTemplet != NULL )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID, true ) );	/// 스킬 레벨
	
			fIncreaseRateFromMasterOfAlchemistSkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ITEM_SPECIAL_ABILITY_REL, iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
			fIncreaseRateFromMasterOfAlchemistSkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ITEM_SPECIAL_ABILITY_REL );
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}
	}
	
	float fIncreaseRateMetabolism = 1.f;
#ifdef CHUNG_SECOND_CLASS_CHANGE
	if ( CX2Unit::UC_CHUNG_FURY_GUARDIAN == GetUnitClass() || 
		CX2Unit::UC_CHUNG_IRON_PALADIN == GetUnitClass() )
#endif
	{
		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		int iSkillLv = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CFG_METABOLISM_BOOST, true );
#else // UPGRADE_SKILL_SYSTEM_2013
		int iSkillLv = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_CFG_METABOLISM_BOOST );
#endif // UPGRADE_SKILL_SYSTEM_2013
		
		if ( 0 < iSkillLv )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			const CX2SkillTree::SkillTemplet* pSkillTemplet = 
				g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_CFG_METABOLISM_BOOST );

			if ( NULL != pSkillTemplet )
			{
				fIncreaseRateMetabolism	= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ITEM_SPECIAL_ABILITY_REL, iSkillLv );
			}
	#else // UPGRADE_SKILL_SYSTEM_2013
			const CX2SkillTree::SkillTemplet* pSkillTemplet = 
				g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_CFG_METABOLISM_BOOST, iSkillLv );

			fIncreaseRateMetabolism	= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ITEM_SPECIAL_ABILITY_REL );
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}
	}
	return fIncreaseRateFromMasterOfAlchemistSkill * fIncreaseRateMetabolism;
}

float CX2GUUser::GetMpUpRateBySkill()
{
	float fIncreaseRateFromMasterOfAlchemistSkill = 1.f;
	if ( GetUnit() != NULL )
	{
		BYTE byMemberShipGrade = GetUnit()->GetUnitData().m_byMemberShipGrade;
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetUnit()->GetUnitData().m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_GP_COMMON_MASTER_OF_ALCHEMIST, byMemberShipGrade);
		if ( pSkillTemplet != NULL )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID, true ) );	/// 스킬 레벨
	
			fIncreaseRateFromMasterOfAlchemistSkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ITEM_SPECIAL_ABILITY_REL, iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
			fIncreaseRateFromMasterOfAlchemistSkill = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ITEM_SPECIAL_ABILITY_REL );
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}
	}
	return fIncreaseRateFromMasterOfAlchemistSkill;
}
#endif NEW_HENIR_TEST

#ifdef ELSWORD_WAY_OF_SWORD
/*virtual*/ int CX2GUUser::GetWayOfSwordState() const
{
	return 0;
}
/*virtual*/ float CX2GUUser::GetWayOfSwordPoint() const
{
	return 0.f;
}
/*virtual*/ void CX2GUUser::SetWayOfSwordPoint( float fWayOfSwordPoint_ )
{
	return;
}
#endif ELSWORD_WAY_OF_SWORD


#ifdef SPECIAL_USE_ITEM
void CX2GUUser::StartSpecialItemBuffWind()
{
	m_fSpecialItemBuff_Wind = 30.f;

	const float MAGIC_ANIM_SPEED_FACTOR = 1.2f;
	const float MAGIC_MOVE_SPEED_FACTOR = 1.2f;
	const float MAGIC_JUMP_SPEED_FACTOR = 1.2f;

	SetAnimSpeedFactor( MAGIC_ANIM_SPEED_FACTOR,	m_fSpecialItemBuff_Wind, CX2GameUnit::SFI_SPEED_11, CX2GameUnit::SFST_UPDATE);
	SetVecMoveSpeedFactor( MAGIC_MOVE_SPEED_FACTOR,	m_fSpecialItemBuff_Wind, CX2GameUnit::SFI_SPEED_11, CX2GameUnit::SFST_UPDATE);
	SetVecJumpSpeedFactor( MAGIC_JUMP_SPEED_FACTOR,	m_fSpecialItemBuff_Wind, CX2GameUnit::SFI_SPEED_11, CX2GameUnit::SFST_UPDATE);


	if( INVALID_EFFECTSET_HANDLE != m_hSpecialItemBuff_Wind )
	{
		g_pX2Game->GetEffectSet()->StopEffectSet( m_hSpecialItemBuff_Wind );
		m_hSpecialItemBuff_Wind = INVALID_EFFECTSET_HANDLE;
	}

	if( INVALID_EFFECTSET_HANDLE == m_hSpecialItemBuff_Wind )
	{
		m_hSpecialItemBuff_Wind = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_SPECIALITEM_BUFF_WIND", this );
		m_vecEffectSetToDeleteOnDie.push_back( m_hSpecialItemBuff_Wind );
	}
	if( IsLocalUnit() == true )// 버프 걸렸다는 채팅 내용. 이름을 바꿔 줘야 한다.
		g_pChatBox->AddChatLog( GET_STRING(STR_ID_15018), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );

	return;
}

void CX2GUUser::EndSpecialItemBuff()
{
	if(m_fSpecialItemBuff_Wind > 0.f)
		m_fSpecialItemBuff_Wind = 0.001f;

	return;
}

void CX2GUUser::StopSpecialItemBuffWind()
{
	if(m_hSpecialItemBuff_Wind == INVALID_EFFECTSET_HANDLE)
		return;

	m_fSpecialItemBuff_Wind = 0.f;

	SetAnimSpeedFactor( 1.f,	0.f, CX2GameUnit::SFI_SPEED_11, CX2GameUnit::SFST_UPDATE);
	SetVecMoveSpeedFactor( 1.f,	0.f, CX2GameUnit::SFI_SPEED_11, CX2GameUnit::SFST_UPDATE);
	SetVecJumpSpeedFactor( 1.f,	0.f, CX2GameUnit::SFI_SPEED_11, CX2GameUnit::SFST_UPDATE);

	//if( INVALID_EFFECTSET_HANDLE != m_hSpecialItemBuff_Wind )
	{
		g_pX2Game->GetEffectSet()->StopEffectSet( m_hSpecialItemBuff_Wind );
		m_hSpecialItemBuff_Wind = INVALID_EFFECTSET_HANDLE;
	}
	if( IsLocalUnit() == true ) // 이건 그대로 해도 될듯??
		g_pChatBox->AddChatLog( GET_STRING(STR_ID_13782), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );

}
#endif SPECIAL_USE_ITEM



//////////////////////////////////////////////////////////////////////////

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
void CX2GUUser::SyncData::SetData( const KDYNAMIC_UNIT_USER_SYNC& SyncPacket, DWORD dwRealFrameMoveCount, float fMaxHP, float fMaxMP )
{
	dwFrameMoveCount	= dwRealFrameMoveCount;

	nowState				= SyncPacket.m_ucNowState;
	nowSubState				= -1;
	nowAction				= SyncPacket.m_ucNowAction;
	bDirectChange			= SyncPacket.DecodeDirectChange();
	stateChangeNum			= SyncPacket.m_cStateChangeNum;

//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
	_DecodeUserSyncPos( position, SyncPacket.m_usPosX, SyncPacket.m_usPosZ, SyncPacket.m_ucLastTouchLineIndex );
    position.y              = SyncPacket.m_fPosY;
//#else   X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//	_DecodeUserSyncPos( position, SyncPacket.m_usPosX, SyncPacket.m_usPosY, SyncPacket.m_usPosZ, SyncPacket.m_ucLastTouchLineIndex );
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC

	lastTouchLineIndex		= SyncPacket.m_ucLastTouchLineIndex;

	bIsRight				= SyncPacket.DecodeIsRight();
	bFrameStop				= SyncPacket.DecodeFrameStop();

	fNowHP					=  SyncPacket.m_fNowHp;
	fNowMP					=  SyncPacket.m_fNowMp;

	m_HyperModeCount		= SyncPacket.DecodeHyperModeCount();

	m_CannonBallCount		= SyncPacket.DecodeCannonBallCount();

	m_usRandomTableIndex	= SyncPacket.m_usRandomTableIndex;

	ucHitCount				= SyncPacket.m_ucHitCount;
	ucHittedCount			= SyncPacket.m_ucHittedCount;
	ucNumOfDeBuff			= SyncPacket.m_ucNumOfDeBuff;
//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
    m_dwRelativePos         = SyncPacket.m_dwRelativePos;
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
}

//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
void CX2GUUser::SyncData::_DecodeUserSyncPos( D3DXVECTOR3& vPosition, USHORT usPosX, USHORT usPosZ, unsigned char ucLastTouchLineIndex )
//#else   X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//void CX2GUUser::SyncData::_DecodeUserSyncPos( D3DXVECTOR3& vPosition, USHORT usPosX, USHORT usPosY, USHORT usPosZ, unsigned char ucLastTouchLineIndex )
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
{
    const CKTDGLineMap::LineData* pLineData = NULL;
	if( !g_pX2Game || !g_pX2Game->GetLineMap() 
        || ( pLineData = g_pX2Game->GetLineMap()->GetLineData( ( int )ucLastTouchLineIndex ) ) == NULL )
    {
		StateLog( L"라인 포인터 이상." );
	    vPosition.x = halfToFloat( usPosX );
//#ifndef X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//        vPosition.y = halfToFloat( usPosY );
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
	    vPosition.z = halfToFloat( usPosZ );
		return;
    }

	vPosition.x = pLineData->startPos.x + halfToFloat( usPosX );
//#ifndef X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//    vPosition.y = pLineData->startPos.y + halfToFloat( usPosY );
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
	vPosition.z = pLineData->startPos.z + halfToFloat( usPosZ );
}

//#else   SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//#ifdef OPTIMIZED_P2P
//void CX2GUUser::SyncData::SetData( KXPT_UNIT_USER_SYNC& SyncPacket, USHORT usHP, USHORT usMP )
//{
//    nowState				= SyncPacket.m_ucNowState;
//	nowSubState				= -1;
//	nowAction				= SyncPacket.nowAction;
//    bDirectChange			= SyncPacket.DecodeDirectChange();
//    stateChangeNum			= SyncPacket.DecodeStateChangeNum();
//
//    const CKTDGLineMap::LineData* pLineData = g_pX2Game->GetLineMap()->GetLineData( ( int )SyncPacket.m_ucLastTouchLineIndex );
//    if( pLineData )
//    {
//        float fValue = halfToFloat( SyncPacket.m_usPosX );
//        position = pLineData->startPos + fValue * pLineData->dirVector;
//        position.y = pLineData->startPos.y + halfToFloat( SyncPacket.m_usPosY );
//    }
//    else
//    {
//        StateLog( L"라인 포인터 이상." );
//    }
//
//    lastTouchLineIndex		= SyncPacket.m_ucLastTouchLineIndex;
//
//    bIsRight				= SyncPacket.DecodeIsRight();
//    bFrameStop				= SyncPacket.DecodeFrameStop();
//
//    fNowHP					= halfToFloat( usHP );
//    fNowMP					= halfToFloat( usMP );
//
//    m_HyperModeCount		= SyncPacket.DecodeHyperModeCount();
//
//#ifdef NEW_RANDOM_TABLE_TEST
//	m_usRandomTableIndex	= SyncPacket.m_usRandomTableIndex;
//#else NEW_RANDOM_TABLE_TEST
////{{AFX
//	m_RandSeed				= SyncPacket.m_RandSeed;
//	m_RandSeed2				= SyncPacket.m_RandSeed2;
////}}AFX
//#endif NEW_RANDOM_TABLE_TEST
//}
//#else
////{{AFX
//void CX2GUUser::SyncData::SetData( KXPT_UNIT_USER_SYNC* pSyncPacket )
//{
//	dwFrameMoveCount		= pSyncPacket->dwFrameMoveCount;
//    nowState				= pSyncPacket->nowState;
//	nowSubState				= -1;
//    nowAction				= pSyncPacket->nowAction;
//    bDirectChange			= pSyncPacket->DecodeDirectChange();
//    stateChangeNum			= pSyncPacket->stateChangeNum;
//    position.x				= pSyncPacket->posX;
//    position.y				= pSyncPacket->posY;
//    position.z				= pSyncPacket->posZ;
//
//    lastTouchLineIndex		= pSyncPacket->lastTouchLineIndex;
//
//    bIsRight				= pSyncPacket->DecodeIsRight();
//    bFrameStop				= pSyncPacket->DecodeFrameStop();
//
//    //{{ kimhc // 2010.12.7 // 던전, 대전 등에서 상대방 또는 파티원의 HP가 줄지 않는 현상 수정
//	fNowHP					= pSyncPacket->fNowHP;
//	fNowMP					= pSyncPacket->fNowMP;
//	//}} kimhc // 2010.12.7 // 던전, 대전 등에서 상대방 또는 파티원의 HP가 줄지 않는 현상 수정
//
//    m_HyperModeCount		= pSyncPacket->DecodeHyperModeCount();
//
////{{ kimhc // 2010.12.13 // 2010-12-23 New Character CHUNG
//#ifdef	NEW_CHARACTER_CHUNG
//	m_CannonBallCount		= pSyncPacket->DecodeCannonBallCount();
//#endif	NEW_CHARACTER_CHUNG
////}} kimhc // 2010.12.13 //  2010-12-23 New Character CHUNG
//
//#ifdef NEW_RANDOM_TABLE_TEST
//	m_usRandomTableIndex	= pSyncPacket->m_usRandomTableIndex;
//#else NEW_RANDOM_TABLE_TEST
////{{AFX
//    m_RandSeed				= pSyncPacket->m_RandSeed;
//    m_RandSeed2				= pSyncPacket->m_RandSeed2;
////}}AFX
//#endif NEW_RANDOM_TABLE_TEST
//	
//	ucHitCount				= pSyncPacket->ucHitCount;
//	ucHittedCount			= pSyncPacket->ucHittedCount;
//	ucNumOfDeBuff			= pSyncPacket->ucNumOfDeBuff;
//}
////}}AFX
//#endif // OPTIMIZED_P2P
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK

#ifdef SUPER_SOCKET_IN_TITLE
void CX2GUUser::SetSuperArmorSocket()
{
	// 피격시 일정확율로 슈퍼아머
	float fRandomValueForSuperArmor = GetRandomFloat( CKTDXRandomNumbers::SRO_SUPER_ARMOR_WHEN_ATTACKED );
	
	if ( g_pX2Game != NULL && ( g_pX2Game->GetGameType() == CX2Game::GT_DUNGEON || g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD ) )
	{
		if( fRandomValueForSuperArmor <= m_SocketData.m_fPercentSuperArmorDungeon && IsSuperArmor() == false)
		{
			m_fSocketSuperArmor = m_SocketData.m_fTimeSuperArmorDungeon;
			m_bSocketSuperArmor = true;							
		}
	}
	else if ( g_pX2Game != NULL && g_pX2Game->GetGameType() == CX2Game::GT_PVP )
	{
		if(fRandomValueForSuperArmor <= m_SocketData.m_fPercentSuperArmorPVP && IsSuperArmor() == false)
		{
			m_fSocketSuperArmor = m_SocketData.m_fTimeSuperArmorPVP;
			m_bSocketSuperArmor = true;							
		}
	}
	else
	{
		if(fRandomValueForSuperArmor <= m_SocketData.m_fPercentSuperArmorDungeon && IsSuperArmor() == false)
		{
			m_fSocketSuperArmor = m_SocketData.m_fTimeSuperArmorDungeon;
			m_bSocketSuperArmor = true;
		}
	}
}
#endif

#ifdef	SERV_TRAPPING_RANGER_TEST
void CX2GUUser::ProcessVPP()
{
	if( m_delegateVitalPointPiercing )
		m_delegateVitalPointPiercing();
}
#endif	SERV_TRAPPING_RANGER_TEST

/*virtual*/ void CX2GUUser::DeleteMinorParticle()
{
	CX2GameUnit::DeleteMinorParticle();

	DeleteGameUnitMinorParticle();
}

bool CX2GUUser::GetShowActiveSkillShow() const
{
	bool bShowActiveSkillShow = false;
	switch( g_pMain->GetGameOption().GetStateCutinShowState() )
	{
	case CX2GameOption::SCSS_ONESELF:
		{
			if( true == IsMyUnit() )
				bShowActiveSkillShow = true;
		}break;
	case CX2GameOption::SCSS_PARTY_MEMBER:
		{
			if( true == IsMyUnit() ||
				g_pData->GetPartyManager()->IsMyPartyMember(m_UnitUID) )
				bShowActiveSkillShow = true;
		} break;
	default:
		break;
	}

	return bShowActiveSkillShow;
}

bool CX2GUUser::GetShowCutInAndChangeWorldColor()
{
	switch ( g_pX2Game->GetGameType() )
	{
	case CX2Game::GT_BATTLE_FIELD:	// 거리 800 이내 인 경우
		if ( IsMyUnit() || GetDistance3Sq( GetPos(), g_pX2Game->GetMyUnit()->GetPos() ) < LIMIT_DISTANCE_SQ )
			return true;
		else
			return false;
		break;

	case CX2Game::GT_DUNGEON:
	case CX2Game::GT_PVP:
		return true;
		break;

	default:
		ASSERT( !L"wrong path" );
		return false;
		break;
	}
}
/** @function : ChangeWorldColorByHyperMode
	@brief : 각성 상태 여부에 따라 월드칼라를 다르게 변경
*/
void CX2GUUser::ChangeWorldColorByHyperMode()
{
	if ( GetShowCutInAndChangeWorldColor() )
	{
		if ( 0.0f < GetRemainHyperModeTime() )
			g_pX2Game->GetWorld()->SetWorldColor( 0xffff0000 );
		else
			g_pX2Game->GetWorld()->SetWorldColor( 0xff222222 );
	}
}

void CX2GUUser::SetEquippedSkillFunc( const CX2Unit::UnitData& kUnitData_, const bool bSlotB_ )
{
	for( int i = 0; i< EQUIPPED_SKILL_SLOT_COUNT; i++ )
	{
		const CX2UserSkillTree::SkillSlotData* pSkillSlotData = kUnitData_.m_UserSkillTree.GetSkillSlot( i, bSlotB_ );
		ASSERT( pSkillSlotData != NULL );
		if( NULL != pSkillSlotData )
			SetEquippedSkillFuncBySkillSlotIndex( pSkillSlotData->m_eID, i, bSlotB_ );
	}
}

/*virtual*/ bool CX2GUUser::ShouldResetNotBusyTimer()
{
	// 현재 상태는 대기 상태이고
#ifdef RIDING_SYSTEM
	 if ( GetWaitStateID() == m_FrameDataFuture.syncData.nowState || GetChargeMpStateID() == m_FrameDataFuture.syncData.nowState
		 || USI_RIDING_WAIT == m_FrameDataFuture.syncData.nowState || USI_RIDING_WAIT_HABIT == m_FrameDataFuture.syncData.nowState )
#else //RIDING_SYSTEM
	if ( GetWaitStateID() == m_FrameDataFuture.syncData.nowState || GetChargeMpStateID() == m_FrameDataFuture.syncData.nowState )
#endif //RIDING_SYSTEM 탈 것 wait 바쁜 상태 예외 추가
	{
		return false;
	}
	else	// 현재 상태가 바쁜 상태면
		return true;	// 리셋 해야함
}

void CX2GUUser::ResetNotBusyTimerOnSpecificState()
{
	if ( ShouldResetNotBusyTimer() )
	{
		//TRACE( L"Before StateID: %d, Now StateID: %d\n", m_FrameDataNowBefore.syncData.nowState, m_FrameDataNow.syncData.nowState );
		m_ElapsedTimeNotBusyState.ResetSumOfElapsedTime();
	}
}

void CX2GUUser::InitByGameType()
{
	switch ( g_pX2Game->GetGameType() )
	{
	case CX2Game::GT_BATTLE_FIELD:
		{
			m_delegatePhysicProcessPortalByGameType = DelegatePhysicProcessPortalByGameType::from_method<CX2GUUser, &CX2GUUser::PhysicProcess_PortalInBattleField>( this );
		} break;

	case CX2Game::GT_DUNGEON:
		{
			if( NULL != g_pMain && false == g_pMain->GetIsPlayingTutorial() )
			{
				m_delegatePhysicProcessPortalByGameType = DelegatePhysicProcessPortalByGameType::from_method<CX2GUUser, &CX2GUUser::PhysicProcess_Portal>( this );
			}
			else
			{
				m_delegatePhysicProcessPortalByGameType = DelegatePhysicProcessPortalByGameType::from_method<CX2GUUser, &CX2GUUser::PhysicProcess_PortalInBattleField>( this );
			}
		} break;

	case CX2Game::GT_PVP:
		{
			m_delegatePhysicProcessPortalByGameType = DelegatePhysicProcessPortalByGameType::from_method<CX2GUUser, &CX2GUUser::PhysicProcess_Portal>( this );
		} break;

	default:
		break;
	}
}

#ifdef BUFF_TEMPLET_SYSTEM 
void CX2GUUser::UpdateBuffInfo( const KStat& kStat_, const vector<KBuffInfo>& vecSetBuffInfo_, const vector<int>& vecEraseBuffInfo_ )
{
	//CX2Unit* pUnit = GetUnit();		/// 구 버프 시스템
	//if ( NULL != pUnit ) 
	//{
	//	CX2Unit::UnitData* pUnitData = &GetUnit()->AccessUnitData();

	//	pUnitData->m_GameStat.SetKStat( kStat_ );
	//	if( kStat_.m_iBaseHP > 0.f )
	//		SetGameStat( kStat_ );

	//	UpdateBuffEffect( vecSetBuffInfo_, vecEraseBuffInfo_ );	//버프 이펙트 제어

	//	pUnitData->ErasePremiumBuffInfo( vecEraseBuffInfo_ );	//지울 버프 아이디
	//	pUnitData->SetPremiumBuffInfo( vecSetBuffInfo_ );		//추가할 버프 아이디

	//	UpdateSocketDataAndEnchantData();
	//	UpdatePassiveAndActiveSkillState();

	//	//HP, MP 증가 소켓을 위해
	//	ResetMaxHP();
	//	ResetMaxMP();
	//}
} 

void CX2GUUser::UpdateBuffEffect( const vector<KBuffInfo>& vecSetBuffInfo_, const vector<int>& vecEraseBuffInfo_ )
{
	////사라져야 할 버프 이펙트 정지 및 삭제
	//BOOST_FOREACH( const int& iBuffID, vecEraseBuffInfo_ )
	//{
	//	switch( iBuffID )
	//	{
	//	case CX2PremiumBuffTemplet::BI_VITALITY_OF_EL:
	//		{
	//			if( m_hEffectCrystalOfElBuff != INVALID_EFFECTSET_HANDLE)
	//			{
	//				g_pX2Game->GetEffectSet()->StopEffectSet(m_hEffectCrystalOfElBuff);
	//			}
	//		}break;
	//	default:
	//		{
	//			return;
	//		}break;
	//	}
	//}

	////생성 되어야 할 버프 이펙트 생성 및 추가
	//BOOST_FOREACH( const KBuffInfo& kBuffInfo, vecSetBuffInfo_ )
	//{
	//	switch( kBuffInfo.m_iBuffID )
	//	{
	//	case CX2PremiumBuffTemplet::BI_VITALITY_OF_EL:
	//		{
	//			if( m_hEffectCrystalOfElBuff != INVALID_EFFECTSET_HANDLE)
	//			{
	//				g_pX2Game->GetEffectSet()->StopEffectSet(m_hEffectCrystalOfElBuff);
	//			}

	//			m_hEffectCrystalOfElBuff = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Crystal_Of_El_Buff", (CX2GameUnit*) this );
	//		}break;
	//	default:
	//		{
	//			return;
	//		}break;
	//	}
	//}
}

//10초당 HP 회복 소켓
void CX2GUUser::SetHPChangeRatePerSecond( float fElapsedTime )
{
	float fSocketHPIncreasePerSecond = GetSocketData().m_fHPRelativeChangeRate;	// HP 지속 회복 소켓

	//소켓이 적용된 상태일 때, 10초당 일정 수치 만큼 회복 한다.
	if( fSocketHPIncreasePerSecond > 0.f )
	{
		float fValueLimit	= GetMaxHp() - GetNowHp();								//회복량이 정확히 표시 되도록 회복 한계치 설정

		if( fValueLimit  <= 0.f )													//현재 체력이 만피이면 동작 금지
		{	
			m_fSocketHPIncreasePerSecondTime = 0.f;									//만피 이상이면 시간은 0으로 초기화

			return;
		}

		m_fSocketHPIncreasePerSecondTime += fElapsedTime;							//만피가 아닐때만 시간 갱신

		if( m_fSocketHPIncreasePerSecondTime > 10.f )								//시간이 10초 이상일 때
		{
			float fValue = GetMaxHp() * fSocketHPIncreasePerSecond;					//회복량

			m_fSocketHPIncreasePerSecondTime = 0.f;									//시간이 10초가 넘었을 때, 무조건 시간은 초기화

			if ( fValueLimit < fValue )												//채워야 할 수치만큼만 연산한다. - ( HP 100/ 90, 회복량 +20 일때,		 화면상에 HP +10 만 나오도록 )
			{
				fValue = fValueLimit;												
			}
			
			UpNowHp( fValue );														

			WCHAR wszIncreaseHP[128] = L"";
			StringCchPrintfW( wszIncreaseHP, ARRAY_SIZE(wszIncreaseHP), L"HP+ %d", static_cast< int >( fValue ) );
			D3DXVECTOR3 pos = GetPos();
			pos.y += 50.0f;
			if( NULL != g_pData->GetPicCharGreen() )
				g_pData->GetPicCharGreen()->DrawText( wszIncreaseHP, pos, GetDirVector(), CKTDGPicChar::AT_CENTER );
		}
	}
	else																			//소켓이 적용 되지 않을 땐 시간 초기화
	{	
		m_fSocketHPIncreasePerSecondTime = 0.f;
	}
}

//MP 지속 회복 소켓
void CX2GUUser::SetMPChangeRateValue( float fElapsedTime )
{
	int iSocketMPChangeRate = GetSocketData().m_iMPChangeValue;		// MP 지속 회복량 증가 소켓

	SetNowMp( GetNowMp() + ( static_cast<float>( iSocketMPChangeRate ) * fElapsedTime ) );
}
#endif BUFF_TEMPLET_SYSTEM

#ifdef PVP_ZOOM_CAMERA
void CX2GUUser::SetSubZoomCameraTimer()
{
	if( IsMyUnit() == true )
		g_pMain->GetGameOption().SetSubZoomCameraTimer(2.f);
}
#endif

#ifdef SERV_RENA_NIGHT_WATCHER
void CX2GUUser::UpdateStartOfDelayedFiring( bool bInsertUnit )
{
	if( CX2Unit::UC_LIRE_NIGHT_WATCHER == GetUnitClass() )
	{
		CX2GULire_ElvenRanger* pRena = static_cast<CX2GULire_ElvenRanger*>(this);
		if( pRena != NULL )
		{
			pRena->UpdateStartOfDelayedFiring( bInsertUnit );
		}
	}
}
#endif SERV_RENA_NIGHT_WATCHER

#ifdef SERV_RAVEN_VETERAN_COMMANDER
float CX2GUUser::GetEDTBleedingTime()
{
	if( CX2Unit::UC_RAVEN_VETERAN_COMMANDER == GetUnitClass() )
	{
		CX2GURaven* pRaven = static_cast<CX2GURaven*>(this);
		if( pRaven != NULL )
		{
			return pRaven->GetEDTBleedingTime();
		}
	}

	return 0.f;
}
#endif SERV_RAVEN_VETERAN_COMMANDER

/*virtual*/ void CX2GUUser::ChargeMpAndEtcInTrainingGame()
{
	SetNowMp( GetMaxMp() );

	if ( GetHyperModeCount() == GetFrameData().syncData.m_HyperModeCount )
	{
		int iHyperModeCount = GetHyperModeCount();
		if ( iHyperModeCount < 1 )
		{
			if ( static_cast<int>( CX2GageUI::PGUWO_ORB3 ) == ++iHyperModeCount )
				iHyperModeCount = static_cast<int>( CX2GageUI::PGUWO_ORB3 );

			SetHyperModeCount( iHyperModeCount );
		}
	}		
}

/** @function : SendBuffInfoNot
	@brief : 자신의 버프 정보를 서버를 통해 다른 유저에게 보내는 함수
	@param : 전송받을 유닛의 UID(uidGameUnitToSendNot_)
*/
void CX2GUUser::SendBuffInfoNot( const UidType uidGameUnitToSendNot_ )
{
	KEGS_UPDATE_USER_UNIT_BUFF_INFO_NOT kPacket;
	kPacket.m_iToUnitUID = uidGameUnitToSendNot_;
	kPacket.m_vecBuffFactor.reserve( m_vecBuffTempletPtr.size() );

	GetBuffFactor( kPacket.m_vecBuffFactor );

	g_pData->GetServerProtocol()->SendPacket( EGS_UPDATE_USER_UNIT_BUFF_INFO_NOT, kPacket );
}

/** @function : HyperModeBuffEffectStart
	@brief : 각성 시 나와야하는 이펙트들 시작
*/
/*virtual*/ void CX2GUUser::HyperModeBuffEffectStart()
{
	BOOST_TEST_FOREACH( CX2EqipPtr, pEquipPtr, m_ViewEqipList )
	{
		pEquipPtr->ChangeHyperMode();
	}
}

/** @function : HyperModeBuffEffectEnd
	@brief : 각성 끝났을 때 이펙트 정리
*/
/*virtual*/ void CX2GUUser::HyperModeBuffEffectEnd()
{
	CX2GameUnit::HyperModeBuffEffectEnd();
	BOOST_TEST_FOREACH( CX2EqipPtr, pEquipPtr, m_ViewEqipList )
	{
		pEquipPtr->ChangeNormalMode();
	}

	m_iHyperModeCountUsed = 0;
}

/** @function : CreateAndInsertRenderParamByBuffUnitType
	@brief : 유닛의 타입별로 버프에 의한 RenderParam 변경을 적용하는 함수
	@param : 버프종류구분(BuffIdentity_), 렌더파람정보 map 컨테이터(mapStBuffRenderParamPtr_)
*/
/*virtual*/ void CX2GUUser::CreateAndInsertRenderParamByBuffUnitType( const KBuffIdentity& BuffIdentity_, const map<CX2Unit::UNIT_TYPE, StBuffRenderParamPtr>& mapStBuffRenderParamPtr_ )
{
	if ( NULL != GetUnit() )
	{
		CX2Unit::UNIT_TYPE eUnitType = GetUnit()->GetType();

		/// 자신의 유닛 타입에 맞는 RenderParam 값이 있는지 검색
		map<CX2Unit::UNIT_TYPE, StBuffRenderParamPtr>::const_iterator mItrByUnitType
			= mapStBuffRenderParamPtr_.find( eUnitType );

		if ( mapStBuffRenderParamPtr_.end() != mItrByUnitType && NULL != mItrByUnitType->second)
		{
			CreateAndInsertRenderParamByBuff( BuffIdentity_, *(mItrByUnitType->second) );
		}
		else	/// 자신만의 RenderParam이 없다면
		{
			/// 공통으로 사용하는 렌더파람 찾기
			map<CX2Unit::UNIT_TYPE, StBuffRenderParamPtr>::const_iterator mItrCommonType
				= mapStBuffRenderParamPtr_.find( CX2Unit::UT_NONE );

			if ( mapStBuffRenderParamPtr_.end() != mItrCommonType && NULL != mItrCommonType->second)
				CreateAndInsertRenderParamByBuff( BuffIdentity_, *(mItrCommonType->second) );
		}
	}
}

/** @function : IsSuperArmor
	@brief : 현재 수퍼아머인가?
	@return : 수퍼아머상태(true), 아님(false)
*/
/*virtual*/ bool CX2GUUser::IsSuperArmor() const
{
	if ( !m_vecSuperArmorPtr.empty() )	/// 버프에 의해 적용된 수퍼아머가 있으면
		return true;	/// 수퍼아머
	else	/// 버프에 의한 수퍼아머가 없으면
		return m_FrameDataNow.stateParam.bSuperArmor;	
}

/** @function : ResetLeftSkillCoolTimeBySkillType
	@brief : 인자로 전달받은 스킬 타입에 해당하는 스킬들의 쿨타임을 초기화 시킨다.
	@param : 쿨타임을 초기화 시킬 스킬타입(eSkillType_)
*/
#ifdef UPGRADE_SKILL_SYSTEM_2013

#ifdef ADDED_BBT_ALL_EQUIP_SKILL_SET_OR_RESET_COOLTIME					// 김종훈 / 13-07-04 / 모든 착용 중인 스킬의 쿨타임 최대치로 설정되게 하는 BBT 추가
/*virtual*/ void CX2GUUser::ResetLeftSkillCoolTimeBySkillType( const CX2SkillTree::SKILL_TYPE eSkillType_, const float fCoolTime /*= 0.f*/, bool bForceSet /*= true*/, BUFF_CHANGE_TYPE eChangeType /*= BCT_RELATION_VALUE*/, const float fCoolTimeRate /*= 1.f */, const bool bIsRelativeAllSkill /*= false */ )
#else // ADDED_BBT_ALL_EQUIP_SKILL_SET_OR_RESET_COOLTIME
/*virtual*/ void CX2GUUser::ResetLeftSkillCoolTimeBySkillType( const CX2SkillTree::SKILL_TYPE eSkillType_, const float fCoolTime /*= 0.f*/, bool bForceSet /*= true*/, BUFF_CHANGE_TYPE eChangeType /*= BCT_RELATION_VALUE*/ )
#endif // ADDED_BBT_ALL_EQUIP_SKILL_SET_OR_RESET_COOLTIME					// 김종훈 / 13-07-04 / 모든 착용 중인 스킬의 쿨타임 최대치로 설정되게 하는 BBT 추가

#else // UPGRADE_SKILL_SYSTEM_2013
/*virtual*/ void CX2GUUser::ResetLeftSkillCoolTimeBySkillType( const CX2SkillTree::SKILL_TYPE eSkillType_ )
#endif // UPGRADE_SKILL_SYSTEM_2013
{
	if ( NULL != GetUnit() )
	{
		CX2Unit::UnitData* pUnitData = &GetUnit()->AccessUnitData();
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013
#ifdef ADDED_BBT_ALL_EQUIP_SKILL_SET_OR_RESET_COOLTIME					// 김종훈 / 13-07-04 / 모든 착용 중인 스킬의 쿨타임 최대치로 설정되게 하는 BBT 추가
			pUnitData->m_UserSkillTree.ResetLeftSkillCoolTimeBySkillType( eSkillType_, fCoolTime, bForceSet, eChangeType, fCoolTimeRate, bIsRelativeAllSkill );
#else // ADDED_BBT_ALL_EQUIP_SKILL_SET_OR_RESET_COOLTIME
			pUnitData->m_UserSkillTree.ResetLeftSkillCoolTimeBySkillType( eSkillType_, fCoolTime, bForceSet, eChangeType );
#endif // ADDED_BBT_ALL_EQUIP_SKILL_SET_OR_RESET_COOLTIME					// 김종훈 / 13-07-04 / 모든 착용 중인 스킬의 쿨타임 최대치로 설정되게 하는 BBT 추가
	#else // UPGRADE_SKILL_SYSTEM_2013
			pUnitData->m_UserSkillTree.ResetLeftSkillCoolTimeBySkillType( eSkillType_ );
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}
	}
}

/** @function : DoGuildSkillChanceToReverse
	@brief : 길드스킬 역전의 기회 실행
*/
void CX2GUUser::DoGuildSkillChanceToReverse()
{
	const CX2Unit::UnitData*	pUnitData = ( NULL != GetUnit() ) ? &GetUnit()->GetUnitData() : NULL;

	if  ( NULL != pUnitData )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = 
			pUnitData->m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_GP_COMMON_CHANCE_TO_REVERSE, pUnitData->m_byMemberShipGrade );
		SetBuffFactorToGameUnit( pSkillTemplet, 0 );
	}
}

/** @function : SetSpecificValueByBuffTempletID
	@brief : 각 유닛마다 특정 버프가 실행 될 때 셋팅해야 하는 함수 실행(ex: 매지컬메이크업이 시전중이라는 플래그 설정 등...)
	@param : 버프템플릿ID(eBuffTempletId_)
*/
void CX2GUUser::SetSpecificValueByBuffTempletID( const BUFF_TEMPLET_ID eBuffTempletId_ )
{
	switch ( eBuffTempletId_ )
	{
#ifdef INT_HALLOWEEN_EVENT_BUF
	case BTI_BUFF_HP_UP_SOUP:
		{
			GetGageData()->SetNowHp( GetMaxHp() );
		} break;
	case BTI_BUFF_MP_UP_SOUP:
		{
			ForceChangeHyperMode( 3 );
			SetForceHyperModeTime( 90.0 );
			GetGageData()->SetNowMp( GetMaxMp() );
		} break;
#endif INT_HALLOWEEN_EVENT_BUF
	case BTI_DEBUFF_SIDE_EFFECT_MEDICINE:
#ifdef ADD_VELDER_ACADEMY_EVENT_MONSTER
	case BTI_DEBUFF_EVENT_BIG_HEAD:
#endif ADD_VELDER_ACADEMY_EVENT_MONSTER
#ifdef INT_HALLOWEEN_EVENT_BUF
	case BTI_BUFF_BIG_HEAD_SOUP:
#endif INT_HALLOWEEN_EVENT_BUF
		{
			ScaleHead();
		} break;

#ifdef ADD_HENIR_BUFF		/// 헤니르 버프 발동시 채팅창에 안내 문구 표시
	case BTI_BUFF_HENIR_FIRE:
		{
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13776), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
		} break;
	case BTI_BUFF_HENIR_WATER:
		{
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13777), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
		} break;
	case BTI_BUFF_HENIR_NATURE:
		{
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13778), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
		} break;
	case BTI_BUFF_HENIR_WIND:
		{
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13779), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
		} break;
	case BTI_BUFF_HENIR_LIGHT:
		{
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13780), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
		} break;
#endif ADD_HENIR_BUFF

#ifdef SERV_NEW_DEFENCE_DUNGEON // 적용날짜: 2013-04-11

	case BTI_BUFF_ELIXIR_BIG_HAND_POTION:
		{
			ScaleHand( D3DXVECTOR3( 1.5f, 1.5f, 1.5f ) );
		} break;

#endif // SERV_NEW_DEFENCE_DUNGEON

	default:
		break;
	}
}

/** @function : UnSetSpecificValueByBuffTempletID
	@brief : 각 유닛마다 특정 버프가 해제 될 때 셋팅해야 하는 함수 실행(ex: 매지컬메이크업이 해제 榮募 플래그 설정 등...)
	@param : 버프템플릿ID(eBuffTempletId_)
*/
void CX2GUUser::UnSetSpecificValueByBuffTempletID( const BUFF_TEMPLET_ID eBuffTempletId_ )
{
	switch ( eBuffTempletId_ )
	{
	case BTI_DEBUFF_SIDE_EFFECT_MEDICINE:
#ifdef ADD_VELDER_ACADEMY_EVENT_MONSTER
	case BTI_DEBUFF_EVENT_BIG_HEAD:
#endif ADD_VELDER_ACADEMY_EVENT_MONSTER
#ifdef INT_HALLOWEEN_EVENT_BUF
	case BTI_BUFF_BIG_HEAD_SOUP:
#endif INT_HALLOWEEN_EVENT_BUF
		{
			RestoreHead();
			PlaySound( L"Pressed_Return.ogg" );
		} break;

#ifdef ADD_HENIR_BUFF		/// 헤니르 버프 종료시 채팅창에 안내 문구 표시
	case BTI_BUFF_HENIR_FIRE:
	case BTI_BUFF_HENIR_WATER:
	case BTI_BUFF_HENIR_NATURE:
	case BTI_BUFF_HENIR_WIND:
	case BTI_BUFF_HENIR_LIGHT:
		{
			if( IsLocalUnit() == true )
				g_pChatBox->AddChatLog( GET_STRING(STR_ID_13782), KEGS_CHAT_REQ::CPT_SYSTEM, D3DXCOLOR(0.92549f, 0.92549f, 0.53333f, 1.f), L"#CECEC88" );
		} break;
#endif ADD_HENIR_BUFF

#ifdef SERV_NEW_DEFENCE_DUNGEON	// 적용날짜: 2013-04-11

	case BTI_BUFF_ELIXIR_BIG_HAND_POTION:
		{
			RestoreHand();
		} break;

#endif // SERV_NEW_DEFENCE_DUNGEON


#ifdef HAMEL_SECRET_DUNGEON // kimjh 하멜 비던
	case BTI_BUFF_WATER_SHIELD :		// 물 보호막이 종료되면 이펙트 셋을 뿌림
		{
			if ( NULL != g_pX2Game && 
				 NULL != g_pX2Game->GetEffectSet() )
			{
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_SHASHA_STAGE0_AttackA_Buff_Hit", this, this );
			}
		} break;

	case BTI_HEALTH_POINT_IMMEDIATELY_CHANGE_ONCE :		// 물 보호막이 종료되면 이펙트 셋을 뿌림
		{
			if ( NULL != g_pX2Game && 
				NULL != g_pX2Game->GetEffectSet() )
			{
				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_SHASHA_STAGE0_AttackB_Heal", this, this );
			}
		} break;


#endif // HAMEL_SECRET_DUNGEON // kimjh 하멜 비던

	default:
		break;
	}
}

void CX2GUUser::ToggleSkillSlotAB()
{
	if( NULL != g_pData && NULL != g_pData->GetUIManager() && 
		NULL != g_pData->GetUIManager()->GetUISkillTree() )
	{
		g_pData->GetUIManager()->GetUISkillTree()->SwapSkillSlot(!g_pData->GetUIManager()->GetUISkillTree()->GetSkillSlotSwap());
	}
}




#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION

//#ifndef X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//
///*FORCEINLINE*/ bool CX2GUUser::ProcessCanPushUserUnit( CX2GUUser* pGameUnit_, const D3DXVECTOR2& vMyUnitMinMaxY_, const D3DXVECTOR2& vMyUnitMinMaxYCur_, OUT D3DXVECTOR3& vMyPos_ )
//{
//	KTDXPROFILE_BEGIN("Push");	
//
//	D3DXVECTOR3 vPosFutureOtherGameUnit	= pGameUnit_->GetPos( true );
//    D3DXVECTOR3 vPosNowOtherGameUnit = pGameUnit_->GetPositionBackup();
//
//	const float fGameUnitYMin = vPosFutureOtherGameUnit.y;
//	const float fGameUnitYMax = fGameUnitYMin + pGameUnit_->GetUnitHeight( true );
//
//	// 높이가 겹칠수 있는 높이인지 먼저 테스트
//	// vMyUnitMinMaxY_에서 x는 Min 값, y는 Max 값
//	if( (fGameUnitYMin >= vMyUnitMinMaxY_.x && fGameUnitYMin <= vMyUnitMinMaxY_.y) ||
//		(fGameUnitYMax >= vMyUnitMinMaxY_.x && fGameUnitYMax <= vMyUnitMinMaxY_.y) ||
//		(fGameUnitYMin <= vMyUnitMinMaxY_.x && fGameUnitYMax >= vMyUnitMinMaxY_.y) )
//	{
//		vPosFutureOtherGameUnit.y = vMyPos_.y;
//		const float fDistanceHorizon3Sq = GetDistance3Sq( vPosFutureOtherGameUnit, vMyPos_ );
//		float fHalfSumUnitWidth = ( GetUnitWidth( true ) + pGameUnit_->GetUnitWidth( true ) ) * 0.5f;
//
//		if( fDistanceHorizon3Sq < fHalfSumUnitWidth * fHalfSumUnitWidth )	/// 서로 근접하여 붙어있으면
//		{
//            float fDistanceHorizon =  sqrt( fDistanceHorizon3Sq );
//            float fMarginMax = FLT_MAX;
//
//			//{{ dmlee 2008.11.6 레이븐 파워어썰트처럼 속도가 빠르고 밀고 나가는 공격인 경우에 예외처리
//			// 특히 캐릭터 혹은 몬스터의 크기가 클수록, 속도가 빠를수록 서로 너무 멀리 밀리게 되서 연타공격이 안되는 문제가 있음
//			// 이름 보정해주기 위한 예외처리
//			if ( pGameUnit_->GetPhysicParam().nowSpeed.x > MAGIC_SPEED_BOUND ||
//				pGameUnit_->GetPhysicParam().passiveSpeed.x > MAGIC_SPEED_BOUND )
//			{				
//				const float fUnitWidthScale = GetUnitWidth( true ) / MAGIC_DEFAULT_UNIT_WIDTH;				
//				fMarginMax = MAGIC_DEFALUT_UNIT_DISPLACE * fUnitWidthScale;
//				if( fMarginMax > MAGIC_MAX_UNIT_DISPLACE )
//					fMarginMax = MAGIC_MAX_UNIT_DISPLACE; 
//			}
//			//}} dmlee 2008.11.6 레이븐 파워어썰트처럼 속도가 빠르고 밀고 나가는 공격인 경우에 예외처리
//
//			//상대 유닛을 향한 방향 벡터
//            D3DXVECTOR3 vTestPos;
//            D3DXVECTOR3 vDirVectorFromMeToOther;
//            const float fGameUnitYMinCur = vPosNowOtherGameUnit.y;
//            const float fGameUnitYMaxCur = fGameUnitYMinCur + pGameUnit_->GetUnitHeight( false );  
//	        if( (fGameUnitYMinCur >= vMyUnitMinMaxYCur_.x && fGameUnitYMinCur <= vMyUnitMinMaxYCur_.y) ||
//		        (fGameUnitYMaxCur >= vMyUnitMinMaxYCur_.x && fGameUnitYMaxCur <= vMyUnitMinMaxYCur_.y) ||
//		        (fGameUnitYMinCur <= vMyUnitMinMaxYCur_.x && fGameUnitYMaxCur >= vMyUnitMinMaxYCur_.y) )
//            {
//                vDirVectorFromMeToOther = vPosNowOtherGameUnit - m_FrameDataFuture.syncData.position;
//                vDirVectorFromMeToOther.y = 0.f;
//			    if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) >= 0 )
//			    {
//                    vDirVectorFromMeToOther = vPosFutureOtherGameUnit - vMyPos_;
//                    if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) >= 0 )
//                    {
//                        float fHalfSumMargin = __min( fHalfSumUnitWidth - fDistanceHorizon, fMarginMax );
//                        vTestPos.x = vMyPos_.x - m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
//                        vTestPos.y = vMyPos_.y;
//                        vTestPos.z = vMyPos_.z - m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin; 
//                    }
//                    else
//                    {
//                        float fHalfSumMargin = __min( fHalfSumUnitWidth, fMarginMax ) + fDistanceHorizon;
//                        vTestPos.x = vMyPos_.x - m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
//                        vTestPos.y = vMyPos_.y;
//                        vTestPos.z = vMyPos_.z - m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin;
//                    }
//                }
//                else
//                {
//                    vDirVectorFromMeToOther = vPosFutureOtherGameUnit - vMyPos_;
//                    vDirVectorFromMeToOther.y = 0.f;
//                    if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) <= 0 )
//                    {
//                        float fHalfSumMargin = __min( fHalfSumUnitWidth - fDistanceHorizon, fMarginMax );
//                        vTestPos.x = vMyPos_.x + m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
//                        vTestPos.y = vMyPos_.y;
//                        vTestPos.z = vMyPos_.z + m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin; 
//                    }
//                    else
//                    {
//                        float fHalfSumMargin = __min( fHalfSumUnitWidth, fMarginMax ) + fDistanceHorizon;
//                        vTestPos.x = vMyPos_.x + m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
//                        vTestPos.y = vMyPos_.y;
//                        vTestPos.z = vMyPos_.z + m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin;
//                    }
//                }
//                vMyPos_ = vTestPos;
//                return true;
//            }
//            else
//            {
//                vDirVectorFromMeToOther = vPosFutureOtherGameUnit - vMyPos_;
//                vDirVectorFromMeToOther.y = 0.f;
//                float fHalfSumMargin = __min( fHalfSumUnitWidth - fDistanceHorizon, fMarginMax );
//			    if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) >= 0 )
//			    {
//                    vTestPos.x = vMyPos_.x - m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
//                    vTestPos.y = vMyPos_.y;
//                    vTestPos.z = vMyPos_.z - m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin; 
//                    if ( CheckPassUnit( pGameUnit_, vTestPos) == false )
//                    {
//                        vMyPos_ = vTestPos;
//                        return true;
//                    }
//                }
//                else
//                {
//                    vTestPos.x = vMyPos_.x + m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
//                    vTestPos.y = vMyPos_.y;
//                    vTestPos.z = vMyPos_.z + m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin; 
//                    if ( CheckPassUnit( pGameUnit_, vTestPos) == false )
//                    {
//                        vMyPos_ = vTestPos;
//                        return true;
//                    }
//                }
//                return false;
//            }
//		} // if	
//	} // if
//
//    if ( CheckPassUnit( pGameUnit_, vMyPos_) == false )
//        return true;
//
//	KTDXPROFILE_END();
//
//    return  false;
//}
//
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC

//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
/*FORCEINLINE*/ bool CX2GUUser::ProcessCanPushUnit( CX2GameUnit* pGameUnit_, const D3DXVECTOR2& vMyUnitMinMaxY_, OUT D3DXVECTOR3& vMyPos_, int iDirection )
//#else   X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
///*FORCEINLINE*/ bool CX2GUUser::ProcessCanPushNPCUnit( CX2GUNPC* pGameUnit_, const D3DXVECTOR2& vMyUnitMinMaxY_, OUT D3DXVECTOR3& vMyPos_, int iDirection )
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
{
	KTDXPROFILE_BEGIN("Push");	

	D3DXVECTOR3 vPosFutureOtherGameUnit = pGameUnit_->GetPos( true );
	const float fGameUnitYMin = vPosFutureOtherGameUnit.y;
	const float fGameUnitYMax = fGameUnitYMin + pGameUnit_->GetUnitHeight( true );

	if( (fGameUnitYMin >= vMyUnitMinMaxY_.x && fGameUnitYMin <= vMyUnitMinMaxY_.y) ||
		(fGameUnitYMax >= vMyUnitMinMaxY_.x && fGameUnitYMax <= vMyUnitMinMaxY_.y) ||
		(fGameUnitYMin <= vMyUnitMinMaxY_.x && fGameUnitYMax >= vMyUnitMinMaxY_.y) )
    {
        if ( iDirection == 1 || iDirection == 2 )
        {
	        // 높이가 겹칠수 있는 높이인지 먼저 테스트
	        // vMyUnitMinMaxY_에서 x는 Min 값, y는 Max 값
		    vPosFutureOtherGameUnit.y = vMyPos_.y;
		    const float fDistanceHorizon3Sq = GetDistance3Sq( vPosFutureOtherGameUnit, vMyPos_ );
     	    float fHalfSumUnitWidth = ( GetUnitWidth( true ) + pGameUnit_->GetUnitWidth( true ) ) * 0.5f;
		
		    if( fDistanceHorizon3Sq < fHalfSumUnitWidth * fHalfSumUnitWidth )	/// 서로 근접하여 붙어있으면
		    {
                float fDistanceHorizon =  sqrt( fDistanceHorizon3Sq );
                float fMarginMax = FLT_MAX;

			    //{{ dmlee 2008.11.6 레이븐 파워어썰트처럼 속도가 빠르고 밀고 나가는 공격인 경우에 예외처리
			    // 특히 캐릭터 혹은 몬스터의 크기가 클수록, 속도가 빠를수록 서로 너무 멀리 밀리게 되서 연타공격이 안되는 문제가 있음
			    // 이름 보정해주기 위한 예외처리
			    if ( pGameUnit_->GetPhysicParam().nowSpeed.x > MAGIC_SPEED_BOUND ||
				    pGameUnit_->GetPhysicParam().passiveSpeed.x > MAGIC_SPEED_BOUND )
			    {				
				    const float fUnitWidthScale = GetUnitWidth( true ) / MAGIC_DEFAULT_UNIT_WIDTH;				
				    fMarginMax = MAGIC_DEFALUT_UNIT_DISPLACE * fUnitWidthScale;
				    if( fMarginMax > MAGIC_MAX_UNIT_DISPLACE )
					    fMarginMax = MAGIC_MAX_UNIT_DISPLACE; 
			    }
			    //}} dmlee 2008.11.6 레이븐 파워어썰트처럼 속도가 빠르고 밀고 나가는 공격인 경우에 예외처리

                D3DXVECTOR3 vTestPos;
                D3DXVECTOR3 vDirVectorFromMeToOther;
			    if ( iDirection == 2 )
			    {
                    vDirVectorFromMeToOther = vPosFutureOtherGameUnit - vMyPos_;
                    vDirVectorFromMeToOther.y = 0.f;
                    if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) >= 0 )
                    {
                        float fHalfSumMargin = __min( fHalfSumUnitWidth - fDistanceHorizon, fMarginMax );
                        vTestPos.x = vMyPos_.x - m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
                        vTestPos.y = vMyPos_.y;
                        vTestPos.z = vMyPos_.z - m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin; 
                    }
                    else
                    {
                        float fHalfSumMargin = __min( fHalfSumUnitWidth, fMarginMax ) + fDistanceHorizon;
                        vTestPos.x = vMyPos_.x - m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
                        vTestPos.y = vMyPos_.y;
                        vTestPos.z = vMyPos_.z - m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin; 
                    }
                }
                else
                {
                    vDirVectorFromMeToOther = vPosFutureOtherGameUnit - vMyPos_;
                    vDirVectorFromMeToOther.y = 0.f;
                    if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) <= 0 )
                    {
                        float fHalfSumMargin = __min( fHalfSumUnitWidth - fDistanceHorizon, fMarginMax );
                        vTestPos.x = vMyPos_.x + m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
                        vTestPos.y = vMyPos_.y;
                        vTestPos.z = vMyPos_.z + m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin; 
                    }
                    else
                    {
                        float fHalfSumMargin = __min( fHalfSumUnitWidth, fMarginMax ) + fDistanceHorizon;
                        vTestPos.x = vMyPos_.x + m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
                        vTestPos.y = vMyPos_.y;
                        vTestPos.z = vMyPos_.z + m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin; 
                    }
                }
                vMyPos_ = vTestPos;
                return true;
		    }
            else
            {
                D3DXVECTOR3 vDirVectorFromMeToOther;
                vDirVectorFromMeToOther = vPosFutureOtherGameUnit - vMyPos_;
                vDirVectorFromMeToOther.y = 0.f;

                if ( iDirection == 2 )
                {
                    if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) >= 0 )
                        return true;
                }
                else
                {
                    if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) <= 0 )
                        return true;
                }
                if ( CheckPassUnit( pGameUnit_, vMyPos_ ) == false )
                    return true;
                return false;
            }
        }
        else
        {
		    vPosFutureOtherGameUnit.y = vMyPos_.y;
		    const float fDistanceHorizon3Sq = GetDistance3Sq( vPosFutureOtherGameUnit, vMyPos_ );
     	    float fHalfSumUnitWidth = ( GetUnitWidth( true ) + pGameUnit_->GetUnitWidth( true ) ) * 0.5f;
		
		    if( fDistanceHorizon3Sq < fHalfSumUnitWidth * fHalfSumUnitWidth )	/// 서로 근접하여 붙어있으면
		    {
                float fDistanceHorizon =  sqrt( fDistanceHorizon3Sq );
                float fMarginMax = FLT_MAX;

			    //{{ dmlee 2008.11.6 레이븐 파워어썰트처럼 속도가 빠르고 밀고 나가는 공격인 경우에 예외처리
			    // 특히 캐릭터 혹은 몬스터의 크기가 클수록, 속도가 빠를수록 서로 너무 멀리 밀리게 되서 연타공격이 안되는 문제가 있음
			    // 이름 보정해주기 위한 예외처리
			    if ( pGameUnit_->GetPhysicParam().nowSpeed.x > MAGIC_SPEED_BOUND ||
				    pGameUnit_->GetPhysicParam().passiveSpeed.x > MAGIC_SPEED_BOUND )
			    {				
				    const float fUnitWidthScale = GetUnitWidth( true ) / MAGIC_DEFAULT_UNIT_WIDTH;				
				    fMarginMax = MAGIC_DEFALUT_UNIT_DISPLACE * fUnitWidthScale;
				    if( fMarginMax > MAGIC_MAX_UNIT_DISPLACE )
					    fMarginMax = MAGIC_MAX_UNIT_DISPLACE; 
			    }
			    //}} dmlee 2008.11.6 레이븐 파워어썰트처럼 속도가 빠르고 밀고 나가는 공격인 경우에 예외처리

                D3DXVECTOR3 vTestPos;
                D3DXVECTOR3 vDirVectorFromMeToOther;
                vDirVectorFromMeToOther = vPosFutureOtherGameUnit - vMyPos_;
                vDirVectorFromMeToOther.y = 0.f;
                float fHalfSumMargin = __min( fHalfSumUnitWidth - fDistanceHorizon, fMarginMax );
                if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) >= 0 )
                {
                    vTestPos.x = vMyPos_.x - m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
                    vTestPos.y = vMyPos_.y;
                    vTestPos.z = vMyPos_.z - m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin; 
                    if ( iDirection == 0 || CheckPassUnit( pGameUnit_, vTestPos ) == false )
                    {
                        vMyPos_ = vTestPos;
                        return true;
                    }
                }
                else
                {
                    vTestPos.x = vMyPos_.x + m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
                    vTestPos.y = vMyPos_.y;
                    vTestPos.z = vMyPos_.z + m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin; 
                    if ( iDirection == 0 || CheckPassUnit( pGameUnit_, vTestPos ) == false )
                    {
                        vMyPos_ = vTestPos;
                        return true;
                    }
                }
                return false;
		    }
            else
            {
                if ( iDirection == 0 || CheckPassUnit( pGameUnit_, vMyPos_ ) == false )
                    return true;
            }//if.. else..
        }
    }
    else
    {
        if ( iDirection == 0 )
            return true;

        if ( fGameUnitYMin >= vMyUnitMinMaxY_.y )
        {
            if ( iDirection == 3 )
                return true;
        }
        else
        {
            if ( iDirection == 4 )
                return true;
        }
        if ( CheckPassUnit( pGameUnit_, vMyPos_ ) == false )
            return true;
    }


	KTDXPROFILE_END();

    return false;
}


#else   X2OPTIMIZE_NPC_NONHOST_SIMULATION

/*FORCEINLINE*/ void CX2GUUser::ProcessCanPushUnit( const CX2GameUnit* pGameUnit_, const D3DXVECTOR2& vMyUnitMinMaxY_, OUT D3DXVECTOR3& vMyPos_ )
{
	KTDXPROFILE_BEGIN("Push");	

	D3DXVECTOR3 vPosFutureOtherGameUnit	= pGameUnit_->GetPos( true );
	const float fGameUnitYMin = vPosFutureOtherGameUnit.y;
	const float fGameUnitYMax = fGameUnitYMin + pGameUnit_->GetUnitHeight( true );

	// 높이가 겹칠수 있는 높이인지 먼저 테스트
	// vMyUnitMinMaxY_에서 x는 Min 값, y는 Max 값
	if( (fGameUnitYMin >= vMyUnitMinMaxY_.x && fGameUnitYMin <= vMyUnitMinMaxY_.y) ||
		(fGameUnitYMax >= vMyUnitMinMaxY_.x && fGameUnitYMax <= vMyUnitMinMaxY_.y) ||
		(fGameUnitYMin <= vMyUnitMinMaxY_.x && fGameUnitYMax >= vMyUnitMinMaxY_.y) )
	{
		vPosFutureOtherGameUnit.y = vMyPos_.y;
		const float fDistanceHorizon3Sq = GetDistance3Sq( vPosFutureOtherGameUnit, vMyPos_ );
		float fHalfSumUnitWidth = ( GetUnitWidth( true ) + pGameUnit_->GetUnitWidth( true ) ) * 0.5f;

		if( fDistanceHorizon3Sq < fHalfSumUnitWidth * fHalfSumUnitWidth )	/// 서로 근접하여 붙어있으면
		{
            float fHalfSumMargin = fHalfSumUnitWidth - sqrt( fDistanceHorizon3Sq );

			//{{ dmlee 2008.11.6 레이븐 파워어썰트처럼 속도가 빠르고 밀고 나가는 공격인 경우에 예외처리
			// 특히 캐릭터 혹은 몬스터의 크기가 클수록, 속도가 빠를수록 서로 너무 멀리 밀리게 되서 연타공격이 안되는 문제가 있음
			// 이름 보정해주기 위한 예외처리
			if ( pGameUnit_->GetPhysicParam().nowSpeed.x > MAGIC_SPEED_BOUND ||
				pGameUnit_->GetPhysicParam().passiveSpeed.x > MAGIC_SPEED_BOUND )
			{				
				const float fUnitWidthScale = GetUnitWidth( true ) / MAGIC_DEFAULT_UNIT_WIDTH;				
				if( fHalfSumMargin > MAGIC_DEFALUT_UNIT_DISPLACE * fUnitWidthScale )
					fHalfSumMargin = MAGIC_DEFALUT_UNIT_DISPLACE * fUnitWidthScale;

				if( fHalfSumMargin > MAGIC_MAX_UNIT_DISPLACE )
					fHalfSumMargin = MAGIC_MAX_UNIT_DISPLACE; 
			}
			//}} dmlee 2008.11.6 레이븐 파워어썰트처럼 속도가 빠르고 밀고 나가는 공격인 경우에 예외처리

			//상대 유닛을 향한 방향 벡터
			D3DXVECTOR3 vDirVectorFromMeToOther = vPosFutureOtherGameUnit - m_FrameDataFuture.syncData.position;
			//D3DXVec3Normalize( &vDirVectorFromMeToOther, &vDirVectorFromMeToOther );
            vDirVectorFromMeToOther.y = 0.f;

			if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) >= 0 ) //앞에있다
			{
				vMyPos_.x -= m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
				vMyPos_.z -= m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin;
			}
			else //뒤에있다
			{
				vMyPos_.x += m_FrameDataFuture.unitCondition.dirVector.x * fHalfSumMargin;
				vMyPos_.z += m_FrameDataFuture.unitCondition.dirVector.z * fHalfSumMargin;
			}
		} // if	
	} // if

	KTDXPROFILE_END();
}


#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION

#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
/*FORCEINLINE*/ bool CX2GUUser::CheckPassUnit( const CX2GameUnit* pGameUnit_, OUT D3DXVECTOR3& vPos_ )
#else   X2OPTIMIZE_NPC_NONHOST_SIMULATION
/*FORCEINLINE*/ void CX2GUUser::ProcessCanPassUnit( const CX2GameUnit* pGameUnit_, OUT D3DXVECTOR3& vPos_ )
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION
{
	KTDXPROFILE_BEGIN("Pass");

	const D3DXVECTOR3& vMyOriginalPos = m_FrameDataFuture.syncData.position;

	if( vPos_ == vMyOriginalPos )
    {
#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
        return false;
#else   X2OPTIMIZE_NPC_NONHOST_SIMULATION
        return;
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION
    }

    const D3DXVECTOR3& vPosFutureOtherGameUnit = pGameUnit_->GetPos( true );	
    D3DXVECTOR3 vPosBackup = const_cast<CX2GameUnit*>(pGameUnit_)->GetPositionBackup();

	D3DXVECTOR3 vDirFromPosFutureToUnit		= vPosFutureOtherGameUnit - vPos_;
	vDirFromPosFutureToUnit.y = 0.f;

    D3DXVECTOR3 vDirFromOrgPosToUnit	= vPosBackup - vMyOriginalPos;
	vDirFromOrgPosToUnit.y = 0.f;

    if ( D3DXVec3Dot( &vDirFromPosFutureToUnit, &vDirFromOrgPosToUnit ) > 0 )
    {
#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
        return false;
#else   X2OPTIMIZE_NPC_NONHOST_SIMULATION
        return;
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION
    }

    vDirFromOrgPosToUnit	= vPosFutureOtherGameUnit - vMyOriginalPos;
	vDirFromOrgPosToUnit.y = 0.f;

	if ( D3DXVec3Dot( &vDirFromPosFutureToUnit, &vDirFromOrgPosToUnit ) < 0 )
	{
		const float fProjObjDistance3Sq 
			= GetDistance3Sq( D3DXVECTOR3( vPosFutureOtherGameUnit.x, vMyOriginalPos.y, vPosFutureOtherGameUnit.z ), vMyOriginalPos );

		const float fProjMoveDistance3Sq 
			= GetDistance3Sq( D3DXVECTOR3( vPos_.x, vMyOriginalPos.y, vPos_.z ), vMyOriginalPos );

		if ( fProjMoveDistance3Sq >= fProjObjDistance3Sq )
		{
			D3DXVECTOR3 moveDir = vPos_ - vMyOriginalPos;
			D3DXVec3Normalize( &moveDir, &moveDir );

			const float fCollisionPointFirstY = vMyOriginalPos.y + moveDir.y * sqrt( fProjObjDistance3Sq );
			const float fCollisionPointSecondY = fCollisionPointFirstY + GetUnitHeight( true );

			const float fGameUnitYMin = vPosFutureOtherGameUnit.y;
			const float fGameUnitYMax = vPosFutureOtherGameUnit.y + pGameUnit_->GetUnitHeight( true );

			if( ( fCollisionPointFirstY >= fGameUnitYMin && fCollisionPointFirstY <= fGameUnitYMax ) ||
				( fCollisionPointSecondY >= fGameUnitYMin && fCollisionPointSecondY <= fGameUnitYMax ) )
                //|| ( fCollisionPointFirstY <= fGameUnitYMin && fCollisionPointSecondY >= fGameUnitYMax ) )
			{
#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
                return true;
#else   X2OPTIMIZE_NPC_NONHOST_SIMULATION
				//관통함
				vPos_ = vMyOriginalPos;
				m_PhysicParam.nowSpeed.x = 0.0f;
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION
			}
		}
	}

	KTDXPROFILE_END();
#ifdef  X2OPTIMIZE_NPC_NONHOST_SIMULATION
    return false;
#endif  X2OPTIMIZE_NPC_NONHOST_SIMULATION
}

/** @function : SetVisitCashShop
	@brief : 캐쉬샵에 들어간 유저에 대한 처리
			(무적, 이모티콘 추가)	
*/
void CX2GUUser::SetEnterCashShop(bool bVal)
{	
	m_bEnterCashShop = bVal;

	if( true == bVal ) 
	{//캐쉬샵 입장
		wstring wstrEmotionName = L"Emotion_SitWait";
#ifdef RIDING_SYSTEM
		if ( true == GetRidingOn() && NULL != GetRidingPet() && false == m_wstrRidingMotionName.empty() )
		{
			wstrEmotionName = m_wstrRidingMotionName;
			GetRidingPet()->StateChange( GetRidingPet()->m_SitWaitState );
		}
#endif //RIDING_SYSTEM
		PlayEmotion(CX2Unit::ET_SITWAIT, wstrEmotionName);

		if( INVALID_PARTICLE_SEQUENCE_HANDLE == m_hEnterCashShop )
		{
			m_hEnterCashShop = 
				g_pX2Game->GetMajorParticle()->CreateSequenceHandle( static_cast<CKTDGObject*>(this),  L"EnterCashShop", 0,0,0 );
		}
		
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hEnterCashShop );
		if( NULL != pSeq )
		{
			pSeq->SetShowObject(true);

			D3DXVECTOR3 vPos = GetPos();
			vPos.y += 200.f;
			vPos.x += 50.f;
			pSeq->SetPosition( vPos );
		}
	}
	else
	{//캐쉬샵 퇴장
		StateChange(GetWaitStateID(), true);	

		if(m_pXSkinAnim != NULL)
		{
#ifdef RIDING_SYSTEM
			if ( true == GetRidingOn() && NULL != GetRidingPet() && false == m_wstrRidingMotionName.empty() )
			{
				m_pXSkinAnim->ChangeAnim( m_wstrRidingMotionName.c_str() , true );
				GetRidingPet()->StateChange( GetRidingPet()->m_SitWaitState );
			}
			else
			{
				m_pXSkinAnim->ChangeAnim( L"Emotion_StandUp" , true );
			}
#else //RIDING_SYSTEM
			m_pXSkinAnim->ChangeAnim( L"Emotion_StandUp" , true );
#endif //RIDING_SYSTEM
			m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		}

		if( INVALID_PARTICLE_SEQUENCE_HANDLE != m_hEnterCashShop )
		{
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle(m_hEnterCashShop);
		}
	}
}

/** @function : CanApplySocketDataByGameType
	@brief : 게임 타입에 따라 소켓옵션을 적용 할 수 있는지 여부
	@param : SocketData의 포인터
	@return : 적용이 되야 하면 true, 안되야 하면 false
*/
bool CX2GUUser::CanApplySocketDataByGameType( const CX2SocketItem::SocketData& kSocketData_ )
{
	if ( NULL != g_pX2Game )
	{
		switch ( g_pX2Game->GetGameType() )
		{
		case CX2Game::GT_BATTLE_FIELD:
		case CX2Game::GT_DUNGEON:
			{
				if ( kSocketData_.m_bPVPOnly )
					return false;
			} break;

		default:	/// pvp
			{
				if ( kSocketData_.m_bDungeonOnly )
					return false;
			}break;
		}
	}

	return true;
}
#ifdef MODIFY_SET_DAMAGE_DATA
void CX2GUUser::SetDamageExceptionProcess( CX2DamageManager::DamageData* pDamageData_, float& fPowerRate)
{
	CX2GameUnit::SetDamageExceptionProcess(pDamageData_, fPowerRate);
	
#ifdef RAVEN_SECOND_CLASS_CHANGE
	if( null != pDamageData_->optrAttackerGameUnit != NULL && pDamageData_->optrAttackerGameUnit->GetGameUnitType() == CX2GameUnit::GUT_USER )
	{
		CX2GUUser *pUser = static_cast<CX2GUUser*>( pDamageData_->optrAttackerGameUnit.GetObservable() );
		CX2DamageManager::DAMAGE_TYPE eDamageType;
		float fDamageRel;		

		pUser->SetHitNasodWeapon(false);

		bool bChange = pUser->GetChangeDamageType(eDamageType, fDamageRel);
		if( bChange == true
#ifdef FIX_EXPLOSIVE_NASOD_HAND
			&& eDamageType == CX2DamageManager::DT_MAGIC
#endif //EXPLOSIVE_NASOD_HAND
			)
		{
			float fDamageRelOri = 1.f;

			switch(pDamageData_->damageType)
			{
			case CX2DamageManager::DT_PHYSIC:
				fDamageRelOri = pDamageData_->damage.fPhysic;
				break;
			case CX2DamageManager::DT_MAGIC:
				fDamageRelOri = pDamageData_->damage.fMagic;
				break;
			default:
				break;
			}

			pDamageData_->damageType = eDamageType;
			switch(eDamageType)
			{
			case CX2DamageManager::DT_PHYSIC:
				pDamageData_->damage.fPhysic = fDamageRelOri * fDamageRel;
				break;
			case CX2DamageManager::DT_MAGIC:
				pDamageData_->damage.fMagic = fDamageRelOri * fDamageRel;
				break;

				//{{ kimhc // 2010.7.30 // 스탯을 제외한 무기만의 데미지
			case CX2DamageManager::DT_WEAPON_PHYSIC:
				pDamageData_->damage.fPhysic = fDamageRelOri * fDamageRel;
				break;
			case CX2DamageManager::DT_WEAPON_MAGIC:
				pDamageData_->damage.fMagic = fDamageRelOri * fDamageRel;
				break;
				//}} kimhc // 2010.7.30 // 스탯을 제외한 무기만의 데미지
			default:
				break;
			}
		}
	}
#endif
}
#endif //MODIFY_SET_DAMAGE_DATA


#ifdef REALTIME_SCRIPT_PATCH
void CX2GUUser::SetScriptFileName()
{
	if( NULL == GetUnit() )
		return;

	switch ( GetUnit()->GetType() )
	{
	case CX2Unit::UT_ELSWORD:	m_ScriptFileName = L"ELSWORD_SWORDMAN.lua"; break;
	case CX2Unit::UT_ARME:		m_ScriptFileName = L"ARME_VIOLETMAGE.lua"; break;
	case CX2Unit::UT_LIRE:		m_ScriptFileName = L"LIRE_ELVENRANGER.lua"; break;
	case CX2Unit::UT_RAVEN:		m_ScriptFileName = L"RAVEN_FIGHTER.lua"; break;
	case CX2Unit::UT_EVE:		m_ScriptFileName = L"EVE_NASOD.lua"; break;
	case CX2Unit::UT_CHUNG:		m_ScriptFileName = L"CHUNG_IRON_CANNON.lua"; break;
	case CX2Unit::UT_ARA:		m_ScriptFileName = L"ARA_MARTIAL_ARTIST.lua";	break;
	case CX2Unit::UT_ELESIS:	m_ScriptFileName = L"ELESIS_KNIGHT.lua";	break;
	case CX2Unit::UT_ADD:		m_ScriptFileName = L"ADD_NASODRULER.lua";	break;
	default:
		break;
	}
}

#endif //REALTIME_SCRIPT_PATCH

const CX2GUUser::UserUnitStateData& CX2GUUser::GetPressedSkillState( const int iPressedIndex_ )
{
	if( GetRemainHyperModeTime() <= 0.f )
	{
		if( iPressedIndex_ > 3 ) //슬롯 B일때
		{
			return m_StateList[_CONST_GUUSER_::aNormalSkillStateIDSlotB[iPressedIndex_-4]];
		}
		else
		{
			return m_StateList[_CONST_GUUSER_::aNormalSkillStateID[iPressedIndex_]];
		}
	}
	else
	{
		if( iPressedIndex_ > 3 ) //슬롯 B일때
		{
			return m_StateList[_CONST_GUUSER_::aHyperSkillStateIDSlotB[iPressedIndex_-4]];
		}
		else
		{
			return m_StateList[_CONST_GUUSER_::aHyperSkillStateID[iPressedIndex_]];
		}
	}
}

#ifdef ADD_UPGRADE_WEAPON_PARTICLE		/// 무기 강화 이펙트 선로딩 함수
void CX2GUUser::AppendUpgradeWeaponParticleToDeviceList( CKTDXDeviceDataList& listInOut_, CX2Unit::UNIT_TYPE eUnitType_, int iUpgradeLevel_ )
{
	if( iUpgradeLevel_ >= ENCHANT_WEAPON_EFFECT_LEVEL_2 )		/// 11강화 이상
	{
		switch( eUnitType_ )
		{
			/// 길쭉한 모양의 무기
		case CX2Unit::UT_ELSWORD:
		case CX2Unit::UT_ARME:
		case CX2Unit::UT_RAVEN:
		case CX2Unit::UT_CHUNG:
		case CX2Unit::UT_ARA:
		case CX2Unit::UT_LIRE:
#ifdef SERV_NEW_CHARACTER_EL
		case CX2Unit::UT_ELESIS:
#endif // SERV_NEW_CHARACTER_EL
#ifdef SERV_9TH_NEW_CHARACTER // 김태환 ( 캐릭터 추가용 )
		case CX2Unit::UT_ADD:
#endif //SERV_9TH_NEW_CHARACTER
			{
				g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"11Gang_Weapon_Effect_Lightning" );
				g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"11Gang_Weapon_Effect_Lightning02" );
				g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"11Gang_Weapon_Effect_Lightning03" );
				g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"11Gang_Weapon_Effect_Lightning04" );
			} break;

			/// 무기가 2개인 이브의 기어
		case CX2Unit::UT_EVE:
			{
				g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"11Gang_Weapon_Effect_Lightning02" );
				g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"11Gang_Weapon_Effect_Lightning04" );
			} break;
		}
	}
}
#endif ADD_UPGRADE_WEAPON_PARTICLE

D3DXVECTOR3	CX2GUUser::GetBonePos( const WCHAR* pBoneName ) const
{
#ifdef EFFECT_TOOL
	if( NULL != m_pXSkinAnim_EffectTool )
	{
		return m_pXSkinAnim_EffectTool->GetCloneFramePosition( pBoneName );
	}
#endif //EFFECT_TOOL

	return m_pXSkinAnim->GetCloneFramePosition( pBoneName ); 
}

#ifdef MODIFY_GET_BONE_POS
bool CX2GUUser::GetBonePos( const WCHAR* pBoneName, OUT D3DXVECTOR3& pos_ ) const 
{ 
#ifdef EFFECT_TOOL
	if( NULL != m_pXSkinAnim_EffectTool )
	{
		return m_pXSkinAnim_EffectTool->GetCloneFramePosition( pBoneName, pos_ );
	}
#endif //EFFECT_TOOL

	return m_pXSkinAnim->GetCloneFramePosition( pBoneName, pos_ ); 
};
#endif //MODIFY_GET_BONE_POS

#ifdef FIX_SUMMONED_MONSTER_POSITION
// 소환된 몬스터 캐릭터 위치로 데려온다
void CX2GUUser::CallSummonedNPC( CX2UnitManager::NPC_UNIT_ID eNPCID /*= CX2UnitManager::NUI_NONE*/ )
{
	if( NULL == g_pX2Game )
		return; 

	for( int i=0; i < g_pX2Game->GetUnitNum(); ++i )
	{
		CX2GameUnit* pUnit = g_pX2Game->GetUnit( i );
		if( NULL == pUnit )
			continue;

		if( CX2GameUnit::GUT_NPC != pUnit->GetGameUnitType() )
			continue;

		CX2GUNPC *pNPC = static_cast<CX2GUNPC*>(pUnit);
		if( NULL == pNPC )
			continue;

		if( CX2UnitManager::NUI_NONE != eNPCID &&
			eNPCID != pNPC->GetNPCTemplet().m_nNPCUnitID )
		{
			continue;
		}

		if( pUnit->GetNowHp() <= 0.f )
			continue;

		if( NULL != pNPC->GetNPCAI() &&
			CX2NPCAI::NAT_ALLY == pNPC->GetNPCAI()->GetAIType() )
		{
			CX2AllyNPCAI* pAllyAI = static_cast<CX2AllyNPCAI*>(pNPC->GetNPCAI());
			if( GetUnitUID() == pAllyAI->GetAllyUnitUID() )
			{
				pNPC->SetPosition( GetPos(), GetIsRight() );
			}
		}
	}
}
#endif //FIX_SUMMONED_MONSTER_POSITION

#ifdef ADDED_RELATIONSHIP_SYSTEM
void CX2GUUser::COMMON_RELATIONSHIP_SKILL_FrameMove()
{
	// 던지기 모션을 사용 하기 때문에 m_fThrowStartTime 통해 타이밍 설정.
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( m_fThrowStartTime ) == true )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( m_fThrowStartTime ) == true && EventCheck( m_fThrowStartTime, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vEffectPos	= GetPos();
		D3DXVECTOR3 vRotate		= GetRotateDegree();

		vEffectPos.y += m_vThrowStartPosOffset.y;

		vEffectPos += (GetIsRight() == true) ? m_vThrowStartPosOffset.x * GetDirVector() : -m_vThrowStartPosOffset.x * GetDirVector();


		wstring wstrDamageEffectName = L"";


		const CX2Unit::UnitData*	pUnitData = ( NULL != GetUnit() ) ? &GetUnit()->GetUnitData() : NULL;
		if( NULL != pUnitData )
		{
			const CX2UserSkillTree::SkillSlotData* pSkillSlot = 
				pUnitData->m_UserSkillTree.GetSkillSlot(CX2SkillTree::SI_ETC_WS_COMMON_LOVE );;

			if( NULL != pSkillSlot )
			{
				switch( pSkillSlot->m_iSkillLevel )
				{
					case 1: wstrDamageEffectName = L"RELATIONSHIP_SKILL_THROW_LV1"; break;
					case 2: wstrDamageEffectName = L"RELATIONSHIP_SKILL_THROW_LV2"; break;
					default:
						ASSERT(!"RelationShip Skill Level Error");
						break;
				}
			}
		}
		if( false == wstrDamageEffectName.empty() )
		{
			CX2DamageEffect::CEffect *pDamageEffect = 
				g_pX2Game->GetDamageEffect()->CreateInstance( this, wstrDamageEffectName.c_str(), GetPowerRate(), vEffectPos, vRotate, vRotate, m_FrameDataNow.unitCondition.landPosition.y );
		}
	}
	CommonFrameMove();
}
void CX2GUUser::COMMON_RELATIONSHIP_SKILL_EventProcess()
{
	if( true == m_pXSkinAnimFuture->IsAnimationEnd() )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}	

	CommonEventProcess();
}
#endif // ADDED_RELATIONSHIP_SYSTEM

#ifdef RIDING_SYSTEM
#pragma region RindingStart
void CX2GUUser::RidingStartStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_StartState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingStartStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
	{
		m_PhysicParam.fWalkSpeed = m_ptrRidingPet->GetPhysicParam().fWalkSpeed;
		m_PhysicParam.fRunSpeed= m_ptrRidingPet->GetPhysicParam().fRunSpeed;
		m_PhysicParam.fJumpSpeed = m_ptrRidingPet->GetPhysicParam().fJumpSpeed;
		m_PhysicParam.fDashJumpSpeed = m_ptrRidingPet->GetPhysicParam().fDashJumpSpeed;

		InitAddtionalDashAndJumpBasicStatValue();

		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_StartState );
	}
}

void CX2GUUser::RidingStartEventProcess()
{
	CommonEventProcess();

	const float EVENT_TIME = 4.5f;

	if( EVENT_TIME <= m_FrameDataFuture.unitCondition.fStateTime )
	{
		StateChange( USI_RIDING_WAIT );
	}
}
#pragma endregion

#pragma region RidingOn
void CX2GUUser::RidingOnStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_StartState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingOnStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_StartState );

	if ( NULL != CX2RidingPetManager::GetInstance() )
	{
// 		if ( NULL == m_ptrRidingPet )
// 			m_ptrRidingPet = CX2RidingPetPtr();
// 
// 		if ( NULL == m_ptrRidingPet )
// 			m_ptrRidingPet = CX2RidingPetManager::GetInstance()->GetRidingPetPtr( GetUnitUID() );

		if ( NULL != m_ptrRidingPet )
		{
			m_FrameDataFuture.unitCondition.fUnitWidth = m_ptrRidingPet->GetUnitWidth();
			m_FrameDataFuture.unitCondition.fUnitHeight = m_ptrRidingPet->GetUnitHeight();

			m_PhysicParam.fWalkSpeed = m_ptrRidingPet->GetPhysicParam().fWalkSpeed;
			m_PhysicParam.fRunSpeed= m_ptrRidingPet->GetPhysicParam().fRunSpeed;
			m_PhysicParam.fJumpSpeed = m_ptrRidingPet->GetPhysicParam().fJumpSpeed;
			m_PhysicParam.fDashJumpSpeed = m_ptrRidingPet->GetPhysicParam().fDashJumpSpeed;

			InitAddtionalDashAndJumpBasicStatValue();

			m_ElapsedTimeRidingWaitHabit.ResetSumOfElapsedTime();
			m_ElapsedTimeRidingWaitHabit.SetTargetTime( static_cast<float>( GetRandomInt() % 6 + 3 ) );

		}
	}
}

void CX2GUUser::RidingOnEventProcess()
{
	CommonEventProcess();

	if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
	{
		StateChange( USI_RIDING_WAIT );
	}
	else if ( false == IsOnSomethingFuture() )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	else if ( true == RidingPetSpecialAttackEventProcess() )
	{
	}
	else if ( true == m_InputData.pureDoubleRight || true == m_InputData.pureDoubleLeft )
	{
		StateChangeDashIfPossible();
	}
	else if ( true == m_InputData.pureRight || true == m_InputData.pureLeft )
	{
		StateChange( USI_RIDING_WALK );
	}
	else if ( true == m_InputData.pureUp )	// 점프
	{
		StateChange( USI_RIDING_JUMP_UP );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS + 60.f;
	}
	else if( true == m_InputData.oneDown &&	
		true == g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS,
		&m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
}
void CX2GUUser::RidingOnEnd()
{
	CommonStateEnd();
}
#pragma endregion

#pragma region RidingOff
void CX2GUUser::RidingOffEventProcess()
{
	CommonEventProcess();

	StateChange( USI_WAIT );
}
void CX2GUUser::RidingOffEnd()
{
	CommonStateEnd();

	m_FrameDataFuture.unitCondition.fUnitWidth = m_vOrgUnitSize.x;
	m_FrameDataFuture.unitCondition.fUnitHeight = m_vOrgUnitSize.y;

	m_PhysicParam = m_OrgPhysicParam;
	m_bPassDash = false;

	InitAddtionalDashAndJumpBasicStatValue();
	SetNoDetonation( false );
}
#pragma endregion

#pragma region RidingWait
void CX2GUUser::RidingWaitStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_WaitState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingWaitStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_WaitState );
}

void CX2GUUser::RidingWaitEventProcess()
{
	if ( false == IsOnSomethingFuture() )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	else if ( true == RidingPetSpecialAttackEventProcess() )
	{
	}
	else if ( true == m_InputData.pureDoubleRight || true == m_InputData.pureDoubleLeft )
	{
		StateChangeDashIfPossible();
	}
	else if ( true == m_InputData.pureRight || true == m_InputData.pureLeft )
	{
		StateChange( USI_RIDING_WALK );
	}
	else if ( true == m_InputData.pureUp )	// 점프
	{
		StateChange( USI_RIDING_JUMP_UP );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
	}
	else if( true == m_InputData.oneDown &&	
		true == g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS,
		&m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( m_ElapsedTimeRidingWaitHabit.CheckElapsedTime() &&
		NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
	{
		StateChange( USI_RIDING_WAIT_HABIT );
	}
#ifdef MODIFY_RIDING_PET_AWAKE
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE(USI_RIDING_HYPER_MODE);
#endif // MODIFY_RIDING_PET_AWAKE

	
	CommonEventProcess();
}
#pragma endregion

#pragma region RidingWalk
void CX2GUUser::RidingWalkStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_WalkState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingWalkStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_WalkState );

	TRACE( L"RidingWalkStart Start\n" );
}

void CX2GUUser::RidingWalkEventProcess()
{
	if ( false == IsOnSomethingFuture() )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	else if ( true == RidingPetSpecialAttackEventProcess() )
	{
		TRACE( L"Walk RidingPetSpecialAttackEventProcess" );
	}
	else if ( true == m_InputData.pureDoubleRight || true == m_InputData.pureDoubleLeft )
	{
		TRACE( L"Walk m_InputData.pureDoubleRight m_InputData.pureDoubleLeft" );
		StateChangeDashIfPossible();
	}
	else if ( false == m_InputData.pureRight && false == m_InputData.pureLeft )
	{
		TRACE( L"Walk m_InputData.pureRight m_InputData.pureLeft" );
		StateChange( USI_RIDING_WAIT );

		TRACE( L"RidingWalkStart Wait\n" );
	}
	else if ( true == m_InputData.pureUp )
	{
		TRACE( L"Walk m_InputData.pureUp" );
		StateChange( USI_RIDING_JUMP_UP );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
	}
	else if( true == m_InputData.oneDown &&
		true == g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS,
		&m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef MODIFY_RIDING_PET_AWAKE
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE(USI_RIDING_HYPER_MODE);
#endif // MODIFY_RIDING_PET_AWAKE
	
	CommonEventProcess();
}
#pragma endregion

#pragma region RidingJumpUp
void CX2GUUser::RidingJumpUpStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_JumpUpState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingJumpUpStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_JumpUpState );
}

void CX2GUUser::RidingJumpUpEventProcess()
{
	if ( true == RidingPetSpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if( 0.0f >= m_PhysicParam.nowSpeed.y )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
	}
	else if( true == m_InputData.pureDoubleLeft || true == m_InputData.pureDoubleRight )
	{
		if ( NULL != m_ptrRidingPet && m_iAirDashCount < 1 )
		{
			if ( CX2RidingPet::RSM_AIR_DASH == m_ptrRidingPet->GetInfo().m_eSpecialMove || 
				 CX2RidingPet::RSM_PASS_DASH == m_ptrRidingPet->GetInfo().m_eSpecialMove )
					StateChange( USI_RIDING_SPECIAL_MOVE );
		}
	}

	if ( true == m_InputData.oneUp )
	{
		if ( NULL != m_ptrRidingPet && CX2RidingPet::RSM_DOUBLE_JUMP == m_ptrRidingPet->GetInfo().m_eSpecialMove && m_iDoubleJumpCount < 1 )
			StateChange( USI_RIDING_SPECIAL_MOVE );
	}

	if( true == m_InputData.oneDown )
	{
		m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed * 2;
		m_bDownForce = true;
	}

	CommonEventProcess();
}
#pragma endregion

#pragma region RidingJumpDown
void CX2GUUser::RidingJumpDownStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_JumpDownState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingJumpDownStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_JumpDownState );
}

void CX2GUUser::RidingJumpDownEventProcess()
{
	if( m_InputData.pureDoubleLeft == true || m_InputData.pureDoubleRight == true )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}

	if ( true == IsOnSomethingFuture() )
	{
		if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
		{
			if( m_InputData.pureLeft == true )
			{
				StateChangeDashIfPossible();
			}
			else if( m_InputData.pureRight == true )
			{
				StateChangeDashIfPossible();
			}
			else
			{
				StateChange( USI_RIDING_JUMP_LANDING );
			}
		}
		else
		StateChange( USI_RIDING_JUMP_LANDING );
		m_bDownForce = false;
	}
	else if ( true == RidingPetSpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if ( 0.0f <= m_PhysicParam.nowSpeed.y )
	{
		StateChange( USI_RIDING_JUMP_UP );
	}
	else if( true == m_InputData.pureDoubleLeft || true == m_InputData.pureDoubleRight )
	{
		if ( NULL != m_ptrRidingPet && m_iAirDashCount < 1 )
		{
			if ( CX2RidingPet::RSM_AIR_DASH == m_ptrRidingPet->GetInfo().m_eSpecialMove || 
				CX2RidingPet::RSM_PASS_DASH == m_ptrRidingPet->GetInfo().m_eSpecialMove )
				StateChange( USI_RIDING_SPECIAL_MOVE );
		}
	}
	if ( true == m_InputData.oneUp )
	{
		if ( NULL != m_ptrRidingPet && CX2RidingPet::RSM_DOUBLE_JUMP == m_ptrRidingPet->GetInfo().m_eSpecialMove && m_iDoubleJumpCount < 1 )
			StateChange( USI_RIDING_SPECIAL_MOVE );
	}

	if( true == m_InputData.oneDown )
	{
		m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed * 2;
		m_bDownForce = true;
	}

	CommonEventProcess();
}
#pragma endregion

#pragma region RidingJumpLanding
void CX2GUUser::RidingJumpLandingStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_JumpLandingState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingJumpLandingStart()
{
	CommonStateStart();
	CreateStepDust();

	if ( NULL != m_ptrRidingPet )
	{
		m_iAirDashCount = 0;
		m_iDoubleJumpCount = 0;
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_JumpLandingState );
	}
}

void CX2GUUser::RidingJumpLandingEventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	else if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
	{
		StateChange( USI_RIDING_WAIT );
	}
	else if ( true == RidingPetSpecialAttackEventProcess() )
	{
	}
	else if( true == m_InputData.pureDoubleRight || true == m_InputData.pureDoubleLeft )
	{
		StateChangeDashIfPossible();
	}
	else if( true == m_InputData.pureRight || true == m_InputData.pureLeft )
	{
		StateChange( USI_RIDING_WALK );
	}
	else if( true == m_InputData.pureUp )
	{
		StateChange( USI_RIDING_JUMP_UP );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
	}
	else if( true == m_InputData.oneDown &&
		true == g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS,
		&m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}	
#ifdef MODIFY_RIDING_PET_AWAKE
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE(USI_RIDING_HYPER_MODE);
#endif // MODIFY_RIDING_PET_AWAKE

	CommonEventProcess();
}
#pragma endregion

#pragma region RidingDash
void CX2GUUser::RidingDashStart()
{
	CommonStateStart();
	CreateStepDust();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_DashState );
}

void CX2GUUser::RidingDashEventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		if ( NULL != m_ptrRidingPet && m_iAirDashCount < 1 )
		{
			if ( CX2RidingPet::RSM_AIR_DASH == m_ptrRidingPet->GetInfo().m_eSpecialMove || 
				CX2RidingPet::RSM_PASS_DASH == m_ptrRidingPet->GetInfo().m_eSpecialMove )
				StateChange( USI_RIDING_SPECIAL_MOVE );
		}
		else
		{
			StateChange( USI_RIDING_DASH_JUMP );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	else if ( true == RidingPetSpecialAttackEventProcess() )
	{
	}
	else if( true == m_InputData.oneUp )
	{
		StateChange( USI_RIDING_DASH_JUMP );
		m_PhysicParam.nowSpeed.y = GetDashJumpSpeed();
	}
	else if( false == m_InputData.pureRight && false == m_InputData.pureLeft )
	{
		StateChange( USI_RIDING_DASH_END );
	}
	else if( m_InputData.pureRight == true && m_InputData.pureLeft == true )
	{
		StateChange( USI_RIDING_DASH_END );
	}
	else if( m_InputData.pureRight == true && m_FrameDataFuture.syncData.bIsRight == false )
	{
		StateChange( USI_RIDING_WALK );
	}
	else if( m_InputData.pureLeft == true && m_FrameDataFuture.syncData.bIsRight == true )
	{
		StateChange( USI_RIDING_WALK );
	}
	else if( true == m_InputData.oneDown && 
		true == g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS,
		&m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
	{
		StateChange( USI_RIDING_DASH_JUMP );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}

	if ( NULL != m_ptrRidingPet && CX2RidingPet::RSM_BOOST_DASH == m_ptrRidingPet->GetInfo().m_eSpecialMove &&
		1.0f <= m_FrameDataFuture.unitCondition.fStateTime )
	{
		StateChange( USI_RIDING_SPECIAL_MOVE );
	}
#ifdef MODIFY_RIDING_PET_AWAKE
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE(USI_RIDING_HYPER_MODE);
#endif // MODIFY_RIDING_PET_AWAKE

	CommonEventProcess();
}
#pragma endregion

#pragma region RidingDashEnd
void CX2GUUser::RidingDashEndStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_DashEndState );

	CommonStateStartFuture();
	m_PhysicParam.nowSpeed.x = GetDashSpeed();
	m_bApplyMotionOffset = false;
}

void CX2GUUser::RidingDashEndStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_DashEndState );
}



void CX2GUUser::RidingDashEndEventProcess()
{
	const float TRIGGER_TIME_FACTOR_DASH_ATTACK = 0.3f;

	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	else if ( true == RidingPetSpecialAttackEventProcess() )
	{
	}
	else if( true == m_InputData.pureDoubleRight || true == m_InputData.pureDoubleLeft )
	{
		StateChangeDashIfPossible();
	}
	else if( true == m_InputData.oneRight && true == m_FrameDataFuture.syncData.bIsRight )
	{
		StateChangeDashIfPossible();
	}
	else if( true == m_InputData.oneLeft && false == m_FrameDataFuture.syncData.bIsRight )
	{
		StateChangeDashIfPossible();
	}
	else if( true == m_InputData.pureRight || true == m_InputData.pureLeft )
	{
		StateChange( USI_RIDING_WALK );
	}
	else if( true == m_InputData.oneDown &&
		true == g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS,
		&m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.oneUp == true )
	{
		StateChange( USI_RIDING_JUMP_UP );
	}
	else if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
	{	
		StateChange( USI_RIDING_WAIT );
	}	
#ifdef MODIFY_RIDING_PET_AWAKE
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE(USI_RIDING_HYPER_MODE);
#endif // MODIFY_RIDING_PET_AWAKE

	CommonEventProcess();
}

void CX2GUUser::RidingDashEndFrameMove()
{
	if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && true == m_ptrRidingPet->GetXSkinAnimFuturePtr()->EventTimer( 0.4f ) )
	{
		CreateStepDust();
	}

	CommonFrameMove();
}
#pragma endregion

#pragma region RidingDashJump
void CX2GUUser::RidingDashJumpStartFuture()
{
#ifdef FIX_HIT_FLY_RIDING_PET_MOTION //김태환
	/// Now 에서 Future 로 이동
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_DashJumpUpState );
#endif //FIX_HIT_FLY_RIDING_PET_MOTION

	CommonStateStartFuture();

	const float MAGIC_NUMBER_MULTIPLY_GRAVITY_ACCEL = 1.2f;
	
	m_PhysicParam.fDownAccel		= m_PhysicParam.fGAccel * MAGIC_NUMBER_MULTIPLY_GRAVITY_ACCEL;
	m_bDownForce					= false;
}

void CX2GUUser::RidingDashJumpStart()
{
	CommonStateStart();

	if( GetMatrix().GetYPos() == m_FrameDataNow.unitCondition.landPosition.y )
		CreateStepDust();

#ifndef FIX_HIT_FLY_RIDING_PET_MOTION //김태환
	/// Now 에서 Future 로 이동
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_DashJumpUpState );
#endif //FIX_HIT_FLY_RIDING_PET_MOTION
}



void CX2GUUser::RidingDashJumpEventProcess()
{
	bool &bCanDashJump = m_FrameDataFuture.stateParam.bEventFlagList[0];

	if ( false == IsOnSomethingFuture() )
	{
		if( true == m_InputData.pureDoubleLeft || true == m_InputData.pureDoubleRight )
		{
			if ( NULL != m_ptrRidingPet && m_iAirDashCount < 1 )
			{
				if ( CX2RidingPet::RSM_AIR_DASH == m_ptrRidingPet->GetInfo().m_eSpecialMove || 
					 CX2RidingPet::RSM_PASS_DASH == m_ptrRidingPet->GetInfo().m_eSpecialMove )
						StateChange( USI_RIDING_SPECIAL_MOVE );
			}
		}
	}

	if( true == IsOnSomethingFuture() )
	{
		if ( true == m_bDownForce )
		{
			StateChange( USI_RIDING_DASH_JUMP_LANDING );
			m_bDownForce = false;
		}
		else
		{
			if( true == m_InputData.pureRight || true == m_InputData.pureLeft )
			{
				StateChangeDashIfPossible();
			}
			else
				StateChange( USI_RIDING_DASH_JUMP_LANDING );

			m_bDownForce = false;
		}
	}
	else if ( true == RidingPetSpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if( true == m_FrameDataFuture.unitCondition.bFootOnWall &&
		( true == m_InputData.oneUp || true == m_InputData.oneDoubleUp ) )
	{
		m_bDisableGravity = true;
		StateChange( USI_RIDING_DASH_JUMP_LANDING );
	}
	else if( true == m_InputData.pureRight )
	{
		if( false == m_FrameDataFuture.syncData.bIsRight )
		{
			if( GetJumpSpeed() < m_PhysicParam.nowSpeed.y )
				m_PhysicParam.nowSpeed.y = GetJumpSpeed();

			if( 0.0f < m_PhysicParam.nowSpeed.y )
				StateChange( USI_RIDING_JUMP_UP );
			else
				StateChange( USI_RIDING_JUMP_DOWN );
		}
	}
	else if( true == m_InputData.pureLeft )
	{
		if( true == m_FrameDataFuture.syncData.bIsRight )
		{
			if( GetJumpSpeed() < m_PhysicParam.nowSpeed.y )
				m_PhysicParam.nowSpeed.y = GetJumpSpeed();

			if( 0.0f < m_PhysicParam.nowSpeed.y )
				StateChange( USI_RIDING_JUMP_UP );
			else
				StateChange( USI_RIDING_JUMP_DOWN );
		}
	}

	if ( true == m_InputData.oneUp )
	{
		if ( NULL != m_ptrRidingPet && CX2RidingPet::RSM_DOUBLE_JUMP == m_ptrRidingPet->GetInfo().m_eSpecialMove && m_iDoubleJumpCount < 1 )
			StateChange( USI_RIDING_SPECIAL_MOVE );
	}
	
	if( true == m_InputData.oneUp  && 0.0f >= m_PhysicParam.nowSpeed.y  )
	{
		bCanDashJump = true;
	}
	if( true == m_InputData.oneDown )
	{
		m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed * 2;
		m_bDownForce = true;
		bCanDashJump = false;
	}

	CommonEventProcess();
}

void CX2GUUser::RidingDashJumpFrameMoveFuture()
{
	const float MAGIC_NUMBER_MULTIPLY_DASH_SPEED = 1.6f;

	if( true == m_InputData.pureRight && true == m_FrameDataNow.syncData.bIsRight )
	{
		m_PhysicParam.nowSpeed.x = GetDashSpeed() * MAGIC_NUMBER_MULTIPLY_DASH_SPEED;
	}
	else if( true == m_InputData.pureLeft && false == m_FrameDataNow.syncData.bIsRight )
	{
		m_PhysicParam.nowSpeed.x = GetDashSpeed() * MAGIC_NUMBER_MULTIPLY_DASH_SPEED;
	}

	CommonFrameMoveFuture();
}

void CX2GUUser::RidingDashJumpEndFuture()
{
	CommonStateEndFuture();
	m_PhysicParam.fDownAccel	= 0.0f;
}
#pragma endregion

#pragma region RidingDashJumpLanding
void CX2GUUser::RidingDashJumpLandingStart()
{
	CommonStateStart();
	CreateStepDust();

	if ( NULL != m_ptrRidingPet )
	{
		m_iAirDashCount = 0;
		m_iDoubleJumpCount = 0;
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_DashJumpLandingState );
	}
}

void CX2GUUser::RidingDashJumpLandingEventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	else if ( true == RidingPetSpecialAttackEventProcess() )
	{
	}
	else if( true == m_InputData.pureDoubleRight || true == m_InputData.pureDoubleLeft )
	{
		StateChangeDashIfPossible();
	}
	else if( true == m_InputData.oneRight && true == m_FrameDataFuture.syncData.bIsRight )
	{
		StateChangeDashIfPossible();
	}
	else if( true == m_InputData.oneLeft && false == m_FrameDataFuture.syncData.bIsRight )
	{
		StateChangeDashIfPossible();
	}
	else if( true == m_InputData.pureRight || true == m_InputData.pureLeft )
	{
		StateChangeDashIfPossible();
	}
	else if( true == m_InputData.pureUp )
	{
		StateChange( USI_RIDING_JUMP_UP );
	}
	else if( true == m_InputData.oneDown &&
		true == g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS,
		&m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}		
	else if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
	{
		StateChange( USI_RIDING_WAIT );
	}

	CommonEventProcess();
}
#pragma endregion

#pragma region RidingDamageFront
void CX2GUUser::RidingDamageFrontStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_DamageFrontState );

	CommonStateStartFuture();

#ifdef FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
	// 연속적으로 피격 받았을 때 스크립트 정보를 파싱하지 못하는 경우가 발생해서 처리 함.
	m_FrameDataFuture.stateParam.bLandConnect = false;
#endif // FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
}

void CX2GUUser::RidingDamageFrontStart()
{
	CommonStateStart();
	CreateStepDust();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_DamageFrontState );
}

void CX2GUUser::RidingDamageFrontEventProcess()
{
#ifdef FIX_HIT_FLY_RIDING_PET_MOTION // 김태환
	/// 공중 피격 후 땅에 닿기 전 까지 피격 끝 모션 그대로 떨어지도록 수정
	if( true == IsOnSomethingFuture() )
	{
		if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
		{	
			if ( false == GetRidingOn() )
				StateChange( USI_RIDING_OFF );
			else
				StateChange( USI_RIDING_WAIT );
		}
	}
#else //FIX_HIT_FLY_RIDING_PET_MOTION
#ifdef FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
	if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
#else
	float fGapFromUnitToLineMap = m_FrameDataFuture.syncData.position.y - m_FrameDataFuture.unitCondition.landPosition.y;
	const float ACCEPTABLE_GAP = 200.0f;

	if( ACCEPTABLE_GAP < fGapFromUnitToLineMap )
	{
		StateChange( USI_RIDING_DAMAGE_FRONT );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
#endif // FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
	{	
		if( false == IsOnSomethingFuture() )
		{
#ifdef FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
			StateChange( USI_RIDING_JUMP_DOWN );
#else
			StateChange( USI_RIDING_DAMAGE_FRONT );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
#endif // FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
		}
		else if ( false == GetRidingOn() )
		{
			StateChange( USI_RIDING_OFF );
		}
		else
			StateChange( USI_RIDING_WAIT );
	}
#ifdef FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
	else if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
	}
#endif // FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
#endif //FIX_HIT_FLY_RIDING_PET_MOTION

	CommonEventProcess();
}
#pragma endregion

#pragma region RidingDamageBack
void CX2GUUser::RidingDamageBackStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_DamageBackState );

	CommonStateStartFuture();
#ifdef FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
	// 연속적으로 피격 받았을 때 스크립트 정보를 파싱하지 못하는 경우가 발생해서 처리 함.
	m_FrameDataFuture.stateParam.bLandConnect = false;
#endif // FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
}

void CX2GUUser::RidingDamageBackStart()
{
	CommonStateStart();
	CreateStepDust();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_DamageBackState );
}

void CX2GUUser::RidingDamageBackEventProcess()
{
#ifdef FIX_HIT_FLY_RIDING_PET_MOTION // 김태환
	/// 공중 피격 후 땅에 닿기 전 까지 피격 끝 모션 그대로 떨어지도록 수정
	if( true == IsOnSomethingFuture() )
	{
		if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
		{	
			if ( false == GetRidingOn() )
				StateChange( USI_RIDING_OFF );
			else
				StateChange( USI_RIDING_WAIT );
		}
	}
#else //FIX_HIT_FLY_RIDING_PET_MOTION

#ifdef FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
	if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
#else
	float fGapFromUnitToLineMap = m_FrameDataFuture.syncData.position.y - m_FrameDataFuture.unitCondition.landPosition.y;
	const float ACCEPTABLE_GAP = 200.0f;


	if( ACCEPTABLE_GAP < fGapFromUnitToLineMap )
	{
		StateChange( USI_RIDING_DAMAGE_BACK );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
#endif // FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
	{	
		if( false == IsOnSomethingFuture() )
		{
#ifdef FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
			StateChange( USI_RIDING_JUMP_DOWN );
#else
			StateChange( USI_RIDING_DAMAGE_BACK );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
#endif // FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
		}
		else if ( false == GetRidingOn() )
		{
			StateChange( USI_RIDING_OFF );
		}
		else
			StateChange( USI_RIDING_WAIT );
	}
#ifdef FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
	else if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
	}
#endif // FIX_RIDING_PET_CONTINUOUS_DAMAGE_REACTION_AT_AIR
#endif //FIX_HIT_FLY_RIDING_PET_MOTION

	CommonEventProcess();
}
#pragma endregion

#pragma region RidingAttackZ
void CX2GUUser::RidingAttackZStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_AttackZState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingAttackZStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
	{
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_AttackZState );

		switch ( m_ptrRidingPet->GetInfo().m_Id )
		{
		case CX2RidingPetManager::RPUI_SCORPION_TYPE_R:
			{
				if ( HaveThisBuff( BTI_RIDING_SCORPION_ENERGY_SWORD ) )
					g_pX2Game->GetEffectSet()->PlayEffectSet( L"Riding_Nasod_Guardian_Special_Attack_Z", this );
				else
					g_pX2Game->GetEffectSet()->PlayEffectSet( L"Riding_Nasod_Guardian_Attack_Z", this );
			} break;
		
		default:
			break;
		}
	}
}

void CX2GUUser::RidingAttackZEventProcess()
{
	if ( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
	{
		StateChange( USI_RIDING_WAIT );
	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	RIDING_SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	RIDING_DASH_CANCEL_AFTER( m_fDashCancelAfter )
	RIDING_WALK_CANCEL_AFTER( m_fWalkCancelAfter )

	CommonEventProcess();
}
#pragma endregion

#pragma region RidingJumpAttackZ
void CX2GUUser::RidingJumpAttackZStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_JumpAttackZState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingJumpAttackZStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_JumpAttackZState );
}

void CX2GUUser::RidingJumpAttackZFrameMoveFuture()
{
	if( true == m_InputData.pureDown && false == m_InputData.pureUp )
	{
		m_PhysicParam.nowSpeed.y -= m_PhysicParam.fGAccel * m_fElapsedTime;
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}

	CommonFrameMoveFuture();
}

void CX2GUUser::RidingJumpAttackZEventProcess()
{
	if ( true == IsOnSomethingFuture() )
	{
		bool &bPureDown = m_FrameDataFuture.stateParam.bEventFlagList[0];

		if ( true == bPureDown )
		{
			m_fCanNotJumpTime = 0.2f;
		}

		StateChange( USI_RIDING_JUMP_LANDING );
	}

	CommonEventProcess();
}
#pragma endregion

#pragma region RidingAttackX
void CX2GUUser::RidingAttackXStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_AttackXState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingAttackXStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_AttackXState );
}

void CX2GUUser::RidingAttackXEventProcess()
{
	if ( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
	{
		StateChange( USI_RIDING_WAIT );
	}

// 	if ( false == IsOnSomethingFuture() )
// 	{
// 		StateChange( USI_RIDING_JUMP_DOWN );
// 		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
// 	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	RIDING_SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	RIDING_DASH_CANCEL_AFTER( m_fDashCancelAfter )
	RIDING_WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	

	CommonEventProcess();
}
#pragma endregion

#pragma region RidingSpecialAttack
void CX2GUUser::RidingSpecialAttackStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_SpecialAttackState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingSpecialAttackStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_SpecialAttackState );

	TRACE( L"RidingSpecialAttack Start\n" );
}

void CX2GUUser::RidingSpecialAttackFrameMove()
{
	if ( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimPtr() )
	{
		switch ( m_ptrRidingPet->GetInfo().m_Id )
		{
		case CX2RidingPetManager::RPUI_SCORPION_TYPE_R:
			{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                if( m_ptrRidingPet->GetXSkinAnimPtr()->EventTimerOneshot( 1.000f ) == true  )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				if( m_ptrRidingPet->GetXSkinAnimPtr()->EventTimer( 1.000f ) == true && EventCheck( 1.000f, false ) == true  )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
					SetBuffFactorToGameUnitByBuffFactorID( static_cast<UINT>( BFI_RIDING_SCORPION_ENERGY_SWORD ) );
			} break;

		default:
			break;
		}
	}

	CommonFrameMove();
}

void CX2GUUser::RidingSpecialAttackEventProcess()
{
	if ( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
	{
		StateChange( USI_RIDING_WAIT );
		TRACE( L"RidingSpecialAttack Wait\n" );
	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	RIDING_SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	RIDING_DASH_CANCEL_AFTER( m_fDashCancelAfter )
	RIDING_WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	
	CommonEventProcess();
}
#pragma endregion

#pragma region RidingWaitHabit
void CX2GUUser::RidingWaitHabitStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_WaitHabitState );

	CommonStateStartFuture();
}

void CX2GUUser::RidingWaitHabitStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
	{
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_WaitHabitState );
		m_ElapsedTimeRidingWaitHabit.ResetSumOfElapsedTime();
		m_ElapsedTimeRidingWaitHabit.SetTargetTime( static_cast<float>( GetRandomInt() % 6 + 3 ) );
	}
}

void CX2GUUser::RidingWaitHabitEventProcess()
{
	if ( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() && m_ptrRidingPet->GetXSkinAnimFuturePtr()->IsAnimationEnd() )
	{
		StateChange( USI_RIDING_WAIT );
	}
	else if ( false == IsOnSomethingFuture() )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( false == GetRidingOn() )
	{
		StateChange( USI_RIDING_OFF );
	}
	else if ( true == RidingPetSpecialAttackEventProcess() )
	{}
	else if ( true == m_InputData.pureDoubleRight || true == m_InputData.pureDoubleLeft )
	{
		StateChangeDashIfPossible();
	}
	else if ( true == m_InputData.pureRight || true == m_InputData.pureLeft )
	{
		StateChange( USI_RIDING_WALK );
	}
	else if ( true == m_InputData.pureUp )	// 점프
	{
		StateChange( USI_RIDING_JUMP_UP );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS + 60.f;
	}
	else if( true == m_InputData.oneDown &&	
		true == g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS,
		&m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
	{
		StateChange( USI_RIDING_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	
	CommonEventProcess();
}
#pragma endregion

#pragma region RidingSpecialMove
void CX2GUUser::RidingSpecialMoveStartFuture()
{
	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChangeFuture( m_ptrRidingPet->m_SpecialMoveState );

	CommonStateStartFuture();

	if ( NULL != m_ptrRidingPet )
	{
		switch ( m_ptrRidingPet->GetInfo().m_eSpecialMove )
		{
		case CX2RidingPet::RSM_AIR_DASH:
			{
				m_bDownForce = false;
				m_bDisableGravity = true;
				m_fAirDashTime = 0.f;
				++m_iAirDashCount;
			} break;
		case CX2RidingPet::RSM_PASS_DASH:
			{
				m_bDownForce = false;
				m_bDisableGravity = true;
				m_fAirDashTime = 0.f;
				++m_iAirDashCount;
				m_FrameDataFuture.stateParam.bCanPassUnit = true;
			} break;
		case CX2RidingPet::RSM_BOOST_DASH:
			m_iRidingBoost = 0;
			break;
		case CX2RidingPet::RSM_DOUBLE_JUMP:
			++m_iDoubleJumpCount;
			break;
		default:
			break;
		}
	}
}

void CX2GUUser::RidingSpecialMoveStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
	{
		// 파티클 처리
		CX2EffectSet::Handle hEffectSetInst = INVALID_EFFECTSET_HANDLE;

		switch ( m_ptrRidingPet->GetInfo().m_eSpecialMove )
		{
		case CX2RidingPet::RSM_AIR_DASH:
			break;

		case CX2RidingPet::RSM_PASS_DASH:
			{
				hEffectSetInst = g_pX2Game->GetEffectSet()->PlayEffectSet( L"Riding_N_G_DashJump", this );
				m_vecEffectSetToDeleteOnStateEnd.push_back( hEffectSetInst );

				SetAlphaObject( true );

				if ( false == IsMyUnit() && false == IsNullGageUI() )
					m_pGageUI->SetAlpha( 0.0f );

				m_RenderParam.renderType	= CKTDGXRenderer::RT_CARTOON;
				m_RenderParam.bAlphaBlend	= true;
				m_RenderParam.color.a		= 0.5f;
				m_bPassDash = true;
//#ifdef  X2OPTIMIZE_USER_PASS_PUSH_UNIT_TIME_BUG_FIX
                m_FrameDataNow.stateParam.bCanPassUnit = true;
//#endif  X2OPTIMIZE_USER_PASS_PUSH_UNIT_TIME_BUG_FIX
			} break;

		case CX2RidingPet::RSM_BOOST_DASH:
			{
				hEffectSetInst = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Riding_Mobi_Booster", this );
				m_vecEffectSetToDeleteOnStateEnd.push_back( hEffectSetInst );
			} break;

		case CX2RidingPet::RSM_DOUBLE_JUMP:
			{
				m_PhysicParam.nowSpeed.y = GetJumpSpeed() * 0.9f;
			} break;

		default:
			break;
		}

		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_SpecialMoveState );
	}
}

void CX2GUUser::RidingSpecialMoveFrameMoveFuture()
{
	if ( NULL != m_ptrRidingPet )
	{
		switch ( m_ptrRidingPet->GetInfo().m_eSpecialMove )
		{
		case CX2RidingPet::RSM_AIR_DASH:
		case CX2RidingPet::RSM_PASS_DASH:
			{
				m_fAirDashTime += m_fElapsedTime;

				if( false == m_InputData.pureDown && true == m_InputData.pureRight && true == m_FrameDataNow.syncData.bIsRight )
				{
					m_PhysicParam.nowSpeed.x = m_PhysicParam.passiveSpeed.x;
					m_PhysicParam.nowSpeed.y = max( 200.f - ( m_fAirDashTime * 500), -1200.f );
				}
				else if( false == m_InputData.pureDown && true == m_InputData.pureLeft && false == m_FrameDataNow.syncData.bIsRight )
				{
					m_PhysicParam.nowSpeed.x = m_PhysicParam.passiveSpeed.x;
					m_PhysicParam.nowSpeed.y = max( 200.f - ( m_fAirDashTime * 500), -1200.f );
				}
				else
				{
					StateChange( USI_RIDING_DASH_JUMP );
				}
			}
			break;
		case CX2RidingPet::RSM_BOOST_DASH:
			{
				if( ( true == m_InputData.pureRight && true == m_BeforeInputData.pureRight ) ||
					( true == m_InputData.pureLeft  && true == m_BeforeInputData.pureLeft  ) )
				{
					switch ( m_iRidingBoost )
					{
					case 1:
						m_PhysicParam.nowSpeed.x = GetDashSpeed() + GetDashSpeed() * 0.1f;
						break;
					case 2:
						m_PhysicParam.nowSpeed.x = GetDashSpeed() + GetDashSpeed() * 0.2f;
						break;
					case 3:
						m_PhysicParam.nowSpeed.x = GetDashSpeed() + GetDashSpeed() * 0.3f;
						break;
					default:
						m_PhysicParam.nowSpeed.x = GetDashSpeed();
						break;
					}
				}
			} break;
		case CX2RidingPet::RSM_DOUBLE_JUMP:
			break;
		default:
			break;
		}
	}

	CommonFrameMoveFuture();
}

void CX2GUUser::RidingSpecialMoveFrameMove()
{
	CommonFrameMove();
}

void CX2GUUser::RidingSpecialMoveEventProcess()
{
	if ( NULL != m_ptrRidingPet )
	{
		switch ( m_ptrRidingPet->GetInfo().m_eSpecialMove )
		{
		case CX2RidingPet::RSM_AIR_DASH:
		case CX2RidingPet::RSM_PASS_DASH:
			{
				if( true == IsOnSomethingFuture() )
				{
					if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
					{
						StateChange( USI_RIDING_DASH_JUMP );
						m_PhysicParam.nowSpeed.y = GetDashJumpSpeed();
						m_bDownForce = false;
					}
					else
					{
						StateChange( USI_RIDING_DASH );
						m_bDownForce = false;
					}
				}
				else if ( false == GetRidingOn() )
				{
					StateChange( USI_RIDING_OFF );
				}
				else if ( true == RidingPetSpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
				{}
				if( m_InputData.oneUp == true && m_PhysicParam.nowSpeed.y <= 0.0f )
				{
					m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
				}
				if( m_InputData.oneDown == true )
				{
					m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed;
					m_bDownForce = true;
					m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
				}
			}
			break;
		case CX2RidingPet::RSM_BOOST_DASH:
			{
				if ( false == IsOnSomethingFuture() )
				{
					StateChange( USI_RIDING_DASH_JUMP );
					m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
				}
				else if ( false == GetRidingOn() )
				{
					StateChange( USI_RIDING_OFF );
				}
				else if ( true == RidingPetSpecialAttackEventProcess() )
				{}
				else if ( true == m_InputData.oneUp )
				{
					StateChange( USI_RIDING_DASH_JUMP );
					m_PhysicParam.nowSpeed.y = GetDashJumpSpeed();
				}
				else if( m_InputData.pureRight == false && m_InputData.pureLeft == false )
				{
					StateChange( USI_RIDING_DASH_END );
				}
				else if( m_InputData.pureRight == true && m_InputData.pureLeft == true )
				{
					StateChange( USI_RIDING_DASH_END );
				}
				else if( m_InputData.pureRight == true && m_FrameDataFuture.syncData.bIsRight == false )
				{
					StateChange( USI_RIDING_WALK );
				}
				else if( m_InputData.pureLeft == true && m_FrameDataFuture.syncData.bIsRight == true )
				{
					StateChange( USI_RIDING_WALK );
				}
				else if( true == m_InputData.oneDown &&	
					true == g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS,
					&m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) )
				{
					StateChange( USI_RIDING_JUMP_DOWN );
					m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
				}

				if ( 1.f <= m_FrameDataFuture.unitCondition.fStateTime && 0 == m_iRidingBoost )
				{
					++m_iRidingBoost;
					CX2EffectSet::Handle hEffectSetInst = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Riding_Mobi_Booster", this );
					m_vecEffectSetToDeleteOnStateEnd.push_back( hEffectSetInst );
				}
				else if ( 2.f <= m_FrameDataFuture.unitCondition.fStateTime && 1 == m_iRidingBoost )
				{
					++m_iRidingBoost;
					CX2EffectSet::Handle hEffectSetInst = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Riding_Mobi_Booster", this );
					m_vecEffectSetToDeleteOnStateEnd.push_back( hEffectSetInst );
				}
				else if ( 3.f <= m_FrameDataFuture.unitCondition.fStateTime && 2 == m_iRidingBoost )
				{
					++m_iRidingBoost;
				}
			}
			break;
		case CX2RidingPet::RSM_DOUBLE_JUMP:
			{
				if ( true == RidingPetSpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
				{}
				else if ( true == IsOnSomethingFuture() )
				{
					StateChange( USI_RIDING_JUMP_LANDING );
				}
				else
				{
					if( m_InputData.pureRight == true )
					{
						m_FrameDataFuture.syncData.bIsRight = true;
						m_PhysicParam.nowSpeed.x = GetWalkSpeed();
					}
					else if( m_InputData.pureLeft == true )
					{
						m_FrameDataFuture.syncData.bIsRight = false;
						m_PhysicParam.nowSpeed.x = GetWalkSpeed();
					}
				}

				if( true == m_InputData.oneDown )
				{
					m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed * 2;
					m_bDownForce = true;
				}
			} break;
		default:
			break;
		}
	}

	CommonEventProcess();
}

void CX2GUUser::RidingSpecialMoveEndFutrue()
{
	CommonStateEndFuture();

	if ( NULL != m_ptrRidingPet )
	{
		switch ( m_ptrRidingPet->GetInfo().m_eSpecialMove )
		{
		case CX2RidingPet::RSM_AIR_DASH:
		case CX2RidingPet::RSM_PASS_DASH:
			m_bDisableGravity = false;
			m_fAirDashTime = 0.f;
			m_iAirDashCount = 0;
			break;
		case CX2RidingPet::RSM_DOUBLE_JUMP:
			break;
		default:
			break;
		}
	}
}

void CX2GUUser::RidingSpecialMoveEnd()
{
	CommonStateEnd();

	if ( NULL != m_ptrRidingPet )
	{
		switch ( m_ptrRidingPet->GetInfo().m_eSpecialMove )
		{
		case CX2RidingPet::RSM_BOOST_DASH:
			m_PhysicParam.nowSpeed.x = GetDashSpeed();
			break;

		case CX2RidingPet::RSM_DOUBLE_JUMP:
			break;

		case CX2RidingPet::RSM_PASS_DASH:
			{
				SetAlphaObject( false );
				if ( false == IsMyUnit() && false == IsNullGageUI() )
					m_pGageUI->SetAlpha( 255.0f );

				m_RenderParam.bAlphaBlend	= false;
				m_RenderParam.color.a		= 1.f;
				m_bPassDash = false;
			} break;

		default:
			break;
		}
	}
}
#pragma endregion 

void CX2GUUser::ProcessRidingOn( IN bool bVal_, IN const KRidingPetInfo& _Info )
{
	if ( NULL != CX2RidingPetManager::GetInstance() )
	{		
		if ( true == bVal_ )
		{
			m_ptrRidingPet 
				= CX2RidingPetManager::GetInstance()->CreateGameRidingPet( GetUnitUID(), _Info );

			// 탑승 버프
			//// 버프의 정보를 얻어오기 위해서 라이딩펫의 템플릿을 가져옴
			CX2RidingPetManager::RidingPetTemplet* pMyRidingPetTemplet
				= CX2RidingPetManager::GetInstance()->GetRidingPetTemplet( static_cast<CX2RidingPetManager::RIDING_PET_UNIT_ID>( _Info.m_usRindingPetID ) );

			/// 라이딩 펫 버프 적용
			if ( NULL != pMyRidingPetTemplet )
			{				
				BOOST_FOREACH( const CX2RidingPetManager::RidingPetBuffInfo& buffInfo, pMyRidingPetTemplet->m_vecBuff )
				{
					/// 버프가 지정되어 있으면 적용
					if ( buffInfo.m_eBuffFactorID != BFI_NONE )
						SetBuffFactorToGameUnitByBuffFactorID( buffInfo.m_eBuffFactorID );
				}					
			}

			if( GetNowHp() > 0 )
			{
				if( false == IsOnSomethingFuture() )
					StateChange( USI_JUMP_DOWN, true );
				else
					StateChange( USI_WAIT, true );
			}
		}
		else
		{
			SetRidingOn( bVal_ );
			if( GetNowHp() > 0 )
			{
				StateChange( USI_RIDING_OFF, true );
			}

			CX2RidingPetManager::GetInstance()->RemoveRidingPet( GetUnitUID() );
		}
		
		/// 내 유닛인 경우에만 처리
		if ( IsMyUnit() && NULL != g_pData->GetUIManager() )
		{
			g_pData->GetUIManager()->SetShowSkillSlot( !bVal_ );
			g_pData->GetUIManager()->SetShowRidingPetSkillSlot( bVal_ );
		}

		/// 펫을 타고 내릴 때 소켓 옵션 재 계산
		UpdateSocketDataAndEnchantData();
#ifdef UPDATE_PASSIVE_AND_ACTIVE_SKILL_STATE_WHEN_RIDING
		UpdatePassiveAndActiveSkillState();
#endif //UPDATE_PASSIVE_AND_ACTIVE_SKILL_STATE_WHEN_RIDING
	}
}

bool CX2GUUser::RidingPetSpecialAttackEventProcess( CX2SkillTree::ACTIVE_SKILL_USE_CONDITION eActiveSkillUseCondition /*= CX2SkillTree::ASUT_GROUND*/ )
{
	if ( NULL == CX2RidingPetManager::GetInstance() || NULL == m_ptrRidingPet )
		return false;

	CX2RidingPetManager* pRidingPetManager = CX2RidingPetManager::GetInstance();

	CX2RidingPetManager::RidingPetTemplet* pRidingPetTemplet = pRidingPetManager->GetRidingPetTemplet( 
		static_cast<CX2RidingPetManager::RIDING_PET_UNIT_ID>( m_ptrRidingPet->GetInfo().m_Id ) );

	if ( NULL == pRidingPetTemplet )
		return false;

	if( true == IsThereEffectiveBlackHoleDamageEffect() )
		return false;

	if( true == m_bSpecialAttackEventProcessedAtThisFrame )
		return false;

	UINT iSkillNum = -1;
	float fMPConsume = 0.f;
	float fCoolTime = 0.f;

	if( true == m_InputData.oneZ )
	{
		iSkillNum = 0;
		fMPConsume = pRidingPetTemplet->m_vecAttackSkill.at(0).m_fConsumeMana;
	}
	else if( true == m_InputData.oneX && CX2SkillTree::ASUT_GROUND == eActiveSkillUseCondition )	/// X 공격은 무조건 땅에서만 동작한다.
	{
		iSkillNum = 1;
		fMPConsume = pRidingPetTemplet->m_vecAttackSkill.at(1).m_fConsumeMana;
	}
	else if( true == m_InputData.oneC && CX2SkillTree::ASUT_GROUND == eActiveSkillUseCondition )	/// C 공격은 무조건 땅에서만 동작한다.
	{
		iSkillNum = 2;
		fMPConsume = pRidingPetTemplet->m_vecAttackSkill.at(2).m_fConsumeMana;
	}
	else
	{
		return false;
	}

	fCoolTime = pRidingPetManager->GetSkillSlot()->GetSkillCoolTime( iSkillNum );

#ifdef _IN_HOUSE_
	if( false == g_pMain->IsMyAuthLevelHigherThan( CX2User::XUAL_DEV ) )
#endif //_IN_HOUSE_
	{
		if( 0.f < fCoolTime )
		{
#ifdef ALWAYS_SCREEN_SHOT_TEST
			if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() == true)
			{
				return false;
			}
#endif ALWAYS_SCREEN_SHOT_TEST
			g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_226 ), D3DXCOLOR(1,1,1,1),
				D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
			return false;
		}

		if ( GetNowMp() < fMPConsume )
		{
#ifdef ALWAYS_SCREEN_SHOT_TEST
			if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() == true)
			{
				return false;
			}
#endif ALWAYS_SCREEN_SHOT_TEST
			g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_2549 ), D3DXCOLOR(1,1,1,1),
				D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
			return false;
		}
	}

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	/// 스킬창에서 스킬 습득중이면, 스킬 사용 불가
	if (	NULL != g_pData &&
			NULL != g_pData->GetUIManager() &&
			NULL != g_pData->GetUIManager()->GetUISkillTree() &&
			true == g_pData->GetUIManager()->GetUISkillTree()->GetNowLearnSkill() )
	{
#ifdef ALWAYS_SCREEN_SHOT_TEST
		if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() == true)
		{
			return false;
		}
#endif ALWAYS_SCREEN_SHOT_TEST
		g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_25110 ), D3DXCOLOR(1,1,1,1),
			D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
		return false;
	}
#endif // UPGRADE_SKILL_SYSTEM_2013

	UpNowMp( -fMPConsume );

	switch ( iSkillNum )
	{
	case 0:
		pRidingPetManager->GetSkillSlot()->SetSkillSlotCoolTime( iSkillNum, pRidingPetTemplet->m_vecAttackSkill.at(0).m_fCoolTime );
		pRidingPetManager->GetSkillSlot()->SetBlindSkillSlot( iSkillNum, true );

		/// 일반 Z 공격은 어느 상황에서 발동 되었는가에 따라서, 달라진다.
		if ( CX2SkillTree::ASUT_AIR == eActiveSkillUseCondition )
			StateChange( USI_RIDING_JUMP_ATTACK_Z );	/// 점프 Z 공격
		else
			StateChange( USI_RIDING_ATTACK_Z );			/// 일반 Z 공격

		if ( pRidingPetTemplet->m_vecAttackSkill.at(0).m_fCoolTime <= 0.f )
			pRidingPetManager->GetSkillSlot()->SetBlindSkillSlot( iSkillNum, false );
		break;

	case 1:
		pRidingPetManager->GetSkillSlot()->SetSkillSlotCoolTime( iSkillNum, pRidingPetTemplet->m_vecAttackSkill.at(1).m_fCoolTime );
		pRidingPetManager->GetSkillSlot()->SetBlindSkillSlot( iSkillNum, true );
		StateChange( USI_RIDING_ATTACK_X );
		if ( pRidingPetTemplet->m_vecAttackSkill.at(1).m_fCoolTime <= 0.f )
			pRidingPetManager->GetSkillSlot()->SetBlindSkillSlot( iSkillNum, false );
		break;

	case 2:
		pRidingPetManager->GetSkillSlot()->SetSkillSlotCoolTime( iSkillNum, pRidingPetTemplet->m_vecAttackSkill.at(2).m_fCoolTime );
		pRidingPetManager->GetSkillSlot()->SetBlindSkillSlot( iSkillNum, true );
		StateChange( USI_RIDING_SPECIAL_ATTACK );
		if ( pRidingPetTemplet->m_vecAttackSkill.at(2).m_fCoolTime <= 0.f )
			pRidingPetManager->GetSkillSlot()->SetBlindSkillSlot( iSkillNum, false );
		break;

	default:
		return false;
	}

	return true;
}

/*virtual*/ bool CX2GUUser::CanRidingState()
{
	if ( GetNowStateID() == CX2GUUser::USI_WAIT || GetNowStateID() == CX2GUUser::USI_WALK || 
		 GetNowStateID() == CX2GUUser::USI_DASH || GetNowStateID() == CX2GUUser::USI_DASH_END || 
		 GetNowStateID() == CX2GUUser::USI_RIDING_WAIT || GetNowStateID() == CX2GUUser::USI_RIDING_WALK ||
		 GetNowStateID() == CX2GUUser::USI_RIDING_WAIT_HABIT || GetNowStateID() == CX2GUUser::USI_RIDING_DASH ||
		 GetNowStateID() == CX2GUUser::USI_RIDING_DASH_END )
		return true;

	return false;
}
#endif //RIDING_SYSTEM


void CX2GUUser::StopTime_StateStart()
{
#ifdef REMOVE_TIME_STOP_EXCEPT_PVP
	if( NULL == g_pX2Game || CX2Game::GT_PVP != g_pX2Game->GetGameType() )
		return;
#endif //REMOVE_TIME_STOP_EXCEPT_PVP

	int index = 0;
	if( IsMyUnit() == false )
	{
		m_StopAllList.clear();
		while( m_LuaManager.BeginTable( "STOP_ALL_UNIT", index ) == true )
		{
			D3DXVECTOR3 stopTime;
			LUA_GET_VALUE( m_LuaManager, 1, stopTime.x, -1.0f );
			LUA_GET_VALUE( m_LuaManager, 2, stopTime.y, -1.0f );
			LUA_GET_VALUE( m_LuaManager, 3, stopTime.z, -1.0f );
			if( stopTime.x != -1.0f )
			{
				stopTime.x -= g_pKTDXApp->GetElapsedTime() * (m_FrameBufferNum-1);
				if( stopTime.x <= g_pKTDXApp->GetElapsedTime() )
				{
					switch ( g_pX2Game->GetGameType() )
					{
					case CX2Game::GT_DUNGEON:
					case CX2Game::GT_BATTLE_FIELD:
						{
							g_pX2Game->StopAllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 800.0f, this, stopTime.z );
							g_pX2Game->StopAllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 700.0f, this, stopTime.z );
						} break;

					case CX2Game::GT_PVP:
						{
							g_pX2Game->StopAllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 2000.0f, this, stopTime.z );
							g_pX2Game->StopAllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 1300.0f, this, stopTime.z );
						} break;

					default:
						ASSERT( !L"wrong path" );
						break;
					}
				}
				else
					m_StopAllList.push_back( stopTime );
			}

			index++;
			m_LuaManager.EndTable();
		}

		index = 0;
		m_Stop2AllList.clear();
		while( m_LuaManager.BeginTable( "STOP2_ALL_UNIT", index ) == true )
		{
			D3DXVECTOR3 stopTime;
			LUA_GET_VALUE( m_LuaManager, 1, stopTime.x, -1.0f );
			LUA_GET_VALUE( m_LuaManager, 2, stopTime.y, -1.0f );
			LUA_GET_VALUE( m_LuaManager, 3, stopTime.z, -1.0f );
			if( stopTime.x != -1.0f )
			{
				stopTime.x -= g_pKTDXApp->GetElapsedTime() * (m_FrameBufferNum-1);
				if( stopTime.x <= g_pKTDXApp->GetElapsedTime() )
				{
					switch ( g_pX2Game->GetGameType() )
					{
					case CX2Game::GT_DUNGEON:
					case CX2Game::GT_BATTLE_FIELD:
						{
							g_pX2Game->Stop2AllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 800.0f, this, stopTime.z );
							g_pX2Game->Stop2AllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 700.0f, this, stopTime.z );
						} break;

					case CX2Game::GT_PVP:
						{
							g_pX2Game->Stop2AllUnit( stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 2000.0f, this, stopTime.z );
							g_pX2Game->Stop2AllUnit( stopTime.y, &m_FrameDataNow.syncData.position, 1300.0f, this, stopTime.z );
						} break;

					default:
						ASSERT( !L"wrong path" );
						break;
					}
				}
				else
					m_Stop2AllList.push_back( stopTime );
			}
			index++;
			m_LuaManager.EndTable();
		}
	}
	index = 0;
	m_StopOtherList.clear();
	while( m_LuaManager.BeginTable( "STOP_OTHER_UNIT", index ) == true )
	{
		D3DXVECTOR2 stopTime;
		LUA_GET_VALUE( m_LuaManager, 1, stopTime.x, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 2, stopTime.y, -1.0f );
		if( stopTime.x != -1.0f )
		{
			stopTime.x -= g_pKTDXApp->GetElapsedTime() * (m_FrameBufferNum-1);
			if( stopTime.x <= g_pKTDXApp->GetElapsedTime() )
			{
				switch ( g_pX2Game->GetGameType() )
				{
				case CX2Game::GT_DUNGEON:
				case CX2Game::GT_BATTLE_FIELD:
					{
						g_pX2Game->StopOtherUnit( this, stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 800.0f );
						g_pX2Game->StopOtherUnit( this, stopTime.y, &m_FrameDataNow.syncData.position, 700.0f );
					} break;

				case CX2Game::GT_PVP:
					{
						g_pX2Game->StopOtherUnit( this, stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 2000.0f );
						g_pX2Game->StopOtherUnit( this, stopTime.y, &m_FrameDataNow.syncData.position, 1300.0f );
					} break;

				default:
					ASSERT( !L"wrong path" );
					break;
				}
			}
			else
				m_StopOtherList.push_back( stopTime );
		}

		index++;
		m_LuaManager.EndTable();
	}

	index = 0;
	m_Stop2OtherList.clear();
	while( m_LuaManager.BeginTable( "STOP2_OTHER_UNIT", index ) == true )
	{
		D3DXVECTOR2 stopTime;
		LUA_GET_VALUE( m_LuaManager, 1, stopTime.x, -1.0f );
		LUA_GET_VALUE( m_LuaManager, 2, stopTime.y, -1.0f );
		if( stopTime.x != -1.0f )
		{
			stopTime.x -= g_pKTDXApp->GetElapsedTime() * (m_FrameBufferNum-1);
			if( stopTime.x <= g_pKTDXApp->GetElapsedTime() )
			{
				switch ( g_pX2Game->GetGameType() )
				{
				case CX2Game::GT_DUNGEON:
				case CX2Game::GT_BATTLE_FIELD:
					{
						g_pX2Game->Stop2OtherUnit( this, stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 800.f );
						g_pX2Game->Stop2OtherUnit( this, stopTime.y, &m_FrameDataNow.syncData.position, 700.0f );
					} break;

				case CX2Game::GT_PVP:
					{
						g_pX2Game->Stop2OtherUnit( this, stopTime.y / 2.0f, &m_FrameDataNow.syncData.position, 2000.0f );
						g_pX2Game->Stop2OtherUnit( this, stopTime.y, &m_FrameDataNow.syncData.position, 1300.0f );
					} break;

				default:
					ASSERT( !L"wrong path" );
					break;
				}
			}
			else
				m_Stop2OtherList.push_back( stopTime );
		}

		index++;
		m_LuaManager.EndTable();
	}	
}
int CX2GUUser::GetMyUnitSkillLevel( const CX2SkillTree::SKILL_ID eSkillID_ )
{
	if( NULL == GetUnit()  )
		return 0;

	return GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( eSkillID_ );
}

#ifdef SERV_SKILL_USE_SUBQUEST
void CX2GUUser::Send_SKILL_USE_REQ( CX2SkillTree::SKILL_ID eSkillID )
{
	// 스킬 사용 카운트는 던전, 대전, 배틀필드 에서만 by 박진웅
	if( CX2Main::XS_DUNGEON_GAME != g_pMain->GetNowStateID() &&
		CX2Main::XS_PVP_GAME != g_pMain->GetNowStateID() &&
		CX2Main::XS_BATTLE_FIELD != g_pMain->GetNowStateID() )
		return;

	// 해당 스킬 서브퀘스트가 있을 경우에만 보낼까?
	if( false == g_pData->GetQuestManager()->HasSkillUseSubQuest( static_cast< int >( eSkillID ) ) )
		return;

	KEGS_SKILL_USE_REQ kPacket;
	kPacket.m_iSkillID		= (int)eSkillID;

	g_pData->GetServerProtocol()->SendPacket( EGS_SKILL_USE_REQ, kPacket );
	//g_pMain->AddServerPacket( EGS_SKILL_USE_ACK, 60.f );
}
#endif SERV_SKILL_USE_SUBQUEST

#ifdef FIX_FORCE_DOWN_AND_DETONATION_BUG
void CX2GUUser::ForceDownAndDetonationProcess()
{
	switch ( m_NowStateData.stateID )
	{
	case USI_DAMAGE_DOWN_FRONT:
	case USI_DAMAGE_DOWN_BACK:
	case USI_DAMAGE_AIR_DOWN_INVINCIBLE:
#ifdef RIDING_SYSTEM
	case USI_RIDING_DAMAGE_FRONT:
	case USI_RIDING_DAMAGE_BACK:
#endif //RIDING_SYSTEM
		{
			bool bApplyForceDownORDetonation = false; 
			if( true == m_pGageData->UpdateDamageFlushMP() )
			{
				bApplyForceDownORDetonation = true;
			}

			if( true == m_pGageData->UpdateFlushForceDown() )
			{
				bApplyForceDownORDetonation = true;
			}

			// 기폭, 다운수치 둘 중 하나라도 적용 되었다면
			// 상태이상 초기화시키고 넘어지도록 하기
			if( true == bApplyForceDownORDetonation ) 
			{
				m_vecStunPtr.clear();
				m_vecFreezePtr.clear();
				m_ExtraDamagePack.m_Stun.Init();
				SetChangeGroggyState(false);
			}
			
		} break;
	default:
		break;
	}
}
#endif //FIX_FORCE_DOWN_AND_DETONATION_BUG

/*virtual*/void CX2GUUser::DamageDataChangeProcess()
{
	if( -1.f == m_fCommonDamageChangeTime )
		return;

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( true == m_pXSkinAnim->EventTimerOneshot( m_fCommonDamageChangeTime ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( true == m_pXSkinAnim->EventTimer( m_fCommonDamageChangeTime ) && true == EventCheck( m_fCommonDamageChangeTime, false ) )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		bool bTableOpen = m_LuaManager.BeginTableByReference( m_NowStateData.stateID );

		if ( true == bTableOpen )
		{
			m_DamageData.SimpleInit();
			m_DamageData.attackerType			= CX2DamageManager::AT_UNIT;
			m_DamageData.optrAttackerGameUnit	= this;
#ifndef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	        m_DamageData.pAttackerEffect		= NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#ifdef ADD_MEMO_1ST_CLASS //김창한
			if( m_bApplyMemo == true )
			{
				if( false == SetDamageData( "DAMAGE_DATA_NEXT_MEMO", m_bApplyMemo ) )
				{
					SetDamageData( "DAMAGE_DATA_NEXT" );
				}
			}
			else
#endif //ADD_MEMO_1ST_CLASS
			SetDamageData( "DAMAGE_DATA_NEXT" );
			m_LuaManager.EndTable();		
		}
	}
}
#ifdef INSERT_BUFF_FACTOR_BY_SCPRIPT_STATE
/** @function : ParsingBuffFactorID
	@brief : 스크립트에서 지정한 스테이트의, 지정한 시간에
		     자기자신에게 적용하는 버프 팩터 정보 파싱
*/
#ifdef ADD_MEMO_1ST_CLASS
/*virtual*/ void CX2GUUser::ParsingBuffFactorID( KLuaManager& luaManager_, const bool IsEqippedMemo_ /*= false*/ )
#else //ADD_MEMO_1ST_CLASS
/*virtual*/ void CX2GUUser::ParsingBuffFactorID( KLuaManager& luaManager_ )
#endif //ADD_MEMO_1ST_CLASS
{
	// 현재 스테이트의 스킬 레벨 초기화
	m_uiNowStateSkillLevel = 0;

	// BuffFactorID, 적용 시간
	m_mapStateInsertBuffFactor.clear();

#ifdef ADD_MEMO_1ST_CLASS //김창한
	if( true == IsEqippedMemo_ )
	{
		if( true == luaManager_.BeginTable( "BUFF_FACTOR_ID_AND_APPLY_TIME_MEMO" ) )
		{
			int iTableIndex = 1;
			while( true == luaManager_.BeginTable( iTableIndex++  ) )
			{
				UINT uiBuffFactorID = 0;
				float fStartAnimationTime = 0.f;

				LUA_GET_VALUE( luaManager_, 1, uiBuffFactorID, 0);
#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				if( 0 == uiBuffFactorID )
					break;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

				LUA_GET_VALUE( luaManager_, 2, fStartAnimationTime, 0.f);

				luaManager_.EndTable();

#ifdef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				if( 0 == uiBuffFactorID )
					break;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

#ifdef _IN_HOUSE_
				if( m_mapStateInsertBuffFactor.end() != m_mapStateInsertBuffFactor.find( uiBuffFactorID ) )
				{
					DISPLAY_ERROR(L"BuffFactor Duplication Error!");
				}
#endif //_IN_HOUSE_

				m_mapStateInsertBuffFactor.insert( std::make_pair( uiBuffFactorID, fStartAnimationTime ) );
			}

			luaManager_.EndTable(); //BUFF_FACTOR_ID
		}
	}
	else
#endif //ADD_MEMO_1ST_CLASS
	if( true == luaManager_.BeginTable( "BUFF_FACTOR_ID_AND_APPLY_TIME" ) )
	{
		int iTableIndex = 1;
		while( true == luaManager_.BeginTable( iTableIndex++  ) )
		{
			UINT uiBuffFactorID = 0;
			float fStartAnimationTime = 0.f;
			
			LUA_GET_VALUE( luaManager_, 1, uiBuffFactorID, 0);
#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			if( 0 == uiBuffFactorID )
				break;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

			LUA_GET_VALUE( luaManager_, 2, fStartAnimationTime, 0.f);

			luaManager_.EndTable();

#ifdef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			if( 0 == uiBuffFactorID )
				break;
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

#ifdef _IN_HOUSE_
			if( m_mapStateInsertBuffFactor.end() != m_mapStateInsertBuffFactor.find( uiBuffFactorID ) )
			{
				DISPLAY_ERROR(L"BuffFactor Duplication Error!");
			}
#endif //_IN_HOUSE_

			m_mapStateInsertBuffFactor.insert( std::make_pair( uiBuffFactorID, fStartAnimationTime ) );
		}

		luaManager_.EndTable(); //BUFF_FACTOR_ID
	}

	if( false == m_mapStateInsertBuffFactor.empty() )
	{
		// 버프 팩터 연동 레벨 값 얻기
		{
			// BuffFactor 레벨 연동 스킬 ID 파싱
			CX2SkillTree::SKILL_ID eSkillID = CX2SkillTree::SI_NONE;
			LUA_GET_VALUE_ENUM( luaManager_, "BUFF_FACTOR_RELATIVE_SKILL_ID", eSkillID,	CX2SkillTree::SKILL_ID,	CX2SkillTree::SI_INVALID );
			
			bool bIsNowStateSkill = false;
			// 스테이트에서 지정한 스킬이 없다면 현재 스테이트 스킬 얻기
			if( CX2SkillTree::SI_INVALID == eSkillID )
			{
				eSkillID = GetNowStateSkillID();
				bIsNowStateSkill = true;
			}

			// 현재 스테이트 or 스테이트에서 지정한 스킬이 있다면
			if( CX2SkillTree::SI_NONE != eSkillID )
			{
				if( NULL != GetUnit() )
				{
					// 스킬트리의 레벨 체크.( 스킬 습득 여부 ) 
					m_uiNowStateSkillLevel = static_cast<UINT>( GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( eSkillID ) );
				}
			}
		}
#ifdef SERV_ELESIS_SECOND_CLASS_CHANGE //김창한
		//유저가 해당 skill을 배웠는지를 체크하는 구문입니다.
		//유저가 해당 skill을 배우지 않았다면 buff를 1레벨이라도 적용하지 않습니다.
		bool CheckSkillLevel = false;
		LUA_GET_VALUE( luaManager_, "RELATIVE_SKILL_LEARN_CHECK", CheckSkillLevel,	false );

		//skill을 체크 값이 true이고 스킬을 배우지 않았다면 버프를 적용시키지 않고 return 시킵니다.
		if( true == CheckSkillLevel && 1 > m_uiNowStateSkillLevel )
		{
			m_mapStateInsertBuffFactor.clear();
			return;
		}
#endif //SERV_ELESIS_SECOND_CLASS_CHANGE

		map< UINT, float >::iterator it = m_mapStateInsertBuffFactor.begin();
		while( it != m_mapStateInsertBuffFactor.end() )
		{
			if( 0.f == it->second )
			{
				SetBuffFactorToGameUnitByBuffFactorID( it->first, max( m_uiNowStateSkillLevel, 1 ) );
				m_mapStateInsertBuffFactor.erase(it++);
			}
			else
			{
				++it;
			}
		}
	}
}
/** @function : CommonFrameMove_InsertBuffFactor
	@brief : 스크립트에서 지정한 스테이트의, 지정한 시간에
			자기자신에게 적용하는 버프 팩터 설정
*/
void CX2GUUser::CommonFrameMove_InsertBuffFactor()
{
	if( NULL == m_pXSkinAnim ) 
		return;

	map< UINT, float >::iterator it = m_mapStateInsertBuffFactor.begin();
	while( it != m_mapStateInsertBuffFactor.end() )
	{
		// 애니메이션 시간이 지정한 시간 이후라면
		if( m_pXSkinAnim->GetNowAnimationTime() >= it->second )
		{
			SetBuffFactorToGameUnitByBuffFactorID( it->first, max( m_uiNowStateSkillLevel, 1 ) );
			m_mapStateInsertBuffFactor.erase(it++);
		}
		else
		{
			++it;
		}
	}
}
#endif // INSERT_BUFF_FACTOR_BY_SCPRIPT_STATE

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환

/// 현빈이가 제작한 스킬 키 입력 제어 기능 머지
void CX2GUUser::CurrentSkillKeyManager::Init()
{
	iSkillSlotIndex = -1;
	m_bIsSkillSLotSwap = false;
}
/** @function : CheckSkillSlotSwap
	@brief : 스킬슬롯 체인지 여부에 따라 슬롯 인덱스 업데이트.
				이 구조체를 사용하려면 EventProcess에서 무조건 호출해야 함.
*/
void CX2GUUser::CurrentSkillKeyManager::CheckSkillSlotSwap()
{ 
	// 스킬슬롯 변경했다면 Index도 변경해주기.
	if( NULL != g_pData->GetUIManager() && 
		NULL != g_pData->GetUIManager()->GetUISkillTree() &&
		m_bIsSkillSLotSwap != g_pData->GetUIManager()->GetUISkillTree()->GetSkillSlotSwap() )
	{ 
		iSkillSlotIndex += ( true == m_bIsSkillSLotSwap ) ? 4 : -4;
		m_bIsSkillSLotSwap = !m_bIsSkillSLotSwap;
	}
}
void CX2GUUser::CurrentSkillKeyManager::InitCurrentSkillKeyManager( int iSkillSlotIndex_ )
{
	iSkillSlotIndex = iSkillSlotIndex_;
	if( NULL != g_pData->GetUIManager() && 
		NULL != g_pData->GetUIManager()->GetUISkillTree() )
	{
		m_bIsSkillSLotSwap = g_pData->GetUIManager()->GetUISkillTree()->GetSkillSlotSwap();
	}
}
/** @function : IsPressedCurrentSkillKey
	@brief : 현재 스킬이 입력된 스킬키가 재 입력 되었는지 체크
*/
bool CX2GUUser::CurrentSkillKeyManager::IsPressedCurrentSkillKey( const CX2GUUser::InputData& InputData_ )
{
	bool bIsKeyPress = false;
	switch( iSkillSlotIndex )
	{
	case 0: bIsKeyPress = InputData_.oneA; break;
	case 1: bIsKeyPress = InputData_.oneS; break;
	case 2: bIsKeyPress = InputData_.oneD; break;
	case 3: bIsKeyPress = InputData_.oneC; break;
	case 4: bIsKeyPress = InputData_.oneQ; break;
	case 5: bIsKeyPress = InputData_.oneW; break;
	case 6: bIsKeyPress = InputData_.oneE; break;
	case 7: bIsKeyPress = InputData_.oneR; break;
	default :
		ASSERT("!DodgeAndSlash SkillIndex Error");
		break;
	}

	return bIsKeyPress;
}
/** @function : IsPressedCurrentSkillKey
	@brief : 현재 스킬이 입력된 스킬키가 안눌려진 상태인지 체크
*/
bool CX2GUUser::CurrentSkillKeyManager::IsUnpressedCurrentSkillKey( const CX2GUUser::InputData& InputData_ )
{
	bool bIsKeyPress = false;
	switch( iSkillSlotIndex )
	{
	case 0: bIsKeyPress = InputData_.pureA; break;
	case 1: bIsKeyPress = InputData_.pureS; break;
	case 2: bIsKeyPress = InputData_.pureD; break;
	case 3: bIsKeyPress = InputData_.pureC; break;
	case 4: bIsKeyPress = InputData_.pureQ; break;
	case 5: bIsKeyPress = InputData_.pureW; break;
	case 6: bIsKeyPress = InputData_.pureE; break;
	case 7: bIsKeyPress = InputData_.pureR; break;
	default :
		ASSERT("!DodgeAndSlash SkillIndex Error");
		break;
	}

	return !bIsKeyPress;
}

#endif // UPGRADE_SKILL_SYSTEM_2013

#ifdef FINALITY_SKILL_SYSTEM
void CX2GUUser::ResetLinkOverChargeIllusion()
{
	CX2GUEve* pEve = static_cast<CX2GUEve*>(this);
	if( NULL != pEve )
		pEve->ResetLinkOverChargeIllusion();
}
#endif //FINALITY_SKILL_SYSTEM
#ifdef MODIFY_RIDING_PET_AWAKE

/** @function : HyperModeStart
	@brief : 하이퍼 모드를 사용한다는 플래그 셋팅
*/
void CX2GUUser::RidingHyperModeStart()
{
	CommonStateStart();

	if ( NULL != m_ptrRidingPet )
		m_ptrRidingPet->StateChange( m_ptrRidingPet->m_WaitState );

	m_bHyperModeUsed = true;
#ifdef HYPER_MODE_FIX
	m_iLastStateHyperModeCount = m_FrameDataNow.syncData.m_HyperModeCount;
	m_iHyperModeCountUsed = m_FrameDataNow.syncData.m_HyperModeCount;

	if ( GetRemainHyperModeTime() > 0.0f )
		SetHyperModeCount( max( GetLastStateHyperModeCount() - 1, 0 ) );	 /// 각성중 재각성 처리(레피)
	else
		SetHyperModeCount( 0 );

	m_FrameDataNow.syncData.m_HyperModeCount = 0;
	m_bReserveHyperModeZero = false;
#endif HYPER_MODE_FIX

}
void CX2GUUser::RidingHyperModeEventProcess()
{
	if( true == m_pXSkinAnimFuture->IsAnimationEnd() )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_RIDING_JUMP_DOWN );
		else
			StateChange( USI_RIDING_WAIT );
	}	
	CommonEventProcess();
}

#ifdef HYPER_MODE_FIX
	void CX2GUUser::RidingHyperModeEnd()
	{
		CommonStateEnd();
		m_iLastStateHyperModeCount = 0;
	}

	void CX2GUUser::RidingHyperModeStartFuture()
	{
		CommonStateStartFuture();
		m_bReserveHyperModeZero = true;
	}
#endif //HYPER_MODE_FIX

#endif // MODIFY_RIDING_PET_AWAKE

#ifdef HAMEL_SECRET_DUNGEON // 김태환
/** @function	: ApplyBuffByUseHyperMode
	@brief		: 각성시 적용할 버프를 설정하는 함수
*/
void CX2GUUser::ApplyBuffByUseHyperMode()
{
	if ( NULL == g_pMain )
		return;

	/// 각성시 적용할 버프 정보 순회
	BOOST_FOREACH( CX2SocketItem::InfoByUseHyperMode sInfoByUseHyperMode, m_SocketData.m_vecInfoByUseHyperMode )
	{
		/// 버프를 사용할 수 있는 위치 ( 던전 및 대전 )
		const CX2SocketItem::POSSIBLE_USE_PLACE ePossible_Use_Place =  sInfoByUseHyperMode.m_ePossibleUsePlace;

		switch( g_pMain->GetNowStateID() )
		{
		case CX2Main::XS_DUNGEON_GAME:
		case CX2Main::XS_BATTLE_FIELD:
		case CX2Main::XS_TRAINING_GAME:
			{
				/// 대전 전용인데 현재 대전이 아니면, 설정 중지
				if ( CX2SocketItem::PUP_PVP_ONLY == ePossible_Use_Place )
					continue;
			} break;
		case CX2Main::XS_PVP_GAME:
			{
				/// 던전 전용인데 현재 던전이 아니면, 설정 중지
				if ( CX2SocketItem::PUP_DUNGEON_ONLY == ePossible_Use_Place )
					continue;
			}
		}

		switch ( sInfoByUseHyperMode.m_eHyperModeEffectiveType )
		{
		case CX2SocketItem::HMET_USE_BUFF:								/// 설정한 버프를 적용
			{
				if ( NULL != sInfoByUseHyperMode.m_pBuffFactorPtr )
				{	
					CX2BuffFactorPtr ptrBuffFactorClone = sInfoByUseHyperMode.m_pBuffFactorPtr->GetClonePtr( 0 );

					if ( NULL != ptrBuffFactorClone )
						SetBuffFactorToGameUnit( *ptrBuffFactorClone );

#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
					SetSocketOptionHyperCoolTime( sInfoByUseHyperMode.m_fCoolTime );
#endif //ADJUST_SECRET_ITEM_OPTION
				}
			} break;
		case CX2SocketItem::HMET_ERASE_DEBUFF_AND_ADD_MP:		///  (define ADJUST_SECRET_ITEM_OPTION) 디버프 삭제, 삭제 갯수에 관계없이 mp 회복으로 수정 <- 걸려있는 디버프를 지우고, 지운 개수만큼 MP 회복
			{
				EraseDebuffAndAddMP( sInfoByUseHyperMode.m_fEffectiveValue );
#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
				SetSocketOptionHyperCoolTime( sInfoByUseHyperMode.m_fCoolTime );
#endif //ADJUST_SECRET_ITEM_OPTION
			} break;
		case CX2SocketItem::HMET_ADD_HP_IMMEDIATELY:			/// HP 5% 즉시 회복 및 지속적인 HP 회복
			{
				const float fAddHPValue = GetMaxHp() * sInfoByUseHyperMode.m_fEffectiveValue;	/// 체력 회복량

				UpNowHp( fAddHPValue );

				/// 회복량 표기 ( Percent )
				if ( NULL != g_pX2Game )
					g_pX2Game->DisplayAddHPInformation( sInfoByUseHyperMode.m_fEffectiveValue * 100.f, GetPos(), GetDirVector() );

#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
				SetSocketOptionHyperCoolTime( sInfoByUseHyperMode.m_fCoolTime );
#endif //ADJUST_SECRET_ITEM_OPTION
			}break;
		default:
			{
				/// 각성시 사용할 효과 설정이 이상하네요!!!
				ASSERT( !"Unknown Hyper Mode Effective!!!" );
			}
		}
	}
}

/** @function	: EraseDebuffAndAddMP
	@brief		:  (define ADJUST_SECRET_ITEM_OPTION) 디버프 삭제, 삭제 갯수에 관계없이 mp 회복으로 수정 <- 걸려있는 디버프를 지우고, 지운 개수만큼 MP 회복
	@param		: 회복 MP량
*/
void CX2GUUser::EraseDebuffAndAddMP( IN const float fMPValue_ )
{
	if ( NULL != g_pX2Game )
	{
#ifndef ADJUST_SECRET_ITEM_OPTION //김창한
		int iEraseCount = 0;	/// 지운 버프 수
#endif //ADJUST_SECRET_ITEM_OPTION

		/// 해로운 효과라고 정의된 공식적인 디버프 목록 순환
		BOOST_FOREACH( BUFF_TEMPLET_ID eBuffTempletID , g_pX2Game->GetOfficiallyDebuffList() )
		{
			auto FindFunc 
				= [eBuffTempletID]( CX2BuffTempletPtr ptrBuffTemplet_ ) {
					return eBuffTempletID == ptrBuffTemplet_->GetBuffTempletID();
			};

			vector<CX2BuffTempletPtr>::iterator vItr
				= std::find_if( m_vecBuffTempletPtr.begin(), m_vecBuffTempletPtr.end(), FindFunc );

			/// 해당 디버프가 걸려 있을 때
			if ( m_vecBuffTempletPtr.end() != vItr )
			{
				EraseBuffTempletFromGameUnitByIterator( vItr );		/// 디버프 해제

#ifndef ADJUST_SECRET_ITEM_OPTION //김창한
				++iEraseCount;										/// 해제 카운트 갱신
#endif //ADJUST_SECRET_ITEM_OPTION
			}
		}

		// 무기 속성도 풀 수 있도록 추가
		if( m_ExtraDamagePack.m_EnchantBlaze.m_fTime > 0.f )
		{
			m_ExtraDamagePack.m_EnchantBlaze.m_fTime = 0.f;
#ifndef ADJUST_SECRET_ITEM_OPTION //김창한
			++iEraseCount;	
#endif //ADJUST_SECRET_ITEM_OPTION
		}
		if( m_ExtraDamagePack.m_EnchantFrozen.m_fTime > 0.f)
		{
			m_ExtraDamagePack.m_EnchantFrozen.m_fTime = 0.f;
#ifndef ADJUST_SECRET_ITEM_OPTION //김창한
			++iEraseCount;	
#endif //ADJUST_SECRET_ITEM_OPTION	
		}
		if( m_ExtraDamagePack.m_EnchantPoison.m_fTime > 0.f)
		{
			m_ExtraDamagePack.m_EnchantPoison.m_fTime = 0.f;
#ifndef ADJUST_SECRET_ITEM_OPTION //김창한
			++iEraseCount;	
#endif //ADJUST_SECRET_ITEM_OPTION
		}
		if( m_ExtraDamagePack.m_EnchantShock.m_fTime > 0.f)
		{
			m_ExtraDamagePack.m_EnchantShock.m_fTime = 0.f;
#ifndef ADJUST_SECRET_ITEM_OPTION //김창한
			++iEraseCount;	
#endif //ADJUST_SECRET_ITEM_OPTION
		}

#ifdef ADJUST_SECRET_ITEM_OPTION //김창한
		UpNowMp( fMPValue_ );
		/// 회복량 표시
		g_pX2Game->DisplayAddMPInformation( fMPValue_, GetPos(), GetDirVector() );
#else
		/// 지운 버프 수 만큼 MP 회복
		if ( 0 < iEraseCount )
		{
			const float fAddMP = fMPValue_ * static_cast<float>( iEraseCount );
			UpNowMp( fAddMP );

			/// 회복량 표시
			g_pX2Game->DisplayAddMPInformation( fAddMP, GetPos(), GetDirVector() );
		}
#endif //ADJUST_SECRET_ITEM_OPTION
	}
}
#endif // HAMEL_SECRET_DUNGEON

void CX2GUUser::ApplyWorldLightColor( OUT CKTDGXRenderer::RenderParam* pRenderParam_ )
{
	if( g_pX2Game->GetWorld() != NULL && m_bUseWorldColor == true )
	{
 		pRenderParam_->color.r	= g_pX2Game->GetWorld()->GetLightColor().r;
 		pRenderParam_->color.g	= g_pX2Game->GetWorld()->GetLightColor().g;
 		pRenderParam_->color.b	= g_pX2Game->GetWorld()->GetLightColor().b;
	}
}

//#ifdef  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK
//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
void CX2GUUser::_EncodeUserSyncPos( USHORT& usPosX, USHORT& usPosZ, const D3DXVECTOR3& position, unsigned char lastTouchLineIndex )
//#else   X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//void CX2GUUser::_EncodeUserSyncPos( USHORT& usPosX, USHORT& usPosY, USHORT& usPosZ, const D3DXVECTOR3& position, unsigned char lastTouchLineIndex )
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
{
    const CKTDGLineMap::LineData* pLineData = NULL;
	if( !g_pX2Game || !g_pX2Game->GetLineMap() 
        || ( pLineData = g_pX2Game->GetLineMap()->GetLineData( ( int )lastTouchLineIndex ) ) == NULL )
    {
		StateLog( L"lastTouchLineIndex가 이상한듯" );
    	usPosX = floatToHalf( position.x );
//#ifndef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//        usPosY = floatToHalf( position.y );
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
	    usPosZ = floatToHalf( position.z );
		return;
    }

	usPosX = floatToHalf( position.x - pLineData->startPos.x );
//#ifndef X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
//    usPosY = floatToHalf( position.y - pLineData->startPos.y );
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC
	usPosZ = floatToHalf( position.z - pLineData->startPos.z );
}
//#endif  SERV_KTDX_OPTIMIZE_UDP_PACKET_PACK


//#ifdef  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC

void    CX2GUUser::ResetLocalAndRelativePosAndTimers()
{
    ZeroMemory( m_acLocalRelativePos, sizeof(m_acLocalRelativePos) );
    m_FrameDataFuture.syncData.m_dwRelativePos = 0;
    m_FrameDataNow.syncData.m_dwRelativePos = 0;
    for( int i = 0; i < MAX_GAME_USER_UNIT_NUM; i++ )
    {
        m_afLocalRelativePosTimers[ i ] = 0.f;
    }
}

void    CX2GUUser::IncrementLocalRelativePosTimers(  float fElapsedTime )
{
    if ( fElapsedTime > 0.f )
    {
        for( int i = 0; i < MAX_GAME_USER_UNIT_NUM; i++ )
        {
            m_afLocalRelativePosTimers[ i ] += fElapsedTime;
        }
    }//if
}

void    CX2GUUser::PhysicProcess_RetrieveRelativePosInfo( CX2GUUser* pGameUnit, int iUnitIndex, OUT int& iDirection )
{
    iDirection = 0;

    int iMyUnitIndex = GetUnitIndex();
    if ( iUnitIndex >= 0 && iUnitIndex < MAX_GAME_USER_UNIT_NUM )
    {
        iDirection = m_acLocalRelativePos[ iUnitIndex ];
        if ( iDirection != 1 && iDirection != 2 )
            return;

        int iUnitDirection = pGameUnit->GetRelativePos( iMyUnitIndex );
        if ( iUnitDirection == 1 || iUnitDirection == 2 )
        {
            if ( iUnitDirection == 1 )
                iUnitDirection = 2;
            else
                iUnitDirection = 1;

            if ( const CX2Room::SlotData* pSlotData = g_pX2Room->GetSlotData( iUnitIndex ) )
            {
                float fToleranceTime = 0.f;
#ifdef  SERV_OPTIMIZE_CHOOSE_FASTEST_HOST_ENHANCE
                fToleranceTime = pSlotData->m_fAvgPingTime + pSlotData->m_fAvgPingStd + 0.2f;
#else   SERV_OPTIMIZE_CHOOSE_FASTEST_HOST_ENHANCE
                fToleranceTime = pSlotData->m_fAvgPingTime + 0.2f;
#endif  SERV_OPTIMIZE_CHOOSE_FASTEST_HOST_ENHANCE

                if ( m_afLocalRelativePosTimers[ iUnitIndex ] < fToleranceTime )
                    return;

                if ( iUnitDirection == iDirection )
                    return;

                if ( iMyUnitIndex < iUnitIndex )
                    return;

                iDirection = iUnitDirection;
            }//if
        }
    }//if
}


void    CX2GUUser::PhysicProcess_UpdateRelativePos()
{
    if ( IsMyUnit() == false )
        return;

    if ( m_FrameDataFuture.stateParam.bCanPassUnit == true )
    {
        ResetLocalAndRelativePosAndTimers();
        return;
    }

    D3DXVECTOR2 vMyUnitMinMaxY( m_FrameDataFuture.syncData.position.y, m_FrameDataFuture.syncData.position.y + GetUnitHeight( true ) );
    int  iUserUnitSize = __min( g_pX2Game->GetUserUnitListSize(), MAX_GAME_USER_UNIT_NUM );
    DWORD   dwNewRelativePos = 0;
    int iMyUnitIndex = GetUnitIndex();
    for( int i = 0; i < iUserUnitSize; i++ )
    {
        CX2GUUser* pGameUnit = g_pX2Game->GetUserUnit( i );
        if ( pGameUnit == NULL || pGameUnit == this || pGameUnit->GetGameUnitState() == GUSI_DIE )
        {
            m_acLocalRelativePos[i] = 0;
            m_afLocalRelativePosTimers[ i ] = 0.f;
            continue;
        }
        const StateParam* pGameUnitStateParam = &pGameUnit->GetStateparam( true );
        if ( false == ( ( ( pGameUnit->GetTeam() != GetTeam() && false == pGameUnitStateParam->bCanPassUnit ) 

#ifdef ADD_CAN_PASS_ALLY_UNIT	//JHKang	
#ifndef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				|| ( pGameUnit->GetTeam() == GetTeam() && false == pGameUnitStateParam->bCanPassAllyUnit ) 
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#endif // ADD_CAN_PASS_ALLY_UNIT
             ) 
             && ( pGameUnit->GetAllyTeam() == CX2Room::TN_NONE || pGameUnit->GetAllyTeam() != static_cast<CX2Room::TEAM_NUM>(GetTeam()) ) // 대상의 아군팀이 설정되어있지 않거나, 대상이 아군팀이 아니면
	        && !( g_pX2Game->GetGameType() == CX2Game::GT_BATTLE_FIELD && false == pGameUnit->DidReceiveFirstSyncPacket() ) )  ) /// 배틀필드에서 싱크패킷을 한번도 못받은게 아니면
        {
            m_acLocalRelativePos[i] = 0;
            m_afLocalRelativePosTimers[ i ] = 0.f;
            continue;
        }
        int iOldLocalDirection = m_acLocalRelativePos[i];
        int iNewLocalDirection = iOldLocalDirection;
        D3DXVECTOR3 vPosFuture = pGameUnit->GetPos( true );
        D3DXVECTOR3 vDirVectorFromMeToOther;
	    const float fGameUnitYMin = vPosFuture.y;
	    const float fGameUnitYMax = fGameUnitYMin + pGameUnit->GetUnitHeight( true );
	    if( (fGameUnitYMin >= vMyUnitMinMaxY.x && fGameUnitYMin <= vMyUnitMinMaxY.y) ||
		    (fGameUnitYMax >= vMyUnitMinMaxY.x && fGameUnitYMax <= vMyUnitMinMaxY.y) ||
		    (fGameUnitYMin <= vMyUnitMinMaxY.x && fGameUnitYMax >= vMyUnitMinMaxY.y) )
        {
            vDirVectorFromMeToOther = vPosFuture - m_FrameDataFuture.syncData.position;
            vDirVectorFromMeToOther.y = 0.f;
            int iHostDirection = pGameUnit->GetRelativePos( iMyUnitIndex );
            switch( iHostDirection )
            {
            case 1:
                iHostDirection = 2;
                break;
            case 2:
                iHostDirection = 1;
                break;
            default:
                iHostDirection = 0;
            }//switch
            if ( D3DXVec3Dot( &m_FrameDataFuture.unitCondition.dirVector, &vDirVectorFromMeToOther ) >= 0 )
                iNewLocalDirection = 2;
            else
                iNewLocalDirection = 1;
            if ( iOldLocalDirection == 0 
                && iNewLocalDirection != 0
                && iNewLocalDirection != iHostDirection )
            {
                m_afLocalRelativePosTimers[ i ] = 0.f;
            }
        }
        else
        {
            if ( fGameUnitYMin >= vMyUnitMinMaxY.y )
                iNewLocalDirection = 3;
            else
                iNewLocalDirection = 4;
            m_afLocalRelativePosTimers[ i ] = 0.f;
        }
        m_acLocalRelativePos[i] = iNewLocalDirection;
        if ( iNewLocalDirection == 1 || iNewLocalDirection == 2 )
            dwNewRelativePos |= iNewLocalDirection << ( i * 2 );
    }
    m_FrameDataFuture.syncData.m_dwRelativePos = dwNewRelativePos;
}
//#endif  X2OPTIMIZE_USER_USER_PUSH_PASS_SYNC

#ifdef CHEAT_SELF_DAMAGE // 김태환
/** @function	: SetSelfDamage
	@brief		: 자신에게 데미지를 주는 기능
	@param		: 데미지 수치 ( 0 - Small, 1 - Big, 2 - Fly )
*/
void CX2GUUser::SetSelfDamage( IN int iValue_, IN int iFrontDamage_ )
{
	/// 기본으로 플라이 데미지 설정
	CX2DamageManager::REACT_TYPE eReactType = CX2DamageManager::RT_SMALL_DAMAGE;
	
	/// 원하는 설정값에 따라 리엑트 타입 변경
	switch ( iValue_ )
	{
	case 1:
		{
			eReactType = CX2DamageManager::RT_BIG_DAMAGE;
		} break;
	case 2:
		{
			eReactType = CX2DamageManager::RT_DOWN;
		} break;
	case 3:
		{
			eReactType = CX2DamageManager::RT_FLY;
			m_DamageData.backSpeed = D3DXVECTOR2( 0.f, 2000.f );
		} break;
	case 4:
		{
			eReactType = CX2DamageManager::RT_UP;
			m_DamageData.backSpeed = D3DXVECTOR2( 0.f, 2000.f );
		} break;
	}

	/// 리엑트 타입 설정
	m_DamageData.reActResult = eReactType;

	/// 피격 방향 설정
	m_iFrontDamage = iFrontDamage_;

	/// 강제로 데미지 설정
	DamageReact( &m_DamageData );

	/// 피격 방향 초기화
	m_iFrontDamage  = -1;
}
#endif //CHEAT_SELF_DAMAGE

#ifdef FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE // 김태환
/** @function	: ProcessSkillAtDie
	@brief		: 사망 직전에 발동되는 스킬 검사
	@param		: 입게 될 데미지, 데미지 데이터
	@return		: 스킬 발동 여부
*/
bool CX2GUUser::ProcessSkillAtDie( IN const float fFinalDamage_, IN CX2DamageManager::DamageData* pDamageData_ /*= NULL*/ )
{
	bool bActiveSkill = false;		/// 스킬 발동 여부

	/// 죽여버릴 데미지라면
	if ( fFinalDamage_ > GetNowHp() )
	{
		/// 아라 2차 전직 명왕 - 회광반조-------------------------------------------------------------------------------------------
		int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_AYR_RESURRECTION, true );

		if( iSkillLevel > 0 )
		{
			CX2GUAra* pAra = static_cast<CX2GUAra*>( this );

			/// 아라일 때, 회광반조 동작
			if ( NULL != pAra && 
				 NULL != GetUnit() &&
				 CX2Unit::UT_ARA == GetUnit()->GetType() &&
				 true == pAra->ProcessResurrection( iSkillLevel ) )
			{
		#ifdef SET_INVINCIBLE_AT_RESURRECTION
				SetForceInvincible( 1.f );								/// 일정시간 무적 설정
		#endif // SET_INVINCIBLE_AT_RESURRECTION

				/// 강제로 넘어뜨려 버리자
				if ( NULL != pDamageData_ )
					pDamageData_->reActResult = CX2DamageManager::RT_DOWN;
				else		/// 데미지 데이터가 없다면, 그냥 스테이트 바꿔 버리자
					StateChange( USI_DAMAGE_DOWN_FRONT );

				bActiveSkill = true;
			}
		}
		/// ------------------------------------------------------------------------------------------------------------------------

		/// 레나 1차 전직 컴뱃 레인저 - 유연한 몸놀림-------------------------------------------------------------------------------
		if( m_SkillRelatedData.m_fSkillCoolTimeLeft_SI_P_COMMON_SOFTBODY <= 0.f )
		{
			int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_LCR_SOFTBODY, true );

			if( iSkillLevel > 0 )
			{
				const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_LCR_SOFTBODY );

				if( NULL != pSkillTemplet )
				{
					if( GetRandomFloat() < pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE, iSkillLevel ) )
					{
						SetNowHp( fFinalDamage_ + 1.f );	/// 체력 1만 남도록 설정						

						m_SkillRelatedData.m_fSkillCoolTimeLeft_SI_P_COMMON_SOFTBODY = pSkillTemplet->GetSkillCoolTimeValue( iSkillLevel );
		#ifdef FIX_SKILL_BALANCE_AISHA_LENA //JHKang
						SetBuffFactorToGameUnit( pSkillTemplet, 0 );
		#endif //FIX_SKILL_BALANCE_AISHA_LENA

						/// 강제로 넘어뜨려 버리자
						if ( NULL != pDamageData_ )
							pDamageData_->reActResult = CX2DamageManager::RT_DOWN;
						else		/// 데미지 데이터가 없다면, 그냥 스테이트 바꿔 버리자
							StateChange( USI_DAMAGE_DOWN_FRONT );

						bActiveSkill = true;
					}
				}
			}
		}
		/// ------------------------------------------------------------------------------------------------------------------------
	}

	if ( true == bActiveSkill )
		return true;

	return false;
}
#endif //FIX_NOT_ACTIVE_SKILL_AT_ENCHANT_DAMAGE

#ifdef MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT
/** @function : IsAvaliableActionDuringDamageReact
	@brief :  피격 중 사용가능한 Action인지 검사하는 함수.
			  ※적용 대상이 적기 때문에 가상함수 사용하지 않았음.
*/
bool CX2GUUser::IsAvaliableActionDuringDamageReact( const UCHAR ucNowAction_ ) const
{
	switch( ucNowAction_ )
	{
	case UAI_MANA_SHIELD:		/// 마나실드
	case UAI_ENDURANCE_POWER:	/// 극기 - 강(强)
	case UAI_ACTIVE_STASIS_FIELD:/// 스테이시 필드
		{
			return true;
		} break;
	default:
		return false;
		break;
	}
}
/** @function : GetActionSyncData
	@brief : SyncData 컨테이너로부터 피격중 사용 가능한 Action정보 얻기
*/
void CX2GUUser::GetActionSyncData( OUT map< int, UCHAR >& mapActionSyncData_, IN const vector<SyncData>& ReceiveSyncDataList_ ) const
{
	// int : 인덱스 , UCHAR : NowAction
	mapActionSyncData_.clear();
	int iIndex = 0; 
	BOOST_FOREACH( const SyncData& ReceiveSyncData, ReceiveSyncDataList_ )
	{
		if( true == IsAvaliableActionDuringDamageReact(ReceiveSyncData.nowAction) )
		{
			mapActionSyncData_.insert( std::make_pair(iIndex, ReceiveSyncData.nowAction) );
		}
		++iIndex;
	}
}
/** @function : SetActionSyncData
	@brief : 기록한 action정보를 SyncData에 설정하기
*/
void CX2GUUser::SetActionSyncData( OUT vector<SyncData>& ReceiveSyncDataList_, IN const map< int, UCHAR >& mapActionSyncData_ ) const
{
	if( false == mapActionSyncData_.empty() )
	{
		int iIndex = 0; 
		BOOST_FOREACH( SyncData& ReceiveSyncData, ReceiveSyncDataList_ )
		{
			map< int, UCHAR >::const_iterator mitActionSyncData = mapActionSyncData_.find( iIndex );
			if( mitActionSyncData != mapActionSyncData_.end() )
			{
				ReceiveSyncData.nowAction = mitActionSyncData->second;
			}
			++iIndex;
		}
	}
}
#endif // MODIFY_NO_STATE_SKILL_DURING_DAMAGE_REACT


#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#ifdef ADD_MEMO_1ST_CLASS //김창한
void CX2GUUser::LoadEffectSetFromScript( IN KLuaManager& luaManager, IN const bool IsEqippedMemo_/* = false */)
#else //ADD_MEMO_1ST_CLASS
void CX2GUUser::LoadEffectSetFromScript( IN KLuaManager& luaManager )
#endif //ADD_MEMO_1ST_CLASS
{
	m_vecEffectSetToPlay.resize(0);

#ifndef ADD_MEMO_1ST_CLASS
#ifdef ADDITIONAL_MEMO
	LUA_GET_VALUE( m_LuaManager, "APPLY_MEMO",		m_iMemoId,		0 );
#endif

#ifdef ADDITIONAL_MEMO
	bool bApplyMemo = false;
	if( m_iMemoId > 0 )
	{
		if( GetEqippedSkillMemo( (CX2SkillTree::SKILL_MEMO_ID)m_iMemoId) )
			bApplyMemo = true;
	}
#endif
#endif //ADD_MEMO_1ST_CLASS

#ifdef ADD_MEMO_1ST_CLASS
	bool bIsEffectSetMemo = false;

	if( true == IsEqippedMemo_ )
	{
		if( true == luaManager.BeginTable( "EFFECT_SET_LIST_MEMO" ) )
		{
			std::wstring wstrEffectSetName = L"";
			float fStartAnimationTime = 0.f;

			for( int iValueIndex = 1; iValueIndex < 100; iValueIndex += 2 )
			{
				if( false == luaManager.GetValue( iValueIndex, wstrEffectSetName ) )
					break;

				if( false == luaManager.GetValue( iValueIndex+1, fStartAnimationTime ) )
					break;

				m_vecEffectSetToPlay.push_back( EffectSetToPlay( wstrEffectSetName, fStartAnimationTime ) );
			}


			luaManager.EndTable(); //EFFECT_SET_LIST_MEMO

			bIsEffectSetMemo = true;
		}
	}

	//APPLY_MEMO가 정의되어 있지 않거나 
	//APPLY_MEMO가 정의되어 있지만 EFFECT_SET_LIST_MEMO가 정의되어 있지 않은 경우 EFFECT_SET_LIST_MEMO를 파싱한다.(DAMAGE_DATA_MEMO를 위해 APPLY_MEMO를 정의한 경우)
	if( false == IsEqippedMemo_ || ( true == IsEqippedMemo_ && false == bIsEffectSetMemo ) )
#endif //ADD_MEMO_1ST_CLASS
	{
		if( true == luaManager.BeginTable( "EFFECT_SET_LIST" ) )
		{
			std::wstring wstrEffectSetName = L"";
			float fStartAnimationTime = 0.f;

		for( int iValueIndex = 1; iValueIndex < 100; iValueIndex += 2 )
		{
			if( false == luaManager.GetValue( iValueIndex, wstrEffectSetName ) )
				break;

			if( false == luaManager.GetValue( iValueIndex+1, fStartAnimationTime ) )
				break;

#ifndef ADD_MEMO_1ST_CLASS
				//동작 방식 수정. 기존에 이 옵션을 사용하던 아야시(2개), 청(4개) state는 수정된 방법으로 스크립트에 적용함.
#ifdef ADDITIONAL_MEMO
			if( bApplyMemo == true )
				wstrEffectSetName = wstrEffectSetName + L"_MEMO";
#endif
#endif //ADD_MEMO_1ST_CLASS
				m_vecEffectSetToPlay.push_back( EffectSetToPlay( wstrEffectSetName, fStartAnimationTime ) );
			}


			luaManager.EndTable(); //EFFECT_SET_LIST
		}
	}


#ifdef ADD_MEMO_1ST_CLASS
	bIsEffectSetMemo = false;
	if( true == IsEqippedMemo_ )
	{
		if( true == luaManager.BeginTable( "EFFECT_SET_LIST_EX_MEMO" ) )
		{
			std::wstring wstrEffectSetName = L"";
			float fStartAnimationTime = 0.f;




#ifdef ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
			vector<DELETE_CONDITION_EFFECT_SET> vecDeleteCondition;		// 종료 조건 벡터
#else // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
			DELETE_CONDITION_EFFECT_SET eDeleteCondition = DCES_NONE;
#endif // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장

			int iTableIndex = 1;

			while( true == luaManager.BeginTable( iTableIndex++  ) )
			{
				LUA_GET_VALUE( luaManager, 1, wstrEffectSetName,	 L"" );
				if( L"" == wstrEffectSetName )
					break;

				LUA_GET_VALUE( luaManager, 2, fStartAnimationTime, 0.f);


#ifdef ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
				int iTableCount = 3;			// 테이블 카운터, 3번 테이블부터 읽어오기 시작함
				UINT uiDeleteConditionType = 0;	// 종료 조건
				vecDeleteCondition.clear();

				while ( luaManager.GetValue( iTableCount, uiDeleteConditionType ) == true )
				{	// 값이 있다면, 테이블 카운터 증가시키고 종료 조건을 벡터에 넣어준다.
					// 얻어온 값이 범위에 벗어난다면, ASSERT 를 띄운다.
#ifdef _IN_HOUSE_
					// 사내 일 경우, 해당 종료 조건이 중복되는지 체크한다.
					ASSERT( vecDeleteCondition.end() == find ( vecDeleteCondition.begin(), vecDeleteCondition.end(), static_cast<CX2GameUnit::DELETE_CONDITION_EFFECT_SET> (uiDeleteConditionType) ) );
#endif // _IN_HOUSE_

					iTableCount++;		
					vecDeleteCondition.push_back( static_cast<CX2GameUnit::DELETE_CONDITION_EFFECT_SET> (uiDeleteConditionType) );	
				}
#else // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
				LUA_GET_VALUE_ENUM( luaManager, 3 , eDeleteCondition, CX2GameUnit::DELETE_CONDITION_EFFECT_SET, CX2GameUnit::DCES_NONE );
#endif // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장

				luaManager.EndTable();

#ifndef ADD_MEMO_1ST_CLASS
				//동작 방식 수정. 기존에 이 옵션을 사용하던 아야시(2개), 청(4개) state는 수정된 방법으로 스크립트에 적용함.
#ifdef ADDITIONAL_MEMO
				if( bApplyMemo == true )
					wstrEffectSetName = wstrEffectSetName + L"_MEMO";
#endif
#endif //ADD_MEMO_1ST_CLASS

#ifdef ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
				m_vecEffectSetToPlay.push_back( EffectSetToPlay( wstrEffectSetName, fStartAnimationTime, vecDeleteCondition ) );
#else // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
				m_vecEffectSetToPlay.push_back( EffectSetToPlay( wstrEffectSetName, fStartAnimationTime, eDeleteCondition ) );
#endif // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장

			}


			luaManager.EndTable(); //EFFECT_SET_LIST_EX_MEMO

			bIsEffectSetMemo = true;
		}
	}

	//APPLY_MEMO가 정의되어 있지 않거나 
	//APPLY_MEMO가 정의되어 있지만 EFFECT_SET_LIST_EX_MEMO가 정의되어 있지 않은 경우 EFFECT_SET_LIST_EX를 파싱한다.(DAMAGE_DATA_MEMO를 위해 APPLY_MEMO를 정의한 경우)
	if( false == IsEqippedMemo_ || ( true == IsEqippedMemo_ && false == bIsEffectSetMemo ) )
#endif //ADD_MEMO_1ST_CLASS
#ifdef MODIFY_EFFECT_SET_DELETE
	{
		if( true == luaManager.BeginTable( "EFFECT_SET_LIST_EX" ) )
		{
			std::wstring wstrEffectSetName = L"";
			float fStartAnimationTime = 0.f;


#ifdef ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
		vector<DELETE_CONDITION_EFFECT_SET> vecDeleteCondition;		// 종료 조건 벡터
#else // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
		DELETE_CONDITION_EFFECT_SET eDeleteCondition = DCES_NONE;
#endif // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장

		int iTableIndex = 1;
		while( true == luaManager.BeginTable( iTableIndex++  ) )
		{
			LUA_GET_VALUE( luaManager, 1, wstrEffectSetName,	 L"" );
			if( L"" == wstrEffectSetName )
				break;

			LUA_GET_VALUE( luaManager, 2, fStartAnimationTime, 0.f);
#ifdef ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
			int iTableCount = 3;			// 테이블 카운터, 3번 테이블부터 읽어오기 시작함
			UINT uiDeleteConditionType = 0;	// 종료 조건
			vecDeleteCondition.clear();

			while ( luaManager.GetValue( iTableCount, uiDeleteConditionType ) == true )
			{	// 값이 있다면, 테이블 카운터 증가시키고 종료 조건을 벡터에 넣어준다.
				// 얻어온 값이 범위에 벗어난다면, ASSERT 를 띄운다.
#ifdef _IN_HOUSE_
				// 사내 일 경우, 해당 종료 조건이 중복되는지 체크한다.
				ASSERT( vecDeleteCondition.end() == find ( vecDeleteCondition.begin(), vecDeleteCondition.end(), static_cast<CX2GameUnit::DELETE_CONDITION_EFFECT_SET> (uiDeleteConditionType) ) );
#endif // _IN_HOUSE_
				
				iTableCount++;		
				vecDeleteCondition.push_back( static_cast<CX2GameUnit::DELETE_CONDITION_EFFECT_SET> (uiDeleteConditionType) );	
			}
#else // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
			LUA_GET_VALUE_ENUM( luaManager, 3 , eDeleteCondition, CX2GameUnit::DELETE_CONDITION_EFFECT_SET, CX2GameUnit::DCES_NONE );
#endif // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장

			luaManager.EndTable();

#ifndef ADD_MEMO_1ST_CLASS
#ifdef ADDITIONAL_MEMO
			if( bApplyMemo == true )
				wstrEffectSetName = wstrEffectSetName + L"_MEMO";
#endif
#endif //ADD_MEMO_1ST_CLASS

#ifdef ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
			m_vecEffectSetToPlay.push_back( EffectSetToPlay( wstrEffectSetName, fStartAnimationTime, vecDeleteCondition ) );
#else // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
			m_vecEffectSetToPlay.push_back( EffectSetToPlay( wstrEffectSetName, fStartAnimationTime, eDeleteCondition ) );
#endif // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
		}

			luaManager.EndTable(); //EFFECT_SET_LIST
		}
	}
#endif // MODIFY_EFFECT_SET_DELETE

	LUA_GET_VALUE( m_LuaManager, "DELETE_EFFECT_SET_ON_STATE_END",		m_bDeleteEffectSetOnStateEnd,		false );
	LUA_GET_VALUE( m_LuaManager, "DELETE_EFFECT_SET_ON_DAMAGE_REACT",	m_bDeleteEffectSetOnDamageReact,	false );

	LUA_GET_VALUE( m_LuaManager, "DELETE_EFFECT_SET_ON_DIE",	m_bDeleteEffectSetOnDie,	false );

#ifdef DELETE_EFFECTSET_ON_CUSTOM_STATE
	LUA_GET_VALUE( m_LuaManager, "DELETE_EFFECT_SET_ON_CUSTOM_STATE",	m_bDeleteEffectSetOnCustomState,	false );
#endif DELETE_EFFECTSET_ON_CUSTOM_STATE

#ifdef CUSTOM_DELETE_EFFECT_ON_DAMAGE_REACT
	LUA_GET_VALUE( m_LuaManager, "CUSTOM_STATE_DELETE_EFFECT_SET_ON_DAMAGE_REACT",	m_bIsCustomStateDeleteEffectOnDamageReact,	false );
#endif // CUSTOM_DELETE_EFFECT_ON_DAMAGE_REACT

	LUA_GET_VALUE( m_LuaManager, "HYPER_EFFECT_SET",		m_bHyperEffectSet,		false );
	LUA_GET_VALUE( m_LuaManager, "EFFECT_SET_LIFE_TIME",	m_fEffectSetLifeTime,	-1.f );

}

void CX2GUUser::CommonFrameMove_EffectSet( float fNowAnimationTime )
{

	if( true == m_vecEffectSetToPlay.empty() )
		return;

	for( int i=0; i<(int)m_vecEffectSetToPlay.size(); ++i )
	{
		EffectSetToPlay& effectSetToPlay = m_vecEffectSetToPlay[i];
		if( 0.f == effectSetToPlay.m_fStartAnimationTime ||
			fNowAnimationTime >= effectSetToPlay.m_fStartAnimationTime )
		{
			CX2EffectSet::Handle hEffectSetInst = g_pX2Game->GetEffectSet()->PlayEffectSet( effectSetToPlay.m_wstrEffectSetName, this, NULL, m_bHyperEffectSet, GetPowerRate(), m_fEffectSetLifeTime);
			
			// 기존에 애니메이션 시간을 기준으로 이펙트를 생성하던 것을 effectSetToPlay.m_fStartAnimationTime이 추가되면서 애니메이션을 기준으로 하지 않도록 변경해준다
			if( 0.f != effectSetToPlay.m_fStartAnimationTime )
			{
				if ( CX2EffectSet::EffectSetInstance* pEffectSetInst = g_pX2Game->GetEffectSet()->GetEffectSetInstance( hEffectSetInst ) )
				{
					pEffectSetInst->SetUseAnimationTiming( false );
				}
			}
			

			if( true == m_bDeleteEffectSetOnDamageReact )
			{
				m_vecEffectSetToDeleteOnDamageReact.push_back( hEffectSetInst );
			}

			if( true == m_bDeleteEffectSetOnStateEnd )
			{
				m_vecEffectSetToDeleteOnStateEnd.push_back( hEffectSetInst );
			}

			if( true == m_bDeleteEffectSetOnDie )
			{
				m_vecEffectSetToDeleteOnDie.push_back( hEffectSetInst );
			}

#ifdef DELETE_EFFECTSET_ON_CUSTOM_STATE
			if( true == m_bDeleteEffectSetOnCustomState )
			{
				m_vecEffectSetToDeleteOnCustomState.push_back( hEffectSetInst );
			}
#endif DELETE_EFFECTSET_ON_CUSTOM_STATE

#ifdef MODIFY_EFFECT_SET_DELETE
#ifdef ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
			AddEffectSetDeleteCondition( hEffectSetInst, effectSetToPlay.m_vecDeleteCondition );
#else // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
			AddEffectSetDeleteCondition( hEffectSetInst, effectSetToPlay.m_eDeleteCondition );
#endif // ADD_TO_EFFECT_SET_LIST_EX_DELETE_CONDITION	  // 김종훈, EFFECT_SET_LIST_EX 테이블의 종료 조건 추가 확장
#endif // MODIFY_EFFECT_SET_DELETE

			m_vecEffectSetToPlay.erase( m_vecEffectSetToPlay.begin() + i );
			--i;
		}
	}
}

bool    CX2GUUser::FindNowAddSlashTraceWithWeaponIndex( int iWeaponIndex, OUT D3DXVECTOR3& vSlaceTraceTime ) const
{
    std::map< int, D3DXVECTOR3 >::const_iterator iter = m_mapNowAddSlashTrace.find( iWeaponIndex );
    if ( iter != m_mapNowAddSlashTrace.end() )
    {
        vSlaceTraceTime = iter->second;
        return true;
    }
    return false;
}

//{{ kimhc // 2010.12.07 // 신스킬
/** @function : LoadImmunityAtThisStateFromScript
	@brief : 현재 스테이트에서만 Immune 시킬 ExtraDamage를 스크립트에서 읽어들이는 함수 
*/
void CX2GUUser::LoadImmunityAtThisStateFromScript( IN KLuaManager& luaManager_ )
{
	m_vecImmunityAtThisState.resize( 0 );

	if ( true == luaManager_.BeginTable( "IMMUNITY_LIST_AT_THIS_STATE" ) )
	{

		int iIndex = 1;
		UINT eImmuneBuffOrDebuffType = 0;

		while ( luaManager_.GetValue( iIndex, eImmuneBuffOrDebuffType ) )
		{
			m_vecImmunityAtThisState.push_back( static_cast<BUFF_TEMPLET_ID>( eImmuneBuffOrDebuffType ) );
			++iIndex;
		}

		luaManager_.EndTable();
	}
}

//}} kimhc // 2010.12.07 // 신스킬

bool    CX2GUUser::FindNowSlashTraceTimeWithWeaponIndex( int iWeaponIndex, OUT D3DXVECTOR3& vSlashTraceTime )
{
    std::map< int, D3DXVECTOR3 >::const_iterator it;
	it = m_mapNowAddSlashTrace.find( iWeaponIndex );
	if( it != m_mapNowAddSlashTrace.end() )
	{
		vSlashTraceTime = it->second;
        return true;
	}
    return false;
}



void    CX2GUUser::ClearAnimEventTimerOneshotNow()
{
    if ( m_pXSkinAnim != NULL )
	    m_pXSkinAnim->ResetOneshotPerformed();
    if ( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimPtr() )
        m_ptrRidingPet->GetXSkinAnimPtr()->ResetOneshotPerformed();
}

void    CX2GUUser::ClearAnimEventTimerOneshotFuture()
{
    if ( m_pXSkinAnimFuture != NULL )
	    m_pXSkinAnimFuture->ResetOneshotPerformed();
    if ( NULL != m_ptrRidingPet && NULL != m_ptrRidingPet->GetXSkinAnimFuturePtr() )
        m_ptrRidingPet->GetXSkinAnimFuturePtr()->ResetOneshotPerformed();
}


#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

#ifdef SERV_9TH_NEW_CHARACTER // 김태환
/** @function	: GetSpecialAbilityValue
	@brief		: 스킬 아이디에 해당하는 SA값을 받아오는 함수
	@param		: SA 타입, 스킬 아이디
	@return		: SA Value
*/
const float CX2GUUser::GetSpecialAbilityValue( IN const CX2SkillTree::SKILL_ABILITY_TYPE eSAValue, IN const CX2SkillTree::SKILL_ID eSkillID ) const
{
	float fReturnValue = 1.f;

	if ( NULL != g_pData &&
		 NULL != g_pData->GetSkillTree() &&
		 NULL != GetUnit() )
	{
		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

		const int iSkillLevel = userSkillTree.GetSkillLevel( eSkillID );

		if ( 0 < iSkillLevel )
		{
			const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( eSkillID );

			if( NULL != pSkillTemplet )
			{
				fReturnValue = pSkillTemplet->GetSkillAbilityValue( eSAValue, iSkillLevel );
			}
		}
	}

	return fReturnValue;
}

/** @function	: CreateNotEnoughMPEffect
	@brief		: MP가 없을 때 나가는 만두 이펙트 설정
	@param		: 생성 위치, 생성 각도
*/
void CX2GUUser::CreateNotEnoughMPEffect( IN const D3DXVECTOR3 vPos, IN const float fDegreeX, IN const float fDegreeY, IN const float fDegreeZ )
{
	CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_MAGIC_FAIL ) );
	if( NULL != pSeq )
	{
		PlaySequenceByTriggerCount( pSeq, vPos, 100, 100, 1 );
		D3DXVECTOR3 vAngle = GetRotateDegree();
		vAngle += D3DXVECTOR3( fDegreeX, fDegreeY, fDegreeZ );

		pSeq->SetAxisAngle( vAngle );
		pSeq->SetAddRotate( vAngle );
	}
}

/** @function	: IsEnoughMPForAttack
	@brief		: 공격에 필요한 MP가 충분하면 true, 충분하지 않으면 false와 함께 만두 이펙트 발사
	@param		: MP 소비량, 발사 위치, 발사 Offset 위치, 발사 각도
	@return		: 공격 가능 여부
*/
bool CX2GUUser::IsEnoughMPForAttack( IN const float fConsumeMP, IN const D3DXVECTOR3 vPos, IN const float fOffsetPos /*= 0.f;*/, 
									 IN const D3DXVECTOR3 vRotDegree /*= D3DXVECTOR3( 0.f, 0.f, 0.f )*/ )
{
	if( FlushMp( fConsumeMP ) == true )
		return true;
	else	/// MP가 부족하면, 만두 이펙트 발사
	{
		D3DXVECTOR3 vFirePos = vPos;

		/// Offset 위치 설정
		if ( false == IsSamef( 0.f, fOffsetPos ) )
			vFirePos += ( true == GetIsRight() ) ? GetDirVector() * 100.f : GetDirVector() * 100.f;

		CreateNotEnoughMPEffect( vFirePos, vRotDegree.x, vRotDegree.y, vRotDegree.z );
	}

	return false;
}
#endif //SERV_9TH_NEW_CHARACTER

#ifdef FIX_SHOOTING_MEGABALL_AT_JUMP_LINE_MAP
/*virtual*/void CX2GUUser::InitInpuDataProcess()
{
	if( m_fCanNotInputTimeZXArrow > 0.f )
	{
		m_InputData.Init_ZXArrowOnly();
	}

	if( true == IsCanNotIntput() )
	{
		m_InputData.Init();
	}
}
#endif // FIX_SHOOTING_MEGABALL_AT_JUMP_LINE_MAP

#ifdef ADD_PLAY_SOUND //김창한
void CX2GUUser::PlaySoundRevive()
{
	const CX2Unit::UNIT_TYPE eUnitType = GetUnitType();

	if( g_pKTDXApp->GetDeviceManager() == NULL )
		return;

	if( eUnitType <= CX2Unit::UT_NONE || eUnitType >= CX2Unit::UT_END )
		return;

	wstring wstrSoundFile = L"";

	switch (eUnitType)
	{
	case CX2Unit::UT_ELSWORD:
		{
			wstrSoundFile = L"ElswordVoice_Revive0";
		} break;

	case CX2Unit::UT_ARME:
		{
			wstrSoundFile = L"AishaVoice_Revive0";
		} break;

	case CX2Unit::UT_LIRE:
		{
			wstrSoundFile = L"LenaVoice_Revive0";
		} break;

	case CX2Unit::UT_RAVEN:
		{
			wstrSoundFile = L"RavenVoice_Revive0";
		} break;

	case CX2Unit::UT_EVE:
		{
			wstrSoundFile = L"EveVoice_Revive0";
		} break;

	case CX2Unit::UT_CHUNG:
		{
			wstrSoundFile = L"ChungVoice_Revive0";
		} break;

	case CX2Unit::UT_ARA:
		{
			wstrSoundFile = L"AraVoice_Revive0";
		} break;

	case CX2Unit::UT_ELESIS:
		{
			wstrSoundFile = L"ElesisVoice_Revive0";
		} break;

	case CX2Unit::UT_ADD:
		{
			wstrSoundFile = L"AddVoice_Revive0";
		} break;

	default:
		break;
	}

	WCHAR buff[6];
	int iRandomSelect = RandomInt() % 2 + 1;
	StringCchPrintf( buff, ARRAY_SIZE(buff), L"%d.ogg ", iRandomSelect );
	wstrSoundFile += std::wstring(buff);

	if( wstrSoundFile.compare(L"") != 0 )
		g_pKTDXApp->GetDeviceManager()->PlaySound(wstrSoundFile.c_str(), false, false );
}
#endif //ADD_PLAY_SOUND


#ifdef SERV_9TH_NEW_CHARACTER
void CX2GUUser::InitPhaseShift()
{
	CX2GUAdd* pAdd = static_cast<CX2GUAdd*>(this);
	if( NULL != pAdd )
		pAdd->InitPhaseShift();
}
#endif //SERV_9TH_NEW_CHARACTER

#ifdef CRAYONPOP_EMOTION_WITH_MUSIC		// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨
bool CX2GUUser::IsPlayAvatarEmotionSoundWithouEmotion  ( CX2Unit::EMOTION_TYPE eEmotionId )
{
	wstring wstrEmotionSoundName = L"";
	bool	bCheckHaveItem = false;
	switch ( eEmotionId )	
	{
		case CX2Unit::ET_EMOTION_AVATAR7:
			for( int i=0; i<ARRAY_SIZE( ITEM_ID_EMOTION_AVATAR1 ); ++i )
			{
				if( NULL != GetUnit() )
				{
					if ( true == GetUnit()->GetInventory().CheckEquippingItem( ITEM_ID_EMOTION_AVATAR1[i] ) )
					{
						m_bIsPlayAvatarEmotionSoundWithoutEmotion = true;
						wstrEmotionSoundName = L"Emotion_Crayonpop_NoMotion.ogg";
						bCheckHaveItem = true;
					}
				}
			}
			break;
		default :
			return false;
	}
	if ( false == bCheckHaveItem )
		return false;

	if ( wstrEmotionSoundName != L"" )
	{
		if( m_pAvatarEmotionSound != NULL )
		{
			m_pAvatarEmotionSound->Stop();
			SAFE_CLOSE( m_pAvatarEmotionSound );
		}
		const float MAGIC_NUMBER = 500.f;
		const float fMaxDist = g_pKTDXApp->GetDGManager()->GetCamera().GetCameraDistance() + MAGIC_NUMBER;
		m_pAvatarEmotionSound = g_pKTDXApp->GetDeviceManager()->OpenSound( wstrEmotionSoundName, 10, true, fMaxDist );
		if( m_pAvatarEmotionSound != NULL )
		{
			if( CX2Main::XS_SQUARE_GAME != g_pMain->GetNowStateID() &&			// note!! 거래광장에서는 일단 2D 사운드로
				CX2Main::XS_PVP_ROOM	!= g_pMain->GetNowStateID() &&
				CX2Main::XS_WEDDING_GAME != g_pMain->GetNowStateID() &&
				true == g_pKTDXApp->GetDSManager()->GetCapable3DSound() &&
				true == g_pKTDXApp->GetDSManager()->GetEnable3DSound() &&
				true == g_pMain->GetGameOption().GetOptionList().m_bEnable3DSound )
			{
				m_pAvatarEmotionSound->Set3DPosition( GetPos() );
				m_pAvatarEmotionSound->Play( false );
			}
			else
			{
				m_pAvatarEmotionSound->Play( false, false );
			}
		}
	}
	return true;
}
#endif // CRAYONPOP_EMOTION_WITH_MUSIC	// 크래용 팝 한벌 아바타 이모션, 사운드가 출력됨

#ifdef ADD_RENA_SYSTEM //김창한
/** @function 	: SetNowDamageRelateSkillData
	@brief 		: 현재 동작중인 스킬 관련 데이터를 저장
*/
void CX2GUUser::SetNowDamageRelateSkillData( Byte byteRelateData_ )
{
	//각각의 스킬을 index로 구별.
	++m_AllDamageRelateSkillData.m_byteSkillIndex;

	//index가 30개 이상 되면 다시 처음부터 시작함.
	//m_AllDamageRelateSkillData.m_vecSaveData 에 저장된 데이터를 해당 스킬이 명중할때 삭제시키는데
	//명중하지 않으면 삭제가 되지 않음. 아직 명확한 방법을 찾지 못해 일단 30개로 제한을 둠
	//30에서 다시 0으로 돌며 이미 인덱스가 같은 것이 있다면 이전의 값을 삭제함.
	if( m_AllDamageRelateSkillData.m_byteSkillIndex > 30 )
		m_AllDamageRelateSkillData.m_byteSkillIndex = 0;

	std::vector<CX2DamageManager::DamageRelateSkillData>::iterator itr = m_AllDamageRelateSkillData.m_vecSaveData.begin();
	for( ; itr != m_AllDamageRelateSkillData.m_vecSaveData.end(); )
	{
		if( m_AllDamageRelateSkillData.m_byteSkillIndex == (*itr).m_byteSkillIndex )
		{
			itr = m_AllDamageRelateSkillData.m_vecSaveData.erase(itr);
			break;
		}
		else
			itr++;
	}

	//관련 데이터 저장
	//byteRelateData_값은 NF게이지를 최대 몇개나 소모하는지를 저장.
	//예외적으로 콤보 DASH_JUMP_XXX, DOUBLE_JUMP_XX, ZZZXX 를 구별하기 위한 값으로 사용
	m_AllDamageRelateSkillData.m_NowData.m_byteSkillIndex = m_AllDamageRelateSkillData.m_byteSkillIndex;
	m_AllDamageRelateSkillData.m_NowData.m_byteRelateData = byteRelateData_;
	
	m_AllDamageRelateSkillData.m_vecSaveData.push_back(m_AllDamageRelateSkillData.m_NowData);
}
#endif //ADD_RENA_SYSTEM

#ifdef SERV_ADD_LUNATIC_PSYKER // 김태환
/** @function	: GetSkillLevelValue
	@brief		: 스킬 아이디에 해당하는 스킬 레벨을 받아오는 함수
	@param		: 스킬 아이디
	@return		: 스킬 레벨
*/
const int CX2GUUser::GetSkillLevelValue( IN const CX2SkillTree::SKILL_ID eSkillID_ )
{
	if ( NULL == GetUnit() )
		return 1;

	const CX2UserSkillTree& userSkillTree	= GetUnit()->GetUnitData().m_UserSkillTree;
	const int				iSkillLevel		= userSkillTree.GetSkillLevel( eSkillID_ );

	return iSkillLevel;
}

/** @function	: SetEffectSoundParticle
	@brief		: 효과음 이펙트 출력 함수
	@param		: 붙일 본 네임, 붙일 이펙트 네임
*/
void CX2GUUser::SetEffectSoundParticle( IN const D3DXVECTOR3& vPos_, IN const wstring& wstrEffectName_ )
{
	if ( GetShowSmallGageAndName() && NULL != g_pX2Game && NULL != g_pX2Game->GetMinorParticle() )
	{
		D3DXVECTOR2 projPos = g_pKTDXApp->GetProj3DPos( vPos_ );

		g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  wstrEffectName_.c_str(), projPos.x, projPos.y, 0.0f, 100, 100, 1, 1 );
	}
}
#endif //SERV_ADD_LUNATIC_PSYKER

